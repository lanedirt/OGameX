/**
 * Timer handler
 *
 * @param integer interval  Default is 1000
 * @param boolean autostart Default is true
 */
var TimerHandler = function (interval, autostart) {
  if (typeof interval == 'undefined') {
    interval = 1000;
  }

  this._interval = interval;
  this._callbacks = new Array();
  this._intervalId = null;
  this._lastId = 0;
  this.pageReloadAlreadyTriggered = false;
  this.checkEventsAlreadyQueued = false;

  if (autostart != false) {
    this.startTimer();
  }
};
/**
 * Append a callback to the timer
 *
 * Returns the index required to remove the callback again
 *
 * @param  object method
 * @return integer
 */


TimerHandler.prototype.appendCallback = function (method) {
  var index = this._lastId++;
  this._callbacks[index] = method;
  return index;
};

TimerHandler.prototype.removeCallback = function (index) {
  this._callbacks[index] = null;
};
/**
 * Start the timer
 *
 * @return void
 */


TimerHandler.prototype.startTimer = function () {
  var instance = this;
  this._intervalId = window.setInterval(function () {
    instance._timer();
  }, this._interval);
};
/**
 * Stop the timer
 *
 * @return void
 */


TimerHandler.prototype.stopTimer = function () {
  window.clearInterval(this._intervalId);
};
/**
 * Timer which is called every N seconds
 *
 * Executes every assigned callback
 *
 * @return void
 */


TimerHandler.prototype._timer = function () {
  for (var i in this._callbacks) {
    if (this._callbacks[i] != null) {
      this._callbacks[i]();
    }
  }
};
// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
document.createElement("canvas").getContext || function () {
  function C() {}

  function B(a) {
    this.type_ = a, this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0, this.colors_ = [];
  }

  function A(a, b, c) {
    !z(b) || (a.m_ = b, c && (a.lineScale_ = f(e(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
  }

  function z(a) {
    var b = 0;

    for (; b < 3; b++) {
      var c = 0;

      for (; c < 2; c++) if (!isFinite(a[b][c]) || isNaN(a[b][c])) return !1;
    }

    return !0;
  }

  function y(a, b, c, d) {
    a.currentPath_.push({
      type: "bezierCurveTo",
      cp1x: b.x,
      cp1y: b.y,
      cp2x: c.x,
      cp2y: c.y,
      x: d.x,
      y: d.y
    }), a.currentX_ = d.x, a.currentY_ = d.y;
  }

  function w(a) {
    this.m_ = r(), this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.fillStyle = this.strokeStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.miterLimit = g * 1, this.globalAlpha = 1, this.canvas = a;
    var b = a.ownerDocument.createElement("div");
    b.style.width = a.clientWidth + "px", b.style.height = a.clientHeight + "px", b.style.overflow = "hidden", b.style.position = "absolute", a.appendChild(b), this.element_ = b, this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
  }

  function v(a) {
    switch (a) {
      case "butt":
        return "flat";

      case "round":
        return "round";

      case "square":
      default:
        return "square";
    }
  }

  function u(a) {
    var b,
        c = 1;
    a = String(a);

    if (a.substring(0, 3) == "rgb") {
      var d = a.indexOf("(", 3),
          e = a.indexOf(")", d + 1),
          f = a.substring(d + 1, e).split(",");
      b = "#";
      var g = 0;

      for (; g < 3; g++) b += o[Number(f[g])];

      f.length == 4 && a.substr(3, 1) == "a" && (c = f[3]);
    } else b = a;

    return {
      color: b,
      alpha: c
    };
  }

  function t(a, b) {
    b.fillStyle = a.fillStyle, b.lineCap = a.lineCap, b.lineJoin = a.lineJoin, b.lineWidth = a.lineWidth, b.miterLimit = a.miterLimit, b.shadowBlur = a.shadowBlur, b.shadowColor = a.shadowColor, b.shadowOffsetX = a.shadowOffsetX, b.shadowOffsetY = a.shadowOffsetY, b.strokeStyle = a.strokeStyle, b.globalAlpha = a.globalAlpha, b.arcScaleX_ = a.arcScaleX_, b.arcScaleY_ = a.arcScaleY_, b.lineScale_ = a.lineScale_;
  }

  function s(a, b) {
    var c = r(),
        d = 0;

    for (; d < 3; d++) {
      var e = 0;

      for (; e < 3; e++) {
        var f = 0,
            g = 0;

        for (; g < 3; g++) f += a[d][g] * b[g][e];

        c[d][e] = f;
      }
    }

    return c;
  }

  function r() {
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  }

  function n(a) {
    var b = a.srcElement;
    b.firstChild && (b.firstChild.style.width = b.clientWidth + "px", b.firstChild.style.height = b.clientHeight + "px");
  }

  function m(a) {
    var b = a.srcElement;

    switch (a.propertyName) {
      case "width":
        b.style.width = b.attributes.width.nodeValue + "px", b.getContext().clearRect();
        break;

      case "height":
        b.style.height = b.attributes.height.nodeValue + "px", b.getContext().clearRect();
    }
  }

  function k(a, b) {
    var c = j.call(arguments, 2);
    return function () {
      return a.apply(b, c.concat(j.call(arguments)));
    };
  }

  function i() {
    return this.context_ || (this.context_ = new w(this));
  }

  var a = Math,
      b = a.round,
      c = a.sin,
      d = a.cos,
      e = a.abs,
      f = a.sqrt,
      g = 10,
      h = g / 2,
      j = Array.prototype.slice,
      l = {
    init: function (a) {
      if (/MSIE/.test(navigator.userAgent) && !window.opera) {
        var b = a || document;
        b.createElement("canvas"), b.attachEvent("onreadystatechange", k(this.init_, this, b));
      }
    },
    init_: function (a) {
      a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");

      if (!a.styleSheets.ex_canvas_) {
        var b = a.createStyleSheet();
        b.owningElement.id = "ex_canvas_", b.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}g_vml_\\:*{behavior:url(#default#VML)}g_o_\\:*{behavior:url(#default#VML)}";
      }

      var c = a.getElementsByTagName("canvas"),
          d = 0;

      for (; d < c.length; d++) this.initElement(c[d]);
    },
    initElement: function (a) {
      if (!a.getContext) {
        a.getContext = i, a.innerHTML = "", a.attachEvent("onpropertychange", m), a.attachEvent("onresize", n);
        var b = a.attributes;
        b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth, b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight;
      }

      return a;
    }
  };
  l.init();
  var o = [],
      p = 0;

  for (; p < 16; p++) {
    var q = 0;

    for (; q < 16; q++) o[p * 16 + q] = p.toString(16) + q.toString(16);
  }

  var x = w.prototype;
  x.clearRect = function () {
    this.element_.innerHTML = "";
  }, x.beginPath = function () {
    this.currentPath_ = [];
  }, x.moveTo = function (a, b) {
    var c = this.getCoords_(a, b);
    this.currentPath_.push({
      type: "moveTo",
      x: c.x,
      y: c.y
    }), this.currentX_ = c.x, this.currentY_ = c.y;
  }, x.lineTo = function (a, b) {
    var c = this.getCoords_(a, b);
    this.currentPath_.push({
      type: "lineTo",
      x: c.x,
      y: c.y
    }), this.currentX_ = c.x, this.currentY_ = c.y;
  }, x.bezierCurveTo = function (a, b, c, d, e, f) {
    var g = this.getCoords_(e, f),
        h = this.getCoords_(a, b),
        i = this.getCoords_(c, d);
    y(this, h, i, g);
  }, x.quadraticCurveTo = function (a, b, c, d) {
    var e = this.getCoords_(a, b),
        f = this.getCoords_(c, d),
        g = {
      x: this.currentX_ + .6666666666666666 * (e.x - this.currentX_),
      y: this.currentY_ + .6666666666666666 * (e.y - this.currentY_)
    };
    y(this, g, {
      x: g.x + (f.x - this.currentX_) / 3,
      y: g.y + (f.y - this.currentY_) / 3
    }, f);
  }, x.arc = function (a, b, e, f, i, j) {
    e *= g;
    var k = j ? "at" : "wa",
        l = a + d(f) * e - h,
        m = b + c(f) * e - h,
        n = a + d(i) * e - h,
        o = b + c(i) * e - h;
    l == n && !j && (l += .125);
    var p = this.getCoords_(a, b),
        q = this.getCoords_(l, m),
        r = this.getCoords_(n, o);
    this.currentPath_.push({
      type: k,
      x: p.x,
      y: p.y,
      radius: e,
      xStart: q.x,
      yStart: q.y,
      xEnd: r.x,
      yEnd: r.y
    });
  }, x.rect = function (a, b, c, d) {
    this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath();
  }, x.strokeRect = function (a, b, c, d) {
    var e = this.currentPath_;
    this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.stroke(), this.currentPath_ = e;
  }, x.fillRect = function (a, b, c, d) {
    var e = this.currentPath_;
    this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.fill(), this.currentPath_ = e;
  }, x.createLinearGradient = function (a, b, c, d) {
    var e = new B("gradient");
    e.x0_ = a, e.y0_ = b, e.x1_ = c, e.y1_ = d;
    return e;
  }, x.createRadialGradient = function (a, b, c, d, e, f) {
    var g = new B("gradientradial");
    g.x0_ = a, g.y0_ = b, g.r0_ = c, g.x1_ = d, g.y1_ = e, g.r1_ = f;
    return g;
  }, x.drawImage = function (c) {
    var d,
        e,
        f,
        h,
        i,
        j,
        k,
        l,
        m = c.runtimeStyle.width,
        n = c.runtimeStyle.height;
    c.runtimeStyle.width = "auto", c.runtimeStyle.height = "auto";
    var o = c.width,
        p = c.height;
    c.runtimeStyle.width = m, c.runtimeStyle.height = n;
    if (arguments.length == 3) d = arguments[1], e = arguments[2], i = j = 0, k = f = o, l = h = p;else if (arguments.length == 5) d = arguments[1], e = arguments[2], f = arguments[3], h = arguments[4], i = j = 0, k = o, l = p;else if (arguments.length == 9) i = arguments[1], j = arguments[2], k = arguments[3], l = arguments[4], d = arguments[5], e = arguments[6], f = arguments[7], h = arguments[8];else throw Error("Invalid number of arguments");
    var q = this.getCoords_(d, e),
        r = [];
    r.push(" <g_vml_:group", ' coordsize="', g * 10, ",", g * 10, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;");

    if (this.m_[0][0] != 1 || this.m_[0][1]) {
      var s = [];
      s.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", b(q.x / g), ",", "Dy=", b(q.y / g), "");
      var t = q,
          u = this.getCoords_(d + f, e),
          v = this.getCoords_(d, e + h),
          w = this.getCoords_(d + f, e + h);
      t.x = a.max(t.x, u.x, v.x, w.x), t.y = a.max(t.y, u.y, v.y, w.y), r.push("padding:0 ", b(t.x / g), "px ", b(t.y / g), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", s.join(""), ", sizingmethod='clip');");
    } else r.push("top:", b(q.y / g), "px;left:", b(q.x / g), "px;");

    r.push(' ">', '<g_vml_:image src="', c.src, '"', ' style="width:', g * f, "px;", " height:", g * h, 'px;"', ' cropleft="', i / o, '"', ' croptop="', j / p, '"', ' cropright="', (o - i - k) / o, '"', ' cropbottom="', (p - j - l) / p, '"', " />", "</g_vml_:group>"), this.element_.insertAdjacentHTML("BeforeEnd", r.join(""));
  }, x.stroke = function (c) {
    var d = [],
        e = u(c ? this.fillStyle : this.strokeStyle),
        f = e.color,
        h = e.alpha * this.globalAlpha;
    d.push("<g_vml_:shape", ' filled="', !!c, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0 0" coordsize="', g * 10, " ", g * 10, '"', ' stroked="', !c, '"', ' path="');
    var i = {
      x: null,
      y: null
    },
        j = {
      x: null,
      y: null
    },
        k = 0;

    for (; k < this.currentPath_.length; k++) {
      var l = this.currentPath_[k];

      switch (l.type) {
        case "moveTo":
          d.push(" m ", b(l.x), ",", b(l.y));
          break;

        case "lineTo":
          d.push(" l ", b(l.x), ",", b(l.y));
          break;

        case "close":
          d.push(" x "), l = null;
          break;

        case "bezierCurveTo":
          d.push(" c ", b(l.cp1x), ",", b(l.cp1y), ",", b(l.cp2x), ",", b(l.cp2y), ",", b(l.x), ",", b(l.y));
          break;

        case "at":
        case "wa":
          d.push(" ", l.type, " ", b(l.x - this.arcScaleX_ * l.radius), ",", b(l.y - this.arcScaleY_ * l.radius), " ", b(l.x + this.arcScaleX_ * l.radius), ",", b(l.y + this.arcScaleY_ * l.radius), " ", b(l.xStart), ",", b(l.yStart), " ", b(l.xEnd), ",", b(l.yEnd));
      }

      if (l) {
        if (i.x == null || l.x < i.x) i.x = l.x;
        if (j.x == null || l.x > j.x) j.x = l.x;
        if (i.y == null || l.y < i.y) i.y = l.y;
        if (j.y == null || l.y > j.y) j.y = l.y;
      }
    }

    d.push(' ">');
    if (c) {
      if (typeof this.fillStyle == "object") {
        var m = this.fillStyle,
            n = 0,
            o = {
          x: 0,
          y: 0
        },
            p = 0,
            q = 1;

        if (m.type_ == "gradient") {
          var r = m.x1_ / this.arcScaleX_,
              s = m.y1_ / this.arcScaleY_,
              t = this.getCoords_(m.x0_ / this.arcScaleX_, m.y0_ / this.arcScaleY_),
              w = this.getCoords_(r, s);
          n = Math.atan2(w.x - t.x, w.y - t.y) * 180 / Math.PI, n < 0 && (n += 360), n < 1e-6 && (n = 0);
        } else {
          var t = this.getCoords_(m.x0_, m.y0_),
              x = j.x - i.x,
              y = j.y - i.y;
          o = {
            x: (t.x - i.x) / x,
            y: (t.y - i.y) / y
          }, x /= this.arcScaleX_ * g, y /= this.arcScaleY_ * g;
          var z = a.max(x, y);
          p = 2 * m.r0_ / z, q = 2 * m.r1_ / z - p;
        }

        var A = m.colors_;
        A.sort(function (a, b) {
          return a.offset - b.offset;
        });
        var B = A.length,
            C = A[0].color,
            D = A[B - 1].color,
            E = A[0].alpha * this.globalAlpha,
            F = A[B - 1].alpha * this.globalAlpha,
            G = [],
            k = 0;

        for (; k < B; k++) {
          var H = A[k];
          G.push(H.offset * q + p + " " + H.color);
        }

        d.push('<g_vml_:fill type="', m.type_, '"', ' method="none" focus="100%"', ' color="', C, '"', ' color2="', D, '"', ' colors="', G.join(","), '"', ' opacity="', F, '"', ' g_o_:opacity2="', E, '"', ' angle="', n, '"', ' focusposition="', o.x, ",", o.y, '" />');
      } else d.push('<g_vml_:fill color="', f, '" opacity="', h, '" />');
    } else {
      var I = this.lineScale_ * this.lineWidth;
      I < 1 && (h *= I), d.push("<g_vml_:stroke", ' opacity="', h, '"', ' joinstyle="', this.lineJoin, '"', ' miterlimit="', this.miterLimit, '"', ' endcap="', v(this.lineCap), '"', ' weight="', I, 'px"', ' color="', f, '" />');
    }
    d.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", d.join(""));
  }, x.fill = function () {
    this.stroke(!0);
  }, x.closePath = function () {
    this.currentPath_.push({
      type: "close"
    });
  }, x.getCoords_ = function (a, b) {
    var c = this.m_;
    return {
      x: g * (a * c[0][0] + b * c[1][0] + c[2][0]) - h,
      y: g * (a * c[0][1] + b * c[1][1] + c[2][1]) - h
    };
  }, x.save = function () {
    var a = {};
    t(this, a), this.aStack_.push(a), this.mStack_.push(this.m_), this.m_ = s(r(), this.m_);
  }, x.restore = function () {
    t(this.aStack_.pop(), this), this.m_ = this.mStack_.pop();
  }, x.translate = function (a, b) {
    A(this, s([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1);
  }, x.rotate = function (a) {
    var b = d(a),
        e = c(a);
    A(this, s([[b, e, 0], [-e, b, 0], [0, 0, 1]], this.m_), !1);
  }, x.scale = function (a, b) {
    this.arcScaleX_ *= a, this.arcScaleY_ *= b, A(this, s([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0);
  }, x.transform = function (a, b, c, d, e, f) {
    A(this, s([[a, b, 0], [c, d, 0], [e, f, 1]], this.m_), !0);
  }, x.setTransform = function (a, b, c, d, e, f) {
    A(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0);
  }, x.clip = function () {}, x.arcTo = function () {}, x.createPattern = function () {
    return new C();
  }, B.prototype.addColorStop = function (a, b) {
    b = u(b), this.colors_.push({
      offset: a,
      color: b.color,
      alpha: b.alpha
    });
  }, G_vmlCanvasManager = l, CanvasRenderingContext2D = w, CanvasGradient = B, CanvasPattern = C;
}();
/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */
(function (t) {
  "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery);
})(function (t) {
  function e(t) {
    for (var e = t.css("visibility"); "inherit" === e;) t = t.parent(), e = t.css("visibility");

    return "hidden" !== e;
  }

  function i(t) {
    for (var e, i; t.length && t[0] !== document;) {
      if (e = t.css("position"), ("absolute" === e || "relative" === e || "fixed" === e) && (i = parseInt(t.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
      t = t.parent();
    }

    return 0;
  }

  function s() {
    this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
      closeText: "Done",
      prevText: "Prev",
      nextText: "Next",
      currentText: "Today",
      monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      weekHeader: "Wk",
      dateFormat: "mm/dd/yy",
      firstDay: 0,
      isRTL: !1,
      showMonthAfterYear: !1,
      yearSuffix: ""
    }, this._defaults = {
      showOn: "focus",
      showAnim: "fadeIn",
      showOptions: {},
      defaultDate: null,
      appendText: "",
      buttonText: "...",
      buttonImage: "",
      buttonImageOnly: !1,
      hideIfNoPrevNext: !1,
      navigationAsDateFormat: !1,
      gotoCurrent: !1,
      changeMonth: !1,
      changeYear: !1,
      yearRange: "c-10:c+10",
      showOtherMonths: !1,
      selectOtherMonths: !1,
      showWeek: !1,
      calculateWeek: this.iso8601Week,
      shortYearCutoff: "+10",
      minDate: null,
      maxDate: null,
      duration: "fast",
      beforeShowDay: null,
      beforeShow: null,
      onSelect: null,
      onChangeMonthYear: null,
      onClose: null,
      numberOfMonths: 1,
      showCurrentAtPos: 0,
      stepMonths: 1,
      stepBigMonths: 12,
      altField: "",
      altFormat: "",
      constrainInput: !0,
      showButtonPanel: !1,
      autoSize: !1,
      disabled: !1
    }, t.extend(this._defaults, this.regional[""]), this.regional.en = t.extend(!0, {}, this.regional[""]), this.regional["en-US"] = t.extend(!0, {}, this.regional.en), this.dpDiv = n(t("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
  }

  function n(e) {
    var i = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
    return e.on("mouseout", i, function () {
      t(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && t(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && t(this).removeClass("ui-datepicker-next-hover");
    }).on("mouseover", i, o);
  }

  function o() {
    t.datepicker._isDisabledDatepicker(m.inline ? m.dpDiv.parent()[0] : m.input[0]) || (t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), t(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && t(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && t(this).addClass("ui-datepicker-next-hover"));
  }

  function a(e, i) {
    t.extend(e, i);

    for (var s in i) null == i[s] && (e[s] = i[s]);

    return e;
  }

  function r(t) {
    return function () {
      var e = this.element.val();
      t.apply(this, arguments), this._refresh(), e !== this.element.val() && this._trigger("change");
    };
  }

  t.ui = t.ui || {}, t.ui.version = "1.12.1";
  var h = 0,
      l = Array.prototype.slice;
  t.cleanData = function (e) {
    return function (i) {
      var s, n, o;

      for (o = 0; null != (n = i[o]); o++) try {
        s = t._data(n, "events"), s && s.remove && t(n).triggerHandler("remove");
      } catch (a) {}

      e(i);
    };
  }(t.cleanData), t.widget = function (e, i, s) {
    var n,
        o,
        a,
        r = {},
        h = e.split(".")[0];
    e = e.split(".")[1];
    var l = h + "-" + e;
    return s || (s = i, i = t.Widget), t.isArray(s) && (s = t.extend.apply(null, [{}].concat(s))), t.expr[":"][l.toLowerCase()] = function (e) {
      return !!t.data(e, l);
    }, t[h] = t[h] || {}, n = t[h][e], o = t[h][e] = function (t, e) {
      return this._createWidget ? (arguments.length && this._createWidget(t, e), void 0) : new o(t, e);
    }, t.extend(o, n, {
      version: s.version,
      _proto: t.extend({}, s),
      _childConstructors: []
    }), a = new i(), a.options = t.widget.extend({}, a.options), t.each(s, function (e, s) {
      return t.isFunction(s) ? (r[e] = function () {
        function t() {
          return i.prototype[e].apply(this, arguments);
        }

        function n(t) {
          return i.prototype[e].apply(this, t);
        }

        return function () {
          var e,
              i = this._super,
              o = this._superApply;
          return this._super = t, this._superApply = n, e = s.apply(this, arguments), this._super = i, this._superApply = o, e;
        };
      }(), void 0) : (r[e] = s, void 0);
    }), o.prototype = t.widget.extend(a, {
      widgetEventPrefix: n ? a.widgetEventPrefix || e : e
    }, r, {
      constructor: o,
      namespace: h,
      widgetName: e,
      widgetFullName: l
    }), n ? (t.each(n._childConstructors, function (e, i) {
      var s = i.prototype;
      t.widget(s.namespace + "." + s.widgetName, o, i._proto);
    }), delete n._childConstructors) : i._childConstructors.push(o), t.widget.bridge(e, o), o;
  }, t.widget.extend = function (e) {
    for (var i, s, n = l.call(arguments, 1), o = 0, a = n.length; a > o; o++) for (i in n[o]) s = n[o][i], n[o].hasOwnProperty(i) && void 0 !== s && (e[i] = t.isPlainObject(s) ? t.isPlainObject(e[i]) ? t.widget.extend({}, e[i], s) : t.widget.extend({}, s) : s);

    return e;
  }, t.widget.bridge = function (e, i) {
    var s = i.prototype.widgetFullName || e;

    t.fn[e] = function (n) {
      var o = "string" == typeof n,
          a = l.call(arguments, 1),
          r = this;
      return o ? this.length || "instance" !== n ? this.each(function () {
        var i,
            o = t.data(this, s);
        return "instance" === n ? (r = o, !1) : o ? t.isFunction(o[n]) && "_" !== n.charAt(0) ? (i = o[n].apply(o, a), i !== o && void 0 !== i ? (r = i && i.jquery ? r.pushStack(i.get()) : i, !1) : void 0) : t.error("no such method '" + n + "' for " + e + " widget instance") : t.error("cannot call methods on " + e + " prior to initialization; " + "attempted to call method '" + n + "'");
      }) : r = void 0 : (a.length && (n = t.widget.extend.apply(null, [n].concat(a))), this.each(function () {
        var e = t.data(this, s);
        e ? (e.option(n || {}), e._init && e._init()) : t.data(this, s, new i(n, this));
      })), r;
    };
  }, t.Widget = function () {}, t.Widget._childConstructors = [], t.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      classes: {},
      disabled: !1,
      create: null
    },
    _createWidget: function (e, i) {
      i = t(i || this.defaultElement || this)[0], this.element = t(i), this.uuid = h++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = t(), this.hoverable = t(), this.focusable = t(), this.classesElementLookup = {}, i !== this && (t.data(i, this.widgetFullName, this), this._on(!0, this.element, {
        remove: function (t) {
          t.target === i && this.destroy();
        }
      }), this.document = t(i.style ? i.ownerDocument : i.document || i), this.window = t(this.document[0].defaultView || this.document[0].parentWindow)), this.options = t.widget.extend({}, this.options, this._getCreateOptions(), e), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init();
    },
    _getCreateOptions: function () {
      return {};
    },
    _getCreateEventData: t.noop,
    _create: t.noop,
    _init: t.noop,
    destroy: function () {
      var e = this;
      this._destroy(), t.each(this.classesElementLookup, function (t, i) {
        e._removeClass(i, t);
      }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace);
    },
    _destroy: t.noop,
    widget: function () {
      return this.element;
    },
    option: function (e, i) {
      var s,
          n,
          o,
          a = e;
      if (0 === arguments.length) return t.widget.extend({}, this.options);
      if ("string" == typeof e) if (a = {}, s = e.split("."), e = s.shift(), s.length) {
        for (n = a[e] = t.widget.extend({}, this.options[e]), o = 0; s.length - 1 > o; o++) n[s[o]] = n[s[o]] || {}, n = n[s[o]];

        if (e = s.pop(), 1 === arguments.length) return void 0 === n[e] ? null : n[e];
        n[e] = i;
      } else {
        if (1 === arguments.length) return void 0 === this.options[e] ? null : this.options[e];
        a[e] = i;
      }
      return this._setOptions(a), this;
    },
    _setOptions: function (t) {
      var e;

      for (e in t) this._setOption(e, t[e]);

      return this;
    },
    _setOption: function (t, e) {
      return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this;
    },
    _setOptionClasses: function (e) {
      var i, s, n;

      for (i in e) n = this.classesElementLookup[i], e[i] !== this.options.classes[i] && n && n.length && (s = t(n.get()), this._removeClass(n, i), s.addClass(this._classes({
        element: s,
        keys: i,
        classes: e,
        add: !0
      })));
    },
    _setOptionDisabled: function (t) {
      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"));
    },
    enable: function () {
      return this._setOptions({
        disabled: !1
      });
    },
    disable: function () {
      return this._setOptions({
        disabled: !0
      });
    },
    _classes: function (e) {
      function i(i, o) {
        var a, r;

        for (r = 0; i.length > r; r++) a = n.classesElementLookup[i[r]] || t(), a = e.add ? t(t.unique(a.get().concat(e.element.get()))) : t(a.not(e.element).get()), n.classesElementLookup[i[r]] = a, s.push(i[r]), o && e.classes[i[r]] && s.push(e.classes[i[r]]);
      }

      var s = [],
          n = this;
      return e = t.extend({
        element: this.element,
        classes: this.options.classes || {}
      }, e), this._on(e.element, {
        remove: "_untrackClassesElement"
      }), e.keys && i(e.keys.match(/\S+/g) || [], !0), e.extra && i(e.extra.match(/\S+/g) || []), s.join(" ");
    },
    _untrackClassesElement: function (e) {
      var i = this;
      t.each(i.classesElementLookup, function (s, n) {
        -1 !== t.inArray(e.target, n) && (i.classesElementLookup[s] = t(n.not(e.target).get()));
      });
    },
    _removeClass: function (t, e, i) {
      return this._toggleClass(t, e, i, !1);
    },
    _addClass: function (t, e, i) {
      return this._toggleClass(t, e, i, !0);
    },
    _toggleClass: function (t, e, i, s) {
      s = "boolean" == typeof s ? s : i;
      var n = "string" == typeof t || null === t,
          o = {
        extra: n ? e : i,
        keys: n ? t : e,
        element: n ? this.element : t,
        add: s
      };
      return o.element.toggleClass(this._classes(o), s), this;
    },
    _on: function (e, i, s) {
      var n,
          o = this;
      "boolean" != typeof e && (s = i, i = e, e = !1), s ? (i = n = t(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), t.each(s, function (s, a) {
        function r() {
          return e || o.options.disabled !== !0 && !t(this).hasClass("ui-state-disabled") ? ("string" == typeof a ? o[a] : a).apply(o, arguments) : void 0;
        }

        "string" != typeof a && (r.guid = a.guid = a.guid || r.guid || t.guid++);
        var h = s.match(/^([\w:-]*)\s*(.*)$/),
            l = h[1] + o.eventNamespace,
            c = h[2];
        c ? n.on(l, c, r) : i.on(l, r);
      });
    },
    _off: function (e, i) {
      i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.off(i).off(i), this.bindings = t(this.bindings.not(e).get()), this.focusable = t(this.focusable.not(e).get()), this.hoverable = t(this.hoverable.not(e).get());
    },
    _delay: function (t, e) {
      function i() {
        return ("string" == typeof t ? s[t] : t).apply(s, arguments);
      }

      var s = this;
      return setTimeout(i, e || 0);
    },
    _hoverable: function (e) {
      this.hoverable = this.hoverable.add(e), this._on(e, {
        mouseenter: function (e) {
          this._addClass(t(e.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function (e) {
          this._removeClass(t(e.currentTarget), null, "ui-state-hover");
        }
      });
    },
    _focusable: function (e) {
      this.focusable = this.focusable.add(e), this._on(e, {
        focusin: function (e) {
          this._addClass(t(e.currentTarget), null, "ui-state-focus");
        },
        focusout: function (e) {
          this._removeClass(t(e.currentTarget), null, "ui-state-focus");
        }
      });
    },
    _trigger: function (e, i, s) {
      var n,
          o,
          a = this.options[e];
      if (s = s || {}, i = t.Event(i), i.type = (e === this.widgetEventPrefix ? e : this.widgetEventPrefix + e).toLowerCase(), i.target = this.element[0], o = i.originalEvent) for (n in o) n in i || (i[n] = o[n]);
      return this.element.trigger(i, s), !(t.isFunction(a) && a.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented());
    }
  }, t.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function (e, i) {
    t.Widget.prototype["_" + e] = function (s, n, o) {
      "string" == typeof n && (n = {
        effect: n
      });
      var a,
          r = n ? n === !0 || "number" == typeof n ? i : n.effect || i : e;
      n = n || {}, "number" == typeof n && (n = {
        duration: n
      }), a = !t.isEmptyObject(n), n.complete = o, n.delay && s.delay(n.delay), a && t.effects && t.effects.effect[r] ? s[e](n) : r !== e && s[r] ? s[r](n.duration, n.easing, o) : s.queue(function (i) {
        t(this)[e](), o && o.call(s[0]), i();
      });
    };
  }), t.widget, function () {
    function e(t, e, i) {
      return [parseFloat(t[0]) * (u.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (u.test(t[1]) ? i / 100 : 1)];
    }

    function i(e, i) {
      return parseInt(t.css(e, i), 10) || 0;
    }

    function s(e) {
      var i = e[0];
      return 9 === i.nodeType ? {
        width: e.width(),
        height: e.height(),
        offset: {
          top: 0,
          left: 0
        }
      } : t.isWindow(i) ? {
        width: e.width(),
        height: e.height(),
        offset: {
          top: e.scrollTop(),
          left: e.scrollLeft()
        }
      } : i.preventDefault ? {
        width: 0,
        height: 0,
        offset: {
          top: i.pageY,
          left: i.pageX
        }
      } : {
        width: e.outerWidth(),
        height: e.outerHeight(),
        offset: e.offset()
      };
    }

    var n,
        o = Math.max,
        a = Math.abs,
        r = /left|center|right/,
        h = /top|center|bottom/,
        l = /[\+\-]\d+(\.[\d]+)?%?/,
        c = /^\w+/,
        u = /%$/,
        d = t.fn.position;
    t.position = {
      scrollbarWidth: function () {
        if (void 0 !== n) return n;
        var e,
            i,
            s = t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
            o = s.children()[0];
        return t("body").append(s), e = o.offsetWidth, s.css("overflow", "scroll"), i = o.offsetWidth, e === i && (i = s[0].clientWidth), s.remove(), n = e - i;
      },
      getScrollInfo: function (e) {
        var i = e.isWindow || e.isDocument ? "" : e.element.css("overflow-x"),
            s = e.isWindow || e.isDocument ? "" : e.element.css("overflow-y"),
            n = "scroll" === i || "auto" === i && e.width < e.element[0].scrollWidth,
            o = "scroll" === s || "auto" === s && e.height < e.element[0].scrollHeight;
        return {
          width: o ? t.position.scrollbarWidth() : 0,
          height: n ? t.position.scrollbarWidth() : 0
        };
      },
      getWithinInfo: function (e) {
        var i = t(e || window),
            s = t.isWindow(i[0]),
            n = !!i[0] && 9 === i[0].nodeType,
            o = !s && !n;
        return {
          element: i,
          isWindow: s,
          isDocument: n,
          offset: o ? t(e).offset() : {
            left: 0,
            top: 0
          },
          scrollLeft: i.scrollLeft(),
          scrollTop: i.scrollTop(),
          width: i.outerWidth(),
          height: i.outerHeight()
        };
      }
    }, t.fn.position = function (n) {
      if (!n || !n.of) return d.apply(this, arguments);
      n = t.extend({}, n);

      var u,
          p,
          f,
          g,
          m,
          _,
          v = t(n.of),
          b = t.position.getWithinInfo(n.within),
          y = t.position.getScrollInfo(b),
          w = (n.collision || "flip").split(" "),
          k = {};

      return _ = s(v), v[0].preventDefault && (n.at = "left top"), p = _.width, f = _.height, g = _.offset, m = t.extend({}, g), t.each(["my", "at"], function () {
        var t,
            e,
            i = (n[this] || "").split(" ");
        1 === i.length && (i = r.test(i[0]) ? i.concat(["center"]) : h.test(i[0]) ? ["center"].concat(i) : ["center", "center"]), i[0] = r.test(i[0]) ? i[0] : "center", i[1] = h.test(i[1]) ? i[1] : "center", t = l.exec(i[0]), e = l.exec(i[1]), k[this] = [t ? t[0] : 0, e ? e[0] : 0], n[this] = [c.exec(i[0])[0], c.exec(i[1])[0]];
      }), 1 === w.length && (w[1] = w[0]), "right" === n.at[0] ? m.left += p : "center" === n.at[0] && (m.left += p / 2), "bottom" === n.at[1] ? m.top += f : "center" === n.at[1] && (m.top += f / 2), u = e(k.at, p, f), m.left += u[0], m.top += u[1], this.each(function () {
        var s,
            r,
            h = t(this),
            l = h.outerWidth(),
            c = h.outerHeight(),
            d = i(this, "marginLeft"),
            _ = i(this, "marginTop"),
            x = l + d + i(this, "marginRight") + y.width,
            C = c + _ + i(this, "marginBottom") + y.height,
            D = t.extend({}, m),
            I = e(k.my, h.outerWidth(), h.outerHeight());

        "right" === n.my[0] ? D.left -= l : "center" === n.my[0] && (D.left -= l / 2), "bottom" === n.my[1] ? D.top -= c : "center" === n.my[1] && (D.top -= c / 2), D.left += I[0], D.top += I[1], s = {
          marginLeft: d,
          marginTop: _
        }, t.each(["left", "top"], function (e, i) {
          t.ui.position[w[e]] && t.ui.position[w[e]][i](D, {
            targetWidth: p,
            targetHeight: f,
            elemWidth: l,
            elemHeight: c,
            collisionPosition: s,
            collisionWidth: x,
            collisionHeight: C,
            offset: [u[0] + I[0], u[1] + I[1]],
            my: n.my,
            at: n.at,
            within: b,
            elem: h
          });
        }), n.using && (r = function (t) {
          var e = g.left - D.left,
              i = e + p - l,
              s = g.top - D.top,
              r = s + f - c,
              u = {
            target: {
              element: v,
              left: g.left,
              top: g.top,
              width: p,
              height: f
            },
            element: {
              element: h,
              left: D.left,
              top: D.top,
              width: l,
              height: c
            },
            horizontal: 0 > i ? "left" : e > 0 ? "right" : "center",
            vertical: 0 > r ? "top" : s > 0 ? "bottom" : "middle"
          };
          l > p && p > a(e + i) && (u.horizontal = "center"), c > f && f > a(s + r) && (u.vertical = "middle"), u.important = o(a(e), a(i)) > o(a(s), a(r)) ? "horizontal" : "vertical", n.using.call(this, t, u);
        }), h.offset(t.extend(D, {
          using: r
        }));
      });
    }, t.ui.position = {
      fit: {
        left: function (t, e) {
          var i,
              s = e.within,
              n = s.isWindow ? s.scrollLeft : s.offset.left,
              a = s.width,
              r = t.left - e.collisionPosition.marginLeft,
              h = n - r,
              l = r + e.collisionWidth - a - n;
          e.collisionWidth > a ? h > 0 && 0 >= l ? (i = t.left + h + e.collisionWidth - a - n, t.left += h - i) : t.left = l > 0 && 0 >= h ? n : h > l ? n + a - e.collisionWidth : n : h > 0 ? t.left += h : l > 0 ? t.left -= l : t.left = o(t.left - r, t.left);
        },
        top: function (t, e) {
          var i,
              s = e.within,
              n = s.isWindow ? s.scrollTop : s.offset.top,
              a = e.within.height,
              r = t.top - e.collisionPosition.marginTop,
              h = n - r,
              l = r + e.collisionHeight - a - n;
          e.collisionHeight > a ? h > 0 && 0 >= l ? (i = t.top + h + e.collisionHeight - a - n, t.top += h - i) : t.top = l > 0 && 0 >= h ? n : h > l ? n + a - e.collisionHeight : n : h > 0 ? t.top += h : l > 0 ? t.top -= l : t.top = o(t.top - r, t.top);
        }
      },
      flip: {
        left: function (t, e) {
          var i,
              s,
              n = e.within,
              o = n.offset.left + n.scrollLeft,
              r = n.width,
              h = n.isWindow ? n.scrollLeft : n.offset.left,
              l = t.left - e.collisionPosition.marginLeft,
              c = l - h,
              u = l + e.collisionWidth - r - h,
              d = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
              p = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
              f = -2 * e.offset[0];
          0 > c ? (i = t.left + d + p + f + e.collisionWidth - r - o, (0 > i || a(c) > i) && (t.left += d + p + f)) : u > 0 && (s = t.left - e.collisionPosition.marginLeft + d + p + f - h, (s > 0 || u > a(s)) && (t.left += d + p + f));
        },
        top: function (t, e) {
          var i,
              s,
              n = e.within,
              o = n.offset.top + n.scrollTop,
              r = n.height,
              h = n.isWindow ? n.scrollTop : n.offset.top,
              l = t.top - e.collisionPosition.marginTop,
              c = l - h,
              u = l + e.collisionHeight - r - h,
              d = "top" === e.my[1],
              p = d ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
              f = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
              g = -2 * e.offset[1];
          0 > c ? (s = t.top + p + f + g + e.collisionHeight - r - o, (0 > s || a(c) > s) && (t.top += p + f + g)) : u > 0 && (i = t.top - e.collisionPosition.marginTop + p + f + g - h, (i > 0 || u > a(i)) && (t.top += p + f + g));
        }
      },
      flipfit: {
        left: function () {
          t.ui.position.flip.left.apply(this, arguments), t.ui.position.fit.left.apply(this, arguments);
        },
        top: function () {
          t.ui.position.flip.top.apply(this, arguments), t.ui.position.fit.top.apply(this, arguments);
        }
      }
    };
  }(), t.ui.position, t.extend(t.expr[":"], {
    data: t.expr.createPseudo ? t.expr.createPseudo(function (e) {
      return function (i) {
        return !!t.data(i, e);
      };
    }) : function (e, i, s) {
      return !!t.data(e, s[3]);
    }
  }), t.fn.extend({
    disableSelection: function () {
      var t = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
      return function () {
        return this.on(t + ".ui-disableSelection", function (t) {
          t.preventDefault();
        });
      };
    }(),
    enableSelection: function () {
      return this.off(".ui-disableSelection");
    }
  });
  var c = "ui-effects-",
      u = "ui-effects-style",
      d = "ui-effects-animated",
      p = t;
  t.effects = {
    effect: {}
  }, function (t, e) {
    function i(t, e, i) {
      var s = u[e.type] || {};
      return null == t ? i || !e.def ? null : e.def : (t = s.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : s.mod ? (t + s.mod) % s.mod : 0 > t ? 0 : t > s.max ? s.max : t);
    }

    function s(i) {
      var s = l(),
          n = s._rgba = [];
      return i = i.toLowerCase(), f(h, function (t, o) {
        var a,
            r = o.re.exec(i),
            h = r && o.parse(r),
            l = o.space || "rgba";
        return h ? (a = s[l](h), s[c[l].cache] = a[c[l].cache], n = s._rgba = a._rgba, !1) : e;
      }), n.length ? ("0,0,0,0" === n.join() && t.extend(n, o.transparent), s) : o[i];
    }

    function n(t, e, i) {
      return i = (i + 1) % 1, 1 > 6 * i ? t + 6 * (e - t) * i : 1 > 2 * i ? e : 2 > 3 * i ? t + 6 * (e - t) * (2 / 3 - i) : t;
    }

    var o,
        a = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
        r = /^([\-+])=\s*(\d+\.?\d*)/,
        h = [{
      re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function (t) {
        return [t[1], t[2], t[3], t[4]];
      }
    }, {
      re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function (t) {
        return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]];
      }
    }, {
      re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
      parse: function (t) {
        return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)];
      }
    }, {
      re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
      parse: function (t) {
        return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)];
      }
    }, {
      re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      space: "hsla",
      parse: function (t) {
        return [t[1], t[2] / 100, t[3] / 100, t[4]];
      }
    }],
        l = t.Color = function (e, i, s, n) {
      return new t.Color.fn.parse(e, i, s, n);
    },
        c = {
      rgba: {
        props: {
          red: {
            idx: 0,
            type: "byte"
          },
          green: {
            idx: 1,
            type: "byte"
          },
          blue: {
            idx: 2,
            type: "byte"
          }
        }
      },
      hsla: {
        props: {
          hue: {
            idx: 0,
            type: "degrees"
          },
          saturation: {
            idx: 1,
            type: "percent"
          },
          lightness: {
            idx: 2,
            type: "percent"
          }
        }
      }
    },
        u = {
      "byte": {
        floor: !0,
        max: 255
      },
      percent: {
        max: 1
      },
      degrees: {
        mod: 360,
        floor: !0
      }
    },
        d = l.support = {},
        p = t("<p>")[0],
        f = t.each;

    p.style.cssText = "background-color:rgba(1,1,1,.5)", d.rgba = p.style.backgroundColor.indexOf("rgba") > -1, f(c, function (t, e) {
      e.cache = "_" + t, e.props.alpha = {
        idx: 3,
        type: "percent",
        def: 1
      };
    }), l.fn = t.extend(l.prototype, {
      parse: function (n, a, r, h) {
        if (n === e) return this._rgba = [null, null, null, null], this;
        (n.jquery || n.nodeType) && (n = t(n).css(a), a = e);
        var u = this,
            d = t.type(n),
            p = this._rgba = [];
        return a !== e && (n = [n, a, r, h], d = "array"), "string" === d ? this.parse(s(n) || o._default) : "array" === d ? (f(c.rgba.props, function (t, e) {
          p[e.idx] = i(n[e.idx], e);
        }), this) : "object" === d ? (n instanceof l ? f(c, function (t, e) {
          n[e.cache] && (u[e.cache] = n[e.cache].slice());
        }) : f(c, function (e, s) {
          var o = s.cache;
          f(s.props, function (t, e) {
            if (!u[o] && s.to) {
              if ("alpha" === t || null == n[t]) return;
              u[o] = s.to(u._rgba);
            }

            u[o][e.idx] = i(n[t], e, !0);
          }), u[o] && 0 > t.inArray(null, u[o].slice(0, 3)) && (u[o][3] = 1, s.from && (u._rgba = s.from(u[o])));
        }), this) : e;
      },
      is: function (t) {
        var i = l(t),
            s = !0,
            n = this;
        return f(c, function (t, o) {
          var a,
              r = i[o.cache];
          return r && (a = n[o.cache] || o.to && o.to(n._rgba) || [], f(o.props, function (t, i) {
            return null != r[i.idx] ? s = r[i.idx] === a[i.idx] : e;
          })), s;
        }), s;
      },
      _space: function () {
        var t = [],
            e = this;
        return f(c, function (i, s) {
          e[s.cache] && t.push(i);
        }), t.pop();
      },
      transition: function (t, e) {
        var s = l(t),
            n = s._space(),
            o = c[n],
            a = 0 === this.alpha() ? l("transparent") : this,
            r = a[o.cache] || o.to(a._rgba),
            h = r.slice();

        return s = s[o.cache], f(o.props, function (t, n) {
          var o = n.idx,
              a = r[o],
              l = s[o],
              c = u[n.type] || {};
          null !== l && (null === a ? h[o] = l : (c.mod && (l - a > c.mod / 2 ? a += c.mod : a - l > c.mod / 2 && (a -= c.mod)), h[o] = i((l - a) * e + a, n)));
        }), this[n](h);
      },
      blend: function (e) {
        if (1 === this._rgba[3]) return this;

        var i = this._rgba.slice(),
            s = i.pop(),
            n = l(e)._rgba;

        return l(t.map(i, function (t, e) {
          return (1 - s) * n[e] + s * t;
        }));
      },
      toRgbaString: function () {
        var e = "rgba(",
            i = t.map(this._rgba, function (t, e) {
          return null == t ? e > 2 ? 1 : 0 : t;
        });
        return 1 === i[3] && (i.pop(), e = "rgb("), e + i.join() + ")";
      },
      toHslaString: function () {
        var e = "hsla(",
            i = t.map(this.hsla(), function (t, e) {
          return null == t && (t = e > 2 ? 1 : 0), e && 3 > e && (t = Math.round(100 * t) + "%"), t;
        });
        return 1 === i[3] && (i.pop(), e = "hsl("), e + i.join() + ")";
      },
      toHexString: function (e) {
        var i = this._rgba.slice(),
            s = i.pop();

        return e && i.push(~~(255 * s)), "#" + t.map(i, function (t) {
          return t = (t || 0).toString(16), 1 === t.length ? "0" + t : t;
        }).join("");
      },
      toString: function () {
        return 0 === this._rgba[3] ? "transparent" : this.toRgbaString();
      }
    }), l.fn.parse.prototype = l.fn, c.hsla.to = function (t) {
      if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
      var e,
          i,
          s = t[0] / 255,
          n = t[1] / 255,
          o = t[2] / 255,
          a = t[3],
          r = Math.max(s, n, o),
          h = Math.min(s, n, o),
          l = r - h,
          c = r + h,
          u = .5 * c;
      return e = h === r ? 0 : s === r ? 60 * (n - o) / l + 360 : n === r ? 60 * (o - s) / l + 120 : 60 * (s - n) / l + 240, i = 0 === l ? 0 : .5 >= u ? l / c : l / (2 - c), [Math.round(e) % 360, i, u, null == a ? 1 : a];
    }, c.hsla.from = function (t) {
      if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
      var e = t[0] / 360,
          i = t[1],
          s = t[2],
          o = t[3],
          a = .5 >= s ? s * (1 + i) : s + i - s * i,
          r = 2 * s - a;
      return [Math.round(255 * n(r, a, e + 1 / 3)), Math.round(255 * n(r, a, e)), Math.round(255 * n(r, a, e - 1 / 3)), o];
    }, f(c, function (s, n) {
      var o = n.props,
          a = n.cache,
          h = n.to,
          c = n.from;
      l.fn[s] = function (s) {
        if (h && !this[a] && (this[a] = h(this._rgba)), s === e) return this[a].slice();
        var n,
            r = t.type(s),
            u = "array" === r || "object" === r ? s : arguments,
            d = this[a].slice();
        return f(o, function (t, e) {
          var s = u["object" === r ? t : e.idx];
          null == s && (s = d[e.idx]), d[e.idx] = i(s, e);
        }), c ? (n = l(c(d)), n[a] = d, n) : l(d);
      }, f(o, function (e, i) {
        l.fn[e] || (l.fn[e] = function (n) {
          var o,
              a = t.type(n),
              h = "alpha" === e ? this._hsla ? "hsla" : "rgba" : s,
              l = this[h](),
              c = l[i.idx];
          return "undefined" === a ? c : ("function" === a && (n = n.call(this, c), a = t.type(n)), null == n && i.empty ? this : ("string" === a && (o = r.exec(n), o && (n = c + parseFloat(o[2]) * ("+" === o[1] ? 1 : -1))), l[i.idx] = n, this[h](l)));
        });
      });
    }), l.hook = function (e) {
      var i = e.split(" ");
      f(i, function (e, i) {
        t.cssHooks[i] = {
          set: function (e, n) {
            var o,
                a,
                r = "";

            if ("transparent" !== n && ("string" !== t.type(n) || (o = s(n)))) {
              if (n = l(o || n), !d.rgba && 1 !== n._rgba[3]) {
                for (a = "backgroundColor" === i ? e.parentNode : e; ("" === r || "transparent" === r) && a && a.style;) try {
                  r = t.css(a, "backgroundColor"), a = a.parentNode;
                } catch (h) {}

                n = n.blend(r && "transparent" !== r ? r : "_default");
              }

              n = n.toRgbaString();
            }

            try {
              e.style[i] = n;
            } catch (h) {}
          }
        }, t.fx.step[i] = function (e) {
          e.colorInit || (e.start = l(e.elem, i), e.end = l(e.end), e.colorInit = !0), t.cssHooks[i].set(e.elem, e.start.transition(e.end, e.pos));
        };
      });
    }, l.hook(a), t.cssHooks.borderColor = {
      expand: function (t) {
        var e = {};
        return f(["Top", "Right", "Bottom", "Left"], function (i, s) {
          e["border" + s + "Color"] = t;
        }), e;
      }
    }, o = t.Color.names = {
      aqua: "#00ffff",
      black: "#000000",
      blue: "#0000ff",
      fuchsia: "#ff00ff",
      gray: "#808080",
      green: "#008000",
      lime: "#00ff00",
      maroon: "#800000",
      navy: "#000080",
      olive: "#808000",
      purple: "#800080",
      red: "#ff0000",
      silver: "#c0c0c0",
      teal: "#008080",
      white: "#ffffff",
      yellow: "#ffff00",
      transparent: [null, null, null, 0],
      _default: "#ffffff"
    };
  }(p), function () {
    function e(e) {
      var i,
          s,
          n = e.ownerDocument.defaultView ? e.ownerDocument.defaultView.getComputedStyle(e, null) : e.currentStyle,
          o = {};
      if (n && n.length && n[0] && n[n[0]]) for (s = n.length; s--;) i = n[s], "string" == typeof n[i] && (o[t.camelCase(i)] = n[i]);else for (i in n) "string" == typeof n[i] && (o[i] = n[i]);
      return o;
    }

    function i(e, i) {
      var s,
          o,
          a = {};

      for (s in i) o = i[s], e[s] !== o && (n[s] || (t.fx.step[s] || !isNaN(parseFloat(o))) && (a[s] = o));

      return a;
    }

    var s = ["add", "remove", "toggle"],
        n = {
      border: 1,
      borderBottom: 1,
      borderColor: 1,
      borderLeft: 1,
      borderRight: 1,
      borderTop: 1,
      borderWidth: 1,
      margin: 1,
      padding: 1
    };
    t.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (e, i) {
      t.fx.step[i] = function (t) {
        ("none" !== t.end && !t.setAttr || 1 === t.pos && !t.setAttr) && (p.style(t.elem, i, t.end), t.setAttr = !0);
      };
    }), t.fn.addBack || (t.fn.addBack = function (t) {
      return this.add(null == t ? this.prevObject : this.prevObject.filter(t));
    }), t.effects.animateClass = function (n, o, a, r) {
      var h = t.speed(o, a, r);
      return this.queue(function () {
        var o,
            a = t(this),
            r = a.attr("class") || "",
            l = h.children ? a.find("*").addBack() : a;
        l = l.map(function () {
          var i = t(this);
          return {
            el: i,
            start: e(this)
          };
        }), o = function () {
          t.each(s, function (t, e) {
            n[e] && a[e + "Class"](n[e]);
          });
        }, o(), l = l.map(function () {
          return this.end = e(this.el[0]), this.diff = i(this.start, this.end), this;
        }), a.attr("class", r), l = l.map(function () {
          var e = this,
              i = t.Deferred(),
              s = t.extend({}, h, {
            queue: !1,
            complete: function () {
              i.resolve(e);
            }
          });
          return this.el.animate(this.diff, s), i.promise();
        }), t.when.apply(t, l.get()).done(function () {
          o(), t.each(arguments, function () {
            var e = this.el;
            t.each(this.diff, function (t) {
              e.css(t, "");
            });
          }), h.complete.call(a[0]);
        });
      });
    }, t.fn.extend({
      addClass: function (e) {
        return function (i, s, n, o) {
          return s ? t.effects.animateClass.call(this, {
            add: i
          }, s, n, o) : e.apply(this, arguments);
        };
      }(t.fn.addClass),
      removeClass: function (e) {
        return function (i, s, n, o) {
          return arguments.length > 1 ? t.effects.animateClass.call(this, {
            remove: i
          }, s, n, o) : e.apply(this, arguments);
        };
      }(t.fn.removeClass),
      toggleClass: function (e) {
        return function (i, s, n, o, a) {
          return "boolean" == typeof s || void 0 === s ? n ? t.effects.animateClass.call(this, s ? {
            add: i
          } : {
            remove: i
          }, n, o, a) : e.apply(this, arguments) : t.effects.animateClass.call(this, {
            toggle: i
          }, s, n, o);
        };
      }(t.fn.toggleClass),
      switchClass: function (e, i, s, n, o) {
        return t.effects.animateClass.call(this, {
          add: i,
          remove: e
        }, s, n, o);
      }
    });
  }(), function () {
    function e(e, i, s, n) {
      return t.isPlainObject(e) && (i = e, e = e.effect), e = {
        effect: e
      }, null == i && (i = {}), t.isFunction(i) && (n = i, s = null, i = {}), ("number" == typeof i || t.fx.speeds[i]) && (n = s, s = i, i = {}), t.isFunction(s) && (n = s, s = null), i && t.extend(e, i), s = s || i.duration, e.duration = t.fx.off ? 0 : "number" == typeof s ? s : s in t.fx.speeds ? t.fx.speeds[s] : t.fx.speeds._default, e.complete = n || i.complete, e;
    }

    function i(e) {
      return !e || "number" == typeof e || t.fx.speeds[e] ? !0 : "string" != typeof e || t.effects.effect[e] ? t.isFunction(e) ? !0 : "object" != typeof e || e.effect ? !1 : !0 : !0;
    }

    function s(t, e) {
      var i = e.outerWidth(),
          s = e.outerHeight(),
          n = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
          o = n.exec(t) || ["", 0, i, s, 0];
      return {
        top: parseFloat(o[1]) || 0,
        right: "auto" === o[2] ? i : parseFloat(o[2]),
        bottom: "auto" === o[3] ? s : parseFloat(o[3]),
        left: parseFloat(o[4]) || 0
      };
    }

    t.expr && t.expr.filters && t.expr.filters.animated && (t.expr.filters.animated = function (e) {
      return function (i) {
        return !!t(i).data(d) || e(i);
      };
    }(t.expr.filters.animated)), t.uiBackCompat !== !1 && t.extend(t.effects, {
      save: function (t, e) {
        for (var i = 0, s = e.length; s > i; i++) null !== e[i] && t.data(c + e[i], t[0].style[e[i]]);
      },
      restore: function (t, e) {
        for (var i, s = 0, n = e.length; n > s; s++) null !== e[s] && (i = t.data(c + e[s]), t.css(e[s], i));
      },
      setMode: function (t, e) {
        return "toggle" === e && (e = t.is(":hidden") ? "show" : "hide"), e;
      },
      createWrapper: function (e) {
        if (e.parent().is(".ui-effects-wrapper")) return e.parent();
        var i = {
          width: e.outerWidth(!0),
          height: e.outerHeight(!0),
          "float": e.css("float")
        },
            s = t("<div></div>").addClass("ui-effects-wrapper").css({
          fontSize: "100%",
          background: "transparent",
          border: "none",
          margin: 0,
          padding: 0
        }),
            n = {
          width: e.width(),
          height: e.height()
        },
            o = document.activeElement;

        try {
          o.id;
        } catch (a) {
          o = document.body;
        }

        return e.wrap(s), (e[0] === o || t.contains(e[0], o)) && t(o).trigger("focus"), s = e.parent(), "static" === e.css("position") ? (s.css({
          position: "relative"
        }), e.css({
          position: "relative"
        })) : (t.extend(i, {
          position: e.css("position"),
          zIndex: e.css("z-index")
        }), t.each(["top", "left", "bottom", "right"], function (t, s) {
          i[s] = e.css(s), isNaN(parseInt(i[s], 10)) && (i[s] = "auto");
        }), e.css({
          position: "relative",
          top: 0,
          left: 0,
          right: "auto",
          bottom: "auto"
        })), e.css(n), s.css(i).show();
      },
      removeWrapper: function (e) {
        var i = document.activeElement;
        return e.parent().is(".ui-effects-wrapper") && (e.parent().replaceWith(e), (e[0] === i || t.contains(e[0], i)) && t(i).trigger("focus")), e;
      }
    }), t.extend(t.effects, {
      version: "1.12.1",
      define: function (e, i, s) {
        return s || (s = i, i = "effect"), t.effects.effect[e] = s, t.effects.effect[e].mode = i, s;
      },
      scaledDimensions: function (t, e, i) {
        if (0 === e) return {
          height: 0,
          width: 0,
          outerHeight: 0,
          outerWidth: 0
        };
        var s = "horizontal" !== i ? (e || 100) / 100 : 1,
            n = "vertical" !== i ? (e || 100) / 100 : 1;
        return {
          height: t.height() * n,
          width: t.width() * s,
          outerHeight: t.outerHeight() * n,
          outerWidth: t.outerWidth() * s
        };
      },
      clipToBox: function (t) {
        return {
          width: t.clip.right - t.clip.left,
          height: t.clip.bottom - t.clip.top,
          left: t.clip.left,
          top: t.clip.top
        };
      },
      unshift: function (t, e, i) {
        var s = t.queue();
        e > 1 && s.splice.apply(s, [1, 0].concat(s.splice(e, i))), t.dequeue();
      },
      saveStyle: function (t) {
        t.data(u, t[0].style.cssText);
      },
      restoreStyle: function (t) {
        t[0].style.cssText = t.data(u) || "", t.removeData(u);
      },
      mode: function (t, e) {
        var i = t.is(":hidden");
        return "toggle" === e && (e = i ? "show" : "hide"), (i ? "hide" === e : "show" === e) && (e = "none"), e;
      },
      getBaseline: function (t, e) {
        var i, s;

        switch (t[0]) {
          case "top":
            i = 0;
            break;

          case "middle":
            i = .5;
            break;

          case "bottom":
            i = 1;
            break;

          default:
            i = t[0] / e.height;
        }

        switch (t[1]) {
          case "left":
            s = 0;
            break;

          case "center":
            s = .5;
            break;

          case "right":
            s = 1;
            break;

          default:
            s = t[1] / e.width;
        }

        return {
          x: s,
          y: i
        };
      },
      createPlaceholder: function (e) {
        var i,
            s = e.css("position"),
            n = e.position();
        return e.css({
          marginTop: e.css("marginTop"),
          marginBottom: e.css("marginBottom"),
          marginLeft: e.css("marginLeft"),
          marginRight: e.css("marginRight")
        }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()), /^(static|relative)/.test(s) && (s = "absolute", i = t("<" + e[0].nodeName + ">").insertAfter(e).css({
          display: /^(inline|ruby)/.test(e.css("display")) ? "inline-block" : "block",
          visibility: "hidden",
          marginTop: e.css("marginTop"),
          marginBottom: e.css("marginBottom"),
          marginLeft: e.css("marginLeft"),
          marginRight: e.css("marginRight"),
          "float": e.css("float")
        }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"), e.data(c + "placeholder", i)), e.css({
          position: s,
          left: n.left,
          top: n.top
        }), i;
      },
      removePlaceholder: function (t) {
        var e = c + "placeholder",
            i = t.data(e);
        i && (i.remove(), t.removeData(e));
      },
      cleanUp: function (e) {
        t.effects.restoreStyle(e), t.effects.removePlaceholder(e);
      },
      setTransition: function (e, i, s, n) {
        return n = n || {}, t.each(i, function (t, i) {
          var o = e.cssUnit(i);
          o[0] > 0 && (n[i] = o[0] * s + o[1]);
        }), n;
      }
    }), t.fn.extend({
      effect: function () {
        function i(e) {
          function i() {
            r.removeData(d), t.effects.cleanUp(r), "hide" === s.mode && r.hide(), a();
          }

          function a() {
            t.isFunction(h) && h.call(r[0]), t.isFunction(e) && e();
          }

          var r = t(this);
          s.mode = c.shift(), t.uiBackCompat === !1 || o ? "none" === s.mode ? (r[l](), a()) : n.call(r[0], s, i) : (r.is(":hidden") ? "hide" === l : "show" === l) ? (r[l](), a()) : n.call(r[0], s, a);
        }

        var s = e.apply(this, arguments),
            n = t.effects.effect[s.effect],
            o = n.mode,
            a = s.queue,
            r = a || "fx",
            h = s.complete,
            l = s.mode,
            c = [],
            u = function (e) {
          var i = t(this),
              s = t.effects.mode(i, l) || o;
          i.data(d, !0), c.push(s), o && ("show" === s || s === o && "hide" === s) && i.show(), o && "none" === s || t.effects.saveStyle(i), t.isFunction(e) && e();
        };

        return t.fx.off || !n ? l ? this[l](s.duration, h) : this.each(function () {
          h && h.call(this);
        }) : a === !1 ? this.each(u).each(i) : this.queue(r, u).queue(r, i);
      },
      show: function (t) {
        return function (s) {
          if (i(s)) return t.apply(this, arguments);
          var n = e.apply(this, arguments);
          return n.mode = "show", this.effect.call(this, n);
        };
      }(t.fn.show),
      hide: function (t) {
        return function (s) {
          if (i(s)) return t.apply(this, arguments);
          var n = e.apply(this, arguments);
          return n.mode = "hide", this.effect.call(this, n);
        };
      }(t.fn.hide),
      toggle: function (t) {
        return function (s) {
          if (i(s) || "boolean" == typeof s) return t.apply(this, arguments);
          var n = e.apply(this, arguments);
          return n.mode = "toggle", this.effect.call(this, n);
        };
      }(t.fn.toggle),
      cssUnit: function (e) {
        var i = this.css(e),
            s = [];
        return t.each(["em", "px", "%", "pt"], function (t, e) {
          i.indexOf(e) > 0 && (s = [parseFloat(i), e]);
        }), s;
      },
      cssClip: function (t) {
        return t ? this.css("clip", "rect(" + t.top + "px " + t.right + "px " + t.bottom + "px " + t.left + "px)") : s(this.css("clip"), this);
      },
      transfer: function (e, i) {
        var s = t(this),
            n = t(e.to),
            o = "fixed" === n.css("position"),
            a = t("body"),
            r = o ? a.scrollTop() : 0,
            h = o ? a.scrollLeft() : 0,
            l = n.offset(),
            c = {
          top: l.top - r,
          left: l.left - h,
          height: n.innerHeight(),
          width: n.innerWidth()
        },
            u = s.offset(),
            d = t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({
          top: u.top - r,
          left: u.left - h,
          height: s.innerHeight(),
          width: s.innerWidth(),
          position: o ? "fixed" : "absolute"
        }).animate(c, e.duration, e.easing, function () {
          d.remove(), t.isFunction(i) && i();
        });
      }
    }), t.fx.step.clip = function (e) {
      e.clipInit || (e.start = t(e.elem).cssClip(), "string" == typeof e.end && (e.end = s(e.end, e.elem)), e.clipInit = !0), t(e.elem).cssClip({
        top: e.pos * (e.end.top - e.start.top) + e.start.top,
        right: e.pos * (e.end.right - e.start.right) + e.start.right,
        bottom: e.pos * (e.end.bottom - e.start.bottom) + e.start.bottom,
        left: e.pos * (e.end.left - e.start.left) + e.start.left
      });
    };
  }(), function () {
    var e = {};
    t.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (t, i) {
      e[i] = function (e) {
        return Math.pow(e, t + 2);
      };
    }), t.extend(e, {
      Sine: function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      },
      Circ: function (t) {
        return 1 - Math.sqrt(1 - t * t);
      },
      Elastic: function (t) {
        return 0 === t || 1 === t ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15);
      },
      Back: function (t) {
        return t * t * (3 * t - 2);
      },
      Bounce: function (t) {
        for (var e, i = 4; ((e = Math.pow(2, --i)) - 1) / 11 > t;);

        return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2);
      }
    }), t.each(e, function (e, i) {
      t.easing["easeIn" + e] = i, t.easing["easeOut" + e] = function (t) {
        return 1 - i(1 - t);
      }, t.easing["easeInOut" + e] = function (t) {
        return .5 > t ? i(2 * t) / 2 : 1 - i(-2 * t + 2) / 2;
      };
    });
  }();
  var f = t.effects;
  t.effects.define("blind", "hide", function (e, i) {
    var s = {
      up: ["bottom", "top"],
      vertical: ["bottom", "top"],
      down: ["top", "bottom"],
      left: ["right", "left"],
      horizontal: ["right", "left"],
      right: ["left", "right"]
    },
        n = t(this),
        o = e.direction || "up",
        a = n.cssClip(),
        r = {
      clip: t.extend({}, a)
    },
        h = t.effects.createPlaceholder(n);
    r.clip[s[o][0]] = r.clip[s[o][1]], "show" === e.mode && (n.cssClip(r.clip), h && h.css(t.effects.clipToBox(r)), r.clip = a), h && h.animate(t.effects.clipToBox(r), e.duration, e.easing), n.animate(r, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  }), t.effects.define("bounce", function (e, i) {
    var s,
        n,
        o,
        a = t(this),
        r = e.mode,
        h = "hide" === r,
        l = "show" === r,
        c = e.direction || "up",
        u = e.distance,
        d = e.times || 5,
        p = 2 * d + (l || h ? 1 : 0),
        f = e.duration / p,
        g = e.easing,
        m = "up" === c || "down" === c ? "top" : "left",
        _ = "up" === c || "left" === c,
        v = 0,
        b = a.queue().length;

    for (t.effects.createPlaceholder(a), o = a.css(m), u || (u = a["top" === m ? "outerHeight" : "outerWidth"]() / 3), l && (n = {
      opacity: 1
    }, n[m] = o, a.css("opacity", 0).css(m, _ ? 2 * -u : 2 * u).animate(n, f, g)), h && (u /= Math.pow(2, d - 1)), n = {}, n[m] = o; d > v; v++) s = {}, s[m] = (_ ? "-=" : "+=") + u, a.animate(s, f, g).animate(n, f, g), u = h ? 2 * u : u / 2;

    h && (s = {
      opacity: 0
    }, s[m] = (_ ? "-=" : "+=") + u, a.animate(s, f, g)), a.queue(i), t.effects.unshift(a, b, p + 1);
  }), t.effects.define("clip", "hide", function (e, i) {
    var s,
        n = {},
        o = t(this),
        a = e.direction || "vertical",
        r = "both" === a,
        h = r || "horizontal" === a,
        l = r || "vertical" === a;
    s = o.cssClip(), n.clip = {
      top: l ? (s.bottom - s.top) / 2 : s.top,
      right: h ? (s.right - s.left) / 2 : s.right,
      bottom: l ? (s.bottom - s.top) / 2 : s.bottom,
      left: h ? (s.right - s.left) / 2 : s.left
    }, t.effects.createPlaceholder(o), "show" === e.mode && (o.cssClip(n.clip), n.clip = s), o.animate(n, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  }), t.effects.define("drop", "hide", function (e, i) {
    var s,
        n = t(this),
        o = e.mode,
        a = "show" === o,
        r = e.direction || "left",
        h = "up" === r || "down" === r ? "top" : "left",
        l = "up" === r || "left" === r ? "-=" : "+=",
        c = "+=" === l ? "-=" : "+=",
        u = {
      opacity: 0
    };
    t.effects.createPlaceholder(n), s = e.distance || n["top" === h ? "outerHeight" : "outerWidth"](!0) / 2, u[h] = l + s, a && (n.css(u), u[h] = c + s, u.opacity = 1), n.animate(u, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  }), t.effects.define("explode", "hide", function (e, i) {
    function s() {
      b.push(this), b.length === u * d && n();
    }

    function n() {
      p.css({
        visibility: "visible"
      }), t(b).remove(), i();
    }

    var o,
        a,
        r,
        h,
        l,
        c,
        u = e.pieces ? Math.round(Math.sqrt(e.pieces)) : 3,
        d = u,
        p = t(this),
        f = e.mode,
        g = "show" === f,
        m = p.show().css("visibility", "hidden").offset(),
        _ = Math.ceil(p.outerWidth() / d),
        v = Math.ceil(p.outerHeight() / u),
        b = [];

    for (o = 0; u > o; o++) for (h = m.top + o * v, c = o - (u - 1) / 2, a = 0; d > a; a++) r = m.left + a * _, l = a - (d - 1) / 2, p.clone().appendTo("body").wrap("<div></div>").css({
      position: "absolute",
      visibility: "visible",
      left: -a * _,
      top: -o * v
    }).parent().addClass("ui-effects-explode").css({
      position: "absolute",
      overflow: "hidden",
      width: _,
      height: v,
      left: r + (g ? l * _ : 0),
      top: h + (g ? c * v : 0),
      opacity: g ? 0 : 1
    }).animate({
      left: r + (g ? 0 : l * _),
      top: h + (g ? 0 : c * v),
      opacity: g ? 1 : 0
    }, e.duration || 500, e.easing, s);
  }), t.effects.define("fade", "toggle", function (e, i) {
    var s = "show" === e.mode;
    t(this).css("opacity", s ? 0 : 1).animate({
      opacity: s ? 1 : 0
    }, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  }), t.effects.define("fold", "hide", function (e, i) {
    var s = t(this),
        n = e.mode,
        o = "show" === n,
        a = "hide" === n,
        r = e.size || 15,
        h = /([0-9]+)%/.exec(r),
        l = !!e.horizFirst,
        c = l ? ["right", "bottom"] : ["bottom", "right"],
        u = e.duration / 2,
        d = t.effects.createPlaceholder(s),
        p = s.cssClip(),
        f = {
      clip: t.extend({}, p)
    },
        g = {
      clip: t.extend({}, p)
    },
        m = [p[c[0]], p[c[1]]],
        _ = s.queue().length;
    h && (r = parseInt(h[1], 10) / 100 * m[a ? 0 : 1]), f.clip[c[0]] = r, g.clip[c[0]] = r, g.clip[c[1]] = 0, o && (s.cssClip(g.clip), d && d.css(t.effects.clipToBox(g)), g.clip = p), s.queue(function (i) {
      d && d.animate(t.effects.clipToBox(f), u, e.easing).animate(t.effects.clipToBox(g), u, e.easing), i();
    }).animate(f, u, e.easing).animate(g, u, e.easing).queue(i), t.effects.unshift(s, _, 4);
  }), t.effects.define("highlight", "show", function (e, i) {
    var s = t(this),
        n = {
      backgroundColor: s.css("backgroundColor")
    };
    "hide" === e.mode && (n.opacity = 0), t.effects.saveStyle(s), s.css({
      backgroundImage: "none",
      backgroundColor: e.color || "#ffff99"
    }).animate(n, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  }), t.effects.define("size", function (e, i) {
    var s,
        n,
        o,
        a = t(this),
        r = ["fontSize"],
        h = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
        l = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
        c = e.mode,
        u = "effect" !== c,
        d = e.scale || "both",
        p = e.origin || ["middle", "center"],
        f = a.css("position"),
        g = a.position(),
        m = t.effects.scaledDimensions(a),
        _ = e.from || m,
        v = e.to || t.effects.scaledDimensions(a, 0);

    t.effects.createPlaceholder(a), "show" === c && (o = _, _ = v, v = o), n = {
      from: {
        y: _.height / m.height,
        x: _.width / m.width
      },
      to: {
        y: v.height / m.height,
        x: v.width / m.width
      }
    }, ("box" === d || "both" === d) && (n.from.y !== n.to.y && (_ = t.effects.setTransition(a, h, n.from.y, _), v = t.effects.setTransition(a, h, n.to.y, v)), n.from.x !== n.to.x && (_ = t.effects.setTransition(a, l, n.from.x, _), v = t.effects.setTransition(a, l, n.to.x, v))), ("content" === d || "both" === d) && n.from.y !== n.to.y && (_ = t.effects.setTransition(a, r, n.from.y, _), v = t.effects.setTransition(a, r, n.to.y, v)), p && (s = t.effects.getBaseline(p, m), _.top = (m.outerHeight - _.outerHeight) * s.y + g.top, _.left = (m.outerWidth - _.outerWidth) * s.x + g.left, v.top = (m.outerHeight - v.outerHeight) * s.y + g.top, v.left = (m.outerWidth - v.outerWidth) * s.x + g.left), a.css(_), ("content" === d || "both" === d) && (h = h.concat(["marginTop", "marginBottom"]).concat(r), l = l.concat(["marginLeft", "marginRight"]), a.find("*[width]").each(function () {
      var i = t(this),
          s = t.effects.scaledDimensions(i),
          o = {
        height: s.height * n.from.y,
        width: s.width * n.from.x,
        outerHeight: s.outerHeight * n.from.y,
        outerWidth: s.outerWidth * n.from.x
      },
          a = {
        height: s.height * n.to.y,
        width: s.width * n.to.x,
        outerHeight: s.height * n.to.y,
        outerWidth: s.width * n.to.x
      };
      n.from.y !== n.to.y && (o = t.effects.setTransition(i, h, n.from.y, o), a = t.effects.setTransition(i, h, n.to.y, a)), n.from.x !== n.to.x && (o = t.effects.setTransition(i, l, n.from.x, o), a = t.effects.setTransition(i, l, n.to.x, a)), u && t.effects.saveStyle(i), i.css(o), i.animate(a, e.duration, e.easing, function () {
        u && t.effects.restoreStyle(i);
      });
    })), a.animate(v, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: function () {
        var e = a.offset();
        0 === v.opacity && a.css("opacity", _.opacity), u || (a.css("position", "static" === f ? "relative" : f).offset(e), t.effects.saveStyle(a)), i();
      }
    });
  }), t.effects.define("scale", function (e, i) {
    var s = t(this),
        n = e.mode,
        o = parseInt(e.percent, 10) || (0 === parseInt(e.percent, 10) ? 0 : "effect" !== n ? 0 : 100),
        a = t.extend(!0, {
      from: t.effects.scaledDimensions(s),
      to: t.effects.scaledDimensions(s, o, e.direction || "both"),
      origin: e.origin || ["middle", "center"]
    }, e);
    e.fade && (a.from.opacity = 1, a.to.opacity = 0), t.effects.effect.size.call(this, a, i);
  }), t.effects.define("puff", "hide", function (e, i) {
    var s = t.extend(!0, {}, e, {
      fade: !0,
      percent: parseInt(e.percent, 10) || 150
    });
    t.effects.effect.scale.call(this, s, i);
  }), t.effects.define("pulsate", "show", function (e, i) {
    var s = t(this),
        n = e.mode,
        o = "show" === n,
        a = "hide" === n,
        r = o || a,
        h = 2 * (e.times || 5) + (r ? 1 : 0),
        l = e.duration / h,
        c = 0,
        u = 1,
        d = s.queue().length;

    for ((o || !s.is(":visible")) && (s.css("opacity", 0).show(), c = 1); h > u; u++) s.animate({
      opacity: c
    }, l, e.easing), c = 1 - c;

    s.animate({
      opacity: c
    }, l, e.easing), s.queue(i), t.effects.unshift(s, d, h + 1);
  }), t.effects.define("shake", function (e, i) {
    var s = 1,
        n = t(this),
        o = e.direction || "left",
        a = e.distance || 20,
        r = e.times || 3,
        h = 2 * r + 1,
        l = Math.round(e.duration / h),
        c = "up" === o || "down" === o ? "top" : "left",
        u = "up" === o || "left" === o,
        d = {},
        p = {},
        f = {},
        g = n.queue().length;

    for (t.effects.createPlaceholder(n), d[c] = (u ? "-=" : "+=") + a, p[c] = (u ? "+=" : "-=") + 2 * a, f[c] = (u ? "-=" : "+=") + 2 * a, n.animate(d, l, e.easing); r > s; s++) n.animate(p, l, e.easing).animate(f, l, e.easing);

    n.animate(p, l, e.easing).animate(d, l / 2, e.easing).queue(i), t.effects.unshift(n, g, h + 1);
  }), t.effects.define("slide", "show", function (e, i) {
    var s,
        n,
        o = t(this),
        a = {
      up: ["bottom", "top"],
      down: ["top", "bottom"],
      left: ["right", "left"],
      right: ["left", "right"]
    },
        r = e.mode,
        h = e.direction || "left",
        l = "up" === h || "down" === h ? "top" : "left",
        c = "up" === h || "left" === h,
        u = e.distance || o["top" === l ? "outerHeight" : "outerWidth"](!0),
        d = {};
    t.effects.createPlaceholder(o), s = o.cssClip(), n = o.position()[l], d[l] = (c ? -1 : 1) * u + n, d.clip = o.cssClip(), d.clip[a[h][1]] = d.clip[a[h][0]], "show" === r && (o.cssClip(d.clip), o.css(l, d[l]), d.clip = s, d[l] = n), o.animate(d, {
      queue: !1,
      duration: e.duration,
      easing: e.easing,
      complete: i
    });
  });
  var f;
  t.uiBackCompat !== !1 && (f = t.effects.define("transfer", function (e, i) {
    t(this).transfer(e, i);
  })), t.ui.focusable = function (i, s) {
    var n,
        o,
        a,
        r,
        h,
        l = i.nodeName.toLowerCase();
    return "area" === l ? (n = i.parentNode, o = n.name, i.href && o && "map" === n.nodeName.toLowerCase() ? (a = t("img[usemap='#" + o + "']"), a.length > 0 && a.is(":visible")) : !1) : (/^(input|select|textarea|button|object)$/.test(l) ? (r = !i.disabled, r && (h = t(i).closest("fieldset")[0], h && (r = !h.disabled))) : r = "a" === l ? i.href || s : s, r && t(i).is(":visible") && e(t(i)));
  }, t.extend(t.expr[":"], {
    focusable: function (e) {
      return t.ui.focusable(e, null != t.attr(e, "tabindex"));
    }
  }), t.ui.focusable, t.fn.form = function () {
    return "string" == typeof this[0].form ? this.closest("form") : t(this[0].form);
  }, t.ui.formResetMixin = {
    _formResetHandler: function () {
      var e = t(this);
      setTimeout(function () {
        var i = e.data("ui-form-reset-instances");
        t.each(i, function () {
          this.refresh();
        });
      });
    },
    _bindFormResetHandler: function () {
      if (this.form = this.element.form(), this.form.length) {
        var t = this.form.data("ui-form-reset-instances") || [];
        t.length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t);
      }
    },
    _unbindFormResetHandler: function () {
      if (this.form.length) {
        var e = this.form.data("ui-form-reset-instances");
        e.splice(t.inArray(this, e), 1), e.length ? this.form.data("ui-form-reset-instances", e) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset");
      }
    }
  }, "1.7" === t.fn.jquery.substring(0, 3) && (t.each(["Width", "Height"], function (e, i) {
    function s(e, i, s, o) {
      return t.each(n, function () {
        i -= parseFloat(t.css(e, "padding" + this)) || 0, s && (i -= parseFloat(t.css(e, "border" + this + "Width")) || 0), o && (i -= parseFloat(t.css(e, "margin" + this)) || 0);
      }), i;
    }

    var n = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"],
        o = i.toLowerCase(),
        a = {
      innerWidth: t.fn.innerWidth,
      innerHeight: t.fn.innerHeight,
      outerWidth: t.fn.outerWidth,
      outerHeight: t.fn.outerHeight
    };
    t.fn["inner" + i] = function (e) {
      return void 0 === e ? a["inner" + i].call(this) : this.each(function () {
        t(this).css(o, s(this, e) + "px");
      });
    }, t.fn["outer" + i] = function (e, n) {
      return "number" != typeof e ? a["outer" + i].call(this, e) : this.each(function () {
        t(this).css(o, s(this, e, !0, n) + "px");
      });
    };
  }), t.fn.addBack = function (t) {
    return this.add(null == t ? this.prevObject : this.prevObject.filter(t));
  }), t.ui.keyCode = {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  }, t.ui.escapeSelector = function () {
    var t = /([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;
    return function (e) {
      return e.replace(t, "\\$1");
    };
  }(), t.fn.labels = function () {
    var e, i, s, n, o;
    return this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (n = this.eq(0).parents("label"), s = this.attr("id"), s && (e = this.eq(0).parents().last(), o = e.add(e.length ? e.siblings() : this.siblings()), i = "label[for='" + t.ui.escapeSelector(s) + "']", n = n.add(o.find(i).addBack(i))), this.pushStack(n));
  }, t.fn.scrollParent = function (e) {
    var i = this.css("position"),
        s = "absolute" === i,
        n = e ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
        o = this.parents().filter(function () {
      var e = t(this);
      return s && "static" === e.css("position") ? !1 : n.test(e.css("overflow") + e.css("overflow-y") + e.css("overflow-x"));
    }).eq(0);
    return "fixed" !== i && o.length ? o : t(this[0].ownerDocument || document);
  }, t.extend(t.expr[":"], {
    tabbable: function (e) {
      var i = t.attr(e, "tabindex"),
          s = null != i;
      return (!s || i >= 0) && t.ui.focusable(e, s);
    }
  }), t.fn.extend({
    uniqueId: function () {
      var t = 0;
      return function () {
        return this.each(function () {
          this.id || (this.id = "ui-id-" + ++t);
        });
      };
    }(),
    removeUniqueId: function () {
      return this.each(function () {
        /^ui-id-\d+$/.test(this.id) && t(this).removeAttr("id");
      });
    }
  }), t.widget("ui.accordion", {
    version: "1.12.1",
    options: {
      active: 0,
      animate: {},
      classes: {
        "ui-accordion-header": "ui-corner-top",
        "ui-accordion-header-collapsed": "ui-corner-all",
        "ui-accordion-content": "ui-corner-bottom"
      },
      collapsible: !1,
      event: "click",
      header: "> li > :first-child, > :not(li):even",
      heightStyle: "auto",
      icons: {
        activeHeader: "ui-icon-triangle-1-s",
        header: "ui-icon-triangle-1-e"
      },
      activate: null,
      beforeActivate: null
    },
    hideProps: {
      borderTopWidth: "hide",
      borderBottomWidth: "hide",
      paddingTop: "hide",
      paddingBottom: "hide",
      height: "hide"
    },
    showProps: {
      borderTopWidth: "show",
      borderBottomWidth: "show",
      paddingTop: "show",
      paddingBottom: "show",
      height: "show"
    },
    _create: function () {
      var e = this.options;
      this.prevShow = this.prevHide = t(), this._addClass("ui-accordion", "ui-widget ui-helper-reset"), this.element.attr("role", "tablist"), e.collapsible || e.active !== !1 && null != e.active || (e.active = 0), this._processPanels(), 0 > e.active && (e.active += this.headers.length), this._refresh();
    },
    _getCreateEventData: function () {
      return {
        header: this.active,
        panel: this.active.length ? this.active.next() : t()
      };
    },
    _createIcons: function () {
      var e,
          i,
          s = this.options.icons;
      s && (e = t("<span>"), this._addClass(e, "ui-accordion-header-icon", "ui-icon " + s.header), e.prependTo(this.headers), i = this.active.children(".ui-accordion-header-icon"), this._removeClass(i, s.header)._addClass(i, null, s.activeHeader)._addClass(this.headers, "ui-accordion-icons"));
    },
    _destroyIcons: function () {
      this._removeClass(this.headers, "ui-accordion-icons"), this.headers.children(".ui-accordion-header-icon").remove();
    },
    _destroy: function () {
      var t;
      this.element.removeAttr("role"), this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(), this._destroyIcons(), t = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && t.css("height", "");
    },
    _setOption: function (t, e) {
      return "active" === t ? (this._activate(e), void 0) : ("event" === t && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(e)), this._super(t, e), "collapsible" !== t || e || this.options.active !== !1 || this._activate(0), "icons" === t && (this._destroyIcons(), e && this._createIcons()), void 0);
    },
    _setOptionDisabled: function (t) {
      this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t), this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!t);
    },
    _keydown: function (e) {
      if (!e.altKey && !e.ctrlKey) {
        var i = t.ui.keyCode,
            s = this.headers.length,
            n = this.headers.index(e.target),
            o = !1;

        switch (e.keyCode) {
          case i.RIGHT:
          case i.DOWN:
            o = this.headers[(n + 1) % s];
            break;

          case i.LEFT:
          case i.UP:
            o = this.headers[(n - 1 + s) % s];
            break;

          case i.SPACE:
          case i.ENTER:
            this._eventHandler(e);

            break;

          case i.HOME:
            o = this.headers[0];
            break;

          case i.END:
            o = this.headers[s - 1];
        }

        o && (t(e.target).attr("tabIndex", -1), t(o).attr("tabIndex", 0), t(o).trigger("focus"), e.preventDefault());
      }
    },
    _panelKeyDown: function (e) {
      e.keyCode === t.ui.keyCode.UP && e.ctrlKey && t(e.currentTarget).prev().trigger("focus");
    },
    refresh: function () {
      var e = this.options;
      this._processPanels(), e.active === !1 && e.collapsible === !0 || !this.headers.length ? (e.active = !1, this.active = t()) : e.active === !1 ? this._activate(0) : this.active.length && !t.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (e.active = !1, this.active = t()) : this._activate(Math.max(0, e.active - 1)) : e.active = this.headers.index(this.active), this._destroyIcons(), this._refresh();
    },
    _processPanels: function () {
      var t = this.headers,
          e = this.panels;
      this.headers = this.element.find(this.options.header), this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default"), this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide(), this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content"), e && (this._off(t.not(this.headers)), this._off(e.not(this.panels)));
    },
    _refresh: function () {
      var e,
          i = this.options,
          s = i.heightStyle,
          n = this.element.parent();
      this.active = this._findActive(i.active), this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed"), this._addClass(this.active.next(), "ui-accordion-content-active"), this.active.next().show(), this.headers.attr("role", "tab").each(function () {
        var e = t(this),
            i = e.uniqueId().attr("id"),
            s = e.next(),
            n = s.uniqueId().attr("id");
        e.attr("aria-controls", n), s.attr("aria-labelledby", i);
      }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
        "aria-selected": "false",
        "aria-expanded": "false",
        tabIndex: -1
      }).next().attr({
        "aria-hidden": "true"
      }).hide(), this.active.length ? this.active.attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      }).next().attr({
        "aria-hidden": "false"
      }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(i.event), "fill" === s ? (e = n.height(), this.element.siblings(":visible").each(function () {
        var i = t(this),
            s = i.css("position");
        "absolute" !== s && "fixed" !== s && (e -= i.outerHeight(!0));
      }), this.headers.each(function () {
        e -= t(this).outerHeight(!0);
      }), this.headers.next().each(function () {
        t(this).height(Math.max(0, e - t(this).innerHeight() + t(this).height()));
      }).css("overflow", "auto")) : "auto" === s && (e = 0, this.headers.next().each(function () {
        var i = t(this).is(":visible");
        i || t(this).show(), e = Math.max(e, t(this).css("height", "").height()), i || t(this).hide();
      }).height(e));
    },
    _activate: function (e) {
      var i = this._findActive(e)[0];

      i !== this.active[0] && (i = i || this.active[0], this._eventHandler({
        target: i,
        currentTarget: i,
        preventDefault: t.noop
      }));
    },
    _findActive: function (e) {
      return "number" == typeof e ? this.headers.eq(e) : t();
    },
    _setupEvents: function (e) {
      var i = {
        keydown: "_keydown"
      };
      e && t.each(e.split(" "), function (t, e) {
        i[e] = "_eventHandler";
      }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i), this._on(this.headers.next(), {
        keydown: "_panelKeyDown"
      }), this._hoverable(this.headers), this._focusable(this.headers);
    },
    _eventHandler: function (e) {
      var i,
          s,
          n = this.options,
          o = this.active,
          a = t(e.currentTarget),
          r = a[0] === o[0],
          h = r && n.collapsible,
          l = h ? t() : a.next(),
          c = o.next(),
          u = {
        oldHeader: o,
        oldPanel: c,
        newHeader: h ? t() : a,
        newPanel: l
      };
      e.preventDefault(), r && !n.collapsible || this._trigger("beforeActivate", e, u) === !1 || (n.active = h ? !1 : this.headers.index(a), this.active = r ? t() : a, this._toggle(u), this._removeClass(o, "ui-accordion-header-active", "ui-state-active"), n.icons && (i = o.children(".ui-accordion-header-icon"), this._removeClass(i, null, n.icons.activeHeader)._addClass(i, null, n.icons.header)), r || (this._removeClass(a, "ui-accordion-header-collapsed")._addClass(a, "ui-accordion-header-active", "ui-state-active"), n.icons && (s = a.children(".ui-accordion-header-icon"), this._removeClass(s, null, n.icons.header)._addClass(s, null, n.icons.activeHeader)), this._addClass(a.next(), "ui-accordion-content-active")));
    },
    _toggle: function (e) {
      var i = e.newPanel,
          s = this.prevShow.length ? this.prevShow : e.oldPanel;
      this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = i, this.prevHide = s, this.options.animate ? this._animate(i, s, e) : (s.hide(), i.show(), this._toggleComplete(e)), s.attr({
        "aria-hidden": "true"
      }), s.prev().attr({
        "aria-selected": "false",
        "aria-expanded": "false"
      }), i.length && s.length ? s.prev().attr({
        tabIndex: -1,
        "aria-expanded": "false"
      }) : i.length && this.headers.filter(function () {
        return 0 === parseInt(t(this).attr("tabIndex"), 10);
      }).attr("tabIndex", -1), i.attr("aria-hidden", "false").prev().attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      });
    },
    _animate: function (t, e, i) {
      var s,
          n,
          o,
          a = this,
          r = 0,
          h = t.css("box-sizing"),
          l = t.length && (!e.length || t.index() < e.index()),
          c = this.options.animate || {},
          u = l && c.down || c,
          d = function () {
        a._toggleComplete(i);
      };

      return "number" == typeof u && (o = u), "string" == typeof u && (n = u), n = n || u.easing || c.easing, o = o || u.duration || c.duration, e.length ? t.length ? (s = t.show().outerHeight(), e.animate(this.hideProps, {
        duration: o,
        easing: n,
        step: function (t, e) {
          e.now = Math.round(t);
        }
      }), t.hide().animate(this.showProps, {
        duration: o,
        easing: n,
        complete: d,
        step: function (t, i) {
          i.now = Math.round(t), "height" !== i.prop ? "content-box" === h && (r += i.now) : "content" !== a.options.heightStyle && (i.now = Math.round(s - e.outerHeight() - r), r = 0);
        }
      }), void 0) : e.animate(this.hideProps, o, n, d) : t.animate(this.showProps, o, n, d);
    },
    _toggleComplete: function (t) {
      var e = t.oldPanel,
          i = e.prev();
      this._removeClass(e, "ui-accordion-content-active"), this._removeClass(i, "ui-accordion-header-active")._addClass(i, "ui-accordion-header-collapsed"), e.length && (e.parent()[0].className = e.parent()[0].className), this._trigger("activate", null, t);
    }
  }), t.ui.safeActiveElement = function (t) {
    var e;

    try {
      e = t.activeElement;
    } catch (i) {
      e = t.body;
    }

    return e || (e = t.body), e.nodeName || (e = t.body), e;
  }, t.widget("ui.menu", {
    version: "1.12.1",
    defaultElement: "<ul>",
    delay: 300,
    options: {
      icons: {
        submenu: "ui-icon-caret-1-e"
      },
      items: "> *",
      menus: "ul",
      position: {
        my: "left top",
        at: "right top"
      },
      role: "menu",
      blur: null,
      focus: null,
      select: null
    },
    _create: function () {
      this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().attr({
        role: this.options.role,
        tabIndex: 0
      }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({
        "mousedown .ui-menu-item": function (t) {
          t.preventDefault();
        },
        "click .ui-menu-item": function (e) {
          var i = t(e.target),
              s = t(t.ui.safeActiveElement(this.document[0]));
          !this.mouseHandled && i.not(".ui-state-disabled").length && (this.select(e), e.isPropagationStopped() || (this.mouseHandled = !0), i.has(".ui-menu").length ? this.expand(e) : !this.element.is(":focus") && s.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)));
        },
        "mouseenter .ui-menu-item": function (e) {
          if (!this.previousFilter) {
            var i = t(e.target).closest(".ui-menu-item"),
                s = t(e.currentTarget);
            i[0] === s[0] && (this._removeClass(s.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(e, s));
          }
        },
        mouseleave: "collapseAll",
        "mouseleave .ui-menu": "collapseAll",
        focus: function (t, e) {
          var i = this.active || this.element.find(this.options.items).eq(0);
          e || this.focus(t, i);
        },
        blur: function (e) {
          this._delay(function () {
            var i = !t.contains(this.element[0], t.ui.safeActiveElement(this.document[0]));
            i && this.collapseAll(e);
          });
        },
        keydown: "_keydown"
      }), this.refresh(), this._on(this.document, {
        click: function (t) {
          this._closeOnDocumentClick(t) && this.collapseAll(t), this.mouseHandled = !1;
        }
      });
    },
    _destroy: function () {
      var e = this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),
          i = e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
      this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), i.children().each(function () {
        var e = t(this);
        e.data("ui-menu-submenu-caret") && e.remove();
      });
    },
    _keydown: function (e) {
      var i,
          s,
          n,
          o,
          a = !0;

      switch (e.keyCode) {
        case t.ui.keyCode.PAGE_UP:
          this.previousPage(e);
          break;

        case t.ui.keyCode.PAGE_DOWN:
          this.nextPage(e);
          break;

        case t.ui.keyCode.HOME:
          this._move("first", "first", e);

          break;

        case t.ui.keyCode.END:
          this._move("last", "last", e);

          break;

        case t.ui.keyCode.UP:
          this.previous(e);
          break;

        case t.ui.keyCode.DOWN:
          this.next(e);
          break;

        case t.ui.keyCode.LEFT:
          this.collapse(e);
          break;

        case t.ui.keyCode.RIGHT:
          this.active && !this.active.is(".ui-state-disabled") && this.expand(e);
          break;

        case t.ui.keyCode.ENTER:
        case t.ui.keyCode.SPACE:
          this._activate(e);

          break;

        case t.ui.keyCode.ESCAPE:
          this.collapse(e);
          break;

        default:
          a = !1, s = this.previousFilter || "", o = !1, n = e.keyCode >= 96 && 105 >= e.keyCode ? "" + (e.keyCode - 96) : String.fromCharCode(e.keyCode), clearTimeout(this.filterTimer), n === s ? o = !0 : n = s + n, i = this._filterMenuItems(n), i = o && -1 !== i.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : i, i.length || (n = String.fromCharCode(e.keyCode), i = this._filterMenuItems(n)), i.length ? (this.focus(e, i), this.previousFilter = n, this.filterTimer = this._delay(function () {
            delete this.previousFilter;
          }, 1e3)) : delete this.previousFilter;
      }

      a && e.preventDefault();
    },
    _activate: function (t) {
      this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t));
    },
    refresh: function () {
      var e,
          i,
          s,
          n,
          o,
          a = this,
          r = this.options.icons.submenu,
          h = this.element.find(this.options.menus);
      this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), s = h.filter(":not(.ui-menu)").hide().attr({
        role: this.options.role,
        "aria-hidden": "true",
        "aria-expanded": "false"
      }).each(function () {
        var e = t(this),
            i = e.prev(),
            s = t("<span>").data("ui-menu-submenu-caret", !0);
        a._addClass(s, "ui-menu-icon", "ui-icon " + r), i.attr("aria-haspopup", "true").prepend(s), e.attr("aria-labelledby", i.attr("id"));
      }), this._addClass(s, "ui-menu", "ui-widget ui-widget-content ui-front"), e = h.add(this.element), i = e.find(this.options.items), i.not(".ui-menu-item").each(function () {
        var e = t(this);
        a._isDivider(e) && a._addClass(e, "ui-menu-divider", "ui-widget-content");
      }), n = i.not(".ui-menu-item, .ui-menu-divider"), o = n.children().not(".ui-menu").uniqueId().attr({
        tabIndex: -1,
        role: this._itemRole()
      }), this._addClass(n, "ui-menu-item")._addClass(o, "ui-menu-item-wrapper"), i.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !t.contains(this.element[0], this.active[0]) && this.blur();
    },
    _itemRole: function () {
      return {
        menu: "menuitem",
        listbox: "option"
      }[this.options.role];
    },
    _setOption: function (t, e) {
      if ("icons" === t) {
        var i = this.element.find(".ui-menu-icon");

        this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu);
      }

      this._super(t, e);
    },
    _setOptionDisabled: function (t) {
      this._super(t), this.element.attr("aria-disabled", t + ""), this._toggleClass(null, "ui-state-disabled", !!t);
    },
    focus: function (t, e) {
      var i, s, n;
      this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), s = this.active.children(".ui-menu-item-wrapper"), this._addClass(s, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", s.attr("id")), n = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(n, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function () {
        this._close();
      }, this.delay), i = e.children(".ui-menu"), i.length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, {
        item: e
      });
    },
    _scrollIntoView: function (e) {
      var i, s, n, o, a, r;
      this._hasScroll() && (i = parseFloat(t.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(t.css(this.activeMenu[0], "paddingTop")) || 0, n = e.offset().top - this.activeMenu.offset().top - i - s, o = this.activeMenu.scrollTop(), a = this.activeMenu.height(), r = e.outerHeight(), 0 > n ? this.activeMenu.scrollTop(o + n) : n + r > a && this.activeMenu.scrollTop(o + n - a + r));
    },
    blur: function (t, e) {
      e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, {
        item: this.active
      }), this.active = null);
    },
    _startOpening: function (t) {
      clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function () {
        this._close(), this._open(t);
      }, this.delay));
    },
    _open: function (e) {
      var i = t.extend({
        of: this.active
      }, this.options.position);
      clearTimeout(this.timer), this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden", "true"), e.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(i);
    },
    collapseAll: function (e, i) {
      clearTimeout(this.timer), this.timer = this._delay(function () {
        var s = i ? this.element : t(e && e.target).closest(this.element.find(".ui-menu"));
        s.length || (s = this.element), this._close(s), this.blur(e), this._removeClass(s.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = s;
      }, this.delay);
    },
    _close: function (t) {
      t || (t = this.active ? this.active.parent() : this.element), t.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false");
    },
    _closeOnDocumentClick: function (e) {
      return !t(e.target).closest(".ui-menu").length;
    },
    _isDivider: function (t) {
      return !/[^\-\u2014\u2013\s]/.test(t.text());
    },
    collapse: function (t) {
      var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);
      e && e.length && (this._close(), this.focus(t, e));
    },
    expand: function (t) {
      var e = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
      e && e.length && (this._open(e.parent()), this._delay(function () {
        this.focus(t, e);
      }));
    },
    next: function (t) {
      this._move("next", "first", t);
    },
    previous: function (t) {
      this._move("prev", "last", t);
    },
    isFirstItem: function () {
      return this.active && !this.active.prevAll(".ui-menu-item").length;
    },
    isLastItem: function () {
      return this.active && !this.active.nextAll(".ui-menu-item").length;
    },
    _move: function (t, e, i) {
      var s;
      this.active && (s = "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[t + "All"](".ui-menu-item").eq(0)), s && s.length && this.active || (s = this.activeMenu.find(this.options.items)[e]()), this.focus(i, s);
    },
    nextPage: function (e) {
      var i, s, n;
      return this.active ? (this.isLastItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
        return i = t(this), 0 > i.offset().top - s - n;
      }), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]())), void 0) : (this.next(e), void 0);
    },
    previousPage: function (e) {
      var i, s, n;
      return this.active ? (this.isFirstItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
        return i = t(this), i.offset().top - s + n > 0;
      }), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items).first())), void 0) : (this.next(e), void 0);
    },
    _hasScroll: function () {
      return this.element.outerHeight() < this.element.prop("scrollHeight");
    },
    select: function (e) {
      this.active = this.active || t(e.target).closest(".ui-menu-item");
      var i = {
        item: this.active
      };
      this.active.has(".ui-menu").length || this.collapseAll(e, !0), this._trigger("select", e, i);
    },
    _filterMenuItems: function (e) {
      var i = e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
          s = RegExp("^" + i, "i");
      return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function () {
        return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()));
      });
    }
  }), t.widget("ui.autocomplete", {
    version: "1.12.1",
    defaultElement: "<input>",
    options: {
      appendTo: null,
      autoFocus: !1,
      delay: 300,
      minLength: 1,
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      source: null,
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
    requestIndex: 0,
    pending: 0,
    _create: function () {
      var e,
          i,
          s,
          n = this.element[0].nodeName.toLowerCase(),
          o = "textarea" === n,
          a = "input" === n;
      this.isMultiLine = o || !a && this._isContentEditable(this.element), this.valueMethod = this.element[o || a ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, {
        keydown: function (n) {
          if (this.element.prop("readOnly")) return e = !0, s = !0, i = !0, void 0;
          e = !1, s = !1, i = !1;
          var o = t.ui.keyCode;

          switch (n.keyCode) {
            case o.PAGE_UP:
              e = !0, this._move("previousPage", n);
              break;

            case o.PAGE_DOWN:
              e = !0, this._move("nextPage", n);
              break;

            case o.UP:
              e = !0, this._keyEvent("previous", n);
              break;

            case o.DOWN:
              e = !0, this._keyEvent("next", n);
              break;

            case o.ENTER:
              this.menu.active && (e = !0, n.preventDefault(), this.menu.select(n));
              break;

            case o.TAB:
              this.menu.active && this.menu.select(n);
              break;

            case o.ESCAPE:
              this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(n), n.preventDefault());
              break;

            default:
              i = !0, this._searchTimeout(n);
          }
        },
        keypress: function (s) {
          if (e) return e = !1, (!this.isMultiLine || this.menu.element.is(":visible")) && s.preventDefault(), void 0;

          if (!i) {
            var n = t.ui.keyCode;

            switch (s.keyCode) {
              case n.PAGE_UP:
                this._move("previousPage", s);

                break;

              case n.PAGE_DOWN:
                this._move("nextPage", s);

                break;

              case n.UP:
                this._keyEvent("previous", s);

                break;

              case n.DOWN:
                this._keyEvent("next", s);

            }
          }
        },
        input: function (t) {
          return s ? (s = !1, t.preventDefault(), void 0) : (this._searchTimeout(t), void 0);
        },
        focus: function () {
          this.selectedItem = null, this.previous = this._value();
        },
        blur: function (t) {
          return this.cancelBlur ? (delete this.cancelBlur, void 0) : (clearTimeout(this.searching), this.close(t), this._change(t), void 0);
        }
      }), this._initSource(), this.menu = t("<ul>").appendTo(this._appendTo()).menu({
        role: null
      }).hide().menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, {
        mousedown: function (e) {
          e.preventDefault(), this.cancelBlur = !0, this._delay(function () {
            delete this.cancelBlur, this.element[0] !== t.ui.safeActiveElement(this.document[0]) && this.element.trigger("focus");
          });
        },
        menufocus: function (e, i) {
          var s, n;
          return this.isNewMenu && (this.isNewMenu = !1, e.originalEvent && /^mouse/.test(e.originalEvent.type)) ? (this.menu.blur(), this.document.one("mousemove", function () {
            t(e.target).trigger(e.originalEvent);
          }), void 0) : (n = i.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", e, {
            item: n
          }) && e.originalEvent && /^key/.test(e.originalEvent.type) && this._value(n.value), s = i.item.attr("aria-label") || n.value, s && t.trim(s).length && (this.liveRegion.children().hide(), t("<div>").text(s).appendTo(this.liveRegion)), void 0);
        },
        menuselect: function (e, i) {
          var s = i.item.data("ui-autocomplete-item"),
              n = this.previous;
          this.element[0] !== t.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = n, this._delay(function () {
            this.previous = n, this.selectedItem = s;
          })), !1 !== this._trigger("select", e, {
            item: s
          }) && this._value(s.value), this.term = this._value(), this.close(e), this.selectedItem = s;
        }
      }), this.liveRegion = t("<div>", {
        role: "status",
        "aria-live": "assertive",
        "aria-relevant": "additions"
      }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr("autocomplete");
        }
      });
    },
    _destroy: function () {
      clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove();
    },
    _setOption: function (t, e) {
      this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort();
    },
    _isEventTargetInWidget: function (e) {
      var i = this.menu.element[0];
      return e.target === this.element[0] || e.target === i || t.contains(i, e.target);
    },
    _closeOnClickOutside: function (t) {
      this._isEventTargetInWidget(t) || this.close();
    },
    _appendTo: function () {
      var e = this.options.appendTo;
      return e && (e = e.jquery || e.nodeType ? t(e) : this.document.find(e).eq(0)), e && e[0] || (e = this.element.closest(".ui-front, dialog")), e.length || (e = this.document[0].body), e;
    },
    _initSource: function () {
      var e,
          i,
          s = this;
      t.isArray(this.options.source) ? (e = this.options.source, this.source = function (i, s) {
        s(t.ui.autocomplete.filter(e, i.term));
      }) : "string" == typeof this.options.source ? (i = this.options.source, this.source = function (e, n) {
        s.xhr && s.xhr.abort(), s.xhr = t.ajax({
          url: i,
          data: e,
          dataType: "json",
          success: function (t) {
            n(t);
          },
          error: function () {
            n([]);
          }
        });
      }) : this.source = this.options.source;
    },
    _searchTimeout: function (t) {
      clearTimeout(this.searching), this.searching = this._delay(function () {
        var e = this.term === this._value(),
            i = this.menu.element.is(":visible"),
            s = t.altKey || t.ctrlKey || t.metaKey || t.shiftKey;

        (!e || e && !i && !s) && (this.selectedItem = null, this.search(null, t));
      }, this.options.delay);
    },
    search: function (t, e) {
      return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : this._trigger("search", e) !== !1 ? this._search(t) : void 0;
    },
    _search: function (t) {
      this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
        term: t
      }, this._response());
    },
    _response: function () {
      var e = ++this.requestIndex;
      return t.proxy(function (t) {
        e === this.requestIndex && this.__response(t), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading");
      }, this);
    },
    __response: function (t) {
      t && (t = this._normalize(t)), this._trigger("response", null, {
        content: t
      }), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close();
    },
    close: function (t) {
      this.cancelSearch = !0, this._close(t);
    },
    _close: function (t) {
      this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t));
    },
    _change: function (t) {
      this.previous !== this._value() && this._trigger("change", t, {
        item: this.selectedItem
      });
    },
    _normalize: function (e) {
      return e.length && e[0].label && e[0].value ? e : t.map(e, function (e) {
        return "string" == typeof e ? {
          label: e,
          value: e
        } : t.extend({}, e, {
          label: e.label || e.value,
          value: e.value || e.label
        });
      });
    },
    _suggest: function (e) {
      var i = this.menu.element.empty();
      this._renderMenu(i, e), this.isNewMenu = !0, this.menu.refresh(), i.show(), this._resizeMenu(), i.position(t.extend({
        of: this.element
      }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, {
        mousedown: "_closeOnClickOutside"
      });
    },
    _resizeMenu: function () {
      var t = this.menu.element;
      t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth()));
    },
    _renderMenu: function (e, i) {
      var s = this;
      t.each(i, function (t, i) {
        s._renderItemData(e, i);
      });
    },
    _renderItemData: function (t, e) {
      return this._renderItem(t, e).data("ui-autocomplete-item", e);
    },
    _renderItem: function (e, i) {
      return t("<li>").append(t("<div>").text(i.label)).appendTo(e);
    },
    _move: function (t, e) {
      return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), this.menu.blur(), void 0) : (this.menu[t](e), void 0) : (this.search(null, e), void 0);
    },
    widget: function () {
      return this.menu.element;
    },
    _value: function () {
      return this.valueMethod.apply(this.element, arguments);
    },
    _keyEvent: function (t, e) {
      (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(t, e), e.preventDefault());
    },
    _isContentEditable: function (t) {
      if (!t.length) return !1;
      var e = t.prop("contentEditable");
      return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e;
    }
  }), t.extend(t.ui.autocomplete, {
    escapeRegex: function (t) {
      return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    },
    filter: function (e, i) {
      var s = RegExp(t.ui.autocomplete.escapeRegex(i), "i");
      return t.grep(e, function (t) {
        return s.test(t.label || t.value || t);
      });
    }
  }), t.widget("ui.autocomplete", t.ui.autocomplete, {
    options: {
      messages: {
        noResults: "No search results.",
        results: function (t) {
          return t + (t > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
        }
      }
    },
    __response: function (e) {
      var i;
      this._superApply(arguments), this.options.disabled || this.cancelSearch || (i = e && e.length ? this.options.messages.results(e.length) : this.options.messages.noResults, this.liveRegion.children().hide(), t("<div>").text(i).appendTo(this.liveRegion));
    }
  }), t.ui.autocomplete;
  var g = /ui-corner-([a-z]){2,6}/g;
  t.widget("ui.controlgroup", {
    version: "1.12.1",
    defaultElement: "<div>",
    options: {
      direction: "horizontal",
      disabled: null,
      onlyVisible: !0,
      items: {
        button: "input[type=button], input[type=submit], input[type=reset], button, a",
        controlgroupLabel: ".ui-controlgroup-label",
        checkboxradio: "input[type='checkbox'], input[type='radio']",
        selectmenu: "select",
        spinner: ".ui-spinner-input"
      }
    },
    _create: function () {
      this._enhance();
    },
    _enhance: function () {
      this.element.attr("role", "toolbar"), this.refresh();
    },
    _destroy: function () {
      this._callChildMethod("destroy"), this.childWidgets.removeData("ui-controlgroup-data"), this.element.removeAttr("role"), this.options.items.controlgroupLabel && this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap();
    },
    _initWidgets: function () {
      var e = this,
          i = [];
      t.each(this.options.items, function (s, n) {
        var o,
            a = {};
        return n ? "controlgroupLabel" === s ? (o = e.element.find(n), o.each(function () {
          var e = t(this);
          e.children(".ui-controlgroup-label-contents").length || e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>");
        }), e._addClass(o, null, "ui-widget ui-widget-content ui-state-default"), i = i.concat(o.get()), void 0) : (t.fn[s] && (a = e["_" + s + "Options"] ? e["_" + s + "Options"]("middle") : {
          classes: {}
        }, e.element.find(n).each(function () {
          var n = t(this),
              o = n[s]("instance"),
              r = t.widget.extend({}, a);

          if ("button" !== s || !n.parent(".ui-spinner").length) {
            o || (o = n[s]()[s]("instance")), o && (r.classes = e._resolveClassesValues(r.classes, o)), n[s](r);
            var h = n[s]("widget");
            t.data(h[0], "ui-controlgroup-data", o ? o : n[s]("instance")), i.push(h[0]);
          }
        })), void 0) : void 0;
      }), this.childWidgets = t(t.unique(i)), this._addClass(this.childWidgets, "ui-controlgroup-item");
    },
    _callChildMethod: function (e) {
      this.childWidgets.each(function () {
        var i = t(this),
            s = i.data("ui-controlgroup-data");
        s && s[e] && s[e]();
      });
    },
    _updateCornerClass: function (t, e) {
      var i = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",
          s = this._buildSimpleOptions(e, "label").classes.label;

      this._removeClass(t, null, i), this._addClass(t, null, s);
    },
    _buildSimpleOptions: function (t, e) {
      var i = "vertical" === this.options.direction,
          s = {
        classes: {}
      };
      return s.classes[e] = {
        middle: "",
        first: "ui-corner-" + (i ? "top" : "left"),
        last: "ui-corner-" + (i ? "bottom" : "right"),
        only: "ui-corner-all"
      }[t], s;
    },
    _spinnerOptions: function (t) {
      var e = this._buildSimpleOptions(t, "ui-spinner");

      return e.classes["ui-spinner-up"] = "", e.classes["ui-spinner-down"] = "", e;
    },
    _buttonOptions: function (t) {
      return this._buildSimpleOptions(t, "ui-button");
    },
    _checkboxradioOptions: function (t) {
      return this._buildSimpleOptions(t, "ui-checkboxradio-label");
    },
    _selectmenuOptions: function (t) {
      var e = "vertical" === this.options.direction;
      return {
        width: e ? "auto" : !1,
        classes: {
          middle: {
            "ui-selectmenu-button-open": "",
            "ui-selectmenu-button-closed": ""
          },
          first: {
            "ui-selectmenu-button-open": "ui-corner-" + (e ? "top" : "tl"),
            "ui-selectmenu-button-closed": "ui-corner-" + (e ? "top" : "left")
          },
          last: {
            "ui-selectmenu-button-open": e ? "" : "ui-corner-tr",
            "ui-selectmenu-button-closed": "ui-corner-" + (e ? "bottom" : "right")
          },
          only: {
            "ui-selectmenu-button-open": "ui-corner-top",
            "ui-selectmenu-button-closed": "ui-corner-all"
          }
        }[t]
      };
    },
    _resolveClassesValues: function (e, i) {
      var s = {};
      return t.each(e, function (n) {
        var o = i.options.classes[n] || "";
        o = t.trim(o.replace(g, "")), s[n] = (o + " " + e[n]).replace(/\s+/g, " ");
      }), s;
    },
    _setOption: function (t, e) {
      return "direction" === t && this._removeClass("ui-controlgroup-" + this.options.direction), this._super(t, e), "disabled" === t ? (this._callChildMethod(e ? "disable" : "enable"), void 0) : (this.refresh(), void 0);
    },
    refresh: function () {
      var e,
          i = this;
      this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction), "horizontal" === this.options.direction && this._addClass(null, "ui-helper-clearfix"), this._initWidgets(), e = this.childWidgets, this.options.onlyVisible && (e = e.filter(":visible")), e.length && (t.each(["first", "last"], function (t, s) {
        var n = e[s]().data("ui-controlgroup-data");

        if (n && i["_" + n.widgetName + "Options"]) {
          var o = i["_" + n.widgetName + "Options"](1 === e.length ? "only" : s);
          o.classes = i._resolveClassesValues(o.classes, n), n.element[n.widgetName](o);
        } else i._updateCornerClass(e[s](), s);
      }), this._callChildMethod("refresh"));
    }
  }), t.widget("ui.checkboxradio", [t.ui.formResetMixin, {
    version: "1.12.1",
    options: {
      disabled: null,
      label: null,
      icon: !0,
      classes: {
        "ui-checkboxradio-label": "ui-corner-all",
        "ui-checkboxradio-icon": "ui-corner-all"
      }
    },
    _getCreateOptions: function () {
      var e,
          i,
          s = this,
          n = this._super() || {};
      return this._readType(), i = this.element.labels(), this.label = t(i[i.length - 1]), this.label.length || t.error("No label found for checkboxradio widget"), this.originalLabel = "", this.label.contents().not(this.element[0]).each(function () {
        s.originalLabel += 3 === this.nodeType ? t(this).text() : this.outerHTML;
      }), this.originalLabel && (n.label = this.originalLabel), e = this.element[0].disabled, null != e && (n.disabled = e), n;
    },
    _create: function () {
      var t = this.element[0].checked;
      this._bindFormResetHandler(), null == this.options.disabled && (this.options.disabled = this.element[0].disabled), this._setOption("disabled", this.options.disabled), this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"), this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"), "radio" === this.type && this._addClass(this.label, "ui-checkboxradio-radio-label"), this.options.label && this.options.label !== this.originalLabel ? this._updateLabel() : this.originalLabel && (this.options.label = this.originalLabel), this._enhance(), t && (this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"), this.icon && this._addClass(this.icon, null, "ui-state-hover")), this._on({
        change: "_toggleClasses",
        focus: function () {
          this._addClass(this.label, null, "ui-state-focus ui-visual-focus");
        },
        blur: function () {
          this._removeClass(this.label, null, "ui-state-focus ui-visual-focus");
        }
      });
    },
    _readType: function () {
      var e = this.element[0].nodeName.toLowerCase();
      this.type = this.element[0].type, "input" === e && /radio|checkbox/.test(this.type) || t.error("Can't create checkboxradio on element.nodeName=" + e + " and element.type=" + this.type);
    },
    _enhance: function () {
      this._updateIcon(this.element[0].checked);
    },
    widget: function () {
      return this.label;
    },
    _getRadioGroup: function () {
      var e,
          i = this.element[0].name,
          s = "input[name='" + t.ui.escapeSelector(i) + "']";
      return i ? (e = this.form.length ? t(this.form[0].elements).filter(s) : t(s).filter(function () {
        return 0 === t(this).form().length;
      }), e.not(this.element)) : t([]);
    },
    _toggleClasses: function () {
      var e = this.element[0].checked;
      this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", e), this.options.icon && "checkbox" === this.type && this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", e)._toggleClass(this.icon, null, "ui-icon-blank", !e), "radio" === this.type && this._getRadioGroup().each(function () {
        var e = t(this).checkboxradio("instance");
        e && e._removeClass(e.label, "ui-checkboxradio-checked", "ui-state-active");
      });
    },
    _destroy: function () {
      this._unbindFormResetHandler(), this.icon && (this.icon.remove(), this.iconSpace.remove());
    },
    _setOption: function (t, e) {
      return "label" !== t || e ? (this._super(t, e), "disabled" === t ? (this._toggleClass(this.label, null, "ui-state-disabled", e), this.element[0].disabled = e, void 0) : (this.refresh(), void 0)) : void 0;
    },
    _updateIcon: function (e) {
      var i = "ui-icon ui-icon-background ";
      this.options.icon ? (this.icon || (this.icon = t("<span>"), this.iconSpace = t("<span> </span>"), this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")), "checkbox" === this.type ? (i += e ? "ui-icon-check ui-state-checked" : "ui-icon-blank", this._removeClass(this.icon, null, e ? "ui-icon-blank" : "ui-icon-check")) : i += "ui-icon-blank", this._addClass(this.icon, "ui-checkboxradio-icon", i), e || this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"), this.icon.prependTo(this.label).after(this.iconSpace)) : void 0 !== this.icon && (this.icon.remove(), this.iconSpace.remove(), delete this.icon);
    },
    _updateLabel: function () {
      var t = this.label.contents().not(this.element[0]);
      this.icon && (t = t.not(this.icon[0])), this.iconSpace && (t = t.not(this.iconSpace[0])), t.remove(), this.label.append(this.options.label);
    },
    refresh: function () {
      var t = this.element[0].checked,
          e = this.element[0].disabled;
      this._updateIcon(t), this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), null !== this.options.label && this._updateLabel(), e !== this.options.disabled && this._setOptions({
        disabled: e
      });
    }
  }]), t.ui.checkboxradio, t.widget("ui.button", {
    version: "1.12.1",
    defaultElement: "<button>",
    options: {
      classes: {
        "ui-button": "ui-corner-all"
      },
      disabled: null,
      icon: null,
      iconPosition: "beginning",
      label: null,
      showLabel: !0
    },
    _getCreateOptions: function () {
      var t,
          e = this._super() || {};
      return this.isInput = this.element.is("input"), t = this.element[0].disabled, null != t && (e.disabled = t), this.originalLabel = this.isInput ? this.element.val() : this.element.html(), this.originalLabel && (e.label = this.originalLabel), e;
    },
    _create: function () {
      !this.option.showLabel & !this.options.icon && (this.options.showLabel = !0), null == this.options.disabled && (this.options.disabled = this.element[0].disabled || !1), this.hasTitle = !!this.element.attr("title"), this.options.label && this.options.label !== this.originalLabel && (this.isInput ? this.element.val(this.options.label) : this.element.html(this.options.label)), this._addClass("ui-button", "ui-widget"), this._setOption("disabled", this.options.disabled), this._enhance(), this.element.is("a") && this._on({
        keyup: function (e) {
          e.keyCode === t.ui.keyCode.SPACE && (e.preventDefault(), this.element[0].click ? this.element[0].click() : this.element.trigger("click"));
        }
      });
    },
    _enhance: function () {
      this.element.is("button") || this.element.attr("role", "button"), this.options.icon && (this._updateIcon("icon", this.options.icon), this._updateTooltip());
    },
    _updateTooltip: function () {
      this.title = this.element.attr("title"), this.options.showLabel || this.title || this.element.attr("title", this.options.label);
    },
    _updateIcon: function (e, i) {
      var s = "iconPosition" !== e,
          n = s ? this.options.iconPosition : i,
          o = "top" === n || "bottom" === n;
      this.icon ? s && this._removeClass(this.icon, null, this.options.icon) : (this.icon = t("<span>"), this._addClass(this.icon, "ui-button-icon", "ui-icon"), this.options.showLabel || this._addClass("ui-button-icon-only")), s && this._addClass(this.icon, null, i), this._attachIcon(n), o ? (this._addClass(this.icon, null, "ui-widget-icon-block"), this.iconSpace && this.iconSpace.remove()) : (this.iconSpace || (this.iconSpace = t("<span> </span>"), this._addClass(this.iconSpace, "ui-button-icon-space")), this._removeClass(this.icon, null, "ui-wiget-icon-block"), this._attachIconSpace(n));
    },
    _destroy: function () {
      this.element.removeAttr("role"), this.icon && this.icon.remove(), this.iconSpace && this.iconSpace.remove(), this.hasTitle || this.element.removeAttr("title");
    },
    _attachIconSpace: function (t) {
      this.icon[/^(?:end|bottom)/.test(t) ? "before" : "after"](this.iconSpace);
    },
    _attachIcon: function (t) {
      this.element[/^(?:end|bottom)/.test(t) ? "append" : "prepend"](this.icon);
    },
    _setOptions: function (t) {
      var e = void 0 === t.showLabel ? this.options.showLabel : t.showLabel,
          i = void 0 === t.icon ? this.options.icon : t.icon;
      e || i || (t.showLabel = !0), this._super(t);
    },
    _setOption: function (t, e) {
      "icon" === t && (e ? this._updateIcon(t, e) : this.icon && (this.icon.remove(), this.iconSpace && this.iconSpace.remove())), "iconPosition" === t && this._updateIcon(t, e), "showLabel" === t && (this._toggleClass("ui-button-icon-only", null, !e), this._updateTooltip()), "label" === t && (this.isInput ? this.element.val(e) : (this.element.html(e), this.icon && (this._attachIcon(this.options.iconPosition), this._attachIconSpace(this.options.iconPosition)))), this._super(t, e), "disabled" === t && (this._toggleClass(null, "ui-state-disabled", e), this.element[0].disabled = e, e && this.element.blur());
    },
    refresh: function () {
      var t = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
      t !== this.options.disabled && this._setOptions({
        disabled: t
      }), this._updateTooltip();
    }
  }), t.uiBackCompat !== !1 && (t.widget("ui.button", t.ui.button, {
    options: {
      text: !0,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function () {
      this.options.showLabel && !this.options.text && (this.options.showLabel = this.options.text), !this.options.showLabel && this.options.text && (this.options.text = this.options.showLabel), this.options.icon || !this.options.icons.primary && !this.options.icons.secondary ? this.options.icon && (this.options.icons.primary = this.options.icon) : this.options.icons.primary ? this.options.icon = this.options.icons.primary : (this.options.icon = this.options.icons.secondary, this.options.iconPosition = "end"), this._super();
    },
    _setOption: function (t, e) {
      return "text" === t ? (this._super("showLabel", e), void 0) : ("showLabel" === t && (this.options.text = e), "icon" === t && (this.options.icons.primary = e), "icons" === t && (e.primary ? (this._super("icon", e.primary), this._super("iconPosition", "beginning")) : e.secondary && (this._super("icon", e.secondary), this._super("iconPosition", "end"))), this._superApply(arguments), void 0);
    }
  }), t.fn.button = function (e) {
    return function () {
      return !this.length || this.length && "INPUT" !== this[0].tagName || this.length && "INPUT" === this[0].tagName && "checkbox" !== this.attr("type") && "radio" !== this.attr("type") ? e.apply(this, arguments) : (t.ui.checkboxradio || t.error("Checkboxradio widget missing"), 0 === arguments.length ? this.checkboxradio({
        icon: !1
      }) : this.checkboxradio.apply(this, arguments));
    };
  }(t.fn.button), t.fn.buttonset = function () {
    return t.ui.controlgroup || t.error("Controlgroup widget missing"), "option" === arguments[0] && "items" === arguments[1] && arguments[2] ? this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]) : "option" === arguments[0] && "items" === arguments[1] ? this.controlgroup.apply(this, [arguments[0], "items.button"]) : ("object" == typeof arguments[0] && arguments[0].items && (arguments[0].items = {
      button: arguments[0].items
    }), this.controlgroup.apply(this, arguments));
  }), t.ui.button, t.extend(t.ui, {
    datepicker: {
      version: "1.12.1"
    }
  });
  var m;
  t.extend(s.prototype, {
    markerClassName: "hasDatepicker",
    maxRows: 4,
    _widgetDatepicker: function () {
      return this.dpDiv;
    },
    setDefaults: function (t) {
      return a(this._defaults, t || {}), this;
    },
    _attachDatepicker: function (e, i) {
      var s, n, o;
      s = e.nodeName.toLowerCase(), n = "div" === s || "span" === s, e.id || (this.uuid += 1, e.id = "dp" + this.uuid), o = this._newInst(t(e), n), o.settings = t.extend({}, i || {}), "input" === s ? this._connectDatepicker(e, o) : n && this._inlineDatepicker(e, o);
    },
    _newInst: function (e, i) {
      var s = e[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
      return {
        id: s,
        input: e,
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0,
        drawMonth: 0,
        drawYear: 0,
        inline: i,
        dpDiv: i ? n(t("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
      };
    },
    _connectDatepicker: function (e, i) {
      var s = t(e);
      i.append = t([]), i.trigger = t([]), s.hasClass(this.markerClassName) || (this._attachments(s, i), s.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(i), t.data(e, "datepicker", i), i.settings.disabled && this._disableDatepicker(e));
    },
    _attachments: function (e, i) {
      var s,
          n,
          o,
          a = this._get(i, "appendText"),
          r = this._get(i, "isRTL");

      i.append && i.append.remove(), a && (i.append = t("<span class='" + this._appendClass + "'>" + a + "</span>"), e[r ? "before" : "after"](i.append)), e.off("focus", this._showDatepicker), i.trigger && i.trigger.remove(), s = this._get(i, "showOn"), ("focus" === s || "both" === s) && e.on("focus", this._showDatepicker), ("button" === s || "both" === s) && (n = this._get(i, "buttonText"), o = this._get(i, "buttonImage"), i.trigger = t(this._get(i, "buttonImageOnly") ? t("<img/>").addClass(this._triggerClass).attr({
        src: o,
        alt: n,
        title: n
      }) : t("<button type='button'></button>").addClass(this._triggerClass).html(o ? t("<img/>").attr({
        src: o,
        alt: n,
        title: n
      }) : n)), e[r ? "before" : "after"](i.trigger), i.trigger.on("click", function () {
        return t.datepicker._datepickerShowing && t.datepicker._lastInput === e[0] ? t.datepicker._hideDatepicker() : t.datepicker._datepickerShowing && t.datepicker._lastInput !== e[0] ? (t.datepicker._hideDatepicker(), t.datepicker._showDatepicker(e[0])) : t.datepicker._showDatepicker(e[0]), !1;
      }));
    },
    _autoSize: function (t) {
      if (this._get(t, "autoSize") && !t.inline) {
        var e,
            i,
            s,
            n,
            o = new Date(2009, 11, 20),
            a = this._get(t, "dateFormat");

        a.match(/[DM]/) && (e = function (t) {
          for (i = 0, s = 0, n = 0; t.length > n; n++) t[n].length > i && (i = t[n].length, s = n);

          return s;
        }, o.setMonth(e(this._get(t, a.match(/MM/) ? "monthNames" : "monthNamesShort"))), o.setDate(e(this._get(t, a.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - o.getDay())), t.input.attr("size", this._formatDate(t, o).length);
      }
    },
    _inlineDatepicker: function (e, i) {
      var s = t(e);
      s.hasClass(this.markerClassName) || (s.addClass(this.markerClassName).append(i.dpDiv), t.data(e, "datepicker", i), this._setDate(i, this._getDefaultDate(i), !0), this._updateDatepicker(i), this._updateAlternate(i), i.settings.disabled && this._disableDatepicker(e), i.dpDiv.css("display", "block"));
    },
    _dialogDatepicker: function (e, i, s, n, o) {
      var r,
          h,
          l,
          c,
          u,
          d = this._dialogInst;
      return d || (this.uuid += 1, r = "dp" + this.uuid, this._dialogInput = t("<input type='text' id='" + r + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), t("body").append(this._dialogInput), d = this._dialogInst = this._newInst(this._dialogInput, !1), d.settings = {}, t.data(this._dialogInput[0], "datepicker", d)), a(d.settings, n || {}), i = i && i.constructor === Date ? this._formatDate(d, i) : i, this._dialogInput.val(i), this._pos = o ? o.length ? o : [o.pageX, o.pageY] : null, this._pos || (h = document.documentElement.clientWidth, l = document.documentElement.clientHeight, c = document.documentElement.scrollLeft || document.body.scrollLeft, u = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [h / 2 - 100 + c, l / 2 - 150 + u]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), d.settings.onSelect = s, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), t.blockUI && t.blockUI(this.dpDiv), t.data(this._dialogInput[0], "datepicker", d), this;
    },
    _destroyDatepicker: function (e) {
      var i,
          s = t(e),
          n = t.data(e, "datepicker");
      s.hasClass(this.markerClassName) && (i = e.nodeName.toLowerCase(), t.removeData(e, "datepicker"), "input" === i ? (n.append.remove(), n.trigger.remove(), s.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : ("div" === i || "span" === i) && s.removeClass(this.markerClassName).empty(), m === n && (m = null));
    },
    _enableDatepicker: function (e) {
      var i,
          s,
          n = t(e),
          o = t.data(e, "datepicker");
      n.hasClass(this.markerClassName) && (i = e.nodeName.toLowerCase(), "input" === i ? (e.disabled = !1, o.trigger.filter("button").each(function () {
        this.disabled = !1;
      }).end().filter("img").css({
        opacity: "1.0",
        cursor: ""
      })) : ("div" === i || "span" === i) && (s = n.children("." + this._inlineClass), s.children().removeClass("ui-state-disabled"), s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = t.map(this._disabledInputs, function (t) {
        return t === e ? null : t;
      }));
    },
    _disableDatepicker: function (e) {
      var i,
          s,
          n = t(e),
          o = t.data(e, "datepicker");
      n.hasClass(this.markerClassName) && (i = e.nodeName.toLowerCase(), "input" === i ? (e.disabled = !0, o.trigger.filter("button").each(function () {
        this.disabled = !0;
      }).end().filter("img").css({
        opacity: "0.5",
        cursor: "default"
      })) : ("div" === i || "span" === i) && (s = n.children("." + this._inlineClass), s.children().addClass("ui-state-disabled"), s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = t.map(this._disabledInputs, function (t) {
        return t === e ? null : t;
      }), this._disabledInputs[this._disabledInputs.length] = e);
    },
    _isDisabledDatepicker: function (t) {
      if (!t) return !1;

      for (var e = 0; this._disabledInputs.length > e; e++) if (this._disabledInputs[e] === t) return !0;

      return !1;
    },
    _getInst: function (e) {
      try {
        return t.data(e, "datepicker");
      } catch (i) {
        throw "Missing instance data for this datepicker";
      }
    },
    _optionDatepicker: function (e, i, s) {
      var n,
          o,
          r,
          h,
          l = this._getInst(e);

      return 2 === arguments.length && "string" == typeof i ? "defaults" === i ? t.extend({}, t.datepicker._defaults) : l ? "all" === i ? t.extend({}, l.settings) : this._get(l, i) : null : (n = i || {}, "string" == typeof i && (n = {}, n[i] = s), l && (this._curInst === l && this._hideDatepicker(), o = this._getDateDatepicker(e, !0), r = this._getMinMaxDate(l, "min"), h = this._getMinMaxDate(l, "max"), a(l.settings, n), null !== r && void 0 !== n.dateFormat && void 0 === n.minDate && (l.settings.minDate = this._formatDate(l, r)), null !== h && void 0 !== n.dateFormat && void 0 === n.maxDate && (l.settings.maxDate = this._formatDate(l, h)), "disabled" in n && (n.disabled ? this._disableDatepicker(e) : this._enableDatepicker(e)), this._attachments(t(e), l), this._autoSize(l), this._setDate(l, o), this._updateAlternate(l), this._updateDatepicker(l)), void 0);
    },
    _changeDatepicker: function (t, e, i) {
      this._optionDatepicker(t, e, i);
    },
    _refreshDatepicker: function (t) {
      var e = this._getInst(t);

      e && this._updateDatepicker(e);
    },
    _setDateDatepicker: function (t, e) {
      var i = this._getInst(t);

      i && (this._setDate(i, e), this._updateDatepicker(i), this._updateAlternate(i));
    },
    _getDateDatepicker: function (t, e) {
      var i = this._getInst(t);

      return i && !i.inline && this._setDateFromField(i, e), i ? this._getDate(i) : null;
    },
    _doKeyDown: function (e) {
      var i,
          s,
          n,
          o = t.datepicker._getInst(e.target),
          a = !0,
          r = o.dpDiv.is(".ui-datepicker-rtl");

      if (o._keyEvent = !0, t.datepicker._datepickerShowing) switch (e.keyCode) {
        case 9:
          t.datepicker._hideDatepicker(), a = !1;
          break;

        case 13:
          return n = t("td." + t.datepicker._dayOverClass + ":not(." + t.datepicker._currentClass + ")", o.dpDiv), n[0] && t.datepicker._selectDay(e.target, o.selectedMonth, o.selectedYear, n[0]), i = t.datepicker._get(o, "onSelect"), i ? (s = t.datepicker._formatDate(o), i.apply(o.input ? o.input[0] : null, [s, o])) : t.datepicker._hideDatepicker(), !1;

        case 27:
          t.datepicker._hideDatepicker();

          break;

        case 33:
          t.datepicker._adjustDate(e.target, e.ctrlKey ? -t.datepicker._get(o, "stepBigMonths") : -t.datepicker._get(o, "stepMonths"), "M");

          break;

        case 34:
          t.datepicker._adjustDate(e.target, e.ctrlKey ? +t.datepicker._get(o, "stepBigMonths") : +t.datepicker._get(o, "stepMonths"), "M");

          break;

        case 35:
          (e.ctrlKey || e.metaKey) && t.datepicker._clearDate(e.target), a = e.ctrlKey || e.metaKey;
          break;

        case 36:
          (e.ctrlKey || e.metaKey) && t.datepicker._gotoToday(e.target), a = e.ctrlKey || e.metaKey;
          break;

        case 37:
          (e.ctrlKey || e.metaKey) && t.datepicker._adjustDate(e.target, r ? 1 : -1, "D"), a = e.ctrlKey || e.metaKey, e.originalEvent.altKey && t.datepicker._adjustDate(e.target, e.ctrlKey ? -t.datepicker._get(o, "stepBigMonths") : -t.datepicker._get(o, "stepMonths"), "M");
          break;

        case 38:
          (e.ctrlKey || e.metaKey) && t.datepicker._adjustDate(e.target, -7, "D"), a = e.ctrlKey || e.metaKey;
          break;

        case 39:
          (e.ctrlKey || e.metaKey) && t.datepicker._adjustDate(e.target, r ? -1 : 1, "D"), a = e.ctrlKey || e.metaKey, e.originalEvent.altKey && t.datepicker._adjustDate(e.target, e.ctrlKey ? +t.datepicker._get(o, "stepBigMonths") : +t.datepicker._get(o, "stepMonths"), "M");
          break;

        case 40:
          (e.ctrlKey || e.metaKey) && t.datepicker._adjustDate(e.target, 7, "D"), a = e.ctrlKey || e.metaKey;
          break;

        default:
          a = !1;
      } else 36 === e.keyCode && e.ctrlKey ? t.datepicker._showDatepicker(this) : a = !1;
      a && (e.preventDefault(), e.stopPropagation());
    },
    _doKeyPress: function (e) {
      var i,
          s,
          n = t.datepicker._getInst(e.target);

      return t.datepicker._get(n, "constrainInput") ? (i = t.datepicker._possibleChars(t.datepicker._get(n, "dateFormat")), s = String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), e.ctrlKey || e.metaKey || " " > s || !i || i.indexOf(s) > -1) : void 0;
    },
    _doKeyUp: function (e) {
      var i,
          s = t.datepicker._getInst(e.target);

      if (s.input.val() !== s.lastVal) try {
        i = t.datepicker.parseDate(t.datepicker._get(s, "dateFormat"), s.input ? s.input.val() : null, t.datepicker._getFormatConfig(s)), i && (t.datepicker._setDateFromField(s), t.datepicker._updateAlternate(s), t.datepicker._updateDatepicker(s));
      } catch (n) {}
      return !0;
    },
    _showDatepicker: function (e) {
      if (e = e.target || e, "input" !== e.nodeName.toLowerCase() && (e = t("input", e.parentNode)[0]), !t.datepicker._isDisabledDatepicker(e) && t.datepicker._lastInput !== e) {
        var s, n, o, r, h, l, c;
        s = t.datepicker._getInst(e), t.datepicker._curInst && t.datepicker._curInst !== s && (t.datepicker._curInst.dpDiv.stop(!0, !0), s && t.datepicker._datepickerShowing && t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])), n = t.datepicker._get(s, "beforeShow"), o = n ? n.apply(e, [e, s]) : {}, o !== !1 && (a(s.settings, o), s.lastVal = null, t.datepicker._lastInput = e, t.datepicker._setDateFromField(s), t.datepicker._inDialog && (e.value = ""), t.datepicker._pos || (t.datepicker._pos = t.datepicker._findPos(e), t.datepicker._pos[1] += e.offsetHeight), r = !1, t(e).parents().each(function () {
          return r |= "fixed" === t(this).css("position"), !r;
        }), h = {
          left: t.datepicker._pos[0],
          top: t.datepicker._pos[1]
        }, t.datepicker._pos = null, s.dpDiv.empty(), s.dpDiv.css({
          position: "absolute",
          display: "block",
          top: "-1000px"
        }), t.datepicker._updateDatepicker(s), h = t.datepicker._checkOffset(s, h, r), s.dpDiv.css({
          position: t.datepicker._inDialog && t.blockUI ? "static" : r ? "fixed" : "absolute",
          display: "none",
          left: h.left + "px",
          top: h.top + "px"
        }), s.inline || (l = t.datepicker._get(s, "showAnim"), c = t.datepicker._get(s, "duration"), s.dpDiv.css("z-index", i(t(e)) + 1), t.datepicker._datepickerShowing = !0, t.effects && t.effects.effect[l] ? s.dpDiv.show(l, t.datepicker._get(s, "showOptions"), c) : s.dpDiv[l || "show"](l ? c : null), t.datepicker._shouldFocusInput(s) && s.input.trigger("focus"), t.datepicker._curInst = s));
      }
    },
    _updateDatepicker: function (e) {
      this.maxRows = 4, m = e, e.dpDiv.empty().append(this._generateHTML(e)), this._attachHandlers(e);

      var i,
          s = this._getNumberOfMonths(e),
          n = s[1],
          a = 17,
          r = e.dpDiv.find("." + this._dayOverClass + " a");

      r.length > 0 && o.apply(r.get(0)), e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), n > 1 && e.dpDiv.addClass("ui-datepicker-multi-" + n).css("width", a * n + "em"), e.dpDiv[(1 !== s[0] || 1 !== s[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), e.dpDiv[(this._get(e, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), e === t.datepicker._curInst && t.datepicker._datepickerShowing && t.datepicker._shouldFocusInput(e) && e.input.trigger("focus"), e.yearshtml && (i = e.yearshtml, setTimeout(function () {
        i === e.yearshtml && e.yearshtml && e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml), i = e.yearshtml = null;
      }, 0));
    },
    _shouldFocusInput: function (t) {
      return t.input && t.input.is(":visible") && !t.input.is(":disabled") && !t.input.is(":focus");
    },
    _checkOffset: function (e, i, s) {
      var n = e.dpDiv.outerWidth(),
          o = e.dpDiv.outerHeight(),
          a = e.input ? e.input.outerWidth() : 0,
          r = e.input ? e.input.outerHeight() : 0,
          h = document.documentElement.clientWidth + (s ? 0 : t(document).scrollLeft()),
          l = document.documentElement.clientHeight + (s ? 0 : t(document).scrollTop());
      return i.left -= this._get(e, "isRTL") ? n - a : 0, i.left -= s && i.left === e.input.offset().left ? t(document).scrollLeft() : 0, i.top -= s && i.top === e.input.offset().top + r ? t(document).scrollTop() : 0, i.left -= Math.min(i.left, i.left + n > h && h > n ? Math.abs(i.left + n - h) : 0), i.top -= Math.min(i.top, i.top + o > l && l > o ? Math.abs(o + r) : 0), i;
    },
    _findPos: function (e) {
      for (var i, s = this._getInst(e), n = this._get(s, "isRTL"); e && ("hidden" === e.type || 1 !== e.nodeType || t.expr.filters.hidden(e));) e = e[n ? "previousSibling" : "nextSibling"];

      return i = t(e).offset(), [i.left, i.top];
    },
    _hideDatepicker: function (e) {
      var i,
          s,
          n,
          o,
          a = this._curInst;
      !a || e && a !== t.data(e, "datepicker") || this._datepickerShowing && (i = this._get(a, "showAnim"), s = this._get(a, "duration"), n = function () {
        t.datepicker._tidyDialog(a);
      }, t.effects && (t.effects.effect[i] || t.effects[i]) ? a.dpDiv.hide(i, t.datepicker._get(a, "showOptions"), s, n) : a.dpDiv["slideDown" === i ? "slideUp" : "fadeIn" === i ? "fadeOut" : "hide"](i ? s : null, n), i || n(), this._datepickerShowing = !1, o = this._get(a, "onClose"), o && o.apply(a.input ? a.input[0] : null, [a.input ? a.input.val() : "", a]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
        position: "absolute",
        left: "0",
        top: "-100px"
      }), t.blockUI && (t.unblockUI(), t("body").append(this.dpDiv))), this._inDialog = !1);
    },
    _tidyDialog: function (t) {
      t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
    },
    _checkExternalClick: function (e) {
      if (t.datepicker._curInst) {
        var i = t(e.target),
            s = t.datepicker._getInst(i[0]);

        (i[0].id !== t.datepicker._mainDivId && 0 === i.parents("#" + t.datepicker._mainDivId).length && !i.hasClass(t.datepicker.markerClassName) && !i.closest("." + t.datepicker._triggerClass).length && t.datepicker._datepickerShowing && (!t.datepicker._inDialog || !t.blockUI) || i.hasClass(t.datepicker.markerClassName) && t.datepicker._curInst !== s) && t.datepicker._hideDatepicker();
      }
    },
    _adjustDate: function (e, i, s) {
      var n = t(e),
          o = this._getInst(n[0]);

      this._isDisabledDatepicker(n[0]) || (this._adjustInstDate(o, i + ("M" === s ? this._get(o, "showCurrentAtPos") : 0), s), this._updateDatepicker(o));
    },
    _gotoToday: function (e) {
      var i,
          s = t(e),
          n = this._getInst(s[0]);

      this._get(n, "gotoCurrent") && n.currentDay ? (n.selectedDay = n.currentDay, n.drawMonth = n.selectedMonth = n.currentMonth, n.drawYear = n.selectedYear = n.currentYear) : (i = new Date(), n.selectedDay = i.getDate(), n.drawMonth = n.selectedMonth = i.getMonth(), n.drawYear = n.selectedYear = i.getFullYear()), this._notifyChange(n), this._adjustDate(s);
    },
    _selectMonthYear: function (e, i, s) {
      var n = t(e),
          o = this._getInst(n[0]);

      o["selected" + ("M" === s ? "Month" : "Year")] = o["draw" + ("M" === s ? "Month" : "Year")] = parseInt(i.options[i.selectedIndex].value, 10), this._notifyChange(o), this._adjustDate(n);
    },
    _selectDay: function (e, i, s, n) {
      var o,
          a = t(e);
      t(n).hasClass(this._unselectableClass) || this._isDisabledDatepicker(a[0]) || (o = this._getInst(a[0]), o.selectedDay = o.currentDay = t("a", n).html(), o.selectedMonth = o.currentMonth = i, o.selectedYear = o.currentYear = s, this._selectDate(e, this._formatDate(o, o.currentDay, o.currentMonth, o.currentYear)));
    },
    _clearDate: function (e) {
      var i = t(e);

      this._selectDate(i, "");
    },
    _selectDate: function (e, i) {
      var s,
          n = t(e),
          o = this._getInst(n[0]);

      i = null != i ? i : this._formatDate(o), o.input && o.input.val(i), this._updateAlternate(o), s = this._get(o, "onSelect"), s ? s.apply(o.input ? o.input[0] : null, [i, o]) : o.input && o.input.trigger("change"), o.inline ? this._updateDatepicker(o) : (this._hideDatepicker(), this._lastInput = o.input[0], "object" != typeof o.input[0] && o.input.trigger("focus"), this._lastInput = null);
    },
    _updateAlternate: function (e) {
      var i,
          s,
          n,
          o = this._get(e, "altField");

      o && (i = this._get(e, "altFormat") || this._get(e, "dateFormat"), s = this._getDate(e), n = this.formatDate(i, s, this._getFormatConfig(e)), t(o).val(n));
    },
    noWeekends: function (t) {
      var e = t.getDay();
      return [e > 0 && 6 > e, ""];
    },
    iso8601Week: function (t) {
      var e,
          i = new Date(t.getTime());
      return i.setDate(i.getDate() + 4 - (i.getDay() || 7)), e = i.getTime(), i.setMonth(0), i.setDate(1), Math.floor(Math.round((e - i) / 864e5) / 7) + 1;
    },
    parseDate: function (e, i, s) {
      if (null == e || null == i) throw "Invalid arguments";
      if (i = "object" == typeof i ? "" + i : i + "", "" === i) return null;

      var n,
          o,
          a,
          r,
          h = 0,
          l = (s ? s.shortYearCutoff : null) || this._defaults.shortYearCutoff,
          c = "string" != typeof l ? l : new Date().getFullYear() % 100 + parseInt(l, 10),
          u = (s ? s.dayNamesShort : null) || this._defaults.dayNamesShort,
          d = (s ? s.dayNames : null) || this._defaults.dayNames,
          p = (s ? s.monthNamesShort : null) || this._defaults.monthNamesShort,
          f = (s ? s.monthNames : null) || this._defaults.monthNames,
          g = -1,
          m = -1,
          _ = -1,
          v = -1,
          b = !1,
          y = function (t) {
        var i = e.length > n + 1 && e.charAt(n + 1) === t;
        return i && n++, i;
      },
          w = function (t) {
        var e = y(t),
            s = "@" === t ? 14 : "!" === t ? 20 : "y" === t && e ? 4 : "o" === t ? 3 : 2,
            n = "y" === t ? s : 1,
            o = RegExp("^\\d{" + n + "," + s + "}"),
            a = i.substring(h).match(o);
        if (!a) throw "Missing number at position " + h;
        return h += a[0].length, parseInt(a[0], 10);
      },
          k = function (e, s, n) {
        var o = -1,
            a = t.map(y(e) ? n : s, function (t, e) {
          return [[e, t]];
        }).sort(function (t, e) {
          return -(t[1].length - e[1].length);
        });
        if (t.each(a, function (t, e) {
          var s = e[1];
          return i.substr(h, s.length).toLowerCase() === s.toLowerCase() ? (o = e[0], h += s.length, !1) : void 0;
        }), -1 !== o) return o + 1;
        throw "Unknown name at position " + h;
      },
          x = function () {
        if (i.charAt(h) !== e.charAt(n)) throw "Unexpected literal at position " + h;
        h++;
      };

      for (n = 0; e.length > n; n++) if (b) "'" !== e.charAt(n) || y("'") ? x() : b = !1;else switch (e.charAt(n)) {
        case "d":
          _ = w("d");
          break;

        case "D":
          k("D", u, d);
          break;

        case "o":
          v = w("o");
          break;

        case "m":
          m = w("m");
          break;

        case "M":
          m = k("M", p, f);
          break;

        case "y":
          g = w("y");
          break;

        case "@":
          r = new Date(w("@")), g = r.getFullYear(), m = r.getMonth() + 1, _ = r.getDate();
          break;

        case "!":
          r = new Date((w("!") - this._ticksTo1970) / 1e4), g = r.getFullYear(), m = r.getMonth() + 1, _ = r.getDate();
          break;

        case "'":
          y("'") ? x() : b = !0;
          break;

        default:
          x();
      }

      if (i.length > h && (a = i.substr(h), !/^\s+/.test(a))) throw "Extra/unparsed characters found in date: " + a;
      if (-1 === g ? g = new Date().getFullYear() : 100 > g && (g += new Date().getFullYear() - new Date().getFullYear() % 100 + (c >= g ? 0 : -100)), v > -1) for (m = 1, _ = v;;) {
        if (o = this._getDaysInMonth(g, m - 1), o >= _) break;
        m++, _ -= o;
      }
      if (r = this._daylightSavingAdjust(new Date(g, m - 1, _)), r.getFullYear() !== g || r.getMonth() + 1 !== m || r.getDate() !== _) throw "Invalid date";
      return r;
    },
    ATOM: "yy-mm-dd",
    COOKIE: "D, dd M yy",
    ISO_8601: "yy-mm-dd",
    RFC_822: "D, d M y",
    RFC_850: "DD, dd-M-y",
    RFC_1036: "D, d M y",
    RFC_1123: "D, d M yy",
    RFC_2822: "D, d M yy",
    RSS: "D, d M y",
    TICKS: "!",
    TIMESTAMP: "@",
    W3C: "yy-mm-dd",
    _ticksTo1970: 1e7 * 60 * 60 * 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)),
    formatDate: function (t, e, i) {
      if (!e) return "";

      var s,
          n = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort,
          o = (i ? i.dayNames : null) || this._defaults.dayNames,
          a = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort,
          r = (i ? i.monthNames : null) || this._defaults.monthNames,
          h = function (e) {
        var i = t.length > s + 1 && t.charAt(s + 1) === e;
        return i && s++, i;
      },
          l = function (t, e, i) {
        var s = "" + e;
        if (h(t)) for (; i > s.length;) s = "0" + s;
        return s;
      },
          c = function (t, e, i, s) {
        return h(t) ? s[e] : i[e];
      },
          u = "",
          d = !1;

      if (e) for (s = 0; t.length > s; s++) if (d) "'" !== t.charAt(s) || h("'") ? u += t.charAt(s) : d = !1;else switch (t.charAt(s)) {
        case "d":
          u += l("d", e.getDate(), 2);
          break;

        case "D":
          u += c("D", e.getDay(), n, o);
          break;

        case "o":
          u += l("o", Math.round((new Date(e.getFullYear(), e.getMonth(), e.getDate()).getTime() - new Date(e.getFullYear(), 0, 0).getTime()) / 864e5), 3);
          break;

        case "m":
          u += l("m", e.getMonth() + 1, 2);
          break;

        case "M":
          u += c("M", e.getMonth(), a, r);
          break;

        case "y":
          u += h("y") ? e.getFullYear() : (10 > e.getFullYear() % 100 ? "0" : "") + e.getFullYear() % 100;
          break;

        case "@":
          u += e.getTime();
          break;

        case "!":
          u += 1e4 * e.getTime() + this._ticksTo1970;
          break;

        case "'":
          h("'") ? u += "'" : d = !0;
          break;

        default:
          u += t.charAt(s);
      }
      return u;
    },
    _possibleChars: function (t) {
      var e,
          i = "",
          s = !1,
          n = function (i) {
        var s = t.length > e + 1 && t.charAt(e + 1) === i;
        return s && e++, s;
      };

      for (e = 0; t.length > e; e++) if (s) "'" !== t.charAt(e) || n("'") ? i += t.charAt(e) : s = !1;else switch (t.charAt(e)) {
        case "d":
        case "m":
        case "y":
        case "@":
          i += "0123456789";
          break;

        case "D":
        case "M":
          return null;

        case "'":
          n("'") ? i += "'" : s = !0;
          break;

        default:
          i += t.charAt(e);
      }

      return i;
    },
    _get: function (t, e) {
      return void 0 !== t.settings[e] ? t.settings[e] : this._defaults[e];
    },
    _setDateFromField: function (t, e) {
      if (t.input.val() !== t.lastVal) {
        var i = this._get(t, "dateFormat"),
            s = t.lastVal = t.input ? t.input.val() : null,
            n = this._getDefaultDate(t),
            o = n,
            a = this._getFormatConfig(t);

        try {
          o = this.parseDate(i, s, a) || n;
        } catch (r) {
          s = e ? "" : s;
        }

        t.selectedDay = o.getDate(), t.drawMonth = t.selectedMonth = o.getMonth(), t.drawYear = t.selectedYear = o.getFullYear(), t.currentDay = s ? o.getDate() : 0, t.currentMonth = s ? o.getMonth() : 0, t.currentYear = s ? o.getFullYear() : 0, this._adjustInstDate(t);
      }
    },
    _getDefaultDate: function (t) {
      return this._restrictMinMax(t, this._determineDate(t, this._get(t, "defaultDate"), new Date()));
    },
    _determineDate: function (e, i, s) {
      var n = function (t) {
        var e = new Date();
        return e.setDate(e.getDate() + t), e;
      },
          o = function (i) {
        try {
          return t.datepicker.parseDate(t.datepicker._get(e, "dateFormat"), i, t.datepicker._getFormatConfig(e));
        } catch (s) {}

        for (var n = (i.toLowerCase().match(/^c/) ? t.datepicker._getDate(e) : null) || new Date(), o = n.getFullYear(), a = n.getMonth(), r = n.getDate(), h = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, l = h.exec(i); l;) {
          switch (l[2] || "d") {
            case "d":
            case "D":
              r += parseInt(l[1], 10);
              break;

            case "w":
            case "W":
              r += 7 * parseInt(l[1], 10);
              break;

            case "m":
            case "M":
              a += parseInt(l[1], 10), r = Math.min(r, t.datepicker._getDaysInMonth(o, a));
              break;

            case "y":
            case "Y":
              o += parseInt(l[1], 10), r = Math.min(r, t.datepicker._getDaysInMonth(o, a));
          }

          l = h.exec(i);
        }

        return new Date(o, a, r);
      },
          a = null == i || "" === i ? s : "string" == typeof i ? o(i) : "number" == typeof i ? isNaN(i) ? s : n(i) : new Date(i.getTime());

      return a = a && "Invalid Date" == "" + a ? s : a, a && (a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)), this._daylightSavingAdjust(a);
    },
    _daylightSavingAdjust: function (t) {
      return t ? (t.setHours(t.getHours() > 12 ? t.getHours() + 2 : 0), t) : null;
    },
    _setDate: function (t, e, i) {
      var s = !e,
          n = t.selectedMonth,
          o = t.selectedYear,
          a = this._restrictMinMax(t, this._determineDate(t, e, new Date()));

      t.selectedDay = t.currentDay = a.getDate(), t.drawMonth = t.selectedMonth = t.currentMonth = a.getMonth(), t.drawYear = t.selectedYear = t.currentYear = a.getFullYear(), n === t.selectedMonth && o === t.selectedYear || i || this._notifyChange(t), this._adjustInstDate(t), t.input && t.input.val(s ? "" : this._formatDate(t));
    },
    _getDate: function (t) {
      var e = !t.currentYear || t.input && "" === t.input.val() ? null : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay));
      return e;
    },
    _attachHandlers: function (e) {
      var i = this._get(e, "stepMonths"),
          s = "#" + e.id.replace(/\\\\/g, "\\");

      e.dpDiv.find("[data-handler]").map(function () {
        var e = {
          prev: function () {
            t.datepicker._adjustDate(s, -i, "M");
          },
          next: function () {
            t.datepicker._adjustDate(s, +i, "M");
          },
          hide: function () {
            t.datepicker._hideDatepicker();
          },
          today: function () {
            t.datepicker._gotoToday(s);
          },
          selectDay: function () {
            return t.datepicker._selectDay(s, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1;
          },
          selectMonth: function () {
            return t.datepicker._selectMonthYear(s, this, "M"), !1;
          },
          selectYear: function () {
            return t.datepicker._selectMonthYear(s, this, "Y"), !1;
          }
        };
        t(this).on(this.getAttribute("data-event"), e[this.getAttribute("data-handler")]);
      });
    },
    _generateHTML: function (t) {
      var e,
          i,
          s,
          n,
          o,
          a,
          r,
          h,
          l,
          c,
          u,
          d,
          p,
          f,
          g,
          m,
          _,
          v,
          b,
          y,
          w,
          k,
          x,
          C,
          D,
          I,
          T,
          P,
          M,
          S,
          H,
          z,
          O,
          A,
          N,
          W,
          E,
          F,
          L,
          R = new Date(),
          B = this._daylightSavingAdjust(new Date(R.getFullYear(), R.getMonth(), R.getDate())),
          Y = this._get(t, "isRTL"),
          j = this._get(t, "showButtonPanel"),
          q = this._get(t, "hideIfNoPrevNext"),
          K = this._get(t, "navigationAsDateFormat"),
          U = this._getNumberOfMonths(t),
          V = this._get(t, "showCurrentAtPos"),
          $ = this._get(t, "stepMonths"),
          X = 1 !== U[0] || 1 !== U[1],
          G = this._daylightSavingAdjust(t.currentDay ? new Date(t.currentYear, t.currentMonth, t.currentDay) : new Date(9999, 9, 9)),
          Q = this._getMinMaxDate(t, "min"),
          J = this._getMinMaxDate(t, "max"),
          Z = t.drawMonth - V,
          te = t.drawYear;

      if (0 > Z && (Z += 12, te--), J) for (e = this._daylightSavingAdjust(new Date(J.getFullYear(), J.getMonth() - U[0] * U[1] + 1, J.getDate())), e = Q && Q > e ? Q : e; this._daylightSavingAdjust(new Date(te, Z, 1)) > e;) Z--, 0 > Z && (Z = 11, te--);

      for (t.drawMonth = Z, t.drawYear = te, i = this._get(t, "prevText"), i = K ? this.formatDate(i, this._daylightSavingAdjust(new Date(te, Z - $, 1)), this._getFormatConfig(t)) : i, s = this._canAdjustMonth(t, -1, te, Z) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + i + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "e" : "w") + "'>" + i + "</span></a>" : q ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + i + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "e" : "w") + "'>" + i + "</span></a>", n = this._get(t, "nextText"), n = K ? this.formatDate(n, this._daylightSavingAdjust(new Date(te, Z + $, 1)), this._getFormatConfig(t)) : n, o = this._canAdjustMonth(t, 1, te, Z) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + n + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "w" : "e") + "'>" + n + "</span></a>" : q ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + n + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "w" : "e") + "'>" + n + "</span></a>", a = this._get(t, "currentText"), r = this._get(t, "gotoCurrent") && t.currentDay ? G : B, a = K ? this.formatDate(a, r, this._getFormatConfig(t)) : a, h = t.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(t, "closeText") + "</button>", l = j ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (Y ? h : "") + (this._isInRange(t, r) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + a + "</button>" : "") + (Y ? "" : h) + "</div>" : "", c = parseInt(this._get(t, "firstDay"), 10), c = isNaN(c) ? 0 : c, u = this._get(t, "showWeek"), d = this._get(t, "dayNames"), p = this._get(t, "dayNamesMin"), f = this._get(t, "monthNames"), g = this._get(t, "monthNamesShort"), m = this._get(t, "beforeShowDay"), _ = this._get(t, "showOtherMonths"), v = this._get(t, "selectOtherMonths"), b = this._getDefaultDate(t), y = "", k = 0; U[0] > k; k++) {
        for (x = "", this.maxRows = 4, C = 0; U[1] > C; C++) {
          if (D = this._daylightSavingAdjust(new Date(te, Z, t.selectedDay)), I = " ui-corner-all", T = "", X) {
            if (T += "<div class='ui-datepicker-group", U[1] > 1) switch (C) {
              case 0:
                T += " ui-datepicker-group-first", I = " ui-corner-" + (Y ? "right" : "left");
                break;

              case U[1] - 1:
                T += " ui-datepicker-group-last", I = " ui-corner-" + (Y ? "left" : "right");
                break;

              default:
                T += " ui-datepicker-group-middle", I = "";
            }
            T += "'>";
          }

          for (T += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + I + "'>" + (/all|left/.test(I) && 0 === k ? Y ? o : s : "") + (/all|right/.test(I) && 0 === k ? Y ? s : o : "") + this._generateMonthYearHeader(t, Z, te, Q, J, k > 0 || C > 0, f, g) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>", P = u ? "<th class='ui-datepicker-week-col'>" + this._get(t, "weekHeader") + "</th>" : "", w = 0; 7 > w; w++) M = (w + c) % 7, P += "<th scope='col'" + ((w + c + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + d[M] + "'>" + p[M] + "</span></th>";

          for (T += P + "</tr></thead><tbody>", S = this._getDaysInMonth(te, Z), te === t.selectedYear && Z === t.selectedMonth && (t.selectedDay = Math.min(t.selectedDay, S)), H = (this._getFirstDayOfMonth(te, Z) - c + 7) % 7, z = Math.ceil((H + S) / 7), O = X ? this.maxRows > z ? this.maxRows : z : z, this.maxRows = O, A = this._daylightSavingAdjust(new Date(te, Z, 1 - H)), N = 0; O > N; N++) {
            for (T += "<tr>", W = u ? "<td class='ui-datepicker-week-col'>" + this._get(t, "calculateWeek")(A) + "</td>" : "", w = 0; 7 > w; w++) E = m ? m.apply(t.input ? t.input[0] : null, [A]) : [!0, ""], F = A.getMonth() !== Z, L = F && !v || !E[0] || Q && Q > A || J && A > J, W += "<td class='" + ((w + c + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (F ? " ui-datepicker-other-month" : "") + (A.getTime() === D.getTime() && Z === t.selectedMonth && t._keyEvent || b.getTime() === A.getTime() && b.getTime() === D.getTime() ? " " + this._dayOverClass : "") + (L ? " " + this._unselectableClass + " ui-state-disabled" : "") + (F && !_ ? "" : " " + E[1] + (A.getTime() === G.getTime() ? " " + this._currentClass : "") + (A.getTime() === B.getTime() ? " ui-datepicker-today" : "")) + "'" + (F && !_ || !E[2] ? "" : " title='" + E[2].replace(/'/g, "&#39;") + "'") + (L ? "" : " data-handler='selectDay' data-event='click' data-month='" + A.getMonth() + "' data-year='" + A.getFullYear() + "'") + ">" + (F && !_ ? "&#xa0;" : L ? "<span class='ui-state-default'>" + A.getDate() + "</span>" : "<a class='ui-state-default" + (A.getTime() === B.getTime() ? " ui-state-highlight" : "") + (A.getTime() === G.getTime() ? " ui-state-active" : "") + (F ? " ui-priority-secondary" : "") + "' href='#'>" + A.getDate() + "</a>") + "</td>", A.setDate(A.getDate() + 1), A = this._daylightSavingAdjust(A);

            T += W + "</tr>";
          }

          Z++, Z > 11 && (Z = 0, te++), T += "</tbody></table>" + (X ? "</div>" + (U[0] > 0 && C === U[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : ""), x += T;
        }

        y += x;
      }

      return y += l, t._keyEvent = !1, y;
    },
    _generateMonthYearHeader: function (t, e, i, s, n, o, a, r) {
      var h,
          l,
          c,
          u,
          d,
          p,
          f,
          g,
          m = this._get(t, "changeMonth"),
          _ = this._get(t, "changeYear"),
          v = this._get(t, "showMonthAfterYear"),
          b = "<div class='ui-datepicker-title'>",
          y = "";

      if (o || !m) y += "<span class='ui-datepicker-month'>" + a[e] + "</span>";else {
        for (h = s && s.getFullYear() === i, l = n && n.getFullYear() === i, y += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", c = 0; 12 > c; c++) (!h || c >= s.getMonth()) && (!l || n.getMonth() >= c) && (y += "<option value='" + c + "'" + (c === e ? " selected='selected'" : "") + ">" + r[c] + "</option>");

        y += "</select>";
      }
      if (v || (b += y + (!o && m && _ ? "" : "&#xa0;")), !t.yearshtml) if (t.yearshtml = "", o || !_) b += "<span class='ui-datepicker-year'>" + i + "</span>";else {
        for (u = this._get(t, "yearRange").split(":"), d = new Date().getFullYear(), p = function (t) {
          var e = t.match(/c[+\-].*/) ? i + parseInt(t.substring(1), 10) : t.match(/[+\-].*/) ? d + parseInt(t, 10) : parseInt(t, 10);
          return isNaN(e) ? d : e;
        }, f = p(u[0]), g = Math.max(f, p(u[1] || "")), f = s ? Math.max(f, s.getFullYear()) : f, g = n ? Math.min(g, n.getFullYear()) : g, t.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; g >= f; f++) t.yearshtml += "<option value='" + f + "'" + (f === i ? " selected='selected'" : "") + ">" + f + "</option>";

        t.yearshtml += "</select>", b += t.yearshtml, t.yearshtml = null;
      }
      return b += this._get(t, "yearSuffix"), v && (b += (!o && m && _ ? "" : "&#xa0;") + y), b += "</div>";
    },
    _adjustInstDate: function (t, e, i) {
      var s = t.selectedYear + ("Y" === i ? e : 0),
          n = t.selectedMonth + ("M" === i ? e : 0),
          o = Math.min(t.selectedDay, this._getDaysInMonth(s, n)) + ("D" === i ? e : 0),
          a = this._restrictMinMax(t, this._daylightSavingAdjust(new Date(s, n, o)));

      t.selectedDay = a.getDate(), t.drawMonth = t.selectedMonth = a.getMonth(), t.drawYear = t.selectedYear = a.getFullYear(), ("M" === i || "Y" === i) && this._notifyChange(t);
    },
    _restrictMinMax: function (t, e) {
      var i = this._getMinMaxDate(t, "min"),
          s = this._getMinMaxDate(t, "max"),
          n = i && i > e ? i : e;

      return s && n > s ? s : n;
    },
    _notifyChange: function (t) {
      var e = this._get(t, "onChangeMonthYear");

      e && e.apply(t.input ? t.input[0] : null, [t.selectedYear, t.selectedMonth + 1, t]);
    },
    _getNumberOfMonths: function (t) {
      var e = this._get(t, "numberOfMonths");

      return null == e ? [1, 1] : "number" == typeof e ? [1, e] : e;
    },
    _getMinMaxDate: function (t, e) {
      return this._determineDate(t, this._get(t, e + "Date"), null);
    },
    _getDaysInMonth: function (t, e) {
      return 32 - this._daylightSavingAdjust(new Date(t, e, 32)).getDate();
    },
    _getFirstDayOfMonth: function (t, e) {
      return new Date(t, e, 1).getDay();
    },
    _canAdjustMonth: function (t, e, i, s) {
      var n = this._getNumberOfMonths(t),
          o = this._daylightSavingAdjust(new Date(i, s + (0 > e ? e : n[0] * n[1]), 1));

      return 0 > e && o.setDate(this._getDaysInMonth(o.getFullYear(), o.getMonth())), this._isInRange(t, o);
    },
    _isInRange: function (t, e) {
      var i,
          s,
          n = this._getMinMaxDate(t, "min"),
          o = this._getMinMaxDate(t, "max"),
          a = null,
          r = null,
          h = this._get(t, "yearRange");

      return h && (i = h.split(":"), s = new Date().getFullYear(), a = parseInt(i[0], 10), r = parseInt(i[1], 10), i[0].match(/[+\-].*/) && (a += s), i[1].match(/[+\-].*/) && (r += s)), (!n || e.getTime() >= n.getTime()) && (!o || e.getTime() <= o.getTime()) && (!a || e.getFullYear() >= a) && (!r || r >= e.getFullYear());
    },
    _getFormatConfig: function (t) {
      var e = this._get(t, "shortYearCutoff");

      return e = "string" != typeof e ? e : new Date().getFullYear() % 100 + parseInt(e, 10), {
        shortYearCutoff: e,
        dayNamesShort: this._get(t, "dayNamesShort"),
        dayNames: this._get(t, "dayNames"),
        monthNamesShort: this._get(t, "monthNamesShort"),
        monthNames: this._get(t, "monthNames")
      };
    },
    _formatDate: function (t, e, i, s) {
      e || (t.currentDay = t.selectedDay, t.currentMonth = t.selectedMonth, t.currentYear = t.selectedYear);
      var n = e ? "object" == typeof e ? e : this._daylightSavingAdjust(new Date(s, i, e)) : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay));
      return this.formatDate(this._get(t, "dateFormat"), n, this._getFormatConfig(t));
    }
  }), t.fn.datepicker = function (e) {
    if (!this.length) return this;
    t.datepicker.initialized || (t(document).on("mousedown", t.datepicker._checkExternalClick), t.datepicker.initialized = !0), 0 === t("#" + t.datepicker._mainDivId).length && t("body").append(t.datepicker.dpDiv);
    var i = Array.prototype.slice.call(arguments, 1);
    return "string" != typeof e || "isDisabled" !== e && "getDate" !== e && "widget" !== e ? "option" === e && 2 === arguments.length && "string" == typeof arguments[1] ? t.datepicker["_" + e + "Datepicker"].apply(t.datepicker, [this[0]].concat(i)) : this.each(function () {
      "string" == typeof e ? t.datepicker["_" + e + "Datepicker"].apply(t.datepicker, [this].concat(i)) : t.datepicker._attachDatepicker(this, e);
    }) : t.datepicker["_" + e + "Datepicker"].apply(t.datepicker, [this[0]].concat(i));
  }, t.datepicker = new s(), t.datepicker.initialized = !1, t.datepicker.uuid = new Date().getTime(), t.datepicker.version = "1.12.1", t.datepicker, t.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

  var _ = !1;

  t(document).on("mouseup", function () {
    _ = !1;
  }), t.widget("ui.mouse", {
    version: "1.12.1",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function () {
      var e = this;
      this.element.on("mousedown." + this.widgetName, function (t) {
        return e._mouseDown(t);
      }).on("click." + this.widgetName, function (i) {
        return !0 === t.data(i.target, e.widgetName + ".preventClickEvent") ? (t.removeData(i.target, e.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1) : void 0;
      }), this.started = !1;
    },
    _mouseDestroy: function () {
      this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
    },
    _mouseDown: function (e) {
      if (!_) {
        this._mouseMoved = !1, this._mouseStarted && this._mouseUp(e), this._mouseDownEvent = e;
        var i = this,
            s = 1 === e.which,
            n = "string" == typeof this.options.cancel && e.target.nodeName ? t(e.target).closest(this.options.cancel).length : !1;
        return s && !n && this._mouseCapture(e) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
          i.mouseDelayMet = !0;
        }, this.options.delay)), this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = this._mouseStart(e) !== !1, !this._mouseStarted) ? (e.preventDefault(), !0) : (!0 === t.data(e.target, this.widgetName + ".preventClickEvent") && t.removeData(e.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (t) {
          return i._mouseMove(t);
        }, this._mouseUpDelegate = function (t) {
          return i._mouseUp(t);
        }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), e.preventDefault(), _ = !0, !0)) : !0;
      }
    },
    _mouseMove: function (e) {
      if (this._mouseMoved) {
        if (t.ui.ie && (!document.documentMode || 9 > document.documentMode) && !e.button) return this._mouseUp(e);
        if (!e.which) if (e.originalEvent.altKey || e.originalEvent.ctrlKey || e.originalEvent.metaKey || e.originalEvent.shiftKey) this.ignoreMissingWhich = !0;else if (!this.ignoreMissingWhich) return this._mouseUp(e);
      }

      return (e.which || e.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(e), e.preventDefault()) : (this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, e) !== !1, this._mouseStarted ? this._mouseDrag(e) : this._mouseUp(e)), !this._mouseStarted);
    },
    _mouseUp: function (e) {
      this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, e.target === this._mouseDownEvent.target && t.data(e.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(e)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, _ = !1, e.preventDefault();
    },
    _mouseDistanceMet: function (t) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - t.pageX), Math.abs(this._mouseDownEvent.pageY - t.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function () {
      return this.mouseDelayMet;
    },
    _mouseStart: function () {},
    _mouseDrag: function () {},
    _mouseStop: function () {},
    _mouseCapture: function () {
      return !0;
    }
  }), t.ui.plugin = {
    add: function (e, i, s) {
      var n,
          o = t.ui[e].prototype;

      for (n in s) o.plugins[n] = o.plugins[n] || [], o.plugins[n].push([i, s[n]]);
    },
    call: function (t, e, i, s) {
      var n,
          o = t.plugins[e];
      if (o && (s || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType)) for (n = 0; o.length > n; n++) t.options[o[n][0]] && o[n][1].apply(t.element, i);
    }
  }, t.ui.safeBlur = function (e) {
    e && "body" !== e.nodeName.toLowerCase() && t(e).trigger("blur");
  }, t.widget("ui.draggable", t.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "drag",
    options: {
      addClasses: !0,
      appendTo: "parent",
      axis: !1,
      connectToSortable: !1,
      containment: !1,
      cursor: "auto",
      cursorAt: !1,
      grid: !1,
      handle: !1,
      helper: "original",
      iframeFix: !1,
      opacity: !1,
      refreshPositions: !1,
      revert: !1,
      revertDuration: 500,
      scope: "default",
      scroll: !0,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: !1,
      snapMode: "both",
      snapTolerance: 20,
      stack: !1,
      zIndex: !1,
      drag: null,
      start: null,
      stop: null
    },
    _create: function () {
      "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit();
    },
    _setOption: function (t, e) {
      this._super(t, e), "handle" === t && (this._removeHandleClassName(), this._setHandleClassName());
    },
    _destroy: function () {
      return (this.helper || this.element).is(".ui-draggable-dragging") ? (this.destroyOnClear = !0, void 0) : (this._removeHandleClassName(), this._mouseDestroy(), void 0);
    },
    _mouseCapture: function (e) {
      var i = this.options;
      return this.helper || i.disabled || t(e.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(e), this.handle ? (this._blurActiveElement(e), this._blockFrames(i.iframeFix === !0 ? "iframe" : i.iframeFix), !0) : !1);
    },
    _blockFrames: function (e) {
      this.iframeBlocks = this.document.find(e).map(function () {
        var e = t(this);
        return t("<div>").css("position", "absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0];
      });
    },
    _unblockFrames: function () {
      this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
    },
    _blurActiveElement: function (e) {
      var i = t.ui.safeActiveElement(this.document[0]),
          s = t(e.target);
      s.closest(i).length || t.ui.safeBlur(i);
    },
    _mouseStart: function (e) {
      var i = this.options;
      return this.helper = this._createHelper(e), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), t.ui.ddmanager && (t.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function () {
        return "fixed" === t(this).css("position");
      }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(e), this.originalPosition = this.position = this._generatePosition(e, !1), this.originalPageX = e.pageX, this.originalPageY = e.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), this._setContainment(), this._trigger("start", e) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), t.ui.ddmanager && !i.dropBehaviour && t.ui.ddmanager.prepareOffsets(this, e), this._mouseDrag(e, !0), t.ui.ddmanager && t.ui.ddmanager.dragStart(this, e), !0);
    },
    _refreshOffsets: function (t) {
      this.offset = {
        top: this.positionAbs.top - this.margins.top,
        left: this.positionAbs.left - this.margins.left,
        scroll: !1,
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      }, this.offset.click = {
        left: t.pageX - this.offset.left,
        top: t.pageY - this.offset.top
      };
    },
    _mouseDrag: function (e, i) {
      if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(e, !0), this.positionAbs = this._convertPositionTo("absolute"), !i) {
        var s = this._uiHash();

        if (this._trigger("drag", e, s) === !1) return this._mouseUp(new t.Event("mouseup", e)), !1;
        this.position = s.position;
      }

      return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", t.ui.ddmanager && t.ui.ddmanager.drag(this, e), !1;
    },
    _mouseStop: function (e) {
      var i = this,
          s = !1;
      return t.ui.ddmanager && !this.options.dropBehaviour && (s = t.ui.ddmanager.drop(this, e)), this.dropped && (s = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !s || "valid" === this.options.revert && s || this.options.revert === !0 || t.isFunction(this.options.revert) && this.options.revert.call(this.element, s) ? t(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
        i._trigger("stop", e) !== !1 && i._clear();
      }) : this._trigger("stop", e) !== !1 && this._clear(), !1;
    },
    _mouseUp: function (e) {
      return this._unblockFrames(), t.ui.ddmanager && t.ui.ddmanager.dragStop(this, e), this.handleElement.is(e.target) && this.element.trigger("focus"), t.ui.mouse.prototype._mouseUp.call(this, e);
    },
    cancel: function () {
      return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new t.Event("mouseup", {
        target: this.element[0]
      })) : this._clear(), this;
    },
    _getHandle: function (e) {
      return this.options.handle ? !!t(e.target).closest(this.element.find(this.options.handle)).length : !0;
    },
    _setHandleClassName: function () {
      this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle");
    },
    _removeHandleClassName: function () {
      this._removeClass(this.handleElement, "ui-draggable-handle");
    },
    _createHelper: function (e) {
      var i = this.options,
          s = t.isFunction(i.helper),
          n = s ? t(i.helper.apply(this.element[0], [e])) : "clone" === i.helper ? this.element.clone().removeAttr("id") : this.element;
      return n.parents("body").length || n.appendTo("parent" === i.appendTo ? this.element[0].parentNode : i.appendTo), s && n[0] === this.element[0] && this._setPositionRelative(), n[0] === this.element[0] || /(fixed|absolute)/.test(n.css("position")) || n.css("position", "absolute"), n;
    },
    _setPositionRelative: function () {
      /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");
    },
    _adjustOffsetFromHelper: function (e) {
      "string" == typeof e && (e = e.split(" ")), t.isArray(e) && (e = {
        left: +e[0],
        top: +e[1] || 0
      }), "left" in e && (this.offset.click.left = e.left + this.margins.left), "right" in e && (this.offset.click.left = this.helperProportions.width - e.right + this.margins.left), "top" in e && (this.offset.click.top = e.top + this.margins.top), "bottom" in e && (this.offset.click.top = this.helperProportions.height - e.bottom + this.margins.top);
    },
    _isRootNode: function (t) {
      return /(html|body)/i.test(t.tagName) || t === this.document[0];
    },
    _getParentOffset: function () {
      var e = this.offsetParent.offset(),
          i = this.document[0];
      return "absolute" === this.cssPosition && this.scrollParent[0] !== i && t.contains(this.scrollParent[0], this.offsetParent[0]) && (e.left += this.scrollParent.scrollLeft(), e.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (e = {
        top: 0,
        left: 0
      }), {
        top: e.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: e.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if ("relative" !== this.cssPosition) return {
        top: 0,
        left: 0
      };

      var t = this.element.position(),
          e = this._isRootNode(this.scrollParent[0]);

      return {
        top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + (e ? 0 : this.scrollParent.scrollTop()),
        left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + (e ? 0 : this.scrollParent.scrollLeft())
      };
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.element.css("marginLeft"), 10) || 0,
        top: parseInt(this.element.css("marginTop"), 10) || 0,
        right: parseInt(this.element.css("marginRight"), 10) || 0,
        bottom: parseInt(this.element.css("marginBottom"), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var e,
          i,
          s,
          n = this.options,
          o = this.document[0];
      return this.relativeContainer = null, n.containment ? "window" === n.containment ? (this.containment = [t(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, t(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, t(window).scrollLeft() + t(window).width() - this.helperProportions.width - this.margins.left, t(window).scrollTop() + (t(window).height() || o.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : "document" === n.containment ? (this.containment = [0, 0, t(o).width() - this.helperProportions.width - this.margins.left, (t(o).height() || o.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : n.containment.constructor === Array ? (this.containment = n.containment, void 0) : ("parent" === n.containment && (n.containment = this.helper[0].parentNode), i = t(n.containment), s = i[0], s && (e = /(scroll|auto)/.test(i.css("overflow")), this.containment = [(parseInt(i.css("borderLeftWidth"), 10) || 0) + (parseInt(i.css("paddingLeft"), 10) || 0), (parseInt(i.css("borderTopWidth"), 10) || 0) + (parseInt(i.css("paddingTop"), 10) || 0), (e ? Math.max(s.scrollWidth, s.offsetWidth) : s.offsetWidth) - (parseInt(i.css("borderRightWidth"), 10) || 0) - (parseInt(i.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (e ? Math.max(s.scrollHeight, s.offsetHeight) : s.offsetHeight) - (parseInt(i.css("borderBottomWidth"), 10) || 0) - (parseInt(i.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = i), void 0) : (this.containment = null, void 0);
    },
    _convertPositionTo: function (t, e) {
      e || (e = this.position);

      var i = "absolute" === t ? 1 : -1,
          s = this._isRootNode(this.scrollParent[0]);

      return {
        top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top) * i,
        left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left) * i
      };
    },
    _generatePosition: function (t, e) {
      var i,
          s,
          n,
          o,
          a = this.options,
          r = this._isRootNode(this.scrollParent[0]),
          h = t.pageX,
          l = t.pageY;

      return r && this.offset.scroll || (this.offset.scroll = {
        top: this.scrollParent.scrollTop(),
        left: this.scrollParent.scrollLeft()
      }), e && (this.containment && (this.relativeContainer ? (s = this.relativeContainer.offset(), i = [this.containment[0] + s.left, this.containment[1] + s.top, this.containment[2] + s.left, this.containment[3] + s.top]) : i = this.containment, t.pageX - this.offset.click.left < i[0] && (h = i[0] + this.offset.click.left), t.pageY - this.offset.click.top < i[1] && (l = i[1] + this.offset.click.top), t.pageX - this.offset.click.left > i[2] && (h = i[2] + this.offset.click.left), t.pageY - this.offset.click.top > i[3] && (l = i[3] + this.offset.click.top)), a.grid && (n = a.grid[1] ? this.originalPageY + Math.round((l - this.originalPageY) / a.grid[1]) * a.grid[1] : this.originalPageY, l = i ? n - this.offset.click.top >= i[1] || n - this.offset.click.top > i[3] ? n : n - this.offset.click.top >= i[1] ? n - a.grid[1] : n + a.grid[1] : n, o = a.grid[0] ? this.originalPageX + Math.round((h - this.originalPageX) / a.grid[0]) * a.grid[0] : this.originalPageX, h = i ? o - this.offset.click.left >= i[0] || o - this.offset.click.left > i[2] ? o : o - this.offset.click.left >= i[0] ? o - a.grid[0] : o + a.grid[0] : o), "y" === a.axis && (h = this.originalPageX), "x" === a.axis && (l = this.originalPageY)), {
        top: l - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : r ? 0 : this.offset.scroll.top),
        left: h - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : r ? 0 : this.offset.scroll.left)
      };
    },
    _clear: function () {
      this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy();
    },
    _trigger: function (e, i, s) {
      return s = s || this._uiHash(), t.ui.plugin.call(this, e, [i, s, this], !0), /^(drag|start|stop)/.test(e) && (this.positionAbs = this._convertPositionTo("absolute"), s.offset = this.positionAbs), t.Widget.prototype._trigger.call(this, e, i, s);
    },
    plugins: {},
    _uiHash: function () {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  }), t.ui.plugin.add("draggable", "connectToSortable", {
    start: function (e, i, s) {
      var n = t.extend({}, i, {
        item: s.element
      });
      s.sortables = [], t(s.options.connectToSortable).each(function () {
        var i = t(this).sortable("instance");
        i && !i.options.disabled && (s.sortables.push(i), i.refreshPositions(), i._trigger("activate", e, n));
      });
    },
    stop: function (e, i, s) {
      var n = t.extend({}, i, {
        item: s.element
      });
      s.cancelHelperRemoval = !1, t.each(s.sortables, function () {
        var t = this;
        t.isOver ? (t.isOver = 0, s.cancelHelperRemoval = !0, t.cancelHelperRemoval = !1, t._storedCSS = {
          position: t.placeholder.css("position"),
          top: t.placeholder.css("top"),
          left: t.placeholder.css("left")
        }, t._mouseStop(e), t.options.helper = t.options._helper) : (t.cancelHelperRemoval = !0, t._trigger("deactivate", e, n));
      });
    },
    drag: function (e, i, s) {
      t.each(s.sortables, function () {
        var n = !1,
            o = this;
        o.positionAbs = s.positionAbs, o.helperProportions = s.helperProportions, o.offset.click = s.offset.click, o._intersectsWith(o.containerCache) && (n = !0, t.each(s.sortables, function () {
          return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions, this.offset.click = s.offset.click, this !== o && this._intersectsWith(this.containerCache) && t.contains(o.element[0], this.element[0]) && (n = !1), n;
        })), n ? (o.isOver || (o.isOver = 1, s._parent = i.helper.parent(), o.currentItem = i.helper.appendTo(o.element).data("ui-sortable-item", !0), o.options._helper = o.options.helper, o.options.helper = function () {
          return i.helper[0];
        }, e.target = o.currentItem[0], o._mouseCapture(e, !0), o._mouseStart(e, !0, !0), o.offset.click.top = s.offset.click.top, o.offset.click.left = s.offset.click.left, o.offset.parent.left -= s.offset.parent.left - o.offset.parent.left, o.offset.parent.top -= s.offset.parent.top - o.offset.parent.top, s._trigger("toSortable", e), s.dropped = o.element, t.each(s.sortables, function () {
          this.refreshPositions();
        }), s.currentItem = s.element, o.fromOutside = s), o.currentItem && (o._mouseDrag(e), i.position = o.position)) : o.isOver && (o.isOver = 0, o.cancelHelperRemoval = !0, o.options._revert = o.options.revert, o.options.revert = !1, o._trigger("out", e, o._uiHash(o)), o._mouseStop(e, !0), o.options.revert = o.options._revert, o.options.helper = o.options._helper, o.placeholder && o.placeholder.remove(), i.helper.appendTo(s._parent), s._refreshOffsets(e), i.position = s._generatePosition(e, !0), s._trigger("fromSortable", e), s.dropped = !1, t.each(s.sortables, function () {
          this.refreshPositions();
        }));
      });
    }
  }), t.ui.plugin.add("draggable", "cursor", {
    start: function (e, i, s) {
      var n = t("body"),
          o = s.options;
      n.css("cursor") && (o._cursor = n.css("cursor")), n.css("cursor", o.cursor);
    },
    stop: function (e, i, s) {
      var n = s.options;
      n._cursor && t("body").css("cursor", n._cursor);
    }
  }), t.ui.plugin.add("draggable", "opacity", {
    start: function (e, i, s) {
      var n = t(i.helper),
          o = s.options;
      n.css("opacity") && (o._opacity = n.css("opacity")), n.css("opacity", o.opacity);
    },
    stop: function (e, i, s) {
      var n = s.options;
      n._opacity && t(i.helper).css("opacity", n._opacity);
    }
  }), t.ui.plugin.add("draggable", "scroll", {
    start: function (t, e, i) {
      i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset());
    },
    drag: function (e, i, s) {
      var n = s.options,
          o = !1,
          a = s.scrollParentNotHidden[0],
          r = s.document[0];
      a !== r && "HTML" !== a.tagName ? (n.axis && "x" === n.axis || (s.overflowOffset.top + a.offsetHeight - e.pageY < n.scrollSensitivity ? a.scrollTop = o = a.scrollTop + n.scrollSpeed : e.pageY - s.overflowOffset.top < n.scrollSensitivity && (a.scrollTop = o = a.scrollTop - n.scrollSpeed)), n.axis && "y" === n.axis || (s.overflowOffset.left + a.offsetWidth - e.pageX < n.scrollSensitivity ? a.scrollLeft = o = a.scrollLeft + n.scrollSpeed : e.pageX - s.overflowOffset.left < n.scrollSensitivity && (a.scrollLeft = o = a.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (e.pageY - t(r).scrollTop() < n.scrollSensitivity ? o = t(r).scrollTop(t(r).scrollTop() - n.scrollSpeed) : t(window).height() - (e.pageY - t(r).scrollTop()) < n.scrollSensitivity && (o = t(r).scrollTop(t(r).scrollTop() + n.scrollSpeed))), n.axis && "y" === n.axis || (e.pageX - t(r).scrollLeft() < n.scrollSensitivity ? o = t(r).scrollLeft(t(r).scrollLeft() - n.scrollSpeed) : t(window).width() - (e.pageX - t(r).scrollLeft()) < n.scrollSensitivity && (o = t(r).scrollLeft(t(r).scrollLeft() + n.scrollSpeed)))), o !== !1 && t.ui.ddmanager && !n.dropBehaviour && t.ui.ddmanager.prepareOffsets(s, e);
    }
  }), t.ui.plugin.add("draggable", "snap", {
    start: function (e, i, s) {
      var n = s.options;
      s.snapElements = [], t(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function () {
        var e = t(this),
            i = e.offset();
        this !== s.element[0] && s.snapElements.push({
          item: this,
          width: e.outerWidth(),
          height: e.outerHeight(),
          top: i.top,
          left: i.left
        });
      });
    },
    drag: function (e, i, s) {
      var n,
          o,
          a,
          r,
          h,
          l,
          c,
          u,
          d,
          p,
          f = s.options,
          g = f.snapTolerance,
          m = i.offset.left,
          _ = m + s.helperProportions.width,
          v = i.offset.top,
          b = v + s.helperProportions.height;

      for (d = s.snapElements.length - 1; d >= 0; d--) h = s.snapElements[d].left - s.margins.left, l = h + s.snapElements[d].width, c = s.snapElements[d].top - s.margins.top, u = c + s.snapElements[d].height, h - g > _ || m > l + g || c - g > b || v > u + g || !t.contains(s.snapElements[d].item.ownerDocument, s.snapElements[d].item) ? (s.snapElements[d].snapping && s.options.snap.release && s.options.snap.release.call(s.element, e, t.extend(s._uiHash(), {
        snapItem: s.snapElements[d].item
      })), s.snapElements[d].snapping = !1) : ("inner" !== f.snapMode && (n = g >= Math.abs(c - b), o = g >= Math.abs(u - v), a = g >= Math.abs(h - _), r = g >= Math.abs(l - m), n && (i.position.top = s._convertPositionTo("relative", {
        top: c - s.helperProportions.height,
        left: 0
      }).top), o && (i.position.top = s._convertPositionTo("relative", {
        top: u,
        left: 0
      }).top), a && (i.position.left = s._convertPositionTo("relative", {
        top: 0,
        left: h - s.helperProportions.width
      }).left), r && (i.position.left = s._convertPositionTo("relative", {
        top: 0,
        left: l
      }).left)), p = n || o || a || r, "outer" !== f.snapMode && (n = g >= Math.abs(c - v), o = g >= Math.abs(u - b), a = g >= Math.abs(h - m), r = g >= Math.abs(l - _), n && (i.position.top = s._convertPositionTo("relative", {
        top: c,
        left: 0
      }).top), o && (i.position.top = s._convertPositionTo("relative", {
        top: u - s.helperProportions.height,
        left: 0
      }).top), a && (i.position.left = s._convertPositionTo("relative", {
        top: 0,
        left: h
      }).left), r && (i.position.left = s._convertPositionTo("relative", {
        top: 0,
        left: l - s.helperProportions.width
      }).left)), !s.snapElements[d].snapping && (n || o || a || r || p) && s.options.snap.snap && s.options.snap.snap.call(s.element, e, t.extend(s._uiHash(), {
        snapItem: s.snapElements[d].item
      })), s.snapElements[d].snapping = n || o || a || r || p);
    }
  }), t.ui.plugin.add("draggable", "stack", {
    start: function (e, i, s) {
      var n,
          o = s.options,
          a = t.makeArray(t(o.stack)).sort(function (e, i) {
        return (parseInt(t(e).css("zIndex"), 10) || 0) - (parseInt(t(i).css("zIndex"), 10) || 0);
      });
      a.length && (n = parseInt(t(a[0]).css("zIndex"), 10) || 0, t(a).each(function (e) {
        t(this).css("zIndex", n + e);
      }), this.css("zIndex", n + a.length));
    }
  }), t.ui.plugin.add("draggable", "zIndex", {
    start: function (e, i, s) {
      var n = t(i.helper),
          o = s.options;
      n.css("zIndex") && (o._zIndex = n.css("zIndex")), n.css("zIndex", o.zIndex);
    },
    stop: function (e, i, s) {
      var n = s.options;
      n._zIndex && t(i.helper).css("zIndex", n._zIndex);
    }
  }), t.ui.draggable, t.widget("ui.resizable", t.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "resize",
    options: {
      alsoResize: !1,
      animate: !1,
      animateDuration: "slow",
      animateEasing: "swing",
      aspectRatio: !1,
      autoHide: !1,
      classes: {
        "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
      },
      containment: !1,
      ghost: !1,
      grid: !1,
      handles: "e,s,se",
      helper: !1,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      zIndex: 90,
      resize: null,
      start: null,
      stop: null
    },
    _num: function (t) {
      return parseFloat(t) || 0;
    },
    _isNumber: function (t) {
      return !isNaN(parseFloat(t));
    },
    _hasScroll: function (e, i) {
      if ("hidden" === t(e).css("overflow")) return !1;
      var s = i && "left" === i ? "scrollLeft" : "scrollTop",
          n = !1;
      return e[s] > 0 ? !0 : (e[s] = 1, n = e[s] > 0, e[s] = 0, n);
    },
    _create: function () {
      var e,
          i = this.options,
          s = this;
      this._addClass("ui-resizable"), t.extend(this, {
        _aspectRatio: !!i.aspectRatio,
        aspectRatio: i.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: i.helper || i.ghost || i.animate ? i.helper || "ui-resizable-helper" : null
      }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
        position: this.element.css("position"),
        width: this.element.outerWidth(),
        height: this.element.outerHeight(),
        top: this.element.css("top"),
        left: this.element.css("left")
      })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = !0, e = {
        marginTop: this.originalElement.css("marginTop"),
        marginRight: this.originalElement.css("marginRight"),
        marginBottom: this.originalElement.css("marginBottom"),
        marginLeft: this.originalElement.css("marginLeft")
      }, this.element.css(e), this.originalElement.css("margin", 0), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
        position: "static",
        zoom: 1,
        display: "block"
      })), this.originalElement.css(e), this._proportionallyResize()), this._setupHandles(), i.autoHide && t(this.element).on("mouseenter", function () {
        i.disabled || (s._removeClass("ui-resizable-autohide"), s._handles.show());
      }).on("mouseleave", function () {
        i.disabled || s.resizing || (s._addClass("ui-resizable-autohide"), s._handles.hide());
      }), this._mouseInit();
    },
    _destroy: function () {
      this._mouseDestroy();

      var e,
          i = function (e) {
        t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove();
      };

      return this.elementIsWrapper && (i(this.element), e = this.element, this.originalElement.css({
        position: e.css("position"),
        width: e.outerWidth(),
        height: e.outerHeight(),
        top: e.css("top"),
        left: e.css("left")
      }).insertAfter(e), e.remove()), this.originalElement.css("resize", this.originalResizeStyle), i(this.originalElement), this;
    },
    _setOption: function (t, e) {
      switch (this._super(t, e), t) {
        case "handles":
          this._removeHandles(), this._setupHandles();
          break;

        default:
      }
    },
    _setupHandles: function () {
      var e,
          i,
          s,
          n,
          o,
          a = this.options,
          r = this;
      if (this.handles = a.handles || (t(".ui-resizable-handle", this.element).length ? {
        n: ".ui-resizable-n",
        e: ".ui-resizable-e",
        s: ".ui-resizable-s",
        w: ".ui-resizable-w",
        se: ".ui-resizable-se",
        sw: ".ui-resizable-sw",
        ne: ".ui-resizable-ne",
        nw: ".ui-resizable-nw"
      } : "e,s,se"), this._handles = t(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), s = this.handles.split(","), this.handles = {}, i = 0; s.length > i; i++) e = t.trim(s[i]), n = "ui-resizable-" + e, o = t("<div>"), this._addClass(o, "ui-resizable-handle " + n), o.css({
        zIndex: a.zIndex
      }), this.handles[e] = ".ui-resizable-" + e, this.element.append(o);
      this._renderAxis = function (e) {
        var i, s, n, o;
        e = e || this.element;

        for (i in this.handles) this.handles[i].constructor === String ? this.handles[i] = this.element.children(this.handles[i]).first().show() : (this.handles[i].jquery || this.handles[i].nodeType) && (this.handles[i] = t(this.handles[i]), this._on(this.handles[i], {
          mousedown: r._mouseDown
        })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (s = t(this.handles[i], this.element), o = /sw|ne|nw|se|n|s/.test(i) ? s.outerHeight() : s.outerWidth(), n = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join(""), e.css(n, o), this._proportionallyResize()), this._handles = this._handles.add(this.handles[i]);
      }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.on("mouseover", function () {
        r.resizing || (this.className && (o = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), r.axis = o && o[1] ? o[1] : "se");
      }), a.autoHide && (this._handles.hide(), this._addClass("ui-resizable-autohide"));
    },
    _removeHandles: function () {
      this._handles.remove();
    },
    _mouseCapture: function (e) {
      var i,
          s,
          n = !1;

      for (i in this.handles) s = t(this.handles[i])[0], (s === e.target || t.contains(s, e.target)) && (n = !0);

      return !this.options.disabled && n;
    },
    _mouseStart: function (e) {
      var i,
          s,
          n,
          o = this.options,
          a = this.element;
      return this.resizing = !0, this._renderProxy(), i = this._num(this.helper.css("left")), s = this._num(this.helper.css("top")), o.containment && (i += t(o.containment).scrollLeft() || 0, s += t(o.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
        left: i,
        top: s
      }, this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: a.width(),
        height: a.height()
      }, this.originalSize = this._helper ? {
        width: a.outerWidth(),
        height: a.outerHeight()
      } : {
        width: a.width(),
        height: a.height()
      }, this.sizeDiff = {
        width: a.outerWidth() - a.width(),
        height: a.outerHeight() - a.height()
      }, this.originalPosition = {
        left: i,
        top: s
      }, this.originalMousePosition = {
        left: e.pageX,
        top: e.pageY
      }, this.aspectRatio = "number" == typeof o.aspectRatio ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1, n = t(".ui-resizable-" + this.axis).css("cursor"), t("body").css("cursor", "auto" === n ? this.axis + "-resize" : n), this._addClass("ui-resizable-resizing"), this._propagate("start", e), !0;
    },
    _mouseDrag: function (e) {
      var i,
          s,
          n = this.originalMousePosition,
          o = this.axis,
          a = e.pageX - n.left || 0,
          r = e.pageY - n.top || 0,
          h = this._change[o];
      return this._updatePrevProperties(), h ? (i = h.apply(this, [e, a, r]), this._updateVirtualBoundaries(e.shiftKey), (this._aspectRatio || e.shiftKey) && (i = this._updateRatio(i, e)), i = this._respectSize(i, e), this._updateCache(i), this._propagate("resize", e), s = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), t.isEmptyObject(s) || (this._updatePrevProperties(), this._trigger("resize", e, this.ui()), this._applyChanges()), !1) : !1;
    },
    _mouseStop: function (e) {
      this.resizing = !1;
      var i,
          s,
          n,
          o,
          a,
          r,
          h,
          l = this.options,
          c = this;
      return this._helper && (i = this._proportionallyResizeElements, s = i.length && /textarea/i.test(i[0].nodeName), n = s && this._hasScroll(i[0], "left") ? 0 : c.sizeDiff.height, o = s ? 0 : c.sizeDiff.width, a = {
        width: c.helper.width() - o,
        height: c.helper.height() - n
      }, r = parseFloat(c.element.css("left")) + (c.position.left - c.originalPosition.left) || null, h = parseFloat(c.element.css("top")) + (c.position.top - c.originalPosition.top) || null, l.animate || this.element.css(t.extend(a, {
        top: h,
        left: r
      })), c.helper.height(c.size.height), c.helper.width(c.size.width), this._helper && !l.animate && this._proportionallyResize()), t("body").css("cursor", "auto"), this._removeClass("ui-resizable-resizing"), this._propagate("stop", e), this._helper && this.helper.remove(), !1;
    },
    _updatePrevProperties: function () {
      this.prevPosition = {
        top: this.position.top,
        left: this.position.left
      }, this.prevSize = {
        width: this.size.width,
        height: this.size.height
      };
    },
    _applyChanges: function () {
      var t = {};
      return this.position.top !== this.prevPosition.top && (t.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (t.left = this.position.left + "px"), this.size.width !== this.prevSize.width && (t.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (t.height = this.size.height + "px"), this.helper.css(t), t;
    },
    _updateVirtualBoundaries: function (t) {
      var e,
          i,
          s,
          n,
          o,
          a = this.options;
      o = {
        minWidth: this._isNumber(a.minWidth) ? a.minWidth : 0,
        maxWidth: this._isNumber(a.maxWidth) ? a.maxWidth : 1 / 0,
        minHeight: this._isNumber(a.minHeight) ? a.minHeight : 0,
        maxHeight: this._isNumber(a.maxHeight) ? a.maxHeight : 1 / 0
      }, (this._aspectRatio || t) && (e = o.minHeight * this.aspectRatio, s = o.minWidth / this.aspectRatio, i = o.maxHeight * this.aspectRatio, n = o.maxWidth / this.aspectRatio, e > o.minWidth && (o.minWidth = e), s > o.minHeight && (o.minHeight = s), o.maxWidth > i && (o.maxWidth = i), o.maxHeight > n && (o.maxHeight = n)), this._vBoundaries = o;
    },
    _updateCache: function (t) {
      this.offset = this.helper.offset(), this._isNumber(t.left) && (this.position.left = t.left), this._isNumber(t.top) && (this.position.top = t.top), this._isNumber(t.height) && (this.size.height = t.height), this._isNumber(t.width) && (this.size.width = t.width);
    },
    _updateRatio: function (t) {
      var e = this.position,
          i = this.size,
          s = this.axis;
      return this._isNumber(t.height) ? t.width = t.height * this.aspectRatio : this._isNumber(t.width) && (t.height = t.width / this.aspectRatio), "sw" === s && (t.left = e.left + (i.width - t.width), t.top = null), "nw" === s && (t.top = e.top + (i.height - t.height), t.left = e.left + (i.width - t.width)), t;
    },
    _respectSize: function (t) {
      var e = this._vBoundaries,
          i = this.axis,
          s = this._isNumber(t.width) && e.maxWidth && e.maxWidth < t.width,
          n = this._isNumber(t.height) && e.maxHeight && e.maxHeight < t.height,
          o = this._isNumber(t.width) && e.minWidth && e.minWidth > t.width,
          a = this._isNumber(t.height) && e.minHeight && e.minHeight > t.height,
          r = this.originalPosition.left + this.originalSize.width,
          h = this.originalPosition.top + this.originalSize.height,
          l = /sw|nw|w/.test(i),
          c = /nw|ne|n/.test(i);
      return o && (t.width = e.minWidth), a && (t.height = e.minHeight), s && (t.width = e.maxWidth), n && (t.height = e.maxHeight), o && l && (t.left = r - e.minWidth), s && l && (t.left = r - e.maxWidth), a && c && (t.top = h - e.minHeight), n && c && (t.top = h - e.maxHeight), t.width || t.height || t.left || !t.top ? t.width || t.height || t.top || !t.left || (t.left = null) : t.top = null, t;
    },
    _getPaddingPlusBorderDimensions: function (t) {
      for (var e = 0, i = [], s = [t.css("borderTopWidth"), t.css("borderRightWidth"), t.css("borderBottomWidth"), t.css("borderLeftWidth")], n = [t.css("paddingTop"), t.css("paddingRight"), t.css("paddingBottom"), t.css("paddingLeft")]; 4 > e; e++) i[e] = parseFloat(s[e]) || 0, i[e] += parseFloat(n[e]) || 0;

      return {
        height: i[0] + i[2],
        width: i[1] + i[3]
      };
    },
    _proportionallyResize: function () {
      if (this._proportionallyResizeElements.length) for (var t, e = 0, i = this.helper || this.element; this._proportionallyResizeElements.length > e; e++) t = this._proportionallyResizeElements[e], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(t)), t.css({
        height: i.height() - this.outerDimensions.height || 0,
        width: i.width() - this.outerDimensions.width || 0
      });
    },
    _renderProxy: function () {
      var e = this.element,
          i = this.options;
      this.elementOffset = e.offset(), this._helper ? (this.helper = this.helper || t("<div style='overflow:hidden;'></div>"), this._addClass(this.helper, this._helper), this.helper.css({
        width: this.element.outerWidth(),
        height: this.element.outerHeight(),
        position: "absolute",
        left: this.elementOffset.left + "px",
        top: this.elementOffset.top + "px",
        zIndex: ++i.zIndex
      }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
    },
    _change: {
      e: function (t, e) {
        return {
          width: this.originalSize.width + e
        };
      },
      w: function (t, e) {
        var i = this.originalSize,
            s = this.originalPosition;
        return {
          left: s.left + e,
          width: i.width - e
        };
      },
      n: function (t, e, i) {
        var s = this.originalSize,
            n = this.originalPosition;
        return {
          top: n.top + i,
          height: s.height - i
        };
      },
      s: function (t, e, i) {
        return {
          height: this.originalSize.height + i
        };
      },
      se: function (e, i, s) {
        return t.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [e, i, s]));
      },
      sw: function (e, i, s) {
        return t.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [e, i, s]));
      },
      ne: function (e, i, s) {
        return t.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [e, i, s]));
      },
      nw: function (e, i, s) {
        return t.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [e, i, s]));
      }
    },
    _propagate: function (e, i) {
      t.ui.plugin.call(this, e, [i, this.ui()]), "resize" !== e && this._trigger(e, i, this.ui());
    },
    plugins: {},
    ui: function () {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  }), t.ui.plugin.add("resizable", "animate", {
    stop: function (e) {
      var i = t(this).resizable("instance"),
          s = i.options,
          n = i._proportionallyResizeElements,
          o = n.length && /textarea/i.test(n[0].nodeName),
          a = o && i._hasScroll(n[0], "left") ? 0 : i.sizeDiff.height,
          r = o ? 0 : i.sizeDiff.width,
          h = {
        width: i.size.width - r,
        height: i.size.height - a
      },
          l = parseFloat(i.element.css("left")) + (i.position.left - i.originalPosition.left) || null,
          c = parseFloat(i.element.css("top")) + (i.position.top - i.originalPosition.top) || null;
      i.element.animate(t.extend(h, c && l ? {
        top: c,
        left: l
      } : {}), {
        duration: s.animateDuration,
        easing: s.animateEasing,
        step: function () {
          var s = {
            width: parseFloat(i.element.css("width")),
            height: parseFloat(i.element.css("height")),
            top: parseFloat(i.element.css("top")),
            left: parseFloat(i.element.css("left"))
          };
          n && n.length && t(n[0]).css({
            width: s.width,
            height: s.height
          }), i._updateCache(s), i._propagate("resize", e);
        }
      });
    }
  }), t.ui.plugin.add("resizable", "containment", {
    start: function () {
      var e,
          i,
          s,
          n,
          o,
          a,
          r,
          h = t(this).resizable("instance"),
          l = h.options,
          c = h.element,
          u = l.containment,
          d = u instanceof t ? u.get(0) : /parent/.test(u) ? c.parent().get(0) : u;
      d && (h.containerElement = t(d), /document/.test(u) || u === document ? (h.containerOffset = {
        left: 0,
        top: 0
      }, h.containerPosition = {
        left: 0,
        top: 0
      }, h.parentData = {
        element: t(document),
        left: 0,
        top: 0,
        width: t(document).width(),
        height: t(document).height() || document.body.parentNode.scrollHeight
      }) : (e = t(d), i = [], t(["Top", "Right", "Left", "Bottom"]).each(function (t, s) {
        i[t] = h._num(e.css("padding" + s));
      }), h.containerOffset = e.offset(), h.containerPosition = e.position(), h.containerSize = {
        height: e.innerHeight() - i[3],
        width: e.innerWidth() - i[1]
      }, s = h.containerOffset, n = h.containerSize.height, o = h.containerSize.width, a = h._hasScroll(d, "left") ? d.scrollWidth : o, r = h._hasScroll(d) ? d.scrollHeight : n, h.parentData = {
        element: d,
        left: s.left,
        top: s.top,
        width: a,
        height: r
      }));
    },
    resize: function (e) {
      var i,
          s,
          n,
          o,
          a = t(this).resizable("instance"),
          r = a.options,
          h = a.containerOffset,
          l = a.position,
          c = a._aspectRatio || e.shiftKey,
          u = {
        top: 0,
        left: 0
      },
          d = a.containerElement,
          p = !0;
      d[0] !== document && /static/.test(d.css("position")) && (u = h), l.left < (a._helper ? h.left : 0) && (a.size.width = a.size.width + (a._helper ? a.position.left - h.left : a.position.left - u.left), c && (a.size.height = a.size.width / a.aspectRatio, p = !1), a.position.left = r.helper ? h.left : 0), l.top < (a._helper ? h.top : 0) && (a.size.height = a.size.height + (a._helper ? a.position.top - h.top : a.position.top), c && (a.size.width = a.size.height * a.aspectRatio, p = !1), a.position.top = a._helper ? h.top : 0), n = a.containerElement.get(0) === a.element.parent().get(0), o = /relative|absolute/.test(a.containerElement.css("position")), n && o ? (a.offset.left = a.parentData.left + a.position.left, a.offset.top = a.parentData.top + a.position.top) : (a.offset.left = a.element.offset().left, a.offset.top = a.element.offset().top), i = Math.abs(a.sizeDiff.width + (a._helper ? a.offset.left - u.left : a.offset.left - h.left)), s = Math.abs(a.sizeDiff.height + (a._helper ? a.offset.top - u.top : a.offset.top - h.top)), i + a.size.width >= a.parentData.width && (a.size.width = a.parentData.width - i, c && (a.size.height = a.size.width / a.aspectRatio, p = !1)), s + a.size.height >= a.parentData.height && (a.size.height = a.parentData.height - s, c && (a.size.width = a.size.height * a.aspectRatio, p = !1)), p || (a.position.left = a.prevPosition.left, a.position.top = a.prevPosition.top, a.size.width = a.prevSize.width, a.size.height = a.prevSize.height);
    },
    stop: function () {
      var e = t(this).resizable("instance"),
          i = e.options,
          s = e.containerOffset,
          n = e.containerPosition,
          o = e.containerElement,
          a = t(e.helper),
          r = a.offset(),
          h = a.outerWidth() - e.sizeDiff.width,
          l = a.outerHeight() - e.sizeDiff.height;
      e._helper && !i.animate && /relative/.test(o.css("position")) && t(this).css({
        left: r.left - n.left - s.left,
        width: h,
        height: l
      }), e._helper && !i.animate && /static/.test(o.css("position")) && t(this).css({
        left: r.left - n.left - s.left,
        width: h,
        height: l
      });
    }
  }), t.ui.plugin.add("resizable", "alsoResize", {
    start: function () {
      var e = t(this).resizable("instance"),
          i = e.options;
      t(i.alsoResize).each(function () {
        var e = t(this);
        e.data("ui-resizable-alsoresize", {
          width: parseFloat(e.width()),
          height: parseFloat(e.height()),
          left: parseFloat(e.css("left")),
          top: parseFloat(e.css("top"))
        });
      });
    },
    resize: function (e, i) {
      var s = t(this).resizable("instance"),
          n = s.options,
          o = s.originalSize,
          a = s.originalPosition,
          r = {
        height: s.size.height - o.height || 0,
        width: s.size.width - o.width || 0,
        top: s.position.top - a.top || 0,
        left: s.position.left - a.left || 0
      };
      t(n.alsoResize).each(function () {
        var e = t(this),
            s = t(this).data("ui-resizable-alsoresize"),
            n = {},
            o = e.parents(i.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
        t.each(o, function (t, e) {
          var i = (s[e] || 0) + (r[e] || 0);
          i && i >= 0 && (n[e] = i || null);
        }), e.css(n);
      });
    },
    stop: function () {
      t(this).removeData("ui-resizable-alsoresize");
    }
  }), t.ui.plugin.add("resizable", "ghost", {
    start: function () {
      var e = t(this).resizable("instance"),
          i = e.size;
      e.ghost = e.originalElement.clone(), e.ghost.css({
        opacity: .25,
        display: "block",
        position: "relative",
        height: i.height,
        width: i.width,
        margin: 0,
        left: 0,
        top: 0
      }), e._addClass(e.ghost, "ui-resizable-ghost"), t.uiBackCompat !== !1 && "string" == typeof e.options.ghost && e.ghost.addClass(this.options.ghost), e.ghost.appendTo(e.helper);
    },
    resize: function () {
      var e = t(this).resizable("instance");
      e.ghost && e.ghost.css({
        position: "relative",
        height: e.size.height,
        width: e.size.width
      });
    },
    stop: function () {
      var e = t(this).resizable("instance");
      e.ghost && e.helper && e.helper.get(0).removeChild(e.ghost.get(0));
    }
  }), t.ui.plugin.add("resizable", "grid", {
    resize: function () {
      var e,
          i = t(this).resizable("instance"),
          s = i.options,
          n = i.size,
          o = i.originalSize,
          a = i.originalPosition,
          r = i.axis,
          h = "number" == typeof s.grid ? [s.grid, s.grid] : s.grid,
          l = h[0] || 1,
          c = h[1] || 1,
          u = Math.round((n.width - o.width) / l) * l,
          d = Math.round((n.height - o.height) / c) * c,
          p = o.width + u,
          f = o.height + d,
          g = s.maxWidth && p > s.maxWidth,
          m = s.maxHeight && f > s.maxHeight,
          _ = s.minWidth && s.minWidth > p,
          v = s.minHeight && s.minHeight > f;

      s.grid = h, _ && (p += l), v && (f += c), g && (p -= l), m && (f -= c), /^(se|s|e)$/.test(r) ? (i.size.width = p, i.size.height = f) : /^(ne)$/.test(r) ? (i.size.width = p, i.size.height = f, i.position.top = a.top - d) : /^(sw)$/.test(r) ? (i.size.width = p, i.size.height = f, i.position.left = a.left - u) : ((0 >= f - c || 0 >= p - l) && (e = i._getPaddingPlusBorderDimensions(this)), f - c > 0 ? (i.size.height = f, i.position.top = a.top - d) : (f = c - e.height, i.size.height = f, i.position.top = a.top + o.height - f), p - l > 0 ? (i.size.width = p, i.position.left = a.left - u) : (p = l - e.width, i.size.width = p, i.position.left = a.left + o.width - p));
    }
  }), t.ui.resizable, t.widget("ui.dialog", {
    version: "1.12.1",
    options: {
      appendTo: "body",
      autoOpen: !0,
      buttons: [],
      classes: {
        "ui-dialog": "ui-corner-all",
        "ui-dialog-titlebar": "ui-corner-all"
      },
      closeOnEscape: !0,
      closeText: "Close",
      draggable: !0,
      hide: null,
      height: "auto",
      maxHeight: null,
      maxWidth: null,
      minHeight: 150,
      minWidth: 150,
      modal: !1,
      position: {
        my: "center",
        at: "center",
        of: window,
        collision: "fit",
        using: function (e) {
          var i = t(this).css(e).offset().top;
          0 > i && t(this).css("top", e.top - i);
        }
      },
      resizable: !0,
      show: null,
      title: null,
      width: 300,
      beforeClose: null,
      close: null,
      drag: null,
      dragStart: null,
      dragStop: null,
      focus: null,
      open: null,
      resize: null,
      resizeStart: null,
      resizeStop: null
    },
    sizeRelatedOptions: {
      buttons: !0,
      height: !0,
      maxHeight: !0,
      maxWidth: !0,
      minHeight: !0,
      minWidth: !0,
      width: !0
    },
    resizableRelatedOptions: {
      maxHeight: !0,
      maxWidth: !0,
      minHeight: !0,
      minWidth: !0
    },
    _create: function () {
      this.originalCss = {
        display: this.element[0].style.display,
        width: this.element[0].style.width,
        minHeight: this.element[0].style.minHeight,
        maxHeight: this.element[0].style.maxHeight,
        height: this.element[0].style.height
      }, this.originalPosition = {
        parent: this.element.parent(),
        index: this.element.parent().children().index(this.element)
      }, this.originalTitle = this.element.attr("title"), null == this.options.title && null != this.originalTitle && (this.options.title = this.originalTitle), this.options.disabled && (this.options.disabled = !1), this._createWrapper(), this.element.show().removeAttr("title").appendTo(this.uiDialog), this._addClass("ui-dialog-content", "ui-widget-content"), this._createTitlebar(), this._createButtonPane(), this.options.draggable && t.fn.draggable && this._makeDraggable(), this.options.resizable && t.fn.resizable && this._makeResizable(), this._isOpen = !1, this._trackFocus();
    },
    _init: function () {
      this.options.autoOpen && this.open();
    },
    _appendTo: function () {
      var e = this.options.appendTo;
      return e && (e.jquery || e.nodeType) ? t(e) : this.document.find(e || "body").eq(0);
    },
    _destroy: function () {
      var t,
          e = this.originalPosition;
      this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().css(this.originalCss).detach(), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), t = e.parent.children().eq(e.index), t.length && t[0] !== this.element[0] ? t.before(this.element) : e.parent.append(this.element);
    },
    widget: function () {
      return this.uiDialog;
    },
    disable: t.noop,
    enable: t.noop,
    close: function (e) {
      var i = this;
      this._isOpen && this._trigger("beforeClose", e) !== !1 && (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), this.opener.filter(":focusable").trigger("focus").length || t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])), this._hide(this.uiDialog, this.options.hide, function () {
        i._trigger("close", e);
      }));
    },
    isOpen: function () {
      return this._isOpen;
    },
    moveToTop: function () {
      this._moveToTop();
    },
    _moveToTop: function (e, i) {
      var s = !1,
          n = this.uiDialog.siblings(".ui-front:visible").map(function () {
        return +t(this).css("z-index");
      }).get(),
          o = Math.max.apply(null, n);
      return o >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", o + 1), s = !0), s && !i && this._trigger("focus", e), s;
    },
    open: function () {
      var e = this;
      return this._isOpen ? (this._moveToTop() && this._focusTabbable(), void 0) : (this._isOpen = !0, this.opener = t(t.ui.safeActiveElement(this.document[0])), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function () {
        e._focusTabbable(), e._trigger("focus");
      }), this._makeFocusTarget(), this._trigger("open"), void 0);
    },
    _focusTabbable: function () {
      var t = this._focusedElement;
      t || (t = this.element.find("[autofocus]")), t.length || (t = this.element.find(":tabbable")), t.length || (t = this.uiDialogButtonPane.find(":tabbable")), t.length || (t = this.uiDialogTitlebarClose.filter(":tabbable")), t.length || (t = this.uiDialog), t.eq(0).trigger("focus");
    },
    _keepFocus: function (e) {
      function i() {
        var e = t.ui.safeActiveElement(this.document[0]),
            i = this.uiDialog[0] === e || t.contains(this.uiDialog[0], e);
        i || this._focusTabbable();
      }

      e.preventDefault(), i.call(this), this._delay(i);
    },
    _createWrapper: function () {
      this.uiDialog = t("<div>").hide().attr({
        tabIndex: -1,
        role: "dialog"
      }).appendTo(this._appendTo()), this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front"), this._on(this.uiDialog, {
        keydown: function (e) {
          if (this.options.closeOnEscape && !e.isDefaultPrevented() && e.keyCode && e.keyCode === t.ui.keyCode.ESCAPE) return e.preventDefault(), this.close(e), void 0;

          if (e.keyCode === t.ui.keyCode.TAB && !e.isDefaultPrevented()) {
            var i = this.uiDialog.find(":tabbable"),
                s = i.filter(":first"),
                n = i.filter(":last");
            e.target !== n[0] && e.target !== this.uiDialog[0] || e.shiftKey ? e.target !== s[0] && e.target !== this.uiDialog[0] || !e.shiftKey || (this._delay(function () {
              n.trigger("focus");
            }), e.preventDefault()) : (this._delay(function () {
              s.trigger("focus");
            }), e.preventDefault());
          }
        },
        mousedown: function (t) {
          this._moveToTop(t) && this._focusTabbable();
        }
      }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({
        "aria-describedby": this.element.uniqueId().attr("id")
      });
    },
    _createTitlebar: function () {
      var e;
      this.uiDialogTitlebar = t("<div>"), this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix"), this._on(this.uiDialogTitlebar, {
        mousedown: function (e) {
          t(e.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.trigger("focus");
        }
      }), this.uiDialogTitlebarClose = t("<button type='button'></button>").button({
        label: t("<a>").text(this.options.closeText).html(),
        icon: "ui-icon-closethick",
        showLabel: !1
      }).appendTo(this.uiDialogTitlebar), this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close"), this._on(this.uiDialogTitlebarClose, {
        click: function (t) {
          t.preventDefault(), this.close(t);
        }
      }), e = t("<span>").uniqueId().prependTo(this.uiDialogTitlebar), this._addClass(e, "ui-dialog-title"), this._title(e), this.uiDialogTitlebar.prependTo(this.uiDialog), this.uiDialog.attr({
        "aria-labelledby": e.attr("id")
      });
    },
    _title: function (t) {
      this.options.title ? t.text(this.options.title) : t.html("&#160;");
    },
    _createButtonPane: function () {
      this.uiDialogButtonPane = t("<div>"), this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix"), this.uiButtonSet = t("<div>").appendTo(this.uiDialogButtonPane), this._addClass(this.uiButtonSet, "ui-dialog-buttonset"), this._createButtons();
    },
    _createButtons: function () {
      var e = this,
          i = this.options.buttons;
      return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), t.isEmptyObject(i) || t.isArray(i) && !i.length ? (this._removeClass(this.uiDialog, "ui-dialog-buttons"), void 0) : (t.each(i, function (i, s) {
        var n, o;
        s = t.isFunction(s) ? {
          click: s,
          text: i
        } : s, s = t.extend({
          type: "button"
        }, s), n = s.click, o = {
          icon: s.icon,
          iconPosition: s.iconPosition,
          showLabel: s.showLabel,
          icons: s.icons,
          text: s.text
        }, delete s.click, delete s.icon, delete s.iconPosition, delete s.showLabel, delete s.icons, "boolean" == typeof s.text && delete s.text, t("<button></button>", s).button(o).appendTo(e.uiButtonSet).on("click", function () {
          n.apply(e.element[0], arguments);
        });
      }), this._addClass(this.uiDialog, "ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog), void 0);
    },
    _makeDraggable: function () {
      function e(t) {
        return {
          position: t.position,
          offset: t.offset
        };
      }

      var i = this,
          s = this.options;
      this.uiDialog.draggable({
        cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
        handle: ".ui-dialog-titlebar",
        containment: "document",
        start: function (s, n) {
          i._addClass(t(this), "ui-dialog-dragging"), i._blockFrames(), i._trigger("dragStart", s, e(n));
        },
        drag: function (t, s) {
          i._trigger("drag", t, e(s));
        },
        stop: function (n, o) {
          var a = o.offset.left - i.document.scrollLeft(),
              r = o.offset.top - i.document.scrollTop();
          s.position = {
            my: "left top",
            at: "left" + (a >= 0 ? "+" : "") + a + " " + "top" + (r >= 0 ? "+" : "") + r,
            of: i.window
          }, i._removeClass(t(this), "ui-dialog-dragging"), i._unblockFrames(), i._trigger("dragStop", n, e(o));
        }
      });
    },
    _makeResizable: function () {
      function e(t) {
        return {
          originalPosition: t.originalPosition,
          originalSize: t.originalSize,
          position: t.position,
          size: t.size
        };
      }

      var i = this,
          s = this.options,
          n = s.resizable,
          o = this.uiDialog.css("position"),
          a = "string" == typeof n ? n : "n,e,s,w,se,sw,ne,nw";
      this.uiDialog.resizable({
        cancel: ".ui-dialog-content",
        containment: "document",
        alsoResize: this.element,
        maxWidth: s.maxWidth,
        maxHeight: s.maxHeight,
        minWidth: s.minWidth,
        minHeight: this._minHeight(),
        handles: a,
        start: function (s, n) {
          i._addClass(t(this), "ui-dialog-resizing"), i._blockFrames(), i._trigger("resizeStart", s, e(n));
        },
        resize: function (t, s) {
          i._trigger("resize", t, e(s));
        },
        stop: function (n, o) {
          var a = i.uiDialog.offset(),
              r = a.left - i.document.scrollLeft(),
              h = a.top - i.document.scrollTop();
          s.height = i.uiDialog.height(), s.width = i.uiDialog.width(), s.position = {
            my: "left top",
            at: "left" + (r >= 0 ? "+" : "") + r + " " + "top" + (h >= 0 ? "+" : "") + h,
            of: i.window
          }, i._removeClass(t(this), "ui-dialog-resizing"), i._unblockFrames(), i._trigger("resizeStop", n, e(o));
        }
      }).css("position", o);
    },
    _trackFocus: function () {
      this._on(this.widget(), {
        focusin: function (e) {
          this._makeFocusTarget(), this._focusedElement = t(e.target);
        }
      });
    },
    _makeFocusTarget: function () {
      this._untrackInstance(), this._trackingInstances().unshift(this);
    },
    _untrackInstance: function () {
      var e = this._trackingInstances(),
          i = t.inArray(this, e);

      -1 !== i && e.splice(i, 1);
    },
    _trackingInstances: function () {
      var t = this.document.data("ui-dialog-instances");
      return t || (t = [], this.document.data("ui-dialog-instances", t)), t;
    },
    _minHeight: function () {
      var t = this.options;
      return "auto" === t.height ? t.minHeight : Math.min(t.minHeight, t.height);
    },
    _position: function () {
      var t = this.uiDialog.is(":visible");
      t || this.uiDialog.show(), this.uiDialog.position(this.options.position), t || this.uiDialog.hide();
    },
    _setOptions: function (e) {
      var i = this,
          s = !1,
          n = {};
      t.each(e, function (t, e) {
        i._setOption(t, e), t in i.sizeRelatedOptions && (s = !0), t in i.resizableRelatedOptions && (n[t] = e);
      }), s && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", n);
    },
    _setOption: function (e, i) {
      var s,
          n,
          o = this.uiDialog;
      "disabled" !== e && (this._super(e, i), "appendTo" === e && this.uiDialog.appendTo(this._appendTo()), "buttons" === e && this._createButtons(), "closeText" === e && this.uiDialogTitlebarClose.button({
        label: t("<a>").text("" + this.options.closeText).html()
      }), "draggable" === e && (s = o.is(":data(ui-draggable)"), s && !i && o.draggable("destroy"), !s && i && this._makeDraggable()), "position" === e && this._position(), "resizable" === e && (n = o.is(":data(ui-resizable)"), n && !i && o.resizable("destroy"), n && "string" == typeof i && o.resizable("option", "handles", i), n || i === !1 || this._makeResizable()), "title" === e && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")));
    },
    _size: function () {
      var t,
          e,
          i,
          s = this.options;
      this.element.show().css({
        width: "auto",
        minHeight: 0,
        maxHeight: "none",
        height: 0
      }), s.minWidth > s.width && (s.width = s.minWidth), t = this.uiDialog.css({
        height: "auto",
        width: s.width
      }).outerHeight(), e = Math.max(0, s.minHeight - t), i = "number" == typeof s.maxHeight ? Math.max(0, s.maxHeight - t) : "none", "auto" === s.height ? this.element.css({
        minHeight: e,
        maxHeight: i,
        height: "auto"
      }) : this.element.height(Math.max(0, s.height - t)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight());
    },
    _blockFrames: function () {
      this.iframeBlocks = this.document.find("iframe").map(function () {
        var e = t(this);
        return t("<div>").css({
          position: "absolute",
          width: e.outerWidth(),
          height: e.outerHeight()
        }).appendTo(e.parent()).offset(e.offset())[0];
      });
    },
    _unblockFrames: function () {
      this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
    },
    _allowInteraction: function (e) {
      return t(e.target).closest(".ui-dialog").length ? !0 : !!t(e.target).closest(".ui-datepicker").length;
    },
    _createOverlay: function () {
      if (this.options.modal) {
        var e = !0;
        this._delay(function () {
          e = !1;
        }), this.document.data("ui-dialog-overlays") || this._on(this.document, {
          focusin: function (t) {
            e || this._allowInteraction(t) || (t.preventDefault(), this._trackingInstances()[0]._focusTabbable());
          }
        }), this.overlay = t("<div>").appendTo(this._appendTo()), this._addClass(this.overlay, null, "ui-widget-overlay ui-front"), this._on(this.overlay, {
          mousedown: "_keepFocus"
        }), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
      }
    },
    _destroyOverlay: function () {
      if (this.options.modal && this.overlay) {
        var t = this.document.data("ui-dialog-overlays") - 1;
        t ? this.document.data("ui-dialog-overlays", t) : (this._off(this.document, "focusin"), this.document.removeData("ui-dialog-overlays")), this.overlay.remove(), this.overlay = null;
      }
    }
  }), t.uiBackCompat !== !1 && t.widget("ui.dialog", t.ui.dialog, {
    options: {
      dialogClass: ""
    },
    _createWrapper: function () {
      this._super(), this.uiDialog.addClass(this.options.dialogClass);
    },
    _setOption: function (t, e) {
      "dialogClass" === t && this.uiDialog.removeClass(this.options.dialogClass).addClass(e), this._superApply(arguments);
    }
  }), t.ui.dialog, t.widget("ui.droppable", {
    version: "1.12.1",
    widgetEventPrefix: "drop",
    options: {
      accept: "*",
      addClasses: !0,
      greedy: !1,
      scope: "default",
      tolerance: "intersect",
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null
    },
    _create: function () {
      var e,
          i = this.options,
          s = i.accept;
      this.isover = !1, this.isout = !0, this.accept = t.isFunction(s) ? s : function (t) {
        return t.is(s);
      }, this.proportions = function () {
        return arguments.length ? (e = arguments[0], void 0) : e ? e : e = {
          width: this.element[0].offsetWidth,
          height: this.element[0].offsetHeight
        };
      }, this._addToManager(i.scope), i.addClasses && this._addClass("ui-droppable");
    },
    _addToManager: function (e) {
      t.ui.ddmanager.droppables[e] = t.ui.ddmanager.droppables[e] || [], t.ui.ddmanager.droppables[e].push(this);
    },
    _splice: function (t) {
      for (var e = 0; t.length > e; e++) t[e] === this && t.splice(e, 1);
    },
    _destroy: function () {
      var e = t.ui.ddmanager.droppables[this.options.scope];

      this._splice(e);
    },
    _setOption: function (e, i) {
      if ("accept" === e) this.accept = t.isFunction(i) ? i : function (t) {
        return t.is(i);
      };else if ("scope" === e) {
        var s = t.ui.ddmanager.droppables[this.options.scope];
        this._splice(s), this._addToManager(i);
      }

      this._super(e, i);
    },
    _activate: function (e) {
      var i = t.ui.ddmanager.current;
      this._addActiveClass(), i && this._trigger("activate", e, this.ui(i));
    },
    _deactivate: function (e) {
      var i = t.ui.ddmanager.current;
      this._removeActiveClass(), i && this._trigger("deactivate", e, this.ui(i));
    },
    _over: function (e) {
      var i = t.ui.ddmanager.current;
      i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this._addHoverClass(), this._trigger("over", e, this.ui(i)));
    },
    _out: function (e) {
      var i = t.ui.ddmanager.current;
      i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this._removeHoverClass(), this._trigger("out", e, this.ui(i)));
    },
    _drop: function (e, i) {
      var s = i || t.ui.ddmanager.current,
          n = !1;
      return s && (s.currentItem || s.element)[0] !== this.element[0] ? (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
        var i = t(this).droppable("instance");
        return i.options.greedy && !i.options.disabled && i.options.scope === s.options.scope && i.accept.call(i.element[0], s.currentItem || s.element) && v(s, t.extend(i, {
          offset: i.element.offset()
        }), i.options.tolerance, e) ? (n = !0, !1) : void 0;
      }), n ? !1 : this.accept.call(this.element[0], s.currentItem || s.element) ? (this._removeActiveClass(), this._removeHoverClass(), this._trigger("drop", e, this.ui(s)), this.element) : !1) : !1;
    },
    ui: function (t) {
      return {
        draggable: t.currentItem || t.element,
        helper: t.helper,
        position: t.position,
        offset: t.positionAbs
      };
    },
    _addHoverClass: function () {
      this._addClass("ui-droppable-hover");
    },
    _removeHoverClass: function () {
      this._removeClass("ui-droppable-hover");
    },
    _addActiveClass: function () {
      this._addClass("ui-droppable-active");
    },
    _removeActiveClass: function () {
      this._removeClass("ui-droppable-active");
    }
  });

  var v = t.ui.intersect = function () {
    function t(t, e, i) {
      return t >= e && e + i > t;
    }

    return function (e, i, s, n) {
      if (!i.offset) return !1;
      var o = (e.positionAbs || e.position.absolute).left + e.margins.left,
          a = (e.positionAbs || e.position.absolute).top + e.margins.top,
          r = o + e.helperProportions.width,
          h = a + e.helperProportions.height,
          l = i.offset.left,
          c = i.offset.top,
          u = l + i.proportions().width,
          d = c + i.proportions().height;

      switch (s) {
        case "fit":
          return o >= l && u >= r && a >= c && d >= h;

        case "intersect":
          return o + e.helperProportions.width / 2 > l && u > r - e.helperProportions.width / 2 && a + e.helperProportions.height / 2 > c && d > h - e.helperProportions.height / 2;

        case "pointer":
          return t(n.pageY, c, i.proportions().height) && t(n.pageX, l, i.proportions().width);

        case "touch":
          return (a >= c && d >= a || h >= c && d >= h || c > a && h > d) && (o >= l && u >= o || r >= l && u >= r || l > o && r > u);

        default:
          return !1;
      }
    };
  }();

  t.ui.ddmanager = {
    current: null,
    droppables: {
      "default": []
    },
    prepareOffsets: function (e, i) {
      var s,
          n,
          o = t.ui.ddmanager.droppables[e.options.scope] || [],
          a = i ? i.type : null,
          r = (e.currentItem || e.element).find(":data(ui-droppable)").addBack();

      t: for (s = 0; o.length > s; s++) if (!(o[s].options.disabled || e && !o[s].accept.call(o[s].element[0], e.currentItem || e.element))) {
        for (n = 0; r.length > n; n++) if (r[n] === o[s].element[0]) {
          o[s].proportions().height = 0;
          continue t;
        }

        o[s].visible = "none" !== o[s].element.css("display"), o[s].visible && ("mousedown" === a && o[s]._activate.call(o[s], i), o[s].offset = o[s].element.offset(), o[s].proportions({
          width: o[s].element[0].offsetWidth,
          height: o[s].element[0].offsetHeight
        }));
      }
    },
    drop: function (e, i) {
      var s = !1;
      return t.each((t.ui.ddmanager.droppables[e.options.scope] || []).slice(), function () {
        this.options && (!this.options.disabled && this.visible && v(e, this, this.options.tolerance, i) && (s = this._drop.call(this, i) || s), !this.options.disabled && this.visible && this.accept.call(this.element[0], e.currentItem || e.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, i)));
      }), s;
    },
    dragStart: function (e, i) {
      e.element.parentsUntil("body").on("scroll.droppable", function () {
        e.options.refreshPositions || t.ui.ddmanager.prepareOffsets(e, i);
      });
    },
    drag: function (e, i) {
      e.options.refreshPositions && t.ui.ddmanager.prepareOffsets(e, i), t.each(t.ui.ddmanager.droppables[e.options.scope] || [], function () {
        if (!this.options.disabled && !this.greedyChild && this.visible) {
          var s,
              n,
              o,
              a = v(e, this, this.options.tolerance, i),
              r = !a && this.isover ? "isout" : a && !this.isover ? "isover" : null;
          r && (this.options.greedy && (n = this.options.scope, o = this.element.parents(":data(ui-droppable)").filter(function () {
            return t(this).droppable("instance").options.scope === n;
          }), o.length && (s = t(o[0]).droppable("instance"), s.greedyChild = "isover" === r)), s && "isover" === r && (s.isover = !1, s.isout = !0, s._out.call(s, i)), this[r] = !0, this["isout" === r ? "isover" : "isout"] = !1, this["isover" === r ? "_over" : "_out"].call(this, i), s && "isout" === r && (s.isout = !1, s.isover = !0, s._over.call(s, i)));
        }
      });
    },
    dragStop: function (e, i) {
      e.element.parentsUntil("body").off("scroll.droppable"), e.options.refreshPositions || t.ui.ddmanager.prepareOffsets(e, i);
    }
  }, t.uiBackCompat !== !1 && t.widget("ui.droppable", t.ui.droppable, {
    options: {
      hoverClass: !1,
      activeClass: !1
    },
    _addActiveClass: function () {
      this._super(), this.options.activeClass && this.element.addClass(this.options.activeClass);
    },
    _removeActiveClass: function () {
      this._super(), this.options.activeClass && this.element.removeClass(this.options.activeClass);
    },
    _addHoverClass: function () {
      this._super(), this.options.hoverClass && this.element.addClass(this.options.hoverClass);
    },
    _removeHoverClass: function () {
      this._super(), this.options.hoverClass && this.element.removeClass(this.options.hoverClass);
    }
  }), t.ui.droppable, t.widget("ui.progressbar", {
    version: "1.12.1",
    options: {
      classes: {
        "ui-progressbar": "ui-corner-all",
        "ui-progressbar-value": "ui-corner-left",
        "ui-progressbar-complete": "ui-corner-right"
      },
      max: 100,
      value: 0,
      change: null,
      complete: null
    },
    min: 0,
    _create: function () {
      this.oldValue = this.options.value = this._constrainedValue(), this.element.attr({
        role: "progressbar",
        "aria-valuemin": this.min
      }), this._addClass("ui-progressbar", "ui-widget ui-widget-content"), this.valueDiv = t("<div>").appendTo(this.element), this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header"), this._refreshValue();
    },
    _destroy: function () {
      this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"), this.valueDiv.remove();
    },
    value: function (t) {
      return void 0 === t ? this.options.value : (this.options.value = this._constrainedValue(t), this._refreshValue(), void 0);
    },
    _constrainedValue: function (t) {
      return void 0 === t && (t = this.options.value), this.indeterminate = t === !1, "number" != typeof t && (t = 0), this.indeterminate ? !1 : Math.min(this.options.max, Math.max(this.min, t));
    },
    _setOptions: function (t) {
      var e = t.value;
      delete t.value, this._super(t), this.options.value = this._constrainedValue(e), this._refreshValue();
    },
    _setOption: function (t, e) {
      "max" === t && (e = Math.max(this.min, e)), this._super(t, e);
    },
    _setOptionDisabled: function (t) {
      this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t);
    },
    _percentage: function () {
      return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
    },
    _refreshValue: function () {
      var e = this.options.value,
          i = this._percentage();

      this.valueDiv.toggle(this.indeterminate || e > this.min).width(i.toFixed(0) + "%"), this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, e === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = t("<div>").appendTo(this.valueDiv), this._addClass(this.overlayDiv, "ui-progressbar-overlay"))) : (this.element.attr({
        "aria-valuemax": this.options.max,
        "aria-valuenow": e
      }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== e && (this.oldValue = e, this._trigger("change")), e === this.options.max && this._trigger("complete");
    }
  }), t.widget("ui.selectable", t.ui.mouse, {
    version: "1.12.1",
    options: {
      appendTo: "body",
      autoRefresh: !0,
      distance: 0,
      filter: "*",
      tolerance: "touch",
      selected: null,
      selecting: null,
      start: null,
      stop: null,
      unselected: null,
      unselecting: null
    },
    _create: function () {
      var e = this;
      this._addClass("ui-selectable"), this.dragged = !1, this.refresh = function () {
        e.elementPos = t(e.element[0]).offset(), e.selectees = t(e.options.filter, e.element[0]), e._addClass(e.selectees, "ui-selectee"), e.selectees.each(function () {
          var i = t(this),
              s = i.offset(),
              n = {
            left: s.left - e.elementPos.left,
            top: s.top - e.elementPos.top
          };
          t.data(this, "selectable-item", {
            element: this,
            $element: i,
            left: n.left,
            top: n.top,
            right: n.left + i.outerWidth(),
            bottom: n.top + i.outerHeight(),
            startselected: !1,
            selected: i.hasClass("ui-selected"),
            selecting: i.hasClass("ui-selecting"),
            unselecting: i.hasClass("ui-unselecting")
          });
        });
      }, this.refresh(), this._mouseInit(), this.helper = t("<div>"), this._addClass(this.helper, "ui-selectable-helper");
    },
    _destroy: function () {
      this.selectees.removeData("selectable-item"), this._mouseDestroy();
    },
    _mouseStart: function (e) {
      var i = this,
          s = this.options;
      this.opos = [e.pageX, e.pageY], this.elementPos = t(this.element[0]).offset(), this.options.disabled || (this.selectees = t(s.filter, this.element[0]), this._trigger("start", e), t(s.appendTo).append(this.helper), this.helper.css({
        left: e.pageX,
        top: e.pageY,
        width: 0,
        height: 0
      }), s.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
        var s = t.data(this, "selectable-item");
        s.startselected = !0, e.metaKey || e.ctrlKey || (i._removeClass(s.$element, "ui-selected"), s.selected = !1, i._addClass(s.$element, "ui-unselecting"), s.unselecting = !0, i._trigger("unselecting", e, {
          unselecting: s.element
        }));
      }), t(e.target).parents().addBack().each(function () {
        var s,
            n = t.data(this, "selectable-item");
        return n ? (s = !e.metaKey && !e.ctrlKey || !n.$element.hasClass("ui-selected"), i._removeClass(n.$element, s ? "ui-unselecting" : "ui-selected")._addClass(n.$element, s ? "ui-selecting" : "ui-unselecting"), n.unselecting = !s, n.selecting = s, n.selected = s, s ? i._trigger("selecting", e, {
          selecting: n.element
        }) : i._trigger("unselecting", e, {
          unselecting: n.element
        }), !1) : void 0;
      }));
    },
    _mouseDrag: function (e) {
      if (this.dragged = !0, !this.options.disabled) {
        var i,
            s = this,
            n = this.options,
            o = this.opos[0],
            a = this.opos[1],
            r = e.pageX,
            h = e.pageY;
        return o > r && (i = r, r = o, o = i), a > h && (i = h, h = a, a = i), this.helper.css({
          left: o,
          top: a,
          width: r - o,
          height: h - a
        }), this.selectees.each(function () {
          var i = t.data(this, "selectable-item"),
              l = !1,
              c = {};
          i && i.element !== s.element[0] && (c.left = i.left + s.elementPos.left, c.right = i.right + s.elementPos.left, c.top = i.top + s.elementPos.top, c.bottom = i.bottom + s.elementPos.top, "touch" === n.tolerance ? l = !(c.left > r || o > c.right || c.top > h || a > c.bottom) : "fit" === n.tolerance && (l = c.left > o && r > c.right && c.top > a && h > c.bottom), l ? (i.selected && (s._removeClass(i.$element, "ui-selected"), i.selected = !1), i.unselecting && (s._removeClass(i.$element, "ui-unselecting"), i.unselecting = !1), i.selecting || (s._addClass(i.$element, "ui-selecting"), i.selecting = !0, s._trigger("selecting", e, {
            selecting: i.element
          }))) : (i.selecting && ((e.metaKey || e.ctrlKey) && i.startselected ? (s._removeClass(i.$element, "ui-selecting"), i.selecting = !1, s._addClass(i.$element, "ui-selected"), i.selected = !0) : (s._removeClass(i.$element, "ui-selecting"), i.selecting = !1, i.startselected && (s._addClass(i.$element, "ui-unselecting"), i.unselecting = !0), s._trigger("unselecting", e, {
            unselecting: i.element
          }))), i.selected && (e.metaKey || e.ctrlKey || i.startselected || (s._removeClass(i.$element, "ui-selected"), i.selected = !1, s._addClass(i.$element, "ui-unselecting"), i.unselecting = !0, s._trigger("unselecting", e, {
            unselecting: i.element
          })))));
        }), !1;
      }
    },
    _mouseStop: function (e) {
      var i = this;
      return this.dragged = !1, t(".ui-unselecting", this.element[0]).each(function () {
        var s = t.data(this, "selectable-item");
        i._removeClass(s.$element, "ui-unselecting"), s.unselecting = !1, s.startselected = !1, i._trigger("unselected", e, {
          unselected: s.element
        });
      }), t(".ui-selecting", this.element[0]).each(function () {
        var s = t.data(this, "selectable-item");
        i._removeClass(s.$element, "ui-selecting")._addClass(s.$element, "ui-selected"), s.selecting = !1, s.selected = !0, s.startselected = !0, i._trigger("selected", e, {
          selected: s.element
        });
      }), this._trigger("stop", e), this.helper.remove(), !1;
    }
  }), t.widget("ui.selectmenu", [t.ui.formResetMixin, {
    version: "1.12.1",
    defaultElement: "<select>",
    options: {
      appendTo: null,
      classes: {
        "ui-selectmenu-button-open": "ui-corner-top",
        "ui-selectmenu-button-closed": "ui-corner-all"
      },
      disabled: null,
      icons: {
        button: "ui-icon-triangle-1-s"
      },
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      width: !1,
      change: null,
      close: null,
      focus: null,
      open: null,
      select: null
    },
    _create: function () {
      var e = this.element.uniqueId().attr("id");
      this.ids = {
        element: e,
        button: e + "-button",
        menu: e + "-menu"
      }, this._drawButton(), this._drawMenu(), this._bindFormResetHandler(), this._rendered = !1, this.menuItems = t();
    },
    _drawButton: function () {
      var e,
          i = this,
          s = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);

      this.labels = this.element.labels().attr("for", this.ids.button), this._on(this.labels, {
        click: function (t) {
          this.button.focus(), t.preventDefault();
        }
      }), this.element.hide(), this.button = t("<span>", {
        tabindex: this.options.disabled ? -1 : 0,
        id: this.ids.button,
        role: "combobox",
        "aria-expanded": "false",
        "aria-autocomplete": "list",
        "aria-owns": this.ids.menu,
        "aria-haspopup": "true",
        title: this.element.attr("title")
      }).insertAfter(this.element), this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget"), e = t("<span>").appendTo(this.button), this._addClass(e, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button), this.buttonItem = this._renderButtonItem(s).appendTo(this.button), this.options.width !== !1 && this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function () {
        i._rendered || i._refreshMenu();
      });
    },
    _drawMenu: function () {
      var e = this;
      this.menu = t("<ul>", {
        "aria-hidden": "true",
        "aria-labelledby": this.ids.button,
        id: this.ids.menu
      }), this.menuWrap = t("<div>").append(this.menu), this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front"), this.menuWrap.appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
        classes: {
          "ui-menu": "ui-corner-bottom"
        },
        role: "listbox",
        select: function (t, i) {
          t.preventDefault(), e._setSelection(), e._select(i.item.data("ui-selectmenu-item"), t);
        },
        focus: function (t, i) {
          var s = i.item.data("ui-selectmenu-item");
          null != e.focusIndex && s.index !== e.focusIndex && (e._trigger("focus", t, {
            item: s
          }), e.isOpen || e._select(s, t)), e.focusIndex = s.index, e.button.attr("aria-activedescendant", e.menuItems.eq(s.index).attr("id"));
        }
      }).menu("instance"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function () {
        return !1;
      }, this.menuInstance._isDivider = function () {
        return !1;
      };
    },
    refresh: function () {
      this._refreshMenu(), this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {})), null === this.options.width && this._resizeButton();
    },
    _refreshMenu: function () {
      var t,
          e = this.element.find("option");
      this.menu.empty(), this._parseOptions(e), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"), this._rendered = !0, e.length && (t = this._getSelectedItem(), this.menuInstance.focus(null, t), this._setAria(t.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")));
    },
    open: function (t) {
      this.options.disabled || (this._rendered ? (this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.menuItems.length && (this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", t)));
    },
    _position: function () {
      this.menuWrap.position(t.extend({
        of: this.button
      }, this.options.position));
    },
    close: function (t) {
      this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", t));
    },
    widget: function () {
      return this.button;
    },
    menuWidget: function () {
      return this.menu;
    },
    _renderButtonItem: function (e) {
      var i = t("<span>");
      return this._setText(i, e.label), this._addClass(i, "ui-selectmenu-text"), i;
    },
    _renderMenu: function (e, i) {
      var s = this,
          n = "";
      t.each(i, function (i, o) {
        var a;
        o.optgroup !== n && (a = t("<li>", {
          text: o.optgroup
        }), s._addClass(a, "ui-selectmenu-optgroup", "ui-menu-divider" + (o.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : "")), a.appendTo(e), n = o.optgroup), s._renderItemData(e, o);
      });
    },
    _renderItemData: function (t, e) {
      return this._renderItem(t, e).data("ui-selectmenu-item", e);
    },
    _renderItem: function (e, i) {
      var s = t("<li>"),
          n = t("<div>", {
        title: i.element.attr("title")
      });
      return i.disabled && this._addClass(s, null, "ui-state-disabled"), this._setText(n, i.label), s.append(n).appendTo(e);
    },
    _setText: function (t, e) {
      e ? t.text(e) : t.html("&#160;");
    },
    _move: function (t, e) {
      var i,
          s,
          n = ".ui-menu-item";
      this.isOpen ? i = this.menuItems.eq(this.focusIndex).parent("li") : (i = this.menuItems.eq(this.element[0].selectedIndex).parent("li"), n += ":not(.ui-state-disabled)"), s = "first" === t || "last" === t ? i["first" === t ? "prevAll" : "nextAll"](n).eq(-1) : i[t + "All"](n).eq(0), s.length && this.menuInstance.focus(e, s);
    },
    _getSelectedItem: function () {
      return this.menuItems.eq(this.element[0].selectedIndex).parent("li");
    },
    _toggle: function (t) {
      this[this.isOpen ? "close" : "open"](t);
    },
    _setSelection: function () {
      var t;
      this.range && (window.getSelection ? (t = window.getSelection(), t.removeAllRanges(), t.addRange(this.range)) : this.range.select(), this.button.focus());
    },
    _documentClick: {
      mousedown: function (e) {
        this.isOpen && (t(e.target).closest(".ui-selectmenu-menu, #" + t.ui.escapeSelector(this.ids.button)).length || this.close(e));
      }
    },
    _buttonEvents: {
      mousedown: function () {
        var t;
        window.getSelection ? (t = window.getSelection(), t.rangeCount && (this.range = t.getRangeAt(0))) : this.range = document.selection.createRange();
      },
      click: function (t) {
        this._setSelection(), this._toggle(t);
      },
      keydown: function (e) {
        var i = !0;

        switch (e.keyCode) {
          case t.ui.keyCode.TAB:
          case t.ui.keyCode.ESCAPE:
            this.close(e), i = !1;
            break;

          case t.ui.keyCode.ENTER:
            this.isOpen && this._selectFocusedItem(e);
            break;

          case t.ui.keyCode.UP:
            e.altKey ? this._toggle(e) : this._move("prev", e);
            break;

          case t.ui.keyCode.DOWN:
            e.altKey ? this._toggle(e) : this._move("next", e);
            break;

          case t.ui.keyCode.SPACE:
            this.isOpen ? this._selectFocusedItem(e) : this._toggle(e);
            break;

          case t.ui.keyCode.LEFT:
            this._move("prev", e);

            break;

          case t.ui.keyCode.RIGHT:
            this._move("next", e);

            break;

          case t.ui.keyCode.HOME:
          case t.ui.keyCode.PAGE_UP:
            this._move("first", e);

            break;

          case t.ui.keyCode.END:
          case t.ui.keyCode.PAGE_DOWN:
            this._move("last", e);

            break;

          default:
            this.menu.trigger(e), i = !1;
        }

        i && e.preventDefault();
      }
    },
    _selectFocusedItem: function (t) {
      var e = this.menuItems.eq(this.focusIndex).parent("li");
      e.hasClass("ui-state-disabled") || this._select(e.data("ui-selectmenu-item"), t);
    },
    _select: function (t, e) {
      var i = this.element[0].selectedIndex;
      this.element[0].selectedIndex = t.index, this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(t)), this._setAria(t), this._trigger("select", e, {
        item: t
      }), t.index !== i && this._trigger("change", e, {
        item: t
      }), this.close(e);
    },
    _setAria: function (t) {
      var e = this.menuItems.eq(t.index).attr("id");
      this.button.attr({
        "aria-labelledby": e,
        "aria-activedescendant": e
      }), this.menu.attr("aria-activedescendant", e);
    },
    _setOption: function (t, e) {
      if ("icons" === t) {
        var i = this.button.find("span.ui-icon");

        this._removeClass(i, null, this.options.icons.button)._addClass(i, null, e.button);
      }

      this._super(t, e), "appendTo" === t && this.menuWrap.appendTo(this._appendTo()), "width" === t && this._resizeButton();
    },
    _setOptionDisabled: function (t) {
      this._super(t), this.menuInstance.option("disabled", t), this.button.attr("aria-disabled", t), this._toggleClass(this.button, null, "ui-state-disabled", t), this.element.prop("disabled", t), t ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0);
    },
    _appendTo: function () {
      var e = this.options.appendTo;
      return e && (e = e.jquery || e.nodeType ? t(e) : this.document.find(e).eq(0)), e && e[0] || (e = this.element.closest(".ui-front, dialog")), e.length || (e = this.document[0].body), e;
    },
    _toggleAttr: function () {
      this.button.attr("aria-expanded", this.isOpen), this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen), this.menu.attr("aria-hidden", !this.isOpen);
    },
    _resizeButton: function () {
      var t = this.options.width;
      return t === !1 ? (this.button.css("width", ""), void 0) : (null === t && (t = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(t), void 0);
    },
    _resizeMenu: function () {
      this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
    },
    _getCreateOptions: function () {
      var t = this._super();

      return t.disabled = this.element.prop("disabled"), t;
    },
    _parseOptions: function (e) {
      var i = this,
          s = [];
      e.each(function (e, n) {
        s.push(i._parseOption(t(n), e));
      }), this.items = s;
    },
    _parseOption: function (t, e) {
      var i = t.parent("optgroup");
      return {
        element: t,
        index: e,
        value: t.val(),
        label: t.text(),
        optgroup: i.attr("label") || "",
        disabled: i.prop("disabled") || t.prop("disabled")
      };
    },
    _destroy: function () {
      this._unbindFormResetHandler(), this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.labels.attr("for", this.ids.element);
    }
  }]), t.widget("ui.slider", t.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "slide",
    options: {
      animate: !1,
      classes: {
        "ui-slider": "ui-corner-all",
        "ui-slider-handle": "ui-corner-all",
        "ui-slider-range": "ui-corner-all ui-widget-header"
      },
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: !1,
      step: 1,
      value: 0,
      values: null,
      change: null,
      slide: null,
      start: null,
      stop: null
    },
    numPages: 5,
    _create: function () {
      this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1;
    },
    _refresh: function () {
      this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
    },
    _createHandles: function () {
      var e,
          i,
          s = this.options,
          n = this.element.find(".ui-slider-handle"),
          o = "<span tabindex='0'></span>",
          a = [];

      for (i = s.values && s.values.length || 1, n.length > i && (n.slice(i).remove(), n = n.slice(0, i)), e = n.length; i > e; e++) a.push(o);

      this.handles = n.add(t(a.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function (e) {
        t(this).data("ui-slider-handle-index", e).attr("tabIndex", 0);
      });
    },
    _createRange: function () {
      var e = this.options;
      e.range ? (e.range === !0 && (e.values ? e.values.length && 2 !== e.values.length ? e.values = [e.values[0], e.values[0]] : t.isArray(e.values) && (e.values = e.values.slice(0)) : e.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
        left: "",
        bottom: ""
      })) : (this.range = t("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), ("min" === e.range || "max" === e.range) && this._addClass(this.range, "ui-slider-range-" + e.range)) : (this.range && this.range.remove(), this.range = null);
    },
    _setupEvents: function () {
      this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles);
    },
    _destroy: function () {
      this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy();
    },
    _mouseCapture: function (e) {
      var i,
          s,
          n,
          o,
          a,
          r,
          h,
          l,
          c = this,
          u = this.options;
      return u.disabled ? !1 : (this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      }, this.elementOffset = this.element.offset(), i = {
        x: e.pageX,
        y: e.pageY
      }, s = this._normValueFromMouse(i), n = this._valueMax() - this._valueMin() + 1, this.handles.each(function (e) {
        var i = Math.abs(s - c.values(e));
        (n > i || n === i && (e === c._lastChangedValue || c.values(e) === u.min)) && (n = i, o = t(this), a = e);
      }), r = this._start(e, a), r === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = a, this._addClass(o, null, "ui-state-active"), o.trigger("focus"), h = o.offset(), l = !t(e.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = l ? {
        left: 0,
        top: 0
      } : {
        left: e.pageX - h.left - o.width() / 2,
        top: e.pageY - h.top - o.height() / 2 - (parseInt(o.css("borderTopWidth"), 10) || 0) - (parseInt(o.css("borderBottomWidth"), 10) || 0) + (parseInt(o.css("marginTop"), 10) || 0)
      }, this.handles.hasClass("ui-state-hover") || this._slide(e, a, s), this._animateOff = !0, !0));
    },
    _mouseStart: function () {
      return !0;
    },
    _mouseDrag: function (t) {
      var e = {
        x: t.pageX,
        y: t.pageY
      },
          i = this._normValueFromMouse(e);

      return this._slide(t, this._handleIndex, i), !1;
    },
    _mouseStop: function (t) {
      return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(t, this._handleIndex), this._change(t, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1;
    },
    _detectOrientation: function () {
      this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
    },
    _normValueFromMouse: function (t) {
      var e, i, s, n, o;
      return "horizontal" === this.orientation ? (e = this.elementSize.width, i = t.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e = this.elementSize.height, i = t.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), s = i / e, s > 1 && (s = 1), 0 > s && (s = 0), "vertical" === this.orientation && (s = 1 - s), n = this._valueMax() - this._valueMin(), o = this._valueMin() + s * n, this._trimAlignValue(o);
    },
    _uiHash: function (t, e, i) {
      var s = {
        handle: this.handles[t],
        handleIndex: t,
        value: void 0 !== e ? e : this.value()
      };
      return this._hasMultipleValues() && (s.value = void 0 !== e ? e : this.values(t), s.values = i || this.values()), s;
    },
    _hasMultipleValues: function () {
      return this.options.values && this.options.values.length;
    },
    _start: function (t, e) {
      return this._trigger("start", t, this._uiHash(e));
    },
    _slide: function (t, e, i) {
      var s,
          n,
          o = this.value(),
          a = this.values();
      this._hasMultipleValues() && (n = this.values(e ? 0 : 1), o = this.values(e), 2 === this.options.values.length && this.options.range === !0 && (i = 0 === e ? Math.min(n, i) : Math.max(n, i)), a[e] = i), i !== o && (s = this._trigger("slide", t, this._uiHash(e, i, a)), s !== !1 && (this._hasMultipleValues() ? this.values(e, i) : this.value(i)));
    },
    _stop: function (t, e) {
      this._trigger("stop", t, this._uiHash(e));
    },
    _change: function (t, e) {
      this._keySliding || this._mouseSliding || (this._lastChangedValue = e, this._trigger("change", t, this._uiHash(e)));
    },
    value: function (t) {
      return arguments.length ? (this.options.value = this._trimAlignValue(t), this._refreshValue(), this._change(null, 0), void 0) : this._value();
    },
    values: function (e, i) {
      var s, n, o;
      if (arguments.length > 1) return this.options.values[e] = this._trimAlignValue(i), this._refreshValue(), this._change(null, e), void 0;
      if (!arguments.length) return this._values();
      if (!t.isArray(arguments[0])) return this._hasMultipleValues() ? this._values(e) : this.value();

      for (s = this.options.values, n = arguments[0], o = 0; s.length > o; o += 1) s[o] = this._trimAlignValue(n[o]), this._change(null, o);

      this._refreshValue();
    },
    _setOption: function (e, i) {
      var s,
          n = 0;

      switch ("range" === e && this.options.range === !0 && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), t.isArray(this.options.values) && (n = this.options.values.length), this._super(e, i), e) {
        case "orientation":
          this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(i), this.handles.css("horizontal" === i ? "bottom" : "left", "");
          break;

        case "value":
          this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
          break;

        case "values":
          for (this._animateOff = !0, this._refreshValue(), s = n - 1; s >= 0; s--) this._change(null, s);

          this._animateOff = !1;
          break;

        case "step":
        case "min":
        case "max":
          this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
          break;

        case "range":
          this._animateOff = !0, this._refresh(), this._animateOff = !1;
      }
    },
    _setOptionDisabled: function (t) {
      this._super(t), this._toggleClass(null, "ui-state-disabled", !!t);
    },
    _value: function () {
      var t = this.options.value;
      return t = this._trimAlignValue(t);
    },
    _values: function (t) {
      var e, i, s;
      if (arguments.length) return e = this.options.values[t], e = this._trimAlignValue(e);

      if (this._hasMultipleValues()) {
        for (i = this.options.values.slice(), s = 0; i.length > s; s += 1) i[s] = this._trimAlignValue(i[s]);

        return i;
      }

      return [];
    },
    _trimAlignValue: function (t) {
      if (this._valueMin() >= t) return this._valueMin();
      if (t >= this._valueMax()) return this._valueMax();
      var e = this.options.step > 0 ? this.options.step : 1,
          i = (t - this._valueMin()) % e,
          s = t - i;
      return 2 * Math.abs(i) >= e && (s += i > 0 ? e : -e), parseFloat(s.toFixed(5));
    },
    _calculateNewMax: function () {
      var t = this.options.max,
          e = this._valueMin(),
          i = this.options.step,
          s = Math.round((t - e) / i) * i;

      t = s + e, t > this.options.max && (t -= i), this.max = parseFloat(t.toFixed(this._precision()));
    },
    _precision: function () {
      var t = this._precisionOf(this.options.step);

      return null !== this.options.min && (t = Math.max(t, this._precisionOf(this.options.min))), t;
    },
    _precisionOf: function (t) {
      var e = "" + t,
          i = e.indexOf(".");
      return -1 === i ? 0 : e.length - i - 1;
    },
    _valueMin: function () {
      return this.options.min;
    },
    _valueMax: function () {
      return this.max;
    },
    _refreshRange: function (t) {
      "vertical" === t && this.range.css({
        width: "",
        left: ""
      }), "horizontal" === t && this.range.css({
        height: "",
        bottom: ""
      });
    },
    _refreshValue: function () {
      var e,
          i,
          s,
          n,
          o,
          a = this.options.range,
          r = this.options,
          h = this,
          l = this._animateOff ? !1 : r.animate,
          c = {};
      this._hasMultipleValues() ? this.handles.each(function (s) {
        i = 100 * ((h.values(s) - h._valueMin()) / (h._valueMax() - h._valueMin())), c["horizontal" === h.orientation ? "left" : "bottom"] = i + "%", t(this).stop(1, 1)[l ? "animate" : "css"](c, r.animate), h.options.range === !0 && ("horizontal" === h.orientation ? (0 === s && h.range.stop(1, 1)[l ? "animate" : "css"]({
          left: i + "%"
        }, r.animate), 1 === s && h.range[l ? "animate" : "css"]({
          width: i - e + "%"
        }, {
          queue: !1,
          duration: r.animate
        })) : (0 === s && h.range.stop(1, 1)[l ? "animate" : "css"]({
          bottom: i + "%"
        }, r.animate), 1 === s && h.range[l ? "animate" : "css"]({
          height: i - e + "%"
        }, {
          queue: !1,
          duration: r.animate
        }))), e = i;
      }) : (s = this.value(), n = this._valueMin(), o = this._valueMax(), i = o !== n ? 100 * ((s - n) / (o - n)) : 0, c["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[l ? "animate" : "css"](c, r.animate), "min" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
        width: i + "%"
      }, r.animate), "max" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
        width: 100 - i + "%"
      }, r.animate), "min" === a && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
        height: i + "%"
      }, r.animate), "max" === a && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
        height: 100 - i + "%"
      }, r.animate));
    },
    _handleEvents: {
      keydown: function (e) {
        var i,
            s,
            n,
            o,
            a = t(e.target).data("ui-slider-handle-index");

        switch (e.keyCode) {
          case t.ui.keyCode.HOME:
          case t.ui.keyCode.END:
          case t.ui.keyCode.PAGE_UP:
          case t.ui.keyCode.PAGE_DOWN:
          case t.ui.keyCode.UP:
          case t.ui.keyCode.RIGHT:
          case t.ui.keyCode.DOWN:
          case t.ui.keyCode.LEFT:
            if (e.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(t(e.target), null, "ui-state-active"), i = this._start(e, a), i === !1)) return;
        }

        switch (o = this.options.step, s = n = this._hasMultipleValues() ? this.values(a) : this.value(), e.keyCode) {
          case t.ui.keyCode.HOME:
            n = this._valueMin();
            break;

          case t.ui.keyCode.END:
            n = this._valueMax();
            break;

          case t.ui.keyCode.PAGE_UP:
            n = this._trimAlignValue(s + (this._valueMax() - this._valueMin()) / this.numPages);
            break;

          case t.ui.keyCode.PAGE_DOWN:
            n = this._trimAlignValue(s - (this._valueMax() - this._valueMin()) / this.numPages);
            break;

          case t.ui.keyCode.UP:
          case t.ui.keyCode.RIGHT:
            if (s === this._valueMax()) return;
            n = this._trimAlignValue(s + o);
            break;

          case t.ui.keyCode.DOWN:
          case t.ui.keyCode.LEFT:
            if (s === this._valueMin()) return;
            n = this._trimAlignValue(s - o);
        }

        this._slide(e, a, n);
      },
      keyup: function (e) {
        var i = t(e.target).data("ui-slider-handle-index");
        this._keySliding && (this._keySliding = !1, this._stop(e, i), this._change(e, i), this._removeClass(t(e.target), null, "ui-state-active"));
      }
    }
  }), t.widget("ui.sortable", t.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "sort",
    ready: !1,
    options: {
      appendTo: "parent",
      axis: !1,
      connectWith: !1,
      containment: !1,
      cursor: "auto",
      cursorAt: !1,
      dropOnEmpty: !0,
      forcePlaceholderSize: !1,
      forceHelperSize: !1,
      grid: !1,
      handle: !1,
      helper: "original",
      items: "> *",
      opacity: !1,
      placeholder: !1,
      revert: !1,
      scroll: !0,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: "default",
      tolerance: "intersect",
      zIndex: 1e3,
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null
    },
    _isOverAxis: function (t, e, i) {
      return t >= e && e + i > t;
    },
    _isFloating: function (t) {
      return /left|right/.test(t.css("float")) || /inline|table-cell/.test(t.css("display"));
    },
    _create: function () {
      this.containerCache = {}, this._addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0;
    },
    _setOption: function (t, e) {
      this._super(t, e), "handle" === t && this._setHandleClassName();
    },
    _setHandleClassName: function () {
      var e = this;
      this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle"), t.each(this.items, function () {
        e._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
      });
    },
    _destroy: function () {
      this._mouseDestroy();

      for (var t = this.items.length - 1; t >= 0; t--) this.items[t].item.removeData(this.widgetName + "-item");

      return this;
    },
    _mouseCapture: function (e, i) {
      var s = null,
          n = !1,
          o = this;
      return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(e), t(e.target).parents().each(function () {
        return t.data(this, o.widgetName + "-item") === o ? (s = t(this), !1) : void 0;
      }), t.data(e.target, o.widgetName + "-item") === o && (s = t(e.target)), s ? !this.options.handle || i || (t(this.options.handle, s).find("*").addBack().each(function () {
        this === e.target && (n = !0);
      }), n) ? (this.currentItem = s, this._removeCurrentsFromItems(), !0) : !1 : !1);
    },
    _mouseStart: function (e, i, s) {
      var n,
          o,
          a = this.options;
      if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(e), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      }, t.extend(this.offset, {
        click: {
          left: e.pageX - this.offset.left,
          top: e.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(e), this.originalPageX = e.pageX, this.originalPageY = e.pageY, a.cursorAt && this._adjustOffsetFromHelper(a.cursorAt), this.domPosition = {
        prev: this.currentItem.prev()[0],
        parent: this.currentItem.parent()[0]
      }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), a.containment && this._setContainment(), a.cursor && "auto" !== a.cursor && (o = this.document.find("body"), this.storedCursor = o.css("cursor"), o.css("cursor", a.cursor), this.storedStylesheet = t("<style>*{ cursor: " + a.cursor + " !important; }</style>").appendTo(o)), a.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", a.opacity)), a.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", a.zIndex)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", e, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !s) for (n = this.containers.length - 1; n >= 0; n--) this.containers[n]._trigger("activate", e, this._uiHash(this));
      return t.ui.ddmanager && (t.ui.ddmanager.current = this), t.ui.ddmanager && !a.dropBehaviour && t.ui.ddmanager.prepareOffsets(this, e), this.dragging = !0, this._addClass(this.helper, "ui-sortable-helper"), this._mouseDrag(e), !0;
    },
    _mouseDrag: function (e) {
      var i,
          s,
          n,
          o,
          a = this.options,
          r = !1;

      for (this.position = this._generatePosition(e), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - e.pageY < a.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + a.scrollSpeed : e.pageY - this.overflowOffset.top < a.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - a.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - e.pageX < a.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + a.scrollSpeed : e.pageX - this.overflowOffset.left < a.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - a.scrollSpeed)) : (e.pageY - this.document.scrollTop() < a.scrollSensitivity ? r = this.document.scrollTop(this.document.scrollTop() - a.scrollSpeed) : this.window.height() - (e.pageY - this.document.scrollTop()) < a.scrollSensitivity && (r = this.document.scrollTop(this.document.scrollTop() + a.scrollSpeed)), e.pageX - this.document.scrollLeft() < a.scrollSensitivity ? r = this.document.scrollLeft(this.document.scrollLeft() - a.scrollSpeed) : this.window.width() - (e.pageX - this.document.scrollLeft()) < a.scrollSensitivity && (r = this.document.scrollLeft(this.document.scrollLeft() + a.scrollSpeed))), r !== !1 && t.ui.ddmanager && !a.dropBehaviour && t.ui.ddmanager.prepareOffsets(this, e)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), i = this.items.length - 1; i >= 0; i--) if (s = this.items[i], n = s.item[0], o = this._intersectsWithPointer(s), o && s.instance === this.currentContainer && n !== this.currentItem[0] && this.placeholder[1 === o ? "next" : "prev"]()[0] !== n && !t.contains(this.placeholder[0], n) && ("semi-dynamic" === this.options.type ? !t.contains(this.element[0], n) : !0)) {
        if (this.direction = 1 === o ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(s)) break;
        this._rearrange(e, s), this._trigger("change", e, this._uiHash());
        break;
      }

      return this._contactContainers(e), t.ui.ddmanager && t.ui.ddmanager.drag(this, e), this._trigger("sort", e, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1;
    },
    _mouseStop: function (e, i) {
      if (e) {
        if (t.ui.ddmanager && !this.options.dropBehaviour && t.ui.ddmanager.drop(this, e), this.options.revert) {
          var s = this,
              n = this.placeholder.offset(),
              o = this.options.axis,
              a = {};
          o && "x" !== o || (a.left = n.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), o && "y" !== o || (a.top = n.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, t(this.helper).animate(a, parseInt(this.options.revert, 10) || 500, function () {
            s._clear(e);
          });
        } else this._clear(e, i);

        return !1;
      }
    },
    cancel: function () {
      if (this.dragging) {
        this._mouseUp(new t.Event("mouseup", {
          target: null
        })), "original" === this.options.helper ? (this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")) : this.currentItem.show();

        for (var e = this.containers.length - 1; e >= 0; e--) this.containers[e]._trigger("deactivate", null, this._uiHash(this)), this.containers[e].containerCache.over && (this.containers[e]._trigger("out", null, this._uiHash(this)), this.containers[e].containerCache.over = 0);
      }

      return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), t.extend(this, {
        helper: null,
        dragging: !1,
        reverting: !1,
        _noFinalSort: null
      }), this.domPosition.prev ? t(this.domPosition.prev).after(this.currentItem) : t(this.domPosition.parent).prepend(this.currentItem)), this;
    },
    serialize: function (e) {
      var i = this._getItemsAsjQuery(e && e.connected),
          s = [];

      return e = e || {}, t(i).each(function () {
        var i = (t(e.item || this).attr(e.attribute || "id") || "").match(e.expression || /(.+)[\-=_](.+)/);
        i && s.push((e.key || i[1] + "[]") + "=" + (e.key && e.expression ? i[1] : i[2]));
      }), !s.length && e.key && s.push(e.key + "="), s.join("&");
    },
    toArray: function (e) {
      var i = this._getItemsAsjQuery(e && e.connected),
          s = [];

      return e = e || {}, i.each(function () {
        s.push(t(e.item || this).attr(e.attribute || "id") || "");
      }), s;
    },
    _intersectsWith: function (t) {
      var e = this.positionAbs.left,
          i = e + this.helperProportions.width,
          s = this.positionAbs.top,
          n = s + this.helperProportions.height,
          o = t.left,
          a = o + t.width,
          r = t.top,
          h = r + t.height,
          l = this.offset.click.top,
          c = this.offset.click.left,
          u = "x" === this.options.axis || s + l > r && h > s + l,
          d = "y" === this.options.axis || e + c > o && a > e + c,
          p = u && d;
      return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > t[this.floating ? "width" : "height"] ? p : e + this.helperProportions.width / 2 > o && a > i - this.helperProportions.width / 2 && s + this.helperProportions.height / 2 > r && h > n - this.helperProportions.height / 2;
    },
    _intersectsWithPointer: function (t) {
      var e,
          i,
          s = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height),
          n = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width),
          o = s && n;

      return o ? (e = this._getDragVerticalDirection(), i = this._getDragHorizontalDirection(), this.floating ? "right" === i || "down" === e ? 2 : 1 : e && ("down" === e ? 2 : 1)) : !1;
    },
    _intersectsWithSides: function (t) {
      var e = this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height),
          i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width),
          s = this._getDragVerticalDirection(),
          n = this._getDragHorizontalDirection();

      return this.floating && n ? "right" === n && i || "left" === n && !i : s && ("down" === s && e || "up" === s && !e);
    },
    _getDragVerticalDirection: function () {
      var t = this.positionAbs.top - this.lastPositionAbs.top;
      return 0 !== t && (t > 0 ? "down" : "up");
    },
    _getDragHorizontalDirection: function () {
      var t = this.positionAbs.left - this.lastPositionAbs.left;
      return 0 !== t && (t > 0 ? "right" : "left");
    },
    refresh: function (t) {
      return this._refreshItems(t), this._setHandleClassName(), this.refreshPositions(), this;
    },
    _connectWith: function () {
      var t = this.options;
      return t.connectWith.constructor === String ? [t.connectWith] : t.connectWith;
    },
    _getItemsAsjQuery: function (e) {
      function i() {
        r.push(this);
      }

      var s,
          n,
          o,
          a,
          r = [],
          h = [],
          l = this._connectWith();

      if (l && e) for (s = l.length - 1; s >= 0; s--) for (o = t(l[s], this.document[0]), n = o.length - 1; n >= 0; n--) a = t.data(o[n], this.widgetFullName), a && a !== this && !a.options.disabled && h.push([t.isFunction(a.options.items) ? a.options.items.call(a.element) : t(a.options.items, a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), a]);

      for (h.push([t.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
        options: this.options,
        item: this.currentItem
      }) : t(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), s = h.length - 1; s >= 0; s--) h[s][0].each(i);

      return t(r);
    },
    _removeCurrentsFromItems: function () {
      var e = this.currentItem.find(":data(" + this.widgetName + "-item)");
      this.items = t.grep(this.items, function (t) {
        for (var i = 0; e.length > i; i++) if (e[i] === t.item[0]) return !1;

        return !0;
      });
    },
    _refreshItems: function (e) {
      this.items = [], this.containers = [this];

      var i,
          s,
          n,
          o,
          a,
          r,
          h,
          l,
          c = this.items,
          u = [[t.isFunction(this.options.items) ? this.options.items.call(this.element[0], e, {
        item: this.currentItem
      }) : t(this.options.items, this.element), this]],
          d = this._connectWith();

      if (d && this.ready) for (i = d.length - 1; i >= 0; i--) for (n = t(d[i], this.document[0]), s = n.length - 1; s >= 0; s--) o = t.data(n[s], this.widgetFullName), o && o !== this && !o.options.disabled && (u.push([t.isFunction(o.options.items) ? o.options.items.call(o.element[0], e, {
        item: this.currentItem
      }) : t(o.options.items, o.element), o]), this.containers.push(o));

      for (i = u.length - 1; i >= 0; i--) for (a = u[i][1], r = u[i][0], s = 0, l = r.length; l > s; s++) h = t(r[s]), h.data(this.widgetName + "-item", a), c.push({
        item: h,
        instance: a,
        width: 0,
        height: 0,
        left: 0,
        top: 0
      });
    },
    refreshPositions: function (e) {
      this.floating = this.items.length ? "x" === this.options.axis || this._isFloating(this.items[0].item) : !1, this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
      var i, s, n, o;

      for (i = this.items.length - 1; i >= 0; i--) s = this.items[i], s.instance !== this.currentContainer && this.currentContainer && s.item[0] !== this.currentItem[0] || (n = this.options.toleranceElement ? t(this.options.toleranceElement, s.item) : s.item, e || (s.width = n.outerWidth(), s.height = n.outerHeight()), o = n.offset(), s.left = o.left, s.top = o.top);

      if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);else for (i = this.containers.length - 1; i >= 0; i--) o = this.containers[i].element.offset(), this.containers[i].containerCache.left = o.left, this.containers[i].containerCache.top = o.top, this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
      return this;
    },
    _createPlaceholder: function (e) {
      e = e || this;
      var i,
          s = e.options;
      s.placeholder && s.placeholder.constructor !== String || (i = s.placeholder, s.placeholder = {
        element: function () {
          var s = e.currentItem[0].nodeName.toLowerCase(),
              n = t("<" + s + ">", e.document[0]);
          return e._addClass(n, "ui-sortable-placeholder", i || e.currentItem[0].className)._removeClass(n, "ui-sortable-helper"), "tbody" === s ? e._createTrPlaceholder(e.currentItem.find("tr").eq(0), t("<tr>", e.document[0]).appendTo(n)) : "tr" === s ? e._createTrPlaceholder(e.currentItem, n) : "img" === s && n.attr("src", e.currentItem.attr("src")), i || n.css("visibility", "hidden"), n;
        },
        update: function (t, n) {
          (!i || s.forcePlaceholderSize) && (n.height() || n.height(e.currentItem.innerHeight() - parseInt(e.currentItem.css("paddingTop") || 0, 10) - parseInt(e.currentItem.css("paddingBottom") || 0, 10)), n.width() || n.width(e.currentItem.innerWidth() - parseInt(e.currentItem.css("paddingLeft") || 0, 10) - parseInt(e.currentItem.css("paddingRight") || 0, 10)));
        }
      }), e.placeholder = t(s.placeholder.element.call(e.element, e.currentItem)), e.currentItem.after(e.placeholder), s.placeholder.update(e, e.placeholder);
    },
    _createTrPlaceholder: function (e, i) {
      var s = this;
      e.children().each(function () {
        t("<td>&#160;</td>", s.document[0]).attr("colspan", t(this).attr("colspan") || 1).appendTo(i);
      });
    },
    _contactContainers: function (e) {
      var i,
          s,
          n,
          o,
          a,
          r,
          h,
          l,
          c,
          u,
          d = null,
          p = null;

      for (i = this.containers.length - 1; i >= 0; i--) if (!t.contains(this.currentItem[0], this.containers[i].element[0])) if (this._intersectsWith(this.containers[i].containerCache)) {
        if (d && t.contains(this.containers[i].element[0], d.element[0])) continue;
        d = this.containers[i], p = i;
      } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", e, this._uiHash(this)), this.containers[i].containerCache.over = 0);

      if (d) if (1 === this.containers.length) this.containers[p].containerCache.over || (this.containers[p]._trigger("over", e, this._uiHash(this)), this.containers[p].containerCache.over = 1);else {
        for (n = 1e4, o = null, c = d.floating || this._isFloating(this.currentItem), a = c ? "left" : "top", r = c ? "width" : "height", u = c ? "pageX" : "pageY", s = this.items.length - 1; s >= 0; s--) t.contains(this.containers[p].element[0], this.items[s].item[0]) && this.items[s].item[0] !== this.currentItem[0] && (h = this.items[s].item.offset()[a], l = !1, e[u] - h > this.items[s][r] / 2 && (l = !0), n > Math.abs(e[u] - h) && (n = Math.abs(e[u] - h), o = this.items[s], this.direction = l ? "up" : "down"));

        if (!o && !this.options.dropOnEmpty) return;
        if (this.currentContainer === this.containers[p]) return this.currentContainer.containerCache.over || (this.containers[p]._trigger("over", e, this._uiHash()), this.currentContainer.containerCache.over = 1), void 0;
        o ? this._rearrange(e, o, null, !0) : this._rearrange(e, null, this.containers[p].element, !0), this._trigger("change", e, this._uiHash()), this.containers[p]._trigger("change", e, this._uiHash(this)), this.currentContainer = this.containers[p], this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[p]._trigger("over", e, this._uiHash(this)), this.containers[p].containerCache.over = 1;
      }
    },
    _createHelper: function (e) {
      var i = this.options,
          s = t.isFunction(i.helper) ? t(i.helper.apply(this.element[0], [e, this.currentItem])) : "clone" === i.helper ? this.currentItem.clone() : this.currentItem;
      return s.parents("body").length || t("parent" !== i.appendTo ? i.appendTo : this.currentItem[0].parentNode)[0].appendChild(s[0]), s[0] === this.currentItem[0] && (this._storedCSS = {
        width: this.currentItem[0].style.width,
        height: this.currentItem[0].style.height,
        position: this.currentItem.css("position"),
        top: this.currentItem.css("top"),
        left: this.currentItem.css("left")
      }), (!s[0].style.width || i.forceHelperSize) && s.width(this.currentItem.width()), (!s[0].style.height || i.forceHelperSize) && s.height(this.currentItem.height()), s;
    },
    _adjustOffsetFromHelper: function (e) {
      "string" == typeof e && (e = e.split(" ")), t.isArray(e) && (e = {
        left: +e[0],
        top: +e[1] || 0
      }), "left" in e && (this.offset.click.left = e.left + this.margins.left), "right" in e && (this.offset.click.left = this.helperProportions.width - e.right + this.margins.left), "top" in e && (this.offset.click.top = e.top + this.margins.top), "bottom" in e && (this.offset.click.top = this.helperProportions.height - e.bottom + this.margins.top);
    },
    _getParentOffset: function () {
      this.offsetParent = this.helper.offsetParent();
      var e = this.offsetParent.offset();
      return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && t.contains(this.scrollParent[0], this.offsetParent[0]) && (e.left += this.scrollParent.scrollLeft(), e.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && t.ui.ie) && (e = {
        top: 0,
        left: 0
      }), {
        top: e.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: e.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if ("relative" === this.cssPosition) {
        var t = this.currentItem.position();
        return {
          top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
          left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
        };
      }

      return {
        top: 0,
        left: 0
      };
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
        top: parseInt(this.currentItem.css("marginTop"), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var e,
          i,
          s,
          n = this.options;
      "parent" === n.containment && (n.containment = this.helper[0].parentNode), ("document" === n.containment || "window" === n.containment) && (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === n.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === n.containment ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(n.containment) || (e = t(n.containment)[0], i = t(n.containment).offset(), s = "hidden" !== t(e).css("overflow"), this.containment = [i.left + (parseInt(t(e).css("borderLeftWidth"), 10) || 0) + (parseInt(t(e).css("paddingLeft"), 10) || 0) - this.margins.left, i.top + (parseInt(t(e).css("borderTopWidth"), 10) || 0) + (parseInt(t(e).css("paddingTop"), 10) || 0) - this.margins.top, i.left + (s ? Math.max(e.scrollWidth, e.offsetWidth) : e.offsetWidth) - (parseInt(t(e).css("borderLeftWidth"), 10) || 0) - (parseInt(t(e).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, i.top + (s ? Math.max(e.scrollHeight, e.offsetHeight) : e.offsetHeight) - (parseInt(t(e).css("borderTopWidth"), 10) || 0) - (parseInt(t(e).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top]);
    },
    _convertPositionTo: function (e, i) {
      i || (i = this.position);
      var s = "absolute" === e ? 1 : -1,
          n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && t.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          o = /(html|body)/i.test(n[0].tagName);
      return {
        top: i.top + this.offset.relative.top * s + this.offset.parent.top * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : o ? 0 : n.scrollTop()) * s,
        left: i.left + this.offset.relative.left * s + this.offset.parent.left * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : o ? 0 : n.scrollLeft()) * s
      };
    },
    _generatePosition: function (e) {
      var i,
          s,
          n = this.options,
          o = e.pageX,
          a = e.pageY,
          r = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && t.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          h = /(html|body)/i.test(r[0].tagName);
      return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (e.pageX - this.offset.click.left < this.containment[0] && (o = this.containment[0] + this.offset.click.left), e.pageY - this.offset.click.top < this.containment[1] && (a = this.containment[1] + this.offset.click.top), e.pageX - this.offset.click.left > this.containment[2] && (o = this.containment[2] + this.offset.click.left), e.pageY - this.offset.click.top > this.containment[3] && (a = this.containment[3] + this.offset.click.top)), n.grid && (i = this.originalPageY + Math.round((a - this.originalPageY) / n.grid[1]) * n.grid[1], a = this.containment ? i - this.offset.click.top >= this.containment[1] && i - this.offset.click.top <= this.containment[3] ? i : i - this.offset.click.top >= this.containment[1] ? i - n.grid[1] : i + n.grid[1] : i, s = this.originalPageX + Math.round((o - this.originalPageX) / n.grid[0]) * n.grid[0], o = this.containment ? s - this.offset.click.left >= this.containment[0] && s - this.offset.click.left <= this.containment[2] ? s : s - this.offset.click.left >= this.containment[0] ? s - n.grid[0] : s + n.grid[0] : s)), {
        top: a - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : h ? 0 : r.scrollTop()),
        left: o - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : h ? 0 : r.scrollLeft())
      };
    },
    _rearrange: function (t, e, i, s) {
      i ? i[0].appendChild(this.placeholder[0]) : e.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? e.item[0] : e.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
      var n = this.counter;

      this._delay(function () {
        n === this.counter && this.refreshPositions(!s);
      });
    },
    _clear: function (t, e) {
      function i(t, e, i) {
        return function (s) {
          i._trigger(t, s, e._uiHash(e));
        };
      }

      this.reverting = !1;
      var s,
          n = [];

      if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
        for (s in this._storedCSS) ("auto" === this._storedCSS[s] || "static" === this._storedCSS[s]) && (this._storedCSS[s] = "");

        this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper");
      } else this.currentItem.show();

      for (this.fromOutside && !e && n.push(function (t) {
        this._trigger("receive", t, this._uiHash(this.fromOutside));
      }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || e || n.push(function (t) {
        this._trigger("update", t, this._uiHash());
      }), this !== this.currentContainer && (e || (n.push(function (t) {
        this._trigger("remove", t, this._uiHash());
      }), n.push(function (t) {
        return function (e) {
          t._trigger("receive", e, this._uiHash(this));
        };
      }.call(this, this.currentContainer)), n.push(function (t) {
        return function (e) {
          t._trigger("update", e, this._uiHash(this));
        };
      }.call(this, this.currentContainer)))), s = this.containers.length - 1; s >= 0; s--) e || n.push(i("deactivate", this, this.containers[s])), this.containers[s].containerCache.over && (n.push(i("out", this, this.containers[s])), this.containers[s].containerCache.over = 0);

      if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, e || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !e) {
        for (s = 0; n.length > s; s++) n[s].call(this, t);

        this._trigger("stop", t, this._uiHash());
      }

      return this.fromOutside = !1, !this.cancelHelperRemoval;
    },
    _trigger: function () {
      t.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel();
    },
    _uiHash: function (e) {
      var i = e || this;
      return {
        helper: i.helper,
        placeholder: i.placeholder || t([]),
        position: i.position,
        originalPosition: i.originalPosition,
        offset: i.positionAbs,
        item: i.currentItem,
        sender: e ? e.element : null
      };
    }
  }), t.widget("ui.spinner", {
    version: "1.12.1",
    defaultElement: "<input>",
    widgetEventPrefix: "spin",
    options: {
      classes: {
        "ui-spinner": "ui-corner-all",
        "ui-spinner-down": "ui-corner-br",
        "ui-spinner-up": "ui-corner-tr"
      },
      culture: null,
      icons: {
        down: "ui-icon-triangle-1-s",
        up: "ui-icon-triangle-1-n"
      },
      incremental: !0,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,
      change: null,
      spin: null,
      start: null,
      stop: null
    },
    _create: function () {
      this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr("autocomplete");
        }
      });
    },
    _getCreateOptions: function () {
      var e = this._super(),
          i = this.element;

      return t.each(["min", "max", "step"], function (t, s) {
        var n = i.attr(s);
        null != n && n.length && (e[s] = n);
      }), e;
    },
    _events: {
      keydown: function (t) {
        this._start(t) && this._keydown(t) && t.preventDefault();
      },
      keyup: "_stop",
      focus: function () {
        this.previous = this.element.val();
      },
      blur: function (t) {
        return this.cancelBlur ? (delete this.cancelBlur, void 0) : (this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", t), void 0);
      },
      mousewheel: function (t, e) {
        if (e) {
          if (!this.spinning && !this._start(t)) return !1;
          this._spin((e > 0 ? 1 : -1) * this.options.step, t), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
            this.spinning && this._stop(t);
          }, 100), t.preventDefault();
        }
      },
      "mousedown .ui-spinner-button": function (e) {
        function i() {
          var e = this.element[0] === t.ui.safeActiveElement(this.document[0]);
          e || (this.element.trigger("focus"), this.previous = s, this._delay(function () {
            this.previous = s;
          }));
        }

        var s;
        s = this.element[0] === t.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val(), e.preventDefault(), i.call(this), this.cancelBlur = !0, this._delay(function () {
          delete this.cancelBlur, i.call(this);
        }), this._start(e) !== !1 && this._repeat(null, t(e.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, e);
      },
      "mouseup .ui-spinner-button": "_stop",
      "mouseenter .ui-spinner-button": function (e) {
        return t(e.currentTarget).hasClass("ui-state-active") ? this._start(e) === !1 ? !1 : (this._repeat(null, t(e.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, e), void 0) : void 0;
      },
      "mouseleave .ui-spinner-button": "_stop"
    },
    _enhance: function () {
      this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>");
    },
    _draw: function () {
      this._enhance(), this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content"), this._addClass("ui-spinner-input"), this.element.attr("role", "spinbutton"), this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", !0).button({
        classes: {
          "ui-button": ""
        }
      }), this._removeClass(this.buttons, "ui-corner-all"), this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up"), this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down"), this.buttons.first().button({
        icon: this.options.icons.up,
        showLabel: !1
      }), this.buttons.last().button({
        icon: this.options.icons.down,
        showLabel: !1
      }), this.buttons.height() > Math.ceil(.5 * this.uiSpinner.height()) && this.uiSpinner.height() > 0 && this.uiSpinner.height(this.uiSpinner.height());
    },
    _keydown: function (e) {
      var i = this.options,
          s = t.ui.keyCode;

      switch (e.keyCode) {
        case s.UP:
          return this._repeat(null, 1, e), !0;

        case s.DOWN:
          return this._repeat(null, -1, e), !0;

        case s.PAGE_UP:
          return this._repeat(null, i.page, e), !0;

        case s.PAGE_DOWN:
          return this._repeat(null, -i.page, e), !0;
      }

      return !1;
    },
    _start: function (t) {
      return this.spinning || this._trigger("start", t) !== !1 ? (this.counter || (this.counter = 1), this.spinning = !0, !0) : !1;
    },
    _repeat: function (t, e, i) {
      t = t || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
        this._repeat(40, e, i);
      }, t), this._spin(e * this.options.step, i);
    },
    _spin: function (t, e) {
      var i = this.value() || 0;
      this.counter || (this.counter = 1), i = this._adjustValue(i + t * this._increment(this.counter)), this.spinning && this._trigger("spin", e, {
        value: i
      }) === !1 || (this._value(i), this.counter++);
    },
    _increment: function (e) {
      var i = this.options.incremental;
      return i ? t.isFunction(i) ? i(e) : Math.floor(e * e * e / 5e4 - e * e / 500 + 17 * e / 200 + 1) : 1;
    },
    _precision: function () {
      var t = this._precisionOf(this.options.step);

      return null !== this.options.min && (t = Math.max(t, this._precisionOf(this.options.min))), t;
    },
    _precisionOf: function (t) {
      var e = "" + t,
          i = e.indexOf(".");
      return -1 === i ? 0 : e.length - i - 1;
    },
    _adjustValue: function (t) {
      var e,
          i,
          s = this.options;
      return e = null !== s.min ? s.min : 0, i = t - e, i = Math.round(i / s.step) * s.step, t = e + i, t = parseFloat(t.toFixed(this._precision())), null !== s.max && t > s.max ? s.max : null !== s.min && s.min > t ? s.min : t;
    },
    _stop: function (t) {
      this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", t));
    },
    _setOption: function (t, e) {
      var i, s, n;
      return "culture" === t || "numberFormat" === t ? (i = this._parse(this.element.val()), this.options[t] = e, this.element.val(this._format(i)), void 0) : (("max" === t || "min" === t || "step" === t) && "string" == typeof e && (e = this._parse(e)), "icons" === t && (s = this.buttons.first().find(".ui-icon"), this._removeClass(s, null, this.options.icons.up), this._addClass(s, null, e.up), n = this.buttons.last().find(".ui-icon"), this._removeClass(n, null, this.options.icons.down), this._addClass(n, null, e.down)), this._super(t, e), void 0);
    },
    _setOptionDisabled: function (t) {
      this._super(t), this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!t), this.element.prop("disabled", !!t), this.buttons.button(t ? "disable" : "enable");
    },
    _setOptions: r(function (t) {
      this._super(t);
    }),
    _parse: function (t) {
      return "string" == typeof t && "" !== t && (t = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(t, 10, this.options.culture) : +t), "" === t || isNaN(t) ? null : t;
    },
    _format: function (t) {
      return "" === t ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(t, this.options.numberFormat, this.options.culture) : t;
    },
    _refresh: function () {
      this.element.attr({
        "aria-valuemin": this.options.min,
        "aria-valuemax": this.options.max,
        "aria-valuenow": this._parse(this.element.val())
      });
    },
    isValid: function () {
      var t = this.value();
      return null === t ? !1 : t === this._adjustValue(t);
    },
    _value: function (t, e) {
      var i;
      "" !== t && (i = this._parse(t), null !== i && (e || (i = this._adjustValue(i)), t = this._format(i))), this.element.val(t), this._refresh();
    },
    _destroy: function () {
      this.element.prop("disabled", !1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"), this.uiSpinner.replaceWith(this.element);
    },
    stepUp: r(function (t) {
      this._stepUp(t);
    }),
    _stepUp: function (t) {
      this._start() && (this._spin((t || 1) * this.options.step), this._stop());
    },
    stepDown: r(function (t) {
      this._stepDown(t);
    }),
    _stepDown: function (t) {
      this._start() && (this._spin((t || 1) * -this.options.step), this._stop());
    },
    pageUp: r(function (t) {
      this._stepUp((t || 1) * this.options.page);
    }),
    pageDown: r(function (t) {
      this._stepDown((t || 1) * this.options.page);
    }),
    value: function (t) {
      return arguments.length ? (r(this._value).call(this, t), void 0) : this._parse(this.element.val());
    },
    widget: function () {
      return this.uiSpinner;
    }
  }), t.uiBackCompat !== !1 && t.widget("ui.spinner", t.ui.spinner, {
    _enhance: function () {
      this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
    },
    _uiSpinnerHtml: function () {
      return "<span>";
    },
    _buttonHtml: function () {
      return "<a></a><a></a>";
    }
  }), t.ui.spinner, t.widget("ui.tabs", {
    version: "1.12.1",
    delay: 300,
    options: {
      active: null,
      classes: {
        "ui-tabs": "ui-corner-all",
        "ui-tabs-nav": "ui-corner-all",
        "ui-tabs-panel": "ui-corner-bottom",
        "ui-tabs-tab": "ui-corner-top"
      },
      collapsible: !1,
      event: "click",
      heightStyle: "content",
      hide: null,
      show: null,
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
    _isLocal: function () {
      var t = /#.*$/;
      return function (e) {
        var i, s;
        i = e.href.replace(t, ""), s = location.href.replace(t, "");

        try {
          i = decodeURIComponent(i);
        } catch (n) {}

        try {
          s = decodeURIComponent(s);
        } catch (n) {}

        return e.hash.length > 1 && i === s;
      };
    }(),
    _create: function () {
      var e = this,
          i = this.options;
      this.running = !1, this._addClass("ui-tabs", "ui-widget ui-widget-content"), this._toggleClass("ui-tabs-collapsible", null, i.collapsible), this._processTabs(), i.active = this._initialActive(), t.isArray(i.disabled) && (i.disabled = t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"), function (t) {
        return e.tabs.index(t);
      }))).sort()), this.active = this.options.active !== !1 && this.anchors.length ? this._findActive(i.active) : t(), this._refresh(), this.active.length && this.load(i.active);
    },
    _initialActive: function () {
      var e = this.options.active,
          i = this.options.collapsible,
          s = location.hash.substring(1);
      return null === e && (s && this.tabs.each(function (i, n) {
        return t(n).attr("aria-controls") === s ? (e = i, !1) : void 0;
      }), null === e && (e = this.tabs.index(this.tabs.filter(".ui-tabs-active"))), (null === e || -1 === e) && (e = this.tabs.length ? 0 : !1)), e !== !1 && (e = this.tabs.index(this.tabs.eq(e)), -1 === e && (e = i ? !1 : 0)), !i && e === !1 && this.anchors.length && (e = 0), e;
    },
    _getCreateEventData: function () {
      return {
        tab: this.active,
        panel: this.active.length ? this._getPanelForTab(this.active) : t()
      };
    },
    _tabKeydown: function (e) {
      var i = t(t.ui.safeActiveElement(this.document[0])).closest("li"),
          s = this.tabs.index(i),
          n = !0;

      if (!this._handlePageNav(e)) {
        switch (e.keyCode) {
          case t.ui.keyCode.RIGHT:
          case t.ui.keyCode.DOWN:
            s++;
            break;

          case t.ui.keyCode.UP:
          case t.ui.keyCode.LEFT:
            n = !1, s--;
            break;

          case t.ui.keyCode.END:
            s = this.anchors.length - 1;
            break;

          case t.ui.keyCode.HOME:
            s = 0;
            break;

          case t.ui.keyCode.SPACE:
            return e.preventDefault(), clearTimeout(this.activating), this._activate(s), void 0;

          case t.ui.keyCode.ENTER:
            return e.preventDefault(), clearTimeout(this.activating), this._activate(s === this.options.active ? !1 : s), void 0;

          default:
            return;
        }

        e.preventDefault(), clearTimeout(this.activating), s = this._focusNextTab(s, n), e.ctrlKey || e.metaKey || (i.attr("aria-selected", "false"), this.tabs.eq(s).attr("aria-selected", "true"), this.activating = this._delay(function () {
          this.option("active", s);
        }, this.delay));
      }
    },
    _panelKeydown: function (e) {
      this._handlePageNav(e) || e.ctrlKey && e.keyCode === t.ui.keyCode.UP && (e.preventDefault(), this.active.trigger("focus"));
    },
    _handlePageNav: function (e) {
      return e.altKey && e.keyCode === t.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : e.altKey && e.keyCode === t.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0;
    },
    _findNextTab: function (e, i) {
      function s() {
        return e > n && (e = 0), 0 > e && (e = n), e;
      }

      for (var n = this.tabs.length - 1; -1 !== t.inArray(s(), this.options.disabled);) e = i ? e + 1 : e - 1;

      return e;
    },
    _focusNextTab: function (t, e) {
      return t = this._findNextTab(t, e), this.tabs.eq(t).trigger("focus"), t;
    },
    _setOption: function (t, e) {
      return "active" === t ? (this._activate(e), void 0) : (this._super(t, e), "collapsible" === t && (this._toggleClass("ui-tabs-collapsible", null, e), e || this.options.active !== !1 || this._activate(0)), "event" === t && this._setupEvents(e), "heightStyle" === t && this._setupHeightStyle(e), void 0);
    },
    _sanitizeSelector: function (t) {
      return t ? t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
    },
    refresh: function () {
      var e = this.options,
          i = this.tablist.children(":has(a[href])");
      e.disabled = t.map(i.filter(".ui-state-disabled"), function (t) {
        return i.index(t);
      }), this._processTabs(), e.active !== !1 && this.anchors.length ? this.active.length && !t.contains(this.tablist[0], this.active[0]) ? this.tabs.length === e.disabled.length ? (e.active = !1, this.active = t()) : this._activate(this._findNextTab(Math.max(0, e.active - 1), !1)) : e.active = this.tabs.index(this.active) : (e.active = !1, this.active = t()), this._refresh();
    },
    _refresh: function () {
      this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
        "aria-selected": "false",
        "aria-expanded": "false",
        tabIndex: -1
      }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
        "aria-hidden": "true"
      }), this.active.length ? (this.active.attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      }), this._addClass(this.active, "ui-tabs-active", "ui-state-active"), this._getPanelForTab(this.active).show().attr({
        "aria-hidden": "false"
      })) : this.tabs.eq(0).attr("tabIndex", 0);
    },
    _processTabs: function () {
      var e = this,
          i = this.tabs,
          s = this.anchors,
          n = this.panels;
      this.tablist = this._getList().attr("role", "tablist"), this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header"), this.tablist.on("mousedown" + this.eventNamespace, "> li", function (e) {
        t(this).is(".ui-state-disabled") && e.preventDefault();
      }).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function () {
        t(this).closest("li").is(".ui-state-disabled") && this.blur();
      }), this.tabs = this.tablist.find("> li:has(a[href])").attr({
        role: "tab",
        tabIndex: -1
      }), this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default"), this.anchors = this.tabs.map(function () {
        return t("a", this)[0];
      }).attr({
        role: "presentation",
        tabIndex: -1
      }), this._addClass(this.anchors, "ui-tabs-anchor"), this.panels = t(), this.anchors.each(function (i, s) {
        var n,
            o,
            a,
            r = t(s).uniqueId().attr("id"),
            h = t(s).closest("li"),
            l = h.attr("aria-controls");
        e._isLocal(s) ? (n = s.hash, a = n.substring(1), o = e.element.find(e._sanitizeSelector(n))) : (a = h.attr("aria-controls") || t({}).uniqueId()[0].id, n = "#" + a, o = e.element.find(n), o.length || (o = e._createPanel(a), o.insertAfter(e.panels[i - 1] || e.tablist)), o.attr("aria-live", "polite")), o.length && (e.panels = e.panels.add(o)), l && h.data("ui-tabs-aria-controls", l), h.attr({
          "aria-controls": a,
          "aria-labelledby": r
        }), o.attr("aria-labelledby", r);
      }), this.panels.attr("role", "tabpanel"), this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content"), i && (this._off(i.not(this.tabs)), this._off(s.not(this.anchors)), this._off(n.not(this.panels)));
    },
    _getList: function () {
      return this.tablist || this.element.find("ol, ul").eq(0);
    },
    _createPanel: function (e) {
      return t("<div>").attr("id", e).data("ui-tabs-destroy", !0);
    },
    _setOptionDisabled: function (e) {
      var i, s, n;

      for (t.isArray(e) && (e.length ? e.length === this.anchors.length && (e = !0) : e = !1), n = 0; s = this.tabs[n]; n++) i = t(s), e === !0 || -1 !== t.inArray(n, e) ? (i.attr("aria-disabled", "true"), this._addClass(i, null, "ui-state-disabled")) : (i.removeAttr("aria-disabled"), this._removeClass(i, null, "ui-state-disabled"));

      this.options.disabled = e, this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, e === !0);
    },
    _setupEvents: function (e) {
      var i = {};
      e && t.each(e.split(" "), function (t, e) {
        i[e] = "_eventHandler";
      }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
        click: function (t) {
          t.preventDefault();
        }
      }), this._on(this.anchors, i), this._on(this.tabs, {
        keydown: "_tabKeydown"
      }), this._on(this.panels, {
        keydown: "_panelKeydown"
      }), this._focusable(this.tabs), this._hoverable(this.tabs);
    },
    _setupHeightStyle: function (e) {
      var i,
          s = this.element.parent();
      "fill" === e ? (i = s.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function () {
        var e = t(this),
            s = e.css("position");
        "absolute" !== s && "fixed" !== s && (i -= e.outerHeight(!0));
      }), this.element.children().not(this.panels).each(function () {
        i -= t(this).outerHeight(!0);
      }), this.panels.each(function () {
        t(this).height(Math.max(0, i - t(this).innerHeight() + t(this).height()));
      }).css("overflow", "auto")) : "auto" === e && (i = 0, this.panels.each(function () {
        i = Math.max(i, t(this).height("").height());
      }).height(i));
    },
    _eventHandler: function (e) {
      var i = this.options,
          s = this.active,
          n = t(e.currentTarget),
          o = n.closest("li"),
          a = o[0] === s[0],
          r = a && i.collapsible,
          h = r ? t() : this._getPanelForTab(o),
          l = s.length ? this._getPanelForTab(s) : t(),
          c = {
        oldTab: s,
        oldPanel: l,
        newTab: r ? t() : o,
        newPanel: h
      };
      e.preventDefault(), o.hasClass("ui-state-disabled") || o.hasClass("ui-tabs-loading") || this.running || a && !i.collapsible || this._trigger("beforeActivate", e, c) === !1 || (i.active = r ? !1 : this.tabs.index(o), this.active = a ? t() : o, this.xhr && this.xhr.abort(), l.length || h.length || t.error("jQuery UI Tabs: Mismatching fragment identifier."), h.length && this.load(this.tabs.index(o), e), this._toggle(e, c));
    },
    _toggle: function (e, i) {
      function s() {
        o.running = !1, o._trigger("activate", e, i);
      }

      function n() {
        o._addClass(i.newTab.closest("li"), "ui-tabs-active", "ui-state-active"), a.length && o.options.show ? o._show(a, o.options.show, s) : (a.show(), s());
      }

      var o = this,
          a = i.newPanel,
          r = i.oldPanel;
      this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, function () {
        o._removeClass(i.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), n();
      }) : (this._removeClass(i.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), r.hide(), n()), r.attr("aria-hidden", "true"), i.oldTab.attr({
        "aria-selected": "false",
        "aria-expanded": "false"
      }), a.length && r.length ? i.oldTab.attr("tabIndex", -1) : a.length && this.tabs.filter(function () {
        return 0 === t(this).attr("tabIndex");
      }).attr("tabIndex", -1), a.attr("aria-hidden", "false"), i.newTab.attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      });
    },
    _activate: function (e) {
      var i,
          s = this._findActive(e);

      s[0] !== this.active[0] && (s.length || (s = this.active), i = s.find(".ui-tabs-anchor")[0], this._eventHandler({
        target: i,
        currentTarget: i,
        preventDefault: t.noop
      }));
    },
    _findActive: function (e) {
      return e === !1 ? t() : this.tabs.eq(e);
    },
    _getIndex: function (e) {
      return "string" == typeof e && (e = this.anchors.index(this.anchors.filter("[href$='" + t.ui.escapeSelector(e) + "']"))), e;
    },
    _destroy: function () {
      this.xhr && this.xhr.abort(), this.tablist.removeAttr("role").off(this.eventNamespace), this.anchors.removeAttr("role tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function () {
        t.data(this, "ui-tabs-destroy") ? t(this).remove() : t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded");
      }), this.tabs.each(function () {
        var e = t(this),
            i = e.data("ui-tabs-aria-controls");
        i ? e.attr("aria-controls", i).removeData("ui-tabs-aria-controls") : e.removeAttr("aria-controls");
      }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "");
    },
    enable: function (e) {
      var i = this.options.disabled;
      i !== !1 && (void 0 === e ? i = !1 : (e = this._getIndex(e), i = t.isArray(i) ? t.map(i, function (t) {
        return t !== e ? t : null;
      }) : t.map(this.tabs, function (t, i) {
        return i !== e ? i : null;
      })), this._setOptionDisabled(i));
    },
    disable: function (e) {
      var i = this.options.disabled;

      if (i !== !0) {
        if (void 0 === e) i = !0;else {
          if (e = this._getIndex(e), -1 !== t.inArray(e, i)) return;
          i = t.isArray(i) ? t.merge([e], i).sort() : [e];
        }

        this._setOptionDisabled(i);
      }
    },
    load: function (e, i) {
      e = this._getIndex(e);

      var s = this,
          n = this.tabs.eq(e),
          o = n.find(".ui-tabs-anchor"),
          a = this._getPanelForTab(n),
          r = {
        tab: n,
        panel: a
      },
          h = function (t, e) {
        "abort" === e && s.panels.stop(!1, !0), s._removeClass(n, "ui-tabs-loading"), a.removeAttr("aria-busy"), t === s.xhr && delete s.xhr;
      };

      this._isLocal(o[0]) || (this.xhr = t.ajax(this._ajaxSettings(o, i, r)), this.xhr && "canceled" !== this.xhr.statusText && (this._addClass(n, "ui-tabs-loading"), a.attr("aria-busy", "true"), this.xhr.done(function (t, e, n) {
        setTimeout(function () {
          a.html(t), s._trigger("load", i, r), h(n, e);
        }, 1);
      }).fail(function (t, e) {
        setTimeout(function () {
          h(t, e);
        }, 1);
      })));
    },
    _ajaxSettings: function (e, i, s) {
      var n = this;
      return {
        url: e.attr("href").replace(/#.*$/, ""),
        beforeSend: function (e, o) {
          return n._trigger("beforeLoad", i, t.extend({
            jqXHR: e,
            ajaxSettings: o
          }, s));
        }
      };
    },
    _getPanelForTab: function (e) {
      var i = t(e).attr("aria-controls");
      return this.element.find(this._sanitizeSelector("#" + i));
    }
  }), t.uiBackCompat !== !1 && t.widget("ui.tabs", t.ui.tabs, {
    _processTabs: function () {
      this._superApply(arguments), this._addClass(this.tabs, "ui-tab");
    }
  }), t.ui.tabs, t.widget("ui.tooltip", {
    version: "1.12.1",
    options: {
      classes: {
        "ui-tooltip": "ui-corner-all ui-widget-shadow"
      },
      content: function () {
        var e = t(this).attr("title") || "";
        return t("<a>").text(e).html();
      },
      hide: !0,
      items: "[title]:not([disabled])",
      position: {
        my: "left top+15",
        at: "left bottom",
        collision: "flipfit flip"
      },
      show: !0,
      track: !1,
      close: null,
      open: null
    },
    _addDescribedBy: function (e, i) {
      var s = (e.attr("aria-describedby") || "").split(/\s+/);
      s.push(i), e.data("ui-tooltip-id", i).attr("aria-describedby", t.trim(s.join(" ")));
    },
    _removeDescribedBy: function (e) {
      var i = e.data("ui-tooltip-id"),
          s = (e.attr("aria-describedby") || "").split(/\s+/),
          n = t.inArray(i, s);
      -1 !== n && s.splice(n, 1), e.removeData("ui-tooltip-id"), s = t.trim(s.join(" ")), s ? e.attr("aria-describedby", s) : e.removeAttr("aria-describedby");
    },
    _create: function () {
      this._on({
        mouseover: "open",
        focusin: "open"
      }), this.tooltips = {}, this.parents = {}, this.liveRegion = t("<div>").attr({
        role: "log",
        "aria-live": "assertive",
        "aria-relevant": "additions"
      }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this.disabledTitles = t([]);
    },
    _setOption: function (e, i) {
      var s = this;
      this._super(e, i), "content" === e && t.each(this.tooltips, function (t, e) {
        s._updateContent(e.element);
      });
    },
    _setOptionDisabled: function (t) {
      this[t ? "_disable" : "_enable"]();
    },
    _disable: function () {
      var e = this;
      t.each(this.tooltips, function (i, s) {
        var n = t.Event("blur");
        n.target = n.currentTarget = s.element[0], e.close(n, !0);
      }), this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function () {
        var e = t(this);
        return e.is("[title]") ? e.data("ui-tooltip-title", e.attr("title")).removeAttr("title") : void 0;
      }));
    },
    _enable: function () {
      this.disabledTitles.each(function () {
        var e = t(this);
        e.data("ui-tooltip-title") && e.attr("title", e.data("ui-tooltip-title"));
      }), this.disabledTitles = t([]);
    },
    open: function (e) {
      var i = this,
          s = t(e ? e.target : this.element).closest(this.options.items);
      s.length && !s.data("ui-tooltip-id") && (s.attr("title") && s.data("ui-tooltip-title", s.attr("title")), s.data("ui-tooltip-open", !0), e && "mouseover" === e.type && s.parents().each(function () {
        var e,
            s = t(this);
        s.data("ui-tooltip-open") && (e = t.Event("blur"), e.target = e.currentTarget = this, i.close(e, !0)), s.attr("title") && (s.uniqueId(), i.parents[this.id] = {
          element: this,
          title: s.attr("title")
        }, s.attr("title", ""));
      }), this._registerCloseHandlers(e, s), this._updateContent(s, e));
    },
    _updateContent: function (t, e) {
      var i,
          s = this.options.content,
          n = this,
          o = e ? e.type : null;
      return "string" == typeof s || s.nodeType || s.jquery ? this._open(e, t, s) : (i = s.call(t[0], function (i) {
        n._delay(function () {
          t.data("ui-tooltip-open") && (e && (e.type = o), this._open(e, t, i));
        });
      }), i && this._open(e, t, i), void 0);
    },
    _open: function (e, i, s) {
      function n(t) {
        l.of = t, a.is(":hidden") || a.position(l);
      }

      var o,
          a,
          r,
          h,
          l = t.extend({}, this.options.position);

      if (s) {
        if (o = this._find(i)) return o.tooltip.find(".ui-tooltip-content").html(s), void 0;
        i.is("[title]") && (e && "mouseover" === e.type ? i.attr("title", "") : i.removeAttr("title")), o = this._tooltip(i), a = o.tooltip, this._addDescribedBy(i, a.attr("id")), a.find(".ui-tooltip-content").html(s), this.liveRegion.children().hide(), h = t("<div>").html(a.find(".ui-tooltip-content").html()), h.removeAttr("name").find("[name]").removeAttr("name"), h.removeAttr("id").find("[id]").removeAttr("id"), h.appendTo(this.liveRegion), this.options.track && e && /^mouse/.test(e.type) ? (this._on(this.document, {
          mousemove: n
        }), n(e)) : a.position(t.extend({
          of: i
        }, this.options.position)), a.hide(), this._show(a, this.options.show), this.options.track && this.options.show && this.options.show.delay && (r = this.delayedShow = setInterval(function () {
          a.is(":visible") && (n(l.of), clearInterval(r));
        }, t.fx.interval)), this._trigger("open", e, {
          tooltip: a
        });
      }
    },
    _registerCloseHandlers: function (e, i) {
      var s = {
        keyup: function (e) {
          if (e.keyCode === t.ui.keyCode.ESCAPE) {
            var s = t.Event(e);
            s.currentTarget = i[0], this.close(s, !0);
          }
        }
      };
      i[0] !== this.element[0] && (s.remove = function () {
        this._removeTooltip(this._find(i).tooltip);
      }), e && "mouseover" !== e.type || (s.mouseleave = "close"), e && "focusin" !== e.type || (s.focusout = "close"), this._on(!0, i, s);
    },
    close: function (e) {
      var i,
          s = this,
          n = t(e ? e.currentTarget : this.element),
          o = this._find(n);

      return o ? (i = o.tooltip, o.closing || (clearInterval(this.delayedShow), n.data("ui-tooltip-title") && !n.attr("title") && n.attr("title", n.data("ui-tooltip-title")), this._removeDescribedBy(n), o.hiding = !0, i.stop(!0), this._hide(i, this.options.hide, function () {
        s._removeTooltip(t(this));
      }), n.removeData("ui-tooltip-open"), this._off(n, "mouseleave focusout keyup"), n[0] !== this.element[0] && this._off(n, "remove"), this._off(this.document, "mousemove"), e && "mouseleave" === e.type && t.each(this.parents, function (e, i) {
        t(i.element).attr("title", i.title), delete s.parents[e];
      }), o.closing = !0, this._trigger("close", e, {
        tooltip: i
      }), o.hiding || (o.closing = !1)), void 0) : (n.removeData("ui-tooltip-open"), void 0);
    },
    _tooltip: function (e) {
      var i = t("<div>").attr("role", "tooltip"),
          s = t("<div>").appendTo(i),
          n = i.uniqueId().attr("id");
      return this._addClass(s, "ui-tooltip-content"), this._addClass(i, "ui-tooltip", "ui-widget ui-widget-content"), i.appendTo(this._appendTo(e)), this.tooltips[n] = {
        element: e,
        tooltip: i
      };
    },
    _find: function (t) {
      var e = t.data("ui-tooltip-id");
      return e ? this.tooltips[e] : null;
    },
    _removeTooltip: function (t) {
      t.remove(), delete this.tooltips[t.attr("id")];
    },
    _appendTo: function (t) {
      var e = t.closest(".ui-front, dialog");
      return e.length || (e = this.document[0].body), e;
    },
    _destroy: function () {
      var e = this;
      t.each(this.tooltips, function (i, s) {
        var n = t.Event("blur"),
            o = s.element;
        n.target = n.currentTarget = o[0], e.close(n, !0), t("#" + i).remove(), o.data("ui-tooltip-title") && (o.attr("title") || o.attr("title", o.data("ui-tooltip-title")), o.removeData("ui-tooltip-title"));
      }), this.liveRegion.remove();
    }
  }), t.uiBackCompat !== !1 && t.widget("ui.tooltip", t.ui.tooltip, {
    options: {
      tooltipClass: null
    },
    _tooltip: function () {
      var t = this._superApply(arguments);

      return this.options.tooltipClass && t.tooltip.addClass(this.options.tooltipClass), t;
    }
  }), t.ui.tooltip;
});
/*!
muh
	AnythingSlider v1.9.7
	Original by Chris Coyier: http://css-tricks.com
	Get the latest version: https://github.com/CSS-Tricks/AnythingSlider

	To use the navigationFormatter function, you must have a function that
	accepts two paramaters, and returns a string of HTML text.

	index = integer index (1 based);
	panel = jQuery wrapped LI item this tab references
	@return = Must return a string of HTML/Text

	navigationFormatter: function(index, panel){
		return "Panel #" + index; // This would have each tab with the text 'Panel #X' where X = index
	}
*/

/*jshint browser:true, jquery:true, unused:false */
;

(function ($, win, doc) {
  "use strict";

  $.anythingSlider = function (el, options) {
    var base = this,
        o,
        t; // Wraps the ul in the necessary divs and then gives Access to jQuery element

    base.el = el;
    base.$el = $(el).addClass('anythingBase').wrap('<div class="anythingSlider"><div class="anythingWindow" /></div>'); // Add a reverse reference to the DOM object

    base.$el.data("AnythingSlider", base);

    base.init = function () {
      // Added "o" to be used in the code instead of "base.options" which doesn't get modifed by the compiler - reduces size by ~1k
      base.options = o = $.extend({}, $.anythingSlider.defaults, options);
      base.initialized = false;

      if ($.isFunction(o.onBeforeInitialize)) {
        base.$el.bind('before_initialize', o.onBeforeInitialize);
      }

      base.$el.trigger('before_initialize', base); // Add "as-oldie" class to body for css purposes

      $('<!--[if lte IE 8]><script>jQuery("body").addClass("as-oldie");</script><![endif]-->').appendTo('body').remove(); // Cache existing DOM elements for later
      // base.$el = original ul
      // for wrap - get parent() then closest in case the ul has "anythingSlider" class

      base.$wrapper = base.$el.parent().closest('div.anythingSlider').addClass('anythingSlider-' + o.theme);
      base.$outer = base.$wrapper.parent();
      base.$window = base.$el.closest('div.anythingWindow');
      base.$win = $(win);
      base.$controls = $('<div class="anythingControls"></div>');
      base.$nav = $('<ul class="thumbNav"><li><a><span></span></a></li></ul>');
      base.$startStop = $('<a href="#" class="start-stop"></a>');

      if (o.buildStartStop || o.buildNavigation) {
        base.$controls.appendTo(o.appendControlsTo && $(o.appendControlsTo).length ? $(o.appendControlsTo) : base.$wrapper);
      }

      if (o.buildNavigation) {
        base.$nav.appendTo(o.appendNavigationTo && $(o.appendNavigationTo).length ? $(o.appendNavigationTo) : base.$controls);
      }

      if (o.buildStartStop) {
        base.$startStop.appendTo(o.appendStartStopTo && $(o.appendStartStopTo).length ? $(o.appendStartStopTo) : base.$controls);
      } // Figure out how many sliders are on the page for indexing


      base.runTimes = $('.anythingBase').length; // hash tag regex - fixes issue #432

      base.regex = o.hashTags ? new RegExp('panel' + base.runTimes + '-(\\d+)', 'i') : null;

      if (base.runTimes === 1) {
        base.makeActive();
      } // make the first slider on the page active
      // Set up a few defaults & get details


      base.flag = false; // event flag to prevent multiple calls (used in control click/focusin)

      if (o.autoPlayLocked) {
        o.autoPlay = true;
      } // if autoplay is locked, start playing


      base.playing = o.autoPlay; // slideshow state; removed "startStopped" option

      base.slideshow = false; // slideshow flag needed to correctly trigger slideshow events

      base.hovered = false; // actively hovering over the slider

      base.panelSize = []; // will contain dimensions and left position of each panel

      base.currentPage = base.targetPage = o.startPanel = parseInt(o.startPanel, 10) || 1; // make sure this isn't a string

      o.changeBy = parseInt(o.changeBy, 10) || 1; // set slider type, but keep backward compatibility with the vertical option

      t = (o.mode || 'h').toLowerCase().match(/(h|v|f)/);
      t = o.vertical ? 'v' : (t || ['h'])[0];
      o.mode = t === 'v' ? 'vertical' : t === 'f' ? 'fade' : 'horizontal';

      if (t === 'f') {
        o.showMultiple = 1; // all slides are stacked in fade mode

        o.infiniteSlides = false; // no cloned slides
      }

      base.adj = o.infiniteSlides ? 0 : 1; // adjust page limits for infinite or limited modes

      base.adjustMultiple = 0;

      if (o.playRtl) {
        base.$wrapper.addClass('rtl');
      } // Build start/stop button


      if (o.buildStartStop) {
        base.buildAutoPlay();
      } // Build forwards/backwards buttons


      if (o.buildArrows) {
        base.buildNextBackButtons();
      }

      base.$lastPage = base.$targetPage = base.$currentPage; // Initialize o.aspectRatio

      if (o.expand) {
        if (o.aspectRatio === true) {
          // if aspectRatio = true calculate it
          o.aspectRatio = base.$el.width() / base.$el.height();
        } else if (typeof o.aspectRatio === 'string' && o.aspectRatio.indexOf(':') !== -1) {
          // Calculate and set a float from a string e.g. '680:317'
          var f = o.aspectRatio.split(':');
          o.aspectRatio = f[0] / f[1];
        } // Adjust the aspectRatio according to showMultiple i.e. the more panels shown the wider the slider gets


        if (o.aspectRatio > 0 && o.showMultiple > 1) {
          o.aspectRatio = o.aspectRatio * o.showMultiple;
        }
      }

      base.updateSlider(); // Expand slider to fit parent

      if (o.expand) {
        base.$window.css({
          width: '100%',
          height: '100%'
        }); // needed for Opera

        base.checkResize();
      } // Make sure easing function exists.


      if (!$.isFunction($.easing[o.easing])) {
        o.easing = "swing";
      } // If pauseOnHover then add hover effects


      if (o.pauseOnHover) {
        base.$wrapper.hover(function () {
          if (base.playing) {
            base.$el.trigger('slideshow_paused', base);
            base.clearTimer(true);
          }
        }, function () {
          if (base.playing) {
            base.$el.trigger('slideshow_unpaused', base);
            base.startStop(base.playing, true);
          }
        });
      } // Hide/Show navigation & play/stop controls


      base.slideControls(false);
      base.$wrapper.bind('mouseenter mouseleave', function (e) {
        // add hovered class to outer wrapper
        $(this)[e.type === 'mouseenter' ? 'addClass' : 'removeClass']('anythingSlider-hovered');
        base.hovered = e.type === 'mouseenter' ? true : false;
        base.slideControls(base.hovered);
      }); // Add keyboard navigation

      $(doc).keyup(function (e) {
        // Stop arrow keys from working when focused on form items
        if (o.enableKeyboard && base.$wrapper.hasClass('activeSlider') && !e.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
          if (o.mode !== 'vertical' && (e.which === 38 || e.which === 40)) {
            return;
          }

          switch (e.which) {
            case 39:
            case 40:
              // right & down arrow
              base.goForward();
              break;

            case 37:
            case 38:
              // left & up arrow
              base.goBack();
              break;
          }
        }
      }); // If a hash can not be used to trigger the plugin, then go to start panel - see issue #432

      base.currentPage = (o.hashTags ? base.gotoHash() : '') || o.startPanel || 1;
      base.gotoPage(base.currentPage, false, null, -1); // Binds events

      var triggers = "slideshow_resized slideshow_paused slideshow_unpaused slide_init slide_begin slideshow_stop slideshow_start initialized swf_completed".split(" ");
      $.each("onSliderResize onShowPause onShowUnpause onSlideInit onSlideBegin onShowStop onShowStart onInitialized onSWFComplete".split(" "), function (i, f) {
        if ($.isFunction(o[f])) {
          base.$el.bind(triggers[i], o[f]);
        }
      });

      if ($.isFunction(o.onSlideComplete)) {
        // Added setTimeout (zero time) to ensure animation is complete... see this bug report: http://bugs.jquery.com/ticket/7157
        base.$el.bind('slide_complete', function () {
          setTimeout(function () {
            o.onSlideComplete(base);
          }, 0);
          return false;
        });
      }

      base.initialized = true;
      base.$el.trigger('initialized', base); // trigger the slideshow

      base.startStop(o.autoPlay);
    }; // called during initialization & to update the slider if a panel is added or deleted


    base.updateSlider = function () {
      // needed for updating the slider
      base.$el.children('.cloned').remove();
      base.navTextVisible = base.$nav.find('span:first').css('visibility') !== 'hidden';
      base.$nav.empty(); // set currentPage to 1 in case it was zero - occurs when adding slides after removing them all

      base.currentPage = base.currentPage || 1;
      base.$items = base.$el.children();
      base.pages = base.$items.length;
      base.dir = o.mode === 'vertical' ? 'top' : 'left';
      o.showMultiple = parseInt(o.showMultiple, 10) || 1; // only integers allowed

      o.navigationSize = o.navigationSize === false ? 0 : parseInt(o.navigationSize, 10) || 0; // Fix tabbing through the page, but don't change the view if the link is in view (showMultiple = true)

      base.$items.find('a').unbind('focus.AnythingSlider').bind('focus.AnythingSlider', function (e) {
        var panel = $(this).closest('.panel'),
            indx = base.$items.index(panel) + base.adj; // index can be -1 in nested sliders - issue #208

        base.$items.find('.focusedLink').removeClass('focusedLink');
        $(this).addClass('focusedLink');
        base.$window.scrollLeft(0).scrollTop(0);

        if (indx !== -1 && (indx >= base.currentPage + o.showMultiple || indx < base.currentPage)) {
          base.gotoPage(indx);
          e.preventDefault();
        }
      });

      if (o.showMultiple > 1) {
        if (o.showMultiple > base.pages) {
          o.showMultiple = base.pages;
        }

        base.adjustMultiple = o.infiniteSlides && base.pages > 1 ? 0 : o.showMultiple - 1;
      } // Hide navigation & player if there is only one page


      base.$controls.add(base.$nav).add(base.$startStop).add(base.$forward).add(base.$back)[base.pages <= 1 ? 'hide' : 'show']();

      if (base.pages > 1) {
        // Build/update navigation tabs
        base.buildNavigation();
      } // Top and tail the list with 'visible' number of items, top has the last section, and tail has the first
      // This supports the "infinite" scrolling, also ensures any cloned elements don't duplicate an ID
      // Moved removeAttr before addClass otherwise IE7 ignores the addClass: http://bugs.jquery.com/ticket/9871


      if (o.mode !== 'fade' && o.infiniteSlides && base.pages > 1) {
        base.$el.prepend(base.$items.filter(':last').clone().addClass('cloned')); // Add support for multiple sliders shown at the same time

        if (o.showMultiple > 1) {
          base.$el.append(base.$items.filter(':lt(' + o.showMultiple + ')').clone().addClass('cloned multiple'));
        } else {
          base.$el.append(base.$items.filter(':first').clone().addClass('cloned'));
        }

        base.$el.find('.cloned').each(function () {
          // disable all focusable elements in cloned panels to prevent shifting the panels by tabbing
          $(this).find('a,input,textarea,select,button,area,form').attr({
            disabled: 'disabled',
            name: ''
          });
          $(this).find('[id]')[$.fn.addBack ? 'addBack' : 'andSelf']().removeAttr('id');
        });
      } // We just added two items, time to re-cache the list, then get the dimensions of each panel


      base.$items = base.$el.addClass(o.mode).children().addClass('panel');
      base.setDimensions(); // Set the dimensions of each panel

      if (o.resizeContents) {
        base.$items.css('width', base.width);
        base.$wrapper.css('width', base.getDim(base.currentPage)[0]).add(base.$items).css('height', base.height);
      } else {
        base.$win.load(function () {
          // set dimensions after all images load
          base.setDimensions(); // make sure the outer wrapper is set properly

          t = base.getDim(base.currentPage);
          base.$wrapper.css({
            width: t[0],
            height: t[1]
          });
          base.setCurrentPage(base.currentPage, false);
        });
      }

      if (base.currentPage > base.pages) {
        base.currentPage = base.pages;
      }

      base.setCurrentPage(base.currentPage, false);
      base.$nav.find('a').eq(base.currentPage - 1).addClass('cur'); // update current selection

      if (o.mode === 'fade') {
        t = base.$items.eq(base.currentPage - 1);

        if (o.resumeOnVisible) {
          // prevent display: none;
          t.css({
            opacity: 1,
            visibility: 'visible'
          }).siblings().css({
            opacity: 0,
            visibility: 'hidden'
          });
        } else {
          // allow display: none; - resets video
          base.$items.css('opacity', 1);
          t.fadeIn(0).siblings().fadeOut(0);
        }
      }
    }; // Creates the numbered navigation links


    base.buildNavigation = function () {
      if (o.buildNavigation && base.pages > 1) {
        var a, c, i, t, $li;
        base.$items.filter(':not(.cloned)').each(function (j) {
          $li = $('<li/>');
          i = j + 1;
          c = (i === 1 ? ' first' : '') + (i === base.pages ? ' last' : '');
          a = '<a class="panel' + i + (base.navTextVisible ? '"' : ' ' + o.tooltipClass + '" title="@"') + ' href="#"><span>@</span></a>'; // If a formatter function is present, use it

          if ($.isFunction(o.navigationFormatter)) {
            t = o.navigationFormatter(i, $(this));

            if (typeof t === "string") {
              $li.html(a.replace(/@/g, t));
            } else {
              $li = $('<li/>', t);
            }
          } else {
            $li.html(a.replace(/@/g, i));
          }

          $li.appendTo(base.$nav).addClass(c).data('index', i);
        });
        base.$nav.children('li').bind(o.clickControls, function (e) {
          if (!base.flag && o.enableNavigation) {
            // prevent running functions twice (once for click, second time for focusin)
            base.flag = true;
            setTimeout(function () {
              base.flag = false;
            }, 100);
            base.gotoPage($(this).data('index'));
          }

          e.preventDefault();
        }); // Add navigation tab scrolling - use !! in case someone sets the size to zero

        if (!!o.navigationSize && o.navigationSize < base.pages) {
          if (!base.$controls.find('.anythingNavWindow').length) {
            base.$nav.before('<ul><li class="prev"><a href="#"><span>' + o.backText + '</span></a></li></ul>').after('<ul><li class="next"><a href="#"><span>' + o.forwardText + '</span></a></li></ul>').wrap('<div class="anythingNavWindow"></div>');
          } // include half of the left position to include extra width from themes like tabs-light and tabs-dark (still not perfect)


          base.navWidths = base.$nav.find('li').map(function () {
            return $(this).outerWidth(true) + Math.ceil(parseInt($(this).find('span').css('left'), 10) / 2 || 0);
          }).get(); // start navLeft at one so calling base.navWindow() will position the current page on the left

          base.navLeft = 1; // add 25 pixels (old IE needs more than 5) to make sure the tabs don't wrap to the next line

          base.$nav.width(base.navWidth(1, base.pages + 1) + 25);
          base.$controls.find('.anythingNavWindow').width(base.navWidth(1, o.navigationSize + 1)).end().find('.prev,.next').bind(o.clickControls, function (e) {
            if (!base.flag) {
              base.flag = true;
              setTimeout(function () {
                base.flag = false;
              }, 200);
              base.navWindow(base.navLeft + o.navigationSize * ($(this).is('.prev') ? -1 : 1));
            }

            e.preventDefault();
          });
        }
      }
    };

    base.navWidth = function (x, y) {
      var i,
          s = Math.min(x, y),
          e = Math.max(x, y),
          w = 0;

      for (i = s; i < e; i++) {
        w += base.navWidths[i - 1] || 0;
      }

      return w;
    };

    base.navWindow = function (n) {
      if (!!o.navigationSize && o.navigationSize < base.pages && base.navWidths) {
        var p = base.pages - o.navigationSize + 1;
        n = n <= 1 ? 1 : n > 1 && n < p ? n : p;

        if (n !== base.navLeft) {
          base.$controls.find('.anythingNavWindow').animate({
            scrollLeft: base.navWidth(1, n),
            width: base.navWidth(n, n + o.navigationSize)
          }, {
            queue: false,
            duration: o.animationTime
          });
          base.navLeft = n;
        }
      }
    }; // Creates the Forward/Backward buttons


    base.buildNextBackButtons = function () {
      base.$forward = $('<span class="arrow forward"><a href="#"><span>' + o.forwardText + '</span></a></span>');
      base.$back = $('<span class="arrow back"><a href="#"><span>' + o.backText + '</span></a></span>'); // Bind to the forward and back buttons

      base.$back.bind(o.clickBackArrow, function (e) {
        // prevent running functions twice (once for click, second time for swipe)
        if (o.enableArrows && !base.flag) {
          base.flag = true;
          setTimeout(function () {
            base.flag = false;
          }, 100);
          base.goBack();
        }

        e.preventDefault();
      });
      base.$forward.bind(o.clickForwardArrow, function (e) {
        // prevent running functions twice (once for click, second time for swipe)
        if (o.enableArrows && !base.flag) {
          base.flag = true;
          setTimeout(function () {
            base.flag = false;
          }, 100);
          base.goForward();
        }

        e.preventDefault();
      }); // using tab to get to arrow links will show they have focus (outline is disabled in css)

      base.$back.add(base.$forward).find('a').bind('focusin focusout', function () {
        $(this).toggleClass('hover');
      }); // Append elements to page

      base.$back.appendTo(o.appendBackTo && $(o.appendBackTo).length ? $(o.appendBackTo) : base.$wrapper);
      base.$forward.appendTo(o.appendForwardTo && $(o.appendForwardTo).length ? $(o.appendForwardTo) : base.$wrapper);
      base.arrowWidth = base.$forward.width(); // assuming the left & right arrows are the same width - used for toggle

      base.arrowRight = parseInt(base.$forward.css('right'), 10);
      base.arrowLeft = parseInt(base.$back.css('left'), 10);
    }; // Creates the Start/Stop button


    base.buildAutoPlay = function () {
      base.$startStop.html('<span>' + (base.playing ? o.stopText : o.startText) + '</span>').bind(o.clickSlideshow, function (e) {
        if (o.enableStartStop) {
          base.startStop(!base.playing);
          base.makeActive();

          if (base.playing && !o.autoPlayDelayed) {
            base.goForward(true, o.playRtl);
          }
        }

        e.preventDefault();
      }) // show button has focus while tabbing
      .bind('focusin focusout', function () {
        $(this).toggleClass('hover');
      });
    }; // Adjust slider dimensions on parent element resize


    base.checkResize = function (stopTimer) {
      // checking document visibility
      var vis = !!(doc.hidden || doc.webkitHidden || doc.mozHidden || doc.msHidden);
      clearTimeout(base.resizeTimer);
      base.resizeTimer = setTimeout(function () {
        var w = base.$outer.width(),
            h = base.$outer[0].tagName === "BODY" ? base.$win.height() : base.$outer.height(); // base.width = width of one panel, so multiply by # of panels; outerPad is padding added for arrows.
        // ignore changes if window hidden

        if (!vis && (base.lastDim[0] !== w || base.lastDim[1] !== h)) {
          base.setDimensions(); // adjust panel sizes
          //callback for slider resize

          base.$el.trigger('slideshow_resized', base); // make sure page is lined up (use -1 animation time, so we can differeniate it from when animationTime = 0)

          base.gotoPage(base.currentPage, base.playing, null, -1);
        }

        if (typeof stopTimer === 'undefined') {
          base.checkResize();
        } // increase time if page is hidden; but don't stop it completely

      }, vis ? 2000 : 500);
    }; // Set panel dimensions to either resize content or adjust panel to content


    base.setDimensions = function () {
      // reset element width & height
      base.$wrapper.find('.anythingWindow, .anythingBase, .panel')[$.fn.addBack ? 'addBack' : 'andSelf']().css({
        width: '',
        height: ''
      });
      base.width = base.$el.width();
      base.height = base.$el.height();
      base.outerPad = [base.$wrapper.innerWidth() - base.$wrapper.width(), base.$wrapper.innerHeight() - base.$wrapper.height()];
      var w,
          h,
          c,
          t,
          edge = 0,
          fullsize = {
        width: '100%',
        height: '100%'
      },
          // determine panel width
      pw = o.showMultiple > 1 && o.mode === 'horizontal' ? base.width || base.$window.width() / o.showMultiple : base.$window.width(),
          ph = o.showMultiple > 1 && o.mode === 'vertical' ? base.height / o.showMultiple || base.$window.height() / o.showMultiple : base.$window.height();

      if (o.expand) {
        base.lastDim = [base.$outer.width(), base.$outer.height()];
        w = base.lastDim[0] - base.outerPad[0];
        h = base.lastDim[1] - base.outerPad[1]; // Rescale according to the aspectRatio if not null
        // We have already insured that (in init) o.aspectRatio contains a float.
        // make sure aspectRatio isn't infinity (divided by zero; so must be less than width, 3 might be a better number)

        if (o.aspectRatio && o.aspectRatio < base.width) {
          var arW = h * o.aspectRatio; // Really: only one of these should be adjusted therefor the else ... if

          if (arW < w) {
            w = arW;
          } else {
            var arH = w / o.aspectRatio;

            if (arH < h) {
              h = arH;
            }
          }
        }

        base.$wrapper.add(base.$window).css({
          width: w,
          height: h
        });
        base.height = h = o.showMultiple > 1 && o.mode === 'vertical' ? ph : h;
        base.width = pw = o.showMultiple > 1 && o.mode === 'horizontal' ? w / o.showMultiple : w;
        base.$items.css({
          width: pw,
          height: ph
        });
      }

      base.$items.each(function (i) {
        t = $(this);
        c = t.children();

        if (o.resizeContents) {
          // resize panel
          w = base.width;
          h = base.height;
          t.css({
            width: w,
            height: h
          });

          if (c.length) {
            if (c[0].tagName === "EMBED") {
              c.attr(fullsize);
            } // needed for IE7; also c.length > 1 in IE7


            if (c[0].tagName === "OBJECT") {
              c.find('embed').attr(fullsize);
            } // resize panel contents, if solitary (wrapped content or solitary image)


            if (c.length === 1) {
              c.css(fullsize);
            }
          }
        } else {
          // get panel width & height and save it
          if (o.mode === 'vertical') {
            w = t.css('display', 'inline-block').width();
            t.css('display', '');
          } else {
            w = t.width() || base.width; // if image hasn't finished loading, width will be zero, so set it to base width instead
          }

          if (c.length === 1 && w >= pw) {
            w = c.width() >= pw ? pw : c.width(); // get width of solitary child

            c.css('max-width', w); // set max width for all children
          }

          t.css({
            width: w,
            height: ''
          }); // set width of panel

          h = c.length === 1 ? c.outerHeight(true) : t.height(); // get height after setting width

          if (h <= base.outerPad[1]) {
            h = base.height;
          } // if height less than the outside padding, then set it to the preset height


          t.css('height', h);
        }

        base.panelSize[i] = [w, h, edge];
        edge += o.mode === 'vertical' ? h : w;
      }); // Set total width of slider

      base.$el.css(o.mode === 'vertical' ? 'height' : 'width', o.mode === 'fade' ? base.width : edge);
    }; // get dimension of multiple panels, as needed


    base.getDim = function (page) {
      var t,
          i,
          w = base.width,
          h = base.height;

      if (base.pages < 1 || isNaN(page)) {
        return [w, h];
      } // prevent errors when base.panelSize is empty


      page = o.infiniteSlides && base.pages > 1 ? page : page - 1;
      i = base.panelSize[page];

      if (i) {
        w = i[0] || w;
        h = i[1] || h;
      }

      if (o.showMultiple > 1) {
        for (i = 1; i < o.showMultiple; i++) {
          // if panel doesn't exist; calculate the next one to be the
          // same size as the last - fixes #659
          t = base.panelSize[page + i] ? page + i : page;

          if (o.mode === 'vertical') {
            w = Math.max(w, base.panelSize[t][0]);
            h += base.panelSize[t][1];
          } else {
            w += base.panelSize[t][0];
            h = Math.max(h, base.panelSize[t][1]);
          }
        }
      }

      return [w, h];
    };

    base.goForward = function (autoplay, rtl) {
      // targetPage changes before animation so if rapidly changing pages, it will have the correct current page
      base.gotoPage(base[o.allowRapidChange ? 'targetPage' : 'currentPage'] + o.changeBy * (rtl ? -1 : 1), autoplay);
    };

    base.goBack = function (autoplay) {
      base.gotoPage(base[o.allowRapidChange ? 'targetPage' : 'currentPage'] - o.changeBy, autoplay);
    };

    base.gotoPage = function (page, autoplay, callback, time) {
      if (autoplay !== true) {
        autoplay = false;
        base.startStop(false);
        base.makeActive();
      } // check if page is an id or class name


      if (/^[#|.]/.test(page) && $(page).length) {
        page = $(page).closest('.panel').index() + base.adj;
      } // rewind effect occurs here when changeBy > 1


      if (o.changeBy !== 1) {
        var adj = base.pages - base.adjustMultiple;

        if (page < 1) {
          page = o.stopAtEnd ? 1 : o.infiniteSlides ? base.pages + page : o.showMultiple > 1 - page ? 1 : adj;
        }

        if (page > base.pages) {
          page = o.stopAtEnd ? base.pages : o.showMultiple > 1 - page ? 1 : page -= adj;
        } else if (page >= adj) {
          // show multiple adjustments
          page = adj;
        }
      }

      if (base.pages <= 1) {
        return;
      } // prevents animation


      base.$lastPage = base.$currentPage;

      if (typeof page !== "number") {
        page = parseInt(page, 10) || o.startPanel;
        base.setCurrentPage(page);
      } // pause YouTube videos before scrolling or prevent change if playing


      if (autoplay && o.isVideoPlaying(base)) {
        return;
      }

      if (o.stopAtEnd && !o.infiniteSlides && page > base.pages - o.showMultiple) {
        page = base.pages - o.showMultiple + 1;
      } // fixes #515


      base.exactPage = page;

      if (page > base.pages + 1 - base.adj) {
        page = !o.infiniteSlides && !o.stopAtEnd ? 1 : base.pages;
      }

      if (page < base.adj) {
        page = !o.infiniteSlides && !o.stopAtEnd ? base.pages : 1;
      }

      if (!o.infiniteSlides) {
        base.exactPage = page;
      } // exact page used by the fx extension


      base.currentPage = page > base.pages ? base.pages : page < 1 ? 1 : base.currentPage;
      base.$currentPage = base.$items.eq(base.currentPage - base.adj);
      base.targetPage = page === 0 ? base.pages : page > base.pages ? 1 : page;
      base.$targetPage = base.$items.eq(base.targetPage - base.adj);
      time = typeof time !== 'undefined' ? time : o.animationTime; // don't trigger events when time < 0 - to prevent FX from firing multiple times on page resize

      if (time >= 0) {
        base.$el.trigger('slide_init', base);
      } // toggle arrows/controls only if there is time to see it - fix issue #317


      if (time > 0 && o.toggleControls === true) {
        base.slideControls(true);
      } // Set visual


      if (o.buildNavigation) {
        base.setNavigation(base.targetPage);
      } // When autoplay isn't passed, we stop the timer


      if (autoplay !== true) {
        autoplay = false;
      } // Stop the slider when we reach the last page, if the option stopAtEnd is set to true


      if (!autoplay || o.stopAtEnd && page === base.pages) {
        base.startStop(false);
      }

      if (time >= 0) {
        base.$el.trigger('slide_begin', base);
      } // delay starting slide animation


      setTimeout(function (d) {
        var p,
            empty = true;

        if (o.allowRapidChange) {
          base.$wrapper.add(base.$el).add(base.$items).stop(true, true);
        } // resize slider if content size varies


        if (!o.resizeContents) {
          // animating the wrapper resize before the window prevents flickering in Firefox
          // don't animate the dimension if it hasn't changed - fix for issue #264
          p = base.getDim(page);
          d = {}; // prevent animating a dimension to zero

          if (base.$wrapper.width() !== p[0]) {
            d.width = p[0] || base.width;
            empty = false;
          }

          if (base.$wrapper.height() !== p[1]) {
            d.height = p[1] || base.height;
            empty = false;
          }

          if (!empty) {
            base.$wrapper.filter(':not(:animated)').animate(d, {
              queue: false,
              duration: time < 0 ? 0 : time,
              easing: o.easing
            });
          }
        }

        if (o.mode === 'fade') {
          if (base.$lastPage[0] !== base.$targetPage[0]) {
            base.fadeIt(base.$lastPage, 0, time);
            base.fadeIt(base.$targetPage, 1, time, function () {
              base.endAnimation(page, callback, time);
            });
          } else {
            base.endAnimation(page, callback, time);
          }
        } else {
          d = {};
          d[base.dir] = -base.panelSize[o.infiniteSlides && base.pages > 1 ? page : page - 1][2]; // resize width of base element (ul) if vertical & width of content varies

          if (o.mode === 'vertical' && !o.resizeContents) {
            d.width = p[0];
          } // Animate Slider


          base.$el.filter(':not(:animated)').animate(d, {
            queue: false,
            duration: time < 0 ? 0 : time,
            easing: o.easing,
            complete: function () {
              base.endAnimation(page, callback, time);
            }
          });
        }
      }, parseInt(o.delayBeforeAnimate, 10) || 0);
    };

    base.endAnimation = function (page, callback, time) {
      if (page === 0) {
        base.$el.css(base.dir, o.mode === 'fade' ? 0 : -base.panelSize[base.pages][2]);
        page = base.pages;
      } else if (page > base.pages) {
        // reset back to start position
        base.$el.css(base.dir, o.mode === 'fade' ? 0 : -base.panelSize[1][2]);
        page = 1;
      }

      base.exactPage = page;
      base.setCurrentPage(page, false);

      if (o.mode === 'fade') {
        // make sure non current panels are hidden (rapid slide changes)
        base.fadeIt(base.$items.not(':eq(' + (page - base.adj) + ')'), 0, 0);
      }

      if (!base.hovered) {
        base.slideControls(false);
      }

      if (o.hashTags) {
        base.setHash(page);
      }

      if (time >= 0) {
        base.$el.trigger('slide_complete', base);
      } // callback from external slide control: $('#slider').anythingSlider(4, function(slider){ })


      if (typeof callback === 'function') {
        callback(base);
      } // Continue slideshow after a delay


      if (o.autoPlayLocked && !base.playing) {
        setTimeout(function () {
          base.startStop(true); // subtract out slide delay as the slideshow waits that additional time.
        }, o.resumeDelay - (o.autoPlayDelayed ? o.delay : 0));
      }
    };

    base.fadeIt = function (el, toOpacity, time, callback) {
      var f = el.filter(':not(:animated)'),
          t = time < 0 ? 0 : time;

      if (o.resumeOnVisible) {
        if (toOpacity === 1) {
          f.css('visibility', 'visible');
        }

        f.fadeTo(t, toOpacity, function () {
          if (toOpacity === 0) {
            f.css('visibility', 'hidden');
          }

          if ($.isFunction(callback)) {
            callback();
          }
        });
      } else {
        f[toOpacity === 0 ? 'fadeOut' : 'fadeIn'](t, callback);
      }
    };

    base.setCurrentPage = function (page, move) {
      page = parseInt(page, 10);

      if (base.pages < 1 || page === 0 || isNaN(page)) {
        return;
      }

      if (page > base.pages + 1 - base.adj) {
        page = base.pages - base.adj;
      }

      if (page < base.adj) {
        page = 1;
      } // hide/show arrows based on infinite scroll mode


      if (o.buildArrows && !o.infiniteSlides && o.stopAtEnd) {
        base.$forward[page === base.pages - base.adjustMultiple ? 'addClass' : 'removeClass']('disabled');
        base.$back[page === 1 ? 'addClass' : 'removeClass']('disabled');

        if (page === base.pages && base.playing) {
          base.startStop();
        }
      } // Only change left if move does not equal false


      if (!move) {
        var d = base.getDim(page);
        base.$wrapper.css({
          width: d[0],
          height: d[1]
        }).add(base.$window).scrollLeft(0).scrollTop(0); // reset in case tabbing changed this scrollLeft - probably overly redundant

        base.$el.css(base.dir, o.mode === 'fade' ? 0 : -base.panelSize[o.infiniteSlides && base.pages > 1 ? page : page - 1][2]);
      } // Update local variable


      base.currentPage = page;
      base.$currentPage = base.$items.removeClass('activePage').eq(page - base.adj).addClass('activePage');

      if (o.buildNavigation) {
        base.setNavigation(page);
      }
    };

    base.setNavigation = function (page) {
      base.$nav.find('.cur').removeClass('cur').end().find('a').eq(page - 1).addClass('cur');
    };

    base.makeActive = function () {
      // Set current slider as active so keyboard navigation works properly
      if (!base.$wrapper.hasClass('activeSlider')) {
        $('.activeSlider').removeClass('activeSlider');
        base.$wrapper.addClass('activeSlider');
      }
    }; // This method tries to find a hash that matches an ID and panel-X
    // If either found, it tries to find a matching item
    // If that is found as well, then it returns the page number


    base.gotoHash = function () {
      var h = win.location.hash,
          i = h.indexOf('&'),
          n = h.match(base.regex); // test for "/#/" or "/#!/" used by the jquery address plugin - $('#/') breaks jQuery

      if (n === null && !/^#&/.test(h) && !/#!?\//.test(h) && !/\=/.test(h)) {
        // #quote2&panel1-3&panel3-3
        h = h.substring(0, i >= 0 ? i : h.length); // ensure the element is in the same slider

        n = $(h).length && $(h).closest('.anythingBase')[0] === base.el ? base.$items.index($(h).closest('.panel')) + base.adj : null;
      } else if (n !== null) {
        // #&panel1-3&panel3-3
        n = o.hashTags ? parseInt(n[1], 10) : null;
      }

      return n;
    };

    base.setHash = function (n) {
      var s = 'panel' + base.runTimes + '-',
          h = win.location.hash;

      if (typeof h !== 'undefined') {
        win.location.hash = h.indexOf(s) > 0 ? h.replace(base.regex, s + n) : h + "&" + s + n;
      }
    }; // Slide controls (nav and play/stop button up or down)


    base.slideControls = function (toggle) {
      var dir = toggle ? 'slideDown' : 'slideUp',
          t1 = toggle ? 0 : o.animationTime,
          t2 = toggle ? o.animationTime : 0,
          op = toggle ? 1 : 0,
          sign = toggle ? 0 : 1; // 0 = visible, 1 = hidden

      if (o.toggleControls) {
        base.$controls.stop(true, true).delay(t1)[dir](o.animationTime / 2).delay(t2);
      }

      if (o.buildArrows && o.toggleArrows) {
        if (!base.hovered && base.playing) {
          sign = 1;
          op = 0;
        } // don't animate arrows during slideshow


        base.$forward.stop(true, true).delay(t1).animate({
          right: base.arrowRight + sign * base.arrowWidth,
          opacity: op
        }, o.animationTime / 2);
        base.$back.stop(true, true).delay(t1).animate({
          left: base.arrowLeft + sign * base.arrowWidth,
          opacity: op
        }, o.animationTime / 2);
      }
    };

    base.clearTimer = function (paused) {
      // Clear the timer only if it is set
      if (base.timer) {
        win.clearInterval(base.timer);

        if (!paused && base.slideshow) {
          base.$el.trigger('slideshow_stop', base);
          base.slideshow = false;
        }
      }
    }; // Pass startStop(false) to stop and startStop(true) to play


    base.startStop = function (playing, paused) {
      if (playing !== true) {
        playing = false;
      } // Default if not supplied is false


      base.playing = playing;

      if (playing && !paused) {
        base.$el.trigger('slideshow_start', base);
        base.slideshow = true;
      } // Toggle playing and text


      if (o.buildStartStop) {
        base.$startStop.toggleClass('playing', playing).find('span').html(playing ? o.stopText : o.startText); // add button text to title attribute if it is hidden by text-indent

        if (base.$startStop.find('span').css('visibility') === "hidden") {
          base.$startStop.addClass(o.tooltipClass).attr('title', playing ? o.stopText : o.startText);
        }
      } // Pause slideshow while video is playing


      if (playing) {
        base.clearTimer(true); // Just in case this was triggered twice in a row

        base.timer = win.setInterval(function () {
          if (!!(doc.hidden || doc.webkitHidden || doc.mozHidden || doc.msHidden)) {
            // stop slideshow if the page isn't visible (issue #463)
            if (!o.autoPlayLocked) {
              base.startStop();
            }
          } else if (!o.isVideoPlaying(base)) {
            // prevent autoplay if video is playing
            base.goForward(true, o.playRtl);
          } else if (!o.resumeOnVideoEnd) {
            // stop slideshow if resume if false
            base.startStop();
          }
        }, o.delay);
      } else {
        base.clearTimer();
      }
    }; // Trigger the initialization


    base.init();
  };

  $.anythingSlider.defaults = {
    // Appearance
    theme: "default",
    // Theme name, add the css stylesheet manually
    mode: "horiz",
    // Set mode to "horizontal", "vertical" or "fade" (only first letter needed); replaces vertical option
    expand: false,
    // If true, the entire slider will expand to fit the parent element
    resizeContents: true,
    // If true, solitary images/objects in the panel will expand to fit the viewport
    // commented out as this will reduce the size of the minified version
    //aspectRatio       : null,      // Valid values: null, true, a float e.g. 1.5 (or as 3/2) or a ratio in a string e.g. '3:2'
    // If true calculate it from original width/height for slider element, if it is a number/ratio use that value
    showMultiple: false,
    // Set this value to a number and it will show that many slides at once
    easing: "swing",
    // Anything other than "linear" or "swing" requires the easing plugin or jQuery UI
    buildArrows: true,
    // If true, builds the forwards and backwards buttons
    buildNavigation: true,
    // If true, builds a list of anchor links to link to each panel
    buildStartStop: true,
    // ** If true, builds the start/stop button

    /*
    		// commented out as this will reduce the size of the minified version
    		appendForwardTo     : null,      // Append forward arrow to a HTML element (jQuery Object, selector or HTMLNode), if not null
    		appendBackTo        : null,      // Append back arrow to a HTML element (jQuery Object, selector or HTMLNode), if not null
    		appendControlsTo    : null,      // Append controls (navigation + start-stop) to a HTML element (jQuery Object, selector or HTMLNode), if not null
    		appendNavigationTo  : null,      // Append navigation buttons to a HTML element (jQuery Object, selector or HTMLNode), if not null
    		appendStartStopTo   : null,      // Append start-stop button to a HTML element (jQuery Object, selector or HTMLNode), if not null
    */
    toggleArrows: false,
    // If true, side navigation arrows will slide out on hovering & hide @ other times
    toggleControls: false,
    // if true, slide in controls (navigation + play/stop button) on hover and slide change, hide @ other times
    startText: "Start",
    // Start button text
    stopText: "Stop",
    // Stop button text
    forwardText: "&raquo;",
    // Link text used to move the slider forward (hidden by CSS, replaced with arrow image)
    backText: "&laquo;",
    // Link text used to move the slider back (hidden by CSS, replace with arrow image)
    tooltipClass: "tooltip",
    // Class added to navigation & start/stop button (text copied to title if it is hidden by a negative text indent)
    // Function
    enableArrows: true,
    // if false, arrows will be visible, but not clickable.
    enableNavigation: true,
    // if false, navigation links will still be visible, but not clickable.
    enableStartStop: true,
    // if false, the play/stop button will still be visible, but not clickable. Previously "enablePlay"
    enableKeyboard: true,
    // if false, keyboard arrow keys will not work for this slider.
    // Navigation
    startPanel: 1,
    // This sets the initial panel
    changeBy: 1,
    // Amount to go forward or back when changing panels.
    hashTags: true,
    // Should links change the hashtag in the URL?
    infiniteSlides: true,
    // if false, the slider will not wrap & not clone any panels
    navigationFormatter: null,
    // Details at the top of the file on this use (advanced use)
    navigationSize: false,
    // Set this to the maximum number of visible navigation tabs; false to disable
    // Slideshow options
    autoPlay: false,
    // If true, the slideshow will start running; replaces "startStopped" option
    autoPlayLocked: false,
    // If true, user changing slides will not stop the slideshow
    autoPlayDelayed: false,
    // If true, starting a slideshow will delay advancing slides; if false, the slider will immediately advance to the next slide when slideshow starts
    pauseOnHover: true,
    // If true & the slideshow is active, the slideshow will pause on hover
    stopAtEnd: false,
    // If true & the slideshow is active, the slideshow will stop on the last page. This also stops the rewind effect when infiniteSlides is false.
    playRtl: false,
    // If true, the slideshow will move right-to-left
    // Times
    delay: 3000,
    // How long between slideshow transitions in AutoPlay mode (in milliseconds)
    resumeDelay: 15000,
    // Resume slideshow after user interaction, only if autoplayLocked is true (in milliseconds).
    animationTime: 600,
    // How long the slideshow transition takes (in milliseconds)
    delayBeforeAnimate: 0,
    // How long to pause slide animation before going to the desired slide (used if you want your "out" FX to show).

    /*
    		// Callbacks - commented out to reduce size of the minified version - they still work
    		onSliderResize      : function(e, slider) {}, // Callback when slider resizes
    		onBeforeInitialize  : function(e, slider) {}, // Callback before the plugin initializes
    		onInitialized       : function(e, slider) {}, // Callback when the plugin finished initializing
    		onShowStart         : function(e, slider) {}, // Callback on slideshow start
    		onShowStop          : function(e, slider) {}, // Callback after slideshow stops
    		onShowPause         : function(e, slider) {}, // Callback when slideshow pauses
    		onShowUnpause       : function(e, slider) {}, // Callback when slideshow unpauses - may not trigger properly if user clicks on any controls
    		onSlideInit         : function(e, slider) {}, // Callback when slide initiates, before control animation
    		onSlideBegin        : function(e, slider) {}, // Callback before slide animates
    		onSlideComplete     : function(slider) {},    // Callback when slide completes - no event variable!
    */
    // Interactivity
    clickForwardArrow: "click",
    // Event used to activate forward arrow functionality (e.g. add jQuery mobile's "swiperight")
    clickBackArrow: "click",
    // Event used to activate back arrow functionality (e.g. add jQuery mobile's "swipeleft")
    clickControls: "click focusin",
    // Events used to activate navigation control functionality
    clickSlideshow: "click",
    // Event used to activate slideshow play/stop button
    allowRapidChange: false,
    // If true, allow rapid changing of the active pane, instead of ignoring activity during animation
    // Video
    resumeOnVideoEnd: true,
    // If true & the slideshow is active & a supported video is playing, it will pause the autoplay until the video is complete
    resumeOnVisible: true,
    // If true the video will resume playing, if previously paused; if false, the video remains paused.
    isVideoPlaying: function (base) {
      return false;
    } // return true if video is playing or false if not - used by video extension
    // deprecated - use the video extension wmode option now
    // addWmodeToObject : "opaque"   // If your slider has a video supported by the extension, the script will automatically add a wmode parameter with this setting

  };

  $.fn.anythingSlider = function (options, callback) {
    return this.each(function () {
      var page,
          anySlide = $(this).data('AnythingSlider'); // initialize the slider but prevent multiple initializations

      if ((typeof options).match('object|undefined')) {
        if (!anySlide) {
          new $.anythingSlider(this, options);
        } else {
          anySlide.updateSlider();
        } // If options is a number, process as an external link to page #: $(element).anythingSlider(#)

      } else if (/\d/.test(options) && !isNaN(options) && anySlide) {
        page = typeof options === "number" ? options : parseInt($.trim(options), 10); // accepts "  2  "
        // ignore out of bound pages

        if (page >= 1 && page <= anySlide.pages) {
          anySlide.gotoPage(page, false, callback); // page #, autoplay, one time callback
        } // Accept id or class name

      } else if (/^[#|.]/.test(options) && $(options).length) {
        anySlide.gotoPage(options, false, callback);
      }
    });
  };
})(jQuery, window, document);
/*!
 * jQuery BBQ: Back Button & Query Library - v1.4pre - 1/15/2013
 * http://benalman.com/projects/jquery-bbq-plugin/
 *
 * Copyright (c) 2010-2013 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.4pre, Last updated: 1/15/2013*
//
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (2.2kb gzipped)
//
// About: License
//
// Copyright (c) 2010-2013 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
//
// About: Release History
//
// 1.4pre - (1/15/2013) Removed $.browser reference to work with jQuery 1.9
// 1.3pre - (8/26/2010) Integrated <jQuery hashchange event> v1.3, which adds
//         document.title and document.domain support in IE6/7, BlackBerry
//         support, better Iframe hiding for accessibility reasons, and the new
//         <jQuery.fn.hashchange> "shortcut" method. Added the
//         <jQuery.param.sorted> method which reduces the possibility of
//         extraneous hashchange event triggering. Added the
//         <jQuery.param.fragment.ajaxCrawlable> method which can be used to
//         enable Google "AJAX Crawlable mode."
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release
(function ($, window) {
  '$:nomunge'; // Used by YUI compressor.
  // Some convenient shortcuts.

  var undefined,
      aps = Array.prototype.slice,
      decode = decodeURIComponent,
      // Method / object references.
  jq_param = $.param,
      jq_param_sorted,
      jq_param_fragment,
      jq_deparam,
      jq_deparam_fragment,
      jq_bbq = $.bbq = $.bbq || {},
      jq_bbq_pushState,
      jq_bbq_getState,
      jq_elemUrlAttr,
      special = $.event.special,
      // Reused strings.
  str_hashchange = 'hashchange',
      str_querystring = 'querystring',
      str_fragment = 'fragment',
      str_elemUrlAttr = 'elemUrlAttr',
      str_href = 'href',
      str_src = 'src',
      // Reused RegExp.
  re_params_querystring = /^.*\?|#.*$/g,
      re_params_fragment,
      re_fragment,
      re_no_escape,
      ajax_crawlable,
      fragment_prefix,
      // Used by jQuery.elemUrlAttr.
  elemUrlAttr_cache = {}; // A few commonly used bits, broken out to help reduce minified file size.

  function is_string(arg) {
    return typeof arg === 'string';
  }

  ; // Why write the same function twice? Let's curry! Mmmm, curry..

  function curry(func) {
    var args = aps.call(arguments, 1);
    return function () {
      return func.apply(this, args.concat(aps.call(arguments)));
    };
  }

  ; // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!

  function get_fragment(url) {
    return url.replace(re_fragment, '$2');
  }

  ; // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!

  function get_querystring(url) {
    return url.replace(/(?:^[^?#]*\?([^#]*).*$)?.*/, '$1');
  }

  ; // Section: Param (to string)
  //
  // Method: jQuery.param.querystring
  //
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.href.
  //
  // Usage:
  //
  // > jQuery.param.querystring( [ url ] );
  //
  // Arguments:
  //
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location.href is used.
  //
  // Returns:
  //
  //  (String) The parsed query string, with any leading "?" removed.
  //
  // Method: jQuery.param.querystring (build url)
  //
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  //
  // Usage:
  //
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  //
  // Arguments:
  //
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  //
  // Returns:
  //
  //  (String) A URL with a urlencoded query string in the format '?a=b&c=d&e=f'.
  // Method: jQuery.param.fragment
  //
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.href.
  //
  // Usage:
  //
  // > jQuery.param.fragment( [ url ] );
  //
  // Arguments:
  //
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location.href is used.
  //
  // Returns:
  //
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  // Method: jQuery.param.fragment (build url)
  //
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  //
  // Usage:
  //
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  //
  // Arguments:
  //
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  //
  // Returns:
  //
  //  (String) A URL with a urlencoded fragment (hash) in the format '#a=b&c=d&e=f'.

  function jq_param_sub(is_fragment, get_func, url, params, merge_mode) {
    var result, qs, matches, url_params, hash;

    if (params !== undefined) {
      // Build URL by merging params into url string.
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match(is_fragment ? re_fragment : /^([^#?]*)\??([^#]*)(#?.*)/); // Get the hash if in 'querystring' mode, and it exists.

      hash = matches[3] || '';

      if (merge_mode === 2 && is_string(params)) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace(is_fragment ? re_params_fragment : re_params_querystring, '');
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam(matches[2]);
        params = is_string(params) // Convert passed params string into object.
        ? jq_deparam[is_fragment ? str_fragment : str_querystring](params) // Passed params object.
        : params;
        qs = merge_mode === 2 ? params // passed params replace url params
        : merge_mode === 1 ? $.extend({}, params, url_params) // url params override passed params
        : $.extend({}, url_params, params); // passed params override url params
        // Convert params object into a sorted params string.

        qs = jq_param_sorted(qs); // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.

        if (is_fragment) {
          qs = qs.replace(re_no_escape, decode);
        }
      } // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.


      result = matches[1] + (is_fragment ? fragment_prefix : qs || !matches[1] ? '?' : '') + qs + hash;
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.href.
      result = get_func(url !== undefined ? url : location.href);
    }

    return result;
  }

  ;
  jq_param[str_querystring] = curry(jq_param_sub, 0, get_querystring);
  jq_param[str_fragment] = jq_param_fragment = curry(jq_param_sub, 1, get_fragment); // Method: jQuery.param.sorted
  //
  // Returns a params string equivalent to that returned by the internal
  // jQuery.param method, but sorted, which makes it suitable for use as a
  // cache key.
  //
  // For example, in most browsers jQuery.param({z:1,a:2}) returns "z=1&a=2"
  // and jQuery.param({a:2,z:1}) returns "a=2&z=1". Even though both the
  // objects being serialized and the resulting params strings are equivalent,
  // if these params strings were set into the location.hash fragment
  // sequentially, the hashchange event would be triggered unnecessarily, since
  // the strings are different (even though the data described by them is the
  // same). By sorting the params string, unecessary hashchange event triggering
  // can be avoided.
  //
  // Usage:
  //
  // > jQuery.param.sorted( obj [, traditional ] );
  //
  // Arguments:
  //
  //  obj - (Object) An object to be serialized.
  //  traditional - (Boolean) Params deep/shallow serialization mode. See the
  //    documentation at http://api.jquery.com/jQuery.param/ for more detail.
  //
  // Returns:
  //
  //  (String) A sorted params string.

  jq_param.sorted = jq_param_sorted = function (a, traditional) {
    var arr = [],
        obj = {};
    $.each(jq_param(a, traditional).split('&'), function (i, v) {
      var key = v.replace(/(?:%5B|=).*$/, ''),
          key_obj = obj[key];

      if (!key_obj) {
        key_obj = obj[key] = [];
        arr.push(key);
      }

      key_obj.push(v);
    });
    return $.map(arr.sort(), function (v) {
      return obj[v];
    }).join('&');
  }; // Method: jQuery.param.fragment.noEscape
  //
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  //
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  //
  // Usage:
  //
  // > jQuery.param.fragment.noEscape( [ chars ] );
  //
  // Arguments:
  //
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  //
  // Returns:
  //
  //  Nothing.


  jq_param_fragment.noEscape = function (chars) {
    chars = chars || '';
    var arr = $.map(chars.split(''), encodeURIComponent);
    re_no_escape = new RegExp(arr.join('|'), 'g');
  }; // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.


  jq_param_fragment.noEscape(',/'); // Method: jQuery.param.fragment.ajaxCrawlable
  //
  // TODO: DESCRIBE
  //
  // Usage:
  //
  // > jQuery.param.fragment.ajaxCrawlable( [ state ] );
  //
  // Arguments:
  //
  //  state - (Boolean) TODO: DESCRIBE
  //
  // Returns:
  //
  //  (Boolean) The current ajaxCrawlable state.

  jq_param_fragment.ajaxCrawlable = function (state) {
    if (state !== undefined) {
      if (state) {
        re_params_fragment = /^.*(?:#!|#)/;
        re_fragment = /^([^#]*)(?:#!|#)?(.*)$/;
        fragment_prefix = '#!';
      } else {
        re_params_fragment = /^.*#/;
        re_fragment = /^([^#]*)#?(.*)$/;
        fragment_prefix = '#';
      }

      ajax_crawlable = !!state;
    }

    return ajax_crawlable;
  };

  jq_param_fragment.ajaxCrawlable(0); // Section: Deparam (from string)
  //
  // Method: jQuery.deparam
  //
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  //
  // Usage:
  //
  // > jQuery.deparam( params [, coerce ] );
  //
  // Arguments:
  //
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.

  $.deparam = jq_deparam = function (params, coerce) {
    var obj = {},
        coerce_types = {
      'true': !0,
      'false': !1,
      'null': null
    }; // Iterate over all name=value pairs.

    $.each(params.replace(/\+/g, ' ').split('&'), function (j, v) {
      var param = v.split('='),
          key = decode(param[0]),
          val,
          cur = obj,
          i = 0,
          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
      // into its component parts.
      keys = key.split(']['),
          keys_last = keys.length - 1; // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.

      if (/\[/.test(keys[0]) && /\]$/.test(keys[keys_last])) {
        // Remove the trailing ] from the last keys part.
        keys[keys_last] = keys[keys_last].replace(/\]$/, ''); // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.

        keys = keys.shift().split('[').concat(keys);
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      } // Are we dealing with a name=value pair, or just a name?


      if (param.length === 2) {
        val = decode(param[1]); // Coerce values.

        if (coerce) {
          val = val && !isNaN(val) ? +val // number
          : val === 'undefined' ? undefined // undefined
          : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
          : val; // string
        }

        if (keys_last) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for (; i <= keys_last; i++) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : []) : val;
          }
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          if ($.isArray(obj[key])) {
            // val is already an array, so push on the next value.
            obj[key].push(val);
          } else if (obj[key] !== undefined) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [obj[key], val];
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
      } else if (key) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce ? undefined : '';
      }
    });
    return obj;
  }; // Method: jQuery.deparam.querystring
  //
  // Parse the query string from a URL or the current window.location.href,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  //
  // Usage:
  //
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  //
  // Arguments:
  //
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current
  //    window.location.href is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.
  // Method: jQuery.deparam.fragment
  //
  // Parse the fragment (hash) from a URL or the current window.location.href,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  //
  // Usage:
  //
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  //
  // Arguments:
  //
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location.href
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.


  function jq_deparam_sub(is_fragment, url_or_params, coerce) {
    if (url_or_params === undefined || typeof url_or_params === 'boolean') {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[is_fragment ? str_fragment : str_querystring]();
    } else {
      url_or_params = is_string(url_or_params) ? url_or_params.replace(is_fragment ? re_params_fragment : re_params_querystring, '') : url_or_params;
    }

    return jq_deparam(url_or_params, coerce);
  }

  ;
  jq_deparam[str_querystring] = curry(jq_deparam_sub, 0);
  jq_deparam[str_fragment] = jq_deparam_fragment = curry(jq_deparam_sub, 1); // Section: Element manipulation
  //
  // Method: jQuery.elemUrlAttr
  //
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  //
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  //
  // Default Tag-Attribute List:
  //
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  //
  // Usage:
  //
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  //
  // Arguments:
  //
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  //
  // Returns:
  //
  //  (Object) An object containing all stored tag-attribute values.
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.

  $[str_elemUrlAttr] || ($[str_elemUrlAttr] = function (obj) {
    return $.extend(elemUrlAttr_cache, obj);
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  jq_elemUrlAttr = $[str_elemUrlAttr]; // Method: jQuery.fn.querystring
  //
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  //
  // Usage:
  //
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  //
  // Arguments:
  //
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  //
  // Returns:
  //
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  // Method: jQuery.fn.fragment
  //
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  //
  // Usage:
  //
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  //
  // Arguments:
  //
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  //
  // Returns:
  //
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.

  function jq_fn_sub(mode, force_attr, params, merge_mode) {
    if (!is_string(params) && typeof params !== 'object') {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }

    return this.each(function () {
      var that = $(this),
          // Get attribute specified, or default specified via $.elemUrlAttr.
      attr = force_attr || jq_elemUrlAttr()[(this.nodeName || '').toLowerCase()] || '',
          // Get URL value.
      url = attr && that.attr(attr) || ''; // Update attribute with new URL.

      that.attr(attr, jq_param[mode](url, params, merge_mode));
    });
  }

  ;
  $.fn[str_querystring] = curry(jq_fn_sub, str_querystring);
  $.fn[str_fragment] = curry(jq_fn_sub, str_fragment); // Section: History, hashchange event
  //
  // Method: jQuery.bbq.pushState
  //
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  //
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  //
  // Usage:
  //
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  //
  // Arguments:
  //
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  //
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  //
  // Returns:
  //
  //  Nothing.
  //
  // Additional Notes:
  //
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.

  jq_bbq.pushState = jq_bbq_pushState = function (params, merge_mode) {
    if (is_string(params) && /^#/.test(params) && merge_mode === undefined) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }

    var has_args = params !== undefined,
        // Merge params into window.location using $.param.fragment.
    url = jq_param_fragment(location.href, has_args ? params : {}, has_args ? merge_mode : 2); // Set new window.location.href. Note that Safari 3 & Chrome barf on
    // location.hash = '#' so the entire URL is set.

    location.href = url;
  }; // Method: jQuery.bbq.getState
  //
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  //
  // Usage:
  //
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  //
  // Arguments:
  //
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  //
  // Returns:
  //
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.


  jq_bbq.getState = jq_bbq_getState = function (key, coerce) {
    return key === undefined || typeof key === 'boolean' ? jq_deparam_fragment(key) // 'key' really means 'coerce' here
    : jq_deparam_fragment(coerce)[key];
  }; // Method: jQuery.bbq.removeState
  //
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  //
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  //
  // Usage:
  //
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  //
  // Arguments:
  //
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  //
  // Returns:
  //
  //  Nothing.
  //
  // Additional Notes:
  //
  //  * Setting an empty state may cause the browser to scroll.


  jq_bbq.removeState = function (arr) {
    var state = {}; // If one or more arguments is passed..

    if (arr !== undefined) {
      // Get the current state.
      state = jq_bbq_getState(); // For each passed key, delete the corresponding property from the current
      // state.

      $.each($.isArray(arr) ? arr : arguments, function (i, v) {
        delete state[v];
      });
    } // Set the state, completely overriding any existing state.


    jq_bbq_pushState(state, 2);
  }; // Event: hashchange event (BBQ)
  //
  // Usage in jQuery 1.4 and newer:
  //
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  //
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  //
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  //
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  //
  // Usage in jQuery 1.3.2:
  //
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  //
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  //
  // Additional Notes:
  //
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.


  special[str_hashchange] = $.extend(special[str_hashchange], {
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function (handleObj) {
      var old_handler;

      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[str_fragment] = jq_param_fragment(); // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.

        e.getState = function (key, coerce) {
          return key === undefined || typeof key === 'boolean' ? jq_deparam(hash, key) // 'key' really means 'coerce' here
          : jq_deparam(hash, coerce)[key];
        };

        old_handler.apply(this, arguments);
      }

      ; // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+

      if ($.isFunction(handleObj)) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
  });
})(jQuery, this);
/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
// Script: jQuery hashchange event
//
// *Version: 1.3, Last updated: 7/21/2010*
//
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
//
// About: Known issues
//
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
//
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
//
// Also note that should a browser natively support the window.onhashchange
// event, but not report that it does, the fallback polling loop will be used.
//
// About: Release History
//
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.


(function ($, window, undefined) {
  '$:nomunge'; // Used by YUI compressor.
  // Reused string.

  var str_hashchange = 'hashchange',
      // Method / object references.
  doc = document,
      fake_onhashchange,
      special = $.event.special,
      // Does the browser support window.onhashchange? Note that IE8 running in
  // IE7 compatibility mode reports true for 'onhashchange' in window, even
  // though the event isn't supported, so also test document.documentMode.
  doc_mode = doc.documentMode,
      supports_onhashchange = 'on' + str_hashchange in window && (doc_mode === undefined || doc_mode > 7); // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!

  function get_fragment(url) {
    url = url || location.href;
    return '#' + url.replace(/^[^#]*#?(.*)$/, '$1');
  }

  ; // Method: jQuery.fn.hashchange
  //
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  //
  // Usage:
  //
  // > jQuery(window).hashchange( [ handler ] );
  //
  // Arguments:
  //
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  //
  // Returns:
  //
  //  (jQuery) The initial jQuery collection of elements.
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.

  $.fn[str_hashchange] = function (fn) {
    return fn ? this.bind(str_hashchange, fn) : this.trigger(str_hashchange);
  }; // Property: jQuery.fn.hashchange.delay
  //
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  // Property: jQuery.fn.hashchange.domain
  //
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  //
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  //
  // Usage:
  //
  // jQuery.fn.hashchange.domain = document.domain;
  // Property: jQuery.fn.hashchange.src
  //
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  //
  // Usage:
  //
  // jQuery.fn.hashchange.src = 'path/to/file.html';


  $.fn[str_hashchange].delay = 50;
  /*
   $.fn[ str_hashchange ].domain = null;
   $.fn[ str_hashchange ].src = null;
   */
  // Event: hashchange event
  //
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  //
  // Usage as described in <jQuery.fn.hashchange>:
  //
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // >
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  //
  // A more verbose usage that allows for event namespacing:
  //
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // >
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  //
  // Additional Notes:
  //
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).

  special[str_hashchange] = $.extend(special[str_hashchange], {
    // Called only when the first 'hashchange' event is bound to window.
    setup: function () {
      // If window.onhashchange is supported natively, there's nothing to do..
      if (supports_onhashchange) {
        return false;
      } // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.


      $(fake_onhashchange.start);
    },
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function () {
      // If window.onhashchange is supported natively, there's nothing to do..
      if (supports_onhashchange) {
        return false;
      } // Otherwise, we need to stop ours (if possible).


      $(fake_onhashchange.stop);
    }
  }); // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.

  fake_onhashchange = function () {
    var self = {},
        timeout_id,
        // Remember the initial hash so it doesn't get triggered immediately.
    last_hash = get_fragment(),
        fn_retval = function (val) {
      return val;
    },
        history_set = fn_retval,
        history_get = fn_retval; // Start the polling loop.


    self.start = function () {
      timeout_id || poll();
    }; // Stop the polling loop.


    self.stop = function () {
      timeout_id && clearTimeout(timeout_id);
      timeout_id = undefined;
    }; // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.


    function poll() {
      var hash = get_fragment(),
          history_hash = history_get(last_hash);

      if (hash !== last_hash) {
        history_set(last_hash = hash, history_hash);
        $(window).trigger(str_hashchange);
      } else if (history_hash !== last_hash) {
        location.href = location.href.replace(/#.*/, '') + history_hash;
      }

      timeout_id = setTimeout(poll, $.fn[str_hashchange].delay);
    }

    ; // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

    navigator.userAgent.match(/MSIE/i) !== null && !supports_onhashchange && function () {
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      var iframe, iframe_src; // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.

      self.start = function () {
        if (!iframe) {
          iframe_src = $.fn[str_hashchange].src;
          iframe_src = iframe_src && iframe_src + get_fragment(); // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.

          iframe = $('<iframe tabindex="-1" title="empty"/>').hide() // When Iframe has completely loaded, initialize the history and
          // start polling.
          .one('load', function () {
            iframe_src || history_set(get_fragment());
            poll();
          }) // Load Iframe src if specified, otherwise nothing.
          .attr('src', iframe_src || 'javascript:0') // Append Iframe after the end of the body to prevent unnecessary
          // initial page scrolling (yes, this works).
          .insertAfter('body')[0].contentWindow; // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.

          doc.onpropertychange = function () {
            try {
              if (event.propertyName === 'title') {
                iframe.document.title = doc.title;
              }
            } catch (e) {}
          };
        }
      }; // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!


      self.stop = fn_retval; // Get history by looking at the hidden Iframe's location.hash.

      history_get = function () {
        return get_fragment(iframe.location.href);
      }; // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.


      history_set = function (hash, history_hash) {
        var iframe_doc = iframe.document,
            domain = $.fn[str_hashchange].domain;

        if (hash !== history_hash) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title; // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.

          iframe_doc.open(); // Set document.domain for the Iframe document as well, if necessary.

          domain && iframe_doc.write('<script>document.domain="' + domain + '"</script>');
          iframe_doc.close(); // Update the Iframe's hash, for great justice.

          iframe.location.hash = hash;
        }
      };
    }(); // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    return self;
  }();
})(jQuery, this);
/* http://keith-wood.name/backgroundPos.html
 Background position animation for jQuery v1.1.1.
 Written by Keith Wood (kbwood{at}iinet.com.au) November 2010.
 Available under the MIT (https://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt) license.
 Please attribute the author if you use it. */
(function ($) {
  var g = !!$.Tween;

  if (g) {
    $.Tween.propHooks['backgroundPosition'] = {
      get: function (a) {
        return parseBackgroundPosition($(a.elem).css(a.prop));
      },
      set: setBackgroundPosition
    };
  } else {
    $.fx.step['backgroundPosition'] = setBackgroundPosition;
  }

  ;

  function parseBackgroundPosition(c) {
    var d = (c || '').split(/ /);
    var e = {
      center: '50%',
      left: '0%',
      right: '100%',
      top: '0%',
      bottom: '100%'
    };

    var f = function (a) {
      var b = (e[d[a]] || d[a] || '50%').match(/^([+-]=)?([+-]?\d+(\.\d*)?)(.*)$/);
      d[a] = [b[1], parseFloat(b[2]), b[4] || 'px'];
    };

    if (d.length == 1 && $.inArray(d[0], ['top', 'bottom']) > -1) {
      d[1] = d[0];
      d[0] = '50%';
    }

    f(0);
    f(1);
    return d;
  }

  function setBackgroundPosition(a) {
    if (!a.set) {
      initBackgroundPosition(a);
    }

    $(a.elem).css('background-position', a.pos * (a.end[0][1] - a.start[0][1]) + a.start[0][1] + a.end[0][2] + ' ' + (a.pos * (a.end[1][1] - a.start[1][1]) + a.start[1][1] + a.end[1][2]));
  }

  function initBackgroundPosition(a) {
    a.start = parseBackgroundPosition($(a.elem).css('backgroundPosition'));
    a.end = parseBackgroundPosition(a.end);

    for (var i = 0; i < a.end.length; i++) {
      if (a.end[i][0]) {
        a.end[i][1] = a.start[i][1] + (a.end[i][0] == '-=' ? -1 : +1) * a.end[i][1];
      }
    }

    a.set = true;
  }
})(jQuery);
/*jslint devel: true, bitwise: true, regexp: true, browser: true, confusion: true, unparam: true, eqeq: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4 */

/*globals jQuery,Color */

/*
 * ColorPicker
 *
 * Copyright (c) 2011-2013 Martijn W. van der Lee
 * Licensed under the MIT.
 *
 * Full-featured colorpicker for jQueryUI with full theming support.
 * Most images from jPicker by Christopher T. Tillman.
 * Sourcecode created from scratch by Martijn W. van der Lee.
 *
 * https://raw.github.com/vanderlee/colorpicker
 */
(function ($) {
  "use strict";

  $.colorpicker = new function () {
    this.regional = [];
    this.regional[''] = {
      ok: 'OK',
      cancel: 'Cancel',
      none: 'None',
      button: 'Color',
      title: 'Pick a color',
      transparent: 'Transparent',
      hsvH: 'H',
      hsvS: 'S',
      hsvV: 'V',
      rgbR: 'R',
      rgbG: 'G',
      rgbB: 'B',
      labL: 'L',
      labA: 'a',
      labB: 'b',
      hslH: 'H',
      hslS: 'S',
      hslL: 'L',
      cmykC: 'C',
      cmykM: 'M',
      cmykY: 'Y',
      cmykK: 'K',
      alphaA: 'A'
    };
    this.swatches = [];
    this.swatches['html'] = {
      'black': {
        r: 0,
        g: 0,
        b: 0
      },
      'dimgray': {
        r: 0.4117647058823529,
        g: 0.4117647058823529,
        b: 0.4117647058823529
      },
      'gray': {
        r: 0.5019607843137255,
        g: 0.5019607843137255,
        b: 0.5019607843137255
      },
      'darkgray': {
        r: 0.6627450980392157,
        g: 0.6627450980392157,
        b: 0.6627450980392157
      },
      'silver': {
        r: 0.7529411764705882,
        g: 0.7529411764705882,
        b: 0.7529411764705882
      },
      'lightgrey': {
        r: 0.8274509803921568,
        g: 0.8274509803921568,
        b: 0.8274509803921568
      },
      'gainsboro': {
        r: 0.8627450980392157,
        g: 0.8627450980392157,
        b: 0.8627450980392157
      },
      'whitesmoke': {
        r: 0.9607843137254902,
        g: 0.9607843137254902,
        b: 0.9607843137254902
      },
      'white': {
        r: 1,
        g: 1,
        b: 1
      },
      'rosybrown': {
        r: 0.7372549019607844,
        g: 0.5607843137254902,
        b: 0.5607843137254902
      },
      'indianred': {
        r: 0.803921568627451,
        g: 0.3607843137254902,
        b: 0.3607843137254902
      },
      'brown': {
        r: 0.6470588235294118,
        g: 0.16470588235294117,
        b: 0.16470588235294117
      },
      'firebrick': {
        r: 0.6980392156862745,
        g: 0.13333333333333333,
        b: 0.13333333333333333
      },
      'lightcoral': {
        r: 0.9411764705882353,
        g: 0.5019607843137255,
        b: 0.5019607843137255
      },
      'maroon': {
        r: 0.5019607843137255,
        g: 0,
        b: 0
      },
      'darkred': {
        r: 0.5450980392156862,
        g: 0,
        b: 0
      },
      'red': {
        r: 1,
        g: 0,
        b: 0
      },
      'snow': {
        r: 1,
        g: 0.9803921568627451,
        b: 0.9803921568627451
      },
      'salmon': {
        r: 0.9803921568627451,
        g: 0.5019607843137255,
        b: 0.4470588235294118
      },
      'mistyrose': {
        r: 1,
        g: 0.8941176470588236,
        b: 0.8823529411764706
      },
      'tomato': {
        r: 1,
        g: 0.38823529411764707,
        b: 0.2784313725490196
      },
      'darksalmon': {
        r: 0.9137254901960784,
        g: 0.5882352941176471,
        b: 0.47843137254901963
      },
      'orangered': {
        r: 1,
        g: 0.27058823529411763,
        b: 0
      },
      'coral': {
        r: 1,
        g: 0.4980392156862745,
        b: 0.3137254901960784
      },
      'lightsalmon': {
        r: 1,
        g: 0.6274509803921569,
        b: 0.47843137254901963
      },
      'sienna': {
        r: 0.6274509803921569,
        g: 0.3215686274509804,
        b: 0.17647058823529413
      },
      'seashell': {
        r: 1,
        g: 0.9607843137254902,
        b: 0.9333333333333333
      },
      'chocolate': {
        r: 0.8235294117647058,
        g: 0.4117647058823529,
        b: 0.11764705882352941
      },
      'saddlebrown': {
        r: 0.5450980392156862,
        g: 0.27058823529411763,
        b: 0.07450980392156863
      },
      'sandybrown': {
        r: 0.9568627450980393,
        g: 0.6431372549019608,
        b: 0.3764705882352941
      },
      'peachpuff': {
        r: 1,
        g: 0.8549019607843137,
        b: 0.7254901960784313
      },
      'peru': {
        r: 0.803921568627451,
        g: 0.5215686274509804,
        b: 0.24705882352941178
      },
      'linen': {
        r: 0.9803921568627451,
        g: 0.9411764705882353,
        b: 0.9019607843137255
      },
      'darkorange': {
        r: 1,
        g: 0.5490196078431373,
        b: 0
      },
      'bisque': {
        r: 1,
        g: 0.8941176470588236,
        b: 0.7686274509803922
      },
      'burlywood': {
        r: 0.8705882352941177,
        g: 0.7215686274509804,
        b: 0.5294117647058824
      },
      'tan': {
        r: 0.8235294117647058,
        g: 0.7058823529411765,
        b: 0.5490196078431373
      },
      'antiquewhite': {
        r: 0.9803921568627451,
        g: 0.9215686274509803,
        b: 0.8431372549019608
      },
      'navajowhite': {
        r: 1,
        g: 0.8705882352941177,
        b: 0.6784313725490196
      },
      'blanchedalmond': {
        r: 1,
        g: 0.9215686274509803,
        b: 0.803921568627451
      },
      'papayawhip': {
        r: 1,
        g: 0.9372549019607843,
        b: 0.8352941176470589
      },
      'orange': {
        r: 1,
        g: 0.6470588235294118,
        b: 0
      },
      'moccasin': {
        r: 1,
        g: 0.8941176470588236,
        b: 0.7098039215686275
      },
      'wheat': {
        r: 0.9607843137254902,
        g: 0.8705882352941177,
        b: 0.7019607843137254
      },
      'oldlace': {
        r: 0.9921568627450981,
        g: 0.9607843137254902,
        b: 0.9019607843137255
      },
      'floralwhite': {
        r: 1,
        g: 0.9803921568627451,
        b: 0.9411764705882353
      },
      'goldenrod': {
        r: 0.8549019607843137,
        g: 0.6470588235294118,
        b: 0.12549019607843137
      },
      'darkgoldenrod': {
        r: 0.7215686274509804,
        g: 0.5254901960784314,
        b: 0.043137254901960784
      },
      'cornsilk': {
        r: 1,
        g: 0.9725490196078431,
        b: 0.8627450980392157
      },
      'gold': {
        r: 1,
        g: 0.8431372549019608,
        b: 0
      },
      'palegoldenrod': {
        r: 0.9333333333333333,
        g: 0.9098039215686274,
        b: 0.6666666666666666
      },
      'khaki': {
        r: 0.9411764705882353,
        g: 0.9019607843137255,
        b: 0.5490196078431373
      },
      'lemonchiffon': {
        r: 1,
        g: 0.9803921568627451,
        b: 0.803921568627451
      },
      'darkkhaki': {
        r: 0.7411764705882353,
        g: 0.7176470588235294,
        b: 0.4196078431372549
      },
      'beige': {
        r: 0.9607843137254902,
        g: 0.9607843137254902,
        b: 0.8627450980392157
      },
      'lightgoldenrodyellow': {
        r: 0.9803921568627451,
        g: 0.9803921568627451,
        b: 0.8235294117647058
      },
      'olive': {
        r: 0.5019607843137255,
        g: 0.5019607843137255,
        b: 0
      },
      'yellow': {
        r: 1,
        g: 1,
        b: 0
      },
      'lightyellow': {
        r: 1,
        g: 1,
        b: 0.8784313725490196
      },
      'ivory': {
        r: 1,
        g: 1,
        b: 0.9411764705882353
      },
      'olivedrab': {
        r: 0.4196078431372549,
        g: 0.5568627450980392,
        b: 0.13725490196078433
      },
      'yellowgreen': {
        r: 0.6039215686274509,
        g: 0.803921568627451,
        b: 0.19607843137254902
      },
      'darkolivegreen': {
        r: 0.3333333333333333,
        g: 0.4196078431372549,
        b: 0.1843137254901961
      },
      'greenyellow': {
        r: 0.6784313725490196,
        g: 1,
        b: 0.1843137254901961
      },
      'lawngreen': {
        r: 0.48627450980392156,
        g: 0.9882352941176471,
        b: 0
      },
      'chartreuse': {
        r: 0.4980392156862745,
        g: 1,
        b: 0
      },
      'darkseagreen': {
        r: 0.5607843137254902,
        g: 0.7372549019607844,
        b: 0.5607843137254902
      },
      'forestgreen': {
        r: 0.13333333333333333,
        g: 0.5450980392156862,
        b: 0.13333333333333333
      },
      'limegreen': {
        r: 0.19607843137254902,
        g: 0.803921568627451,
        b: 0.19607843137254902
      },
      'lightgreen': {
        r: 0.5647058823529412,
        g: 0.9333333333333333,
        b: 0.5647058823529412
      },
      'palegreen': {
        r: 0.596078431372549,
        g: 0.984313725490196,
        b: 0.596078431372549
      },
      'darkgreen': {
        r: 0,
        g: 0.39215686274509803,
        b: 0
      },
      'green': {
        r: 0,
        g: 0.5019607843137255,
        b: 0
      },
      'lime': {
        r: 0,
        g: 1,
        b: 0
      },
      'honeydew': {
        r: 0.9411764705882353,
        g: 1,
        b: 0.9411764705882353
      },
      'mediumseagreen': {
        r: 0.23529411764705882,
        g: 0.7019607843137254,
        b: 0.44313725490196076
      },
      'seagreen': {
        r: 0.1803921568627451,
        g: 0.5450980392156862,
        b: 0.3411764705882353
      },
      'springgreen': {
        r: 0,
        g: 1,
        b: 0.4980392156862745
      },
      'mintcream': {
        r: 0.9607843137254902,
        g: 1,
        b: 0.9803921568627451
      },
      'mediumspringgreen': {
        r: 0,
        g: 0.9803921568627451,
        b: 0.6039215686274509
      },
      'mediumaquamarine': {
        r: 0.4,
        g: 0.803921568627451,
        b: 0.6666666666666666
      },
      'aquamarine': {
        r: 0.4980392156862745,
        g: 1,
        b: 0.8313725490196079
      },
      'turquoise': {
        r: 0.25098039215686274,
        g: 0.8784313725490196,
        b: 0.8156862745098039
      },
      'lightseagreen': {
        r: 0.12549019607843137,
        g: 0.6980392156862745,
        b: 0.6666666666666666
      },
      'mediumturquoise': {
        r: 0.2823529411764706,
        g: 0.8196078431372549,
        b: 0.8
      },
      'darkslategray': {
        r: 0.1843137254901961,
        g: 0.30980392156862746,
        b: 0.30980392156862746
      },
      'paleturquoise': {
        r: 0.6862745098039216,
        g: 0.9333333333333333,
        b: 0.9333333333333333
      },
      'teal': {
        r: 0,
        g: 0.5019607843137255,
        b: 0.5019607843137255
      },
      'darkcyan': {
        r: 0,
        g: 0.5450980392156862,
        b: 0.5450980392156862
      },
      'darkturquoise': {
        r: 0,
        g: 0.807843137254902,
        b: 0.8196078431372549
      },
      'aqua': {
        r: 0,
        g: 1,
        b: 1
      },
      'cyan': {
        r: 0,
        g: 1,
        b: 1
      },
      'lightcyan': {
        r: 0.8784313725490196,
        g: 1,
        b: 1
      },
      'azure': {
        r: 0.9411764705882353,
        g: 1,
        b: 1
      },
      'cadetblue': {
        r: 0.37254901960784315,
        g: 0.6196078431372549,
        b: 0.6274509803921569
      },
      'powderblue': {
        r: 0.6901960784313725,
        g: 0.8784313725490196,
        b: 0.9019607843137255
      },
      'lightblue': {
        r: 0.6784313725490196,
        g: 0.8470588235294118,
        b: 0.9019607843137255
      },
      'deepskyblue': {
        r: 0,
        g: 0.7490196078431373,
        b: 1
      },
      'skyblue': {
        r: 0.5294117647058824,
        g: 0.807843137254902,
        b: 0.9215686274509803
      },
      'lightskyblue': {
        r: 0.5294117647058824,
        g: 0.807843137254902,
        b: 0.9803921568627451
      },
      'steelblue': {
        r: 0.27450980392156865,
        g: 0.5098039215686274,
        b: 0.7058823529411765
      },
      'aliceblue': {
        r: 0.9411764705882353,
        g: 0.9725490196078431,
        b: 1
      },
      'dodgerblue': {
        r: 0.11764705882352941,
        g: 0.5647058823529412,
        b: 1
      },
      'slategray': {
        r: 0.4392156862745098,
        g: 0.5019607843137255,
        b: 0.5647058823529412
      },
      'lightslategray': {
        r: 0.4666666666666667,
        g: 0.5333333333333333,
        b: 0.6
      },
      'lightsteelblue': {
        r: 0.6901960784313725,
        g: 0.7686274509803922,
        b: 0.8705882352941177
      },
      'cornflowerblue': {
        r: 0.39215686274509803,
        g: 0.5843137254901961,
        b: 0.9294117647058824
      },
      'royalblue': {
        r: 0.2549019607843137,
        g: 0.4117647058823529,
        b: 0.8823529411764706
      },
      'midnightblue': {
        r: 0.09803921568627451,
        g: 0.09803921568627451,
        b: 0.4392156862745098
      },
      'lavender': {
        r: 0.9019607843137255,
        g: 0.9019607843137255,
        b: 0.9803921568627451
      },
      'navy': {
        r: 0,
        g: 0,
        b: 0.5019607843137255
      },
      'darkblue': {
        r: 0,
        g: 0,
        b: 0.5450980392156862
      },
      'mediumblue': {
        r: 0,
        g: 0,
        b: 0.803921568627451
      },
      'blue': {
        r: 0,
        g: 0,
        b: 1
      },
      'ghostwhite': {
        r: 0.9725490196078431,
        g: 0.9725490196078431,
        b: 1
      },
      'darkslateblue': {
        r: 0.2823529411764706,
        g: 0.23921568627450981,
        b: 0.5450980392156862
      },
      'slateblue': {
        r: 0.41568627450980394,
        g: 0.35294117647058826,
        b: 0.803921568627451
      },
      'mediumslateblue': {
        r: 0.4823529411764706,
        g: 0.40784313725490196,
        b: 0.9333333333333333
      },
      'mediumpurple': {
        r: 0.5764705882352941,
        g: 0.4392156862745098,
        b: 0.8588235294117647
      },
      'blueviolet': {
        r: 0.5411764705882353,
        g: 0.16862745098039217,
        b: 0.8862745098039215
      },
      'indigo': {
        r: 0.29411764705882354,
        g: 0,
        b: 0.5098039215686274
      },
      'darkorchid': {
        r: 0.6,
        g: 0.19607843137254902,
        b: 0.8
      },
      'darkviolet': {
        r: 0.5803921568627451,
        g: 0,
        b: 0.8274509803921568
      },
      'mediumorchid': {
        r: 0.7294117647058823,
        g: 0.3333333333333333,
        b: 0.8274509803921568
      },
      'thistle': {
        r: 0.8470588235294118,
        g: 0.7490196078431373,
        b: 0.8470588235294118
      },
      'plum': {
        r: 0.8666666666666667,
        g: 0.6274509803921569,
        b: 0.8666666666666667
      },
      'violet': {
        r: 0.9333333333333333,
        g: 0.5098039215686274,
        b: 0.9333333333333333
      },
      'purple': {
        r: 0.5019607843137255,
        g: 0,
        b: 0.5019607843137255
      },
      'darkmagenta': {
        r: 0.5450980392156862,
        g: 0,
        b: 0.5450980392156862
      },
      'magenta': {
        r: 1,
        g: 0,
        b: 1
      },
      'fuchsia': {
        r: 1,
        g: 0,
        b: 1
      },
      'orchid': {
        r: 0.8549019607843137,
        g: 0.4392156862745098,
        b: 0.8392156862745098
      },
      'mediumvioletred': {
        r: 0.7803921568627451,
        g: 0.08235294117647059,
        b: 0.5215686274509804
      },
      'deeppink': {
        r: 1,
        g: 0.0784313725490196,
        b: 0.5764705882352941
      },
      'hotpink': {
        r: 1,
        g: 0.4117647058823529,
        b: 0.7058823529411765
      },
      'palevioletred': {
        r: 0.8588235294117647,
        g: 0.4392156862745098,
        b: 0.5764705882352941
      },
      'lavenderblush': {
        r: 1,
        g: 0.9411764705882353,
        b: 0.9607843137254902
      },
      'crimson': {
        r: 0.8627450980392157,
        g: 0.0784313725490196,
        b: 0.23529411764705882
      },
      'pink': {
        r: 1,
        g: 0.7529411764705882,
        b: 0.796078431372549
      },
      'lightpink': {
        r: 1,
        g: 0.7137254901960784,
        b: 0.7568627450980392
      }
    };
  }();

  var _colorpicker_index = 0,
      _container_popup = '<div class="ui-colorpicker ui-colorpicker-dialog ui-dialog ui-widget ui-widget-content ui-corner-all" style="display: none;"></div>',
      _container_inline = '<div class="ui-colorpicker ui-colorpicker-inline ui-dialog ui-widget ui-widget-content ui-corner-all"></div>',
      _parts_lists = {
    'full': ['header', 'map', 'bar', 'hex', 'hsv', 'rgb', 'alpha', 'lab', 'cmyk', 'preview', 'swatches', 'footer'],
    'popup': ['map', 'bar', 'hex', 'hsv', 'rgb', 'alpha', 'preview', 'footer'],
    'draggable': ['header', 'map', 'bar', 'hex', 'hsv', 'rgb', 'alpha', 'preview', 'footer'],
    'inline': ['map', 'bar', 'hex', 'hsv', 'rgb', 'alpha', 'preview']
  },
      _intToHex = function (dec) {
    var result = Math.round(dec).toString(16);

    if (result.length === 1) {
      result = '0' + result;
    }

    return result.toLowerCase();
  },
      _parseHex = function (color) {
    var c, m; // {#}rrggbb

    m = /^#?([a-fA-F0-9]{1,6})$/.exec(color);

    if (m) {
      c = parseInt(m[1], 16);
      return new Color((c >> 16 & 0xFF) / 255, (c >> 8 & 0xFF) / 255, (c & 0xFF) / 255);
    }

    return new Color();
  },
      _layoutTable = function (layout, callback) {
    var bitmap, x, y, width, height, columns, rows, index, cell, html, w, h, colspan, walked;
    layout.sort(function (a, b) {
      if (a.pos[1] == b.pos[1]) {
        return a.pos[0] - b.pos[0];
      }

      return a.pos[1] - b.pos[1];
    }); // Determine dimensions of the table

    width = 0;
    height = 0;
    $.each(layout, function (index, part) {
      width = Math.max(width, part.pos[0] + part.pos[2]);
      height = Math.max(height, part.pos[1] + part.pos[3]);
    }); // Initialize bitmap

    bitmap = [];

    for (x = 0; x < width; ++x) {
      bitmap.push([]);
    } // Mark rows and columns which have layout assigned


    rows = [];
    columns = [];
    $.each(layout, function (index, part) {
      // mark columns
      for (x = 0; x < part.pos[2]; x += 1) {
        columns[part.pos[0] + x] = true;
      }

      for (y = 0; y < part.pos[3]; y += 1) {
        rows[part.pos[1] + y] = true;
      }
    }); // Generate the table

    html = '';
    cell = layout[index = 0];

    for (y = 0; y < height; ++y) {
      html += '<tr>';

      for (x = 0; x < width; x) {
        if (typeof cell !== 'undefined' && x == cell.pos[0] && y == cell.pos[1]) {
          // Create a "real" cell
          html += callback(cell, x, y);

          for (h = 0; h < cell.pos[3]; h += 1) {
            for (w = 0; w < cell.pos[2]; w += 1) {
              bitmap[x + w][y + h] = true;
            }
          }

          x += cell.pos[2];
          cell = layout[++index];
        } else {
          // Fill in the gaps
          colspan = 0;
          walked = false;

          while (x < width && bitmap[x][y] === undefined && (cell === undefined || y < cell.pos[1] || y == cell.pos[1] && x < cell.pos[0])) {
            if (columns[x] === true) {
              colspan += 1;
            }

            walked = true;
            x += 1;
          }

          if (colspan > 0) {
            html += '<td colspan="' + colspan + '"></td>';
          } else if (!walked) {
            x += 1;
          }
        }
      }

      html += '</tr>';
    }

    return '<table cellspacing="0" cellpadding="0" border="0"><tbody>' + html + '</tbody></table>';
  },
      _parts = {
    header: function (inst) {
      var that = this,
          e = null,
          _html = function () {
        var title = inst.options.title || inst._getRegional('title'),
            html = '<span class="ui-dialog-title">' + title + '</span>';

        if (!inst.inline && inst.options.showCloseButton) {
          html += '<a href="#" class="ui-dialog-titlebar-close ui-corner-all" role="button">' + '<span class="ui-icon ui-icon-closethick">close</span></a>';
        }

        return '<div class="ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix">' + html + '</div>';
      };

      this.init = function () {
        e = $(_html()).prependTo(inst.dialog);
        var close = $('.ui-dialog-titlebar-close', e);

        inst._hoverable(close);

        inst._focusable(close);

        close.click(function (event) {
          event.preventDefault();
          inst.close();
        });

        if (!inst.inline && inst.options.draggable) {
          inst.dialog.draggable({
            handle: e
          });
        }
      };
    },
    map: function (inst) {
      var that = this,
          e = null,
          mousemove_timeout = null,
          _mousedown,
          _mouseup,
          _mousemove,
          _html;

      _mousedown = function (event) {
        if (!inst.opened) {
          return;
        }

        var div = $('.ui-colorpicker-map-layer-pointer', e),
            offset = div.offset(),
            width = div.width(),
            height = div.height(),
            x = event.pageX - offset.left,
            y = event.pageY - offset.top;

        if (x >= 0 && x < width && y >= 0 && y < height) {
          event.stopImmediatePropagation();
          event.preventDefault();
          e.unbind('mousedown', _mousedown);
          $(document).bind('mouseup', _mouseup);
          $(document).bind('mousemove', _mousemove);

          _mousemove(event);
        }
      };

      _mouseup = function (event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        $(document).unbind('mouseup', _mouseup);
        $(document).unbind('mousemove', _mousemove);
        e.bind('mousedown', _mousedown);
      };

      _mousemove = function (event) {
        event.stopImmediatePropagation();
        event.preventDefault();

        if (event.pageX === that.x && event.pageY === that.y) {
          return;
        }

        that.x = event.pageX;
        that.y = event.pageY;
        var div = $('.ui-colorpicker-map-layer-pointer', e),
            offset = div.offset(),
            width = div.width(),
            height = div.height(),
            x = event.pageX - offset.left,
            y = event.pageY - offset.top;
        x = Math.max(0, Math.min(x / width, 1));
        y = Math.max(0, Math.min(y / height, 1)); // interpret values

        switch (inst.mode) {
          case 'h':
            inst.color.setHSV(null, x, 1 - y);
            break;

          case 's':
          case 'a':
            inst.color.setHSV(x, null, 1 - y);
            break;

          case 'v':
            inst.color.setHSV(x, 1 - y, null);
            break;

          case 'r':
            inst.color.setRGB(null, 1 - y, x);
            break;

          case 'g':
            inst.color.setRGB(1 - y, null, x);
            break;

          case 'b':
            inst.color.setRGB(x, 1 - y, null);
            break;
        }

        inst._change();
      };

      _html = function () {
        var html = '<div class="ui-colorpicker-map ui-colorpicker-border">' + '<span class="ui-colorpicker-map-layer-1">&nbsp;</span>' + '<span class="ui-colorpicker-map-layer-2">&nbsp;</span>' + (inst.options.alpha ? '<span class="ui-colorpicker-map-layer-alpha">&nbsp;</span>' : '') + '<span class="ui-colorpicker-map-layer-pointer"><span class="ui-colorpicker-map-pointer"></span></span></div>';
        return html;
      };

      this.update = function () {
        switch (inst.mode) {
          case 'h':
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 0',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).hide();
            break;

          case 's':
          case 'a':
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 -260px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).css({
              'background-position': '0 -520px',
              'opacity': ''
            }).show();
            break;

          case 'v':
            $(e).css('background-color', 'black');
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 -780px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).hide();
            break;

          case 'r':
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 -1040px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).css({
              'background-position': '0 -1300px',
              'opacity': ''
            }).show();
            break;

          case 'g':
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 -1560px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).css({
              'background-position': '0 -1820px',
              'opacity': ''
            }).show();
            break;

          case 'b':
            $('.ui-colorpicker-map-layer-1', e).css({
              'background-position': '0 -2080px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-map-layer-2', e).css({
              'background-position': '0 -2340px',
              'opacity': ''
            }).show();
            break;
        }

        that.repaint();
      };

      this.repaint = function () {
        var div = $('.ui-colorpicker-map-layer-pointer', e),
            x = 0,
            y = 0;

        switch (inst.mode) {
          case 'h':
            x = inst.color.getHSV().s * div.width();
            y = (1 - inst.color.getHSV().v) * div.width();
            $(e).css('background-color', inst.color.copy().normalize().toCSS());
            break;

          case 's':
          case 'a':
            x = inst.color.getHSV().h * div.width();
            y = (1 - inst.color.getHSV().v) * div.width();
            $('.ui-colorpicker-map-layer-2', e).css('opacity', 1 - inst.color.getHSV().s);
            break;

          case 'v':
            x = inst.color.getHSV().h * div.width();
            y = (1 - inst.color.getHSV().s) * div.width();
            $('.ui-colorpicker-map-layer-1', e).css('opacity', inst.color.getHSV().v);
            break;

          case 'r':
            x = inst.color.getRGB().b * div.width();
            y = (1 - inst.color.getRGB().g) * div.width();
            $('.ui-colorpicker-map-layer-2', e).css('opacity', inst.color.getRGB().r);
            break;

          case 'g':
            x = inst.color.getRGB().b * div.width();
            y = (1 - inst.color.getRGB().r) * div.width();
            $('.ui-colorpicker-map-layer-2', e).css('opacity', inst.color.getRGB().g);
            break;

          case 'b':
            x = inst.color.getRGB().r * div.width();
            y = (1 - inst.color.getRGB().g) * div.width();
            $('.ui-colorpicker-map-layer-2', e).css('opacity', inst.color.getRGB().b);
            break;
        }

        if (inst.options.alpha) {
          $('.ui-colorpicker-map-layer-alpha', e).css('opacity', 1 - inst.color.getAlpha());
        }

        $('.ui-colorpicker-map-pointer', e).css({
          'left': x - 7,
          'top': y - 7
        });
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-map-container', inst.dialog));
        e.bind('mousedown', _mousedown);
      };
    },
    bar: function (inst) {
      var that = this,
          e = null,
          _mousedown,
          _mouseup,
          _mousemove,
          _html;

      _mousedown = function (event) {
        if (!inst.opened) {
          return;
        }

        var div = $('.ui-colorpicker-bar-layer-pointer', e),
            offset = div.offset(),
            width = div.width(),
            height = div.height(),
            x = event.pageX - offset.left,
            y = event.pageY - offset.top;

        if (x >= 0 && x < width && y >= 0 && y < height) {
          event.stopImmediatePropagation();
          event.preventDefault();
          e.unbind('mousedown', _mousedown);
          $(document).bind('mouseup', _mouseup);
          $(document).bind('mousemove', _mousemove);

          _mousemove(event);
        }
      };

      _mouseup = function (event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        $(document).unbind('mouseup', _mouseup);
        $(document).unbind('mousemove', _mousemove);
        e.bind('mousedown', _mousedown);
      };

      _mousemove = function (event) {
        event.stopImmediatePropagation();
        event.preventDefault();

        if (event.pageY === that.y) {
          return;
        }

        that.y = event.pageY;
        var div = $('.ui-colorpicker-bar-layer-pointer', e),
            offset = div.offset(),
            height = div.height(),
            y = event.pageY - offset.top;
        y = Math.max(0, Math.min(y / height, 1)); // interpret values

        switch (inst.mode) {
          case 'h':
            inst.color.setHSV(1 - y, null, null);
            break;

          case 's':
            inst.color.setHSV(null, 1 - y, null);
            break;

          case 'v':
            inst.color.setHSV(null, null, 1 - y);
            break;

          case 'r':
            inst.color.setRGB(1 - y, null, null);
            break;

          case 'g':
            inst.color.setRGB(null, 1 - y, null);
            break;

          case 'b':
            inst.color.setRGB(null, null, 1 - y);
            break;

          case 'a':
            inst.color.setAlpha(1 - y);
            break;
        }

        inst._change();
      };

      _html = function () {
        var html = '<div class="ui-colorpicker-bar ui-colorpicker-border">' + '<span class="ui-colorpicker-bar-layer-1">&nbsp;</span>' + '<span class="ui-colorpicker-bar-layer-2">&nbsp;</span>' + '<span class="ui-colorpicker-bar-layer-3">&nbsp;</span>' + '<span class="ui-colorpicker-bar-layer-4">&nbsp;</span>';

        if (inst.options.alpha) {
          html += '<span class="ui-colorpicker-bar-layer-alpha">&nbsp;</span>' + '<span class="ui-colorpicker-bar-layer-alphabar">&nbsp;</span>';
        }

        html += '<span class="ui-colorpicker-bar-layer-pointer"><span class="ui-colorpicker-bar-pointer"></span></span></div>';
        return html;
      };

      this.update = function () {
        switch (inst.mode) {
          case 'h':
          case 's':
          case 'v':
          case 'r':
          case 'g':
          case 'b':
            $('.ui-colorpicker-bar-layer-alpha', e).show();
            $('.ui-colorpicker-bar-layer-alphabar', e).hide();
            break;

          case 'a':
            $('.ui-colorpicker-bar-layer-alpha', e).hide();
            $('.ui-colorpicker-bar-layer-alphabar', e).show();
            break;
        }

        switch (inst.mode) {
          case 'h':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 0',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).hide();
            $('.ui-colorpicker-bar-layer-3', e).hide();
            $('.ui-colorpicker-bar-layer-4', e).hide();
            break;

          case 's':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 -260px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).css({
              'background-position': '0 -520px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-3', e).hide();
            $('.ui-colorpicker-bar-layer-4', e).hide();
            break;

          case 'v':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 -520px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).hide();
            $('.ui-colorpicker-bar-layer-3', e).hide();
            $('.ui-colorpicker-bar-layer-4', e).hide();
            break;

          case 'r':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 -1560px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).css({
              'background-position': '0 -1300px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-3', e).css({
              'background-position': '0 -780px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-4', e).css({
              'background-position': '0 -1040px',
              'opacity': ''
            }).show();
            break;

          case 'g':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 -2600px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).css({
              'background-position': '0 -2340px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-3', e).css({
              'background-position': '0 -1820px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-4', e).css({
              'background-position': '0 -2080px',
              'opacity': ''
            }).show();
            break;

          case 'b':
            $('.ui-colorpicker-bar-layer-1', e).css({
              'background-position': '0 -3640px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-2', e).css({
              'background-position': '0 -3380px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-3', e).css({
              'background-position': '0 -2860px',
              'opacity': ''
            }).show();
            $('.ui-colorpicker-bar-layer-4', e).css({
              'background-position': '0 -3120px',
              'opacity': ''
            }).show();
            break;

          case 'a':
            $('.ui-colorpicker-bar-layer-1', e).hide();
            $('.ui-colorpicker-bar-layer-2', e).hide();
            $('.ui-colorpicker-bar-layer-3', e).hide();
            $('.ui-colorpicker-bar-layer-4', e).hide();
            break;
        }

        that.repaint();
      };

      this.repaint = function () {
        var div = $('.ui-colorpicker-bar-layer-pointer', e),
            y = 0;

        switch (inst.mode) {
          case 'h':
            y = (1 - inst.color.getHSV().h) * div.height();
            break;

          case 's':
            y = (1 - inst.color.getHSV().s) * div.height();
            $('.ui-colorpicker-bar-layer-2', e).css('opacity', 1 - inst.color.getHSV().v);
            $(e).css('background-color', inst.color.copy().normalize().toCSS());
            break;

          case 'v':
            y = (1 - inst.color.getHSV().v) * div.height();
            $(e).css('background-color', inst.color.copy().normalize().toCSS());
            break;

          case 'r':
            y = (1 - inst.color.getRGB().r) * div.height();
            $('.ui-colorpicker-bar-layer-2', e).css('opacity', Math.max(0, inst.color.getRGB().b - inst.color.getRGB().g));
            $('.ui-colorpicker-bar-layer-3', e).css('opacity', Math.max(0, inst.color.getRGB().g - inst.color.getRGB().b));
            $('.ui-colorpicker-bar-layer-4', e).css('opacity', Math.min(inst.color.getRGB().b, inst.color.getRGB().g));
            break;

          case 'g':
            y = (1 - inst.color.getRGB().g) * div.height();
            $('.ui-colorpicker-bar-layer-2', e).css('opacity', Math.max(0, inst.color.getRGB().b - inst.color.getRGB().r));
            $('.ui-colorpicker-bar-layer-3', e).css('opacity', Math.max(0, inst.color.getRGB().r - inst.color.getRGB().b));
            $('.ui-colorpicker-bar-layer-4', e).css('opacity', Math.min(inst.color.getRGB().r, inst.color.getRGB().b));
            break;

          case 'b':
            y = (1 - inst.color.getRGB().b) * div.height();
            $('.ui-colorpicker-bar-layer-2', e).css('opacity', Math.max(0, inst.color.getRGB().r - inst.color.getRGB().g));
            $('.ui-colorpicker-bar-layer-3', e).css('opacity', Math.max(0, inst.color.getRGB().g - inst.color.getRGB().r));
            $('.ui-colorpicker-bar-layer-4', e).css('opacity', Math.min(inst.color.getRGB().r, inst.color.getRGB().g));
            break;

          case 'a':
            y = (1 - inst.color.getAlpha()) * div.height();
            $(e).css('background-color', inst.color.copy().normalize().toCSS());
            break;
        }

        if (inst.mode !== 'a') {
          $('.ui-colorpicker-bar-layer-alpha', e).css('opacity', 1 - inst.color.getAlpha());
        }

        $('.ui-colorpicker-bar-pointer', e).css('top', y - 3);
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-bar-container', inst.dialog));
        e.bind('mousedown', _mousedown);
      };
    },
    preview: function (inst) {
      var that = this,
          e = null,
          _html;

      _html = function () {
        return '<div class="ui-colorpicker-preview ui-colorpicker-border">' + '<div class="ui-colorpicker-preview-initial"><div class="ui-colorpicker-preview-initial-alpha"></div></div>' + '<div class="ui-colorpicker-preview-current"><div class="ui-colorpicker-preview-current-alpha"></div></div>' + '</div>';
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-preview-container', inst.dialog));
        $('.ui-colorpicker-preview-initial', e).click(function () {
          inst.color = inst.currentColor.copy();

          inst._change();
        });
      };

      this.update = function () {
        if (inst.options.alpha) {
          $('.ui-colorpicker-preview-initial-alpha, .ui-colorpicker-preview-current-alpha', e).show();
        } else {
          $('.ui-colorpicker-preview-initial-alpha, .ui-colorpicker-preview-current-alpha', e).hide();
        }

        this.repaint();
      };

      this.repaint = function () {
        $('.ui-colorpicker-preview-initial', e).css('background-color', inst.currentColor.toCSS()).attr('title', inst.currentColor.toHex());
        $('.ui-colorpicker-preview-initial-alpha', e).css('opacity', 1 - inst.currentColor.getAlpha());
        $('.ui-colorpicker-preview-current', e).css('background-color', inst.color.toCSS()).attr('title', inst.color.toHex());
        $('.ui-colorpicker-preview-current-alpha', e).css('opacity', 1 - inst.color.getAlpha());
      };
    },
    hsv: function (inst) {
      var that = this,
          e = null,
          _html;

      _html = function () {
        var html = '';

        if (inst.options.hsv) {
          html += '<div class="ui-colorpicker-hsv-h"><input class="ui-colorpicker-mode" type="radio" value="h"/><label>' + inst._getRegional('hsvH') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="360" size="10"/><span class="ui-colorpicker-unit">&deg;</span></div>' + '<div class="ui-colorpicker-hsv-s"><input class="ui-colorpicker-mode" type="radio" value="s"/><label>' + inst._getRegional('hsvS') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100" size="10"/><span class="ui-colorpicker-unit">%</span></div>' + '<div class="ui-colorpicker-hsv-v"><input class="ui-colorpicker-mode" type="radio" value="v"/><label>' + inst._getRegional('hsvV') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100" size="10"/><span class="ui-colorpicker-unit">%</span></div>';
        }

        return '<div class="ui-colorpicker-hsv">' + html + '</div>';
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-hsv-container', inst.dialog));
        $('.ui-colorpicker-mode', e).click(function () {
          inst.mode = $(this).val();

          inst._updateAllParts();
        });
        $('.ui-colorpicker-number', e).bind('change keyup', function () {
          inst.color.setHSV($('.ui-colorpicker-hsv-h .ui-colorpicker-number', e).val() / 360, $('.ui-colorpicker-hsv-s .ui-colorpicker-number', e).val() / 100, $('.ui-colorpicker-hsv-v .ui-colorpicker-number', e).val() / 100);

          inst._change();
        });
      };

      this.repaint = function () {
        var hsv = inst.color.getHSV();
        hsv.h *= 360;
        hsv.s *= 100;
        hsv.v *= 100;
        $.each(hsv, function (index, value) {
          var input = $('.ui-colorpicker-hsv-' + index + ' .ui-colorpicker-number', e);
          value = Math.round(value);

          if (input.val() !== value) {
            input.val(value);
          }
        });
      };

      this.update = function () {
        $('.ui-colorpicker-mode', e).each(function () {
          $(this).attr('checked', $(this).val() === inst.mode);
        });
        this.repaint();
      };
    },
    rgb: function (inst) {
      var that = this,
          e = null,
          _html;

      _html = function () {
        var html = '';

        if (inst.options.rgb) {
          html += '<div class="ui-colorpicker-rgb-r"><input class="ui-colorpicker-mode" type="radio" value="r"/><label>' + inst._getRegional('rgbR') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="255"/></div>' + '<div class="ui-colorpicker-rgb-g"><input class="ui-colorpicker-mode" type="radio" value="g"/><label>' + inst._getRegional('rgbG') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="255"/></div>' + '<div class="ui-colorpicker-rgb-b"><input class="ui-colorpicker-mode" type="radio" value="b"/><label>' + inst._getRegional('rgbB') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="255"/></div>';
        }

        return '<div class="ui-colorpicker-rgb">' + html + '</div>';
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-rgb-container', inst.dialog));
        $('.ui-colorpicker-mode', e).click(function () {
          inst.mode = $(this).val();

          inst._updateAllParts();
        });
        $('.ui-colorpicker-number', e).bind('change keyup', function () {
          inst.color.setRGB($('.ui-colorpicker-rgb-r .ui-colorpicker-number', e).val() / 255, $('.ui-colorpicker-rgb-g .ui-colorpicker-number', e).val() / 255, $('.ui-colorpicker-rgb-b .ui-colorpicker-number', e).val() / 255);

          inst._change();
        });
      };

      this.repaint = function () {
        $.each(inst.color.getRGB(), function (index, value) {
          var input = $('.ui-colorpicker-rgb-' + index + ' .ui-colorpicker-number', e);
          value = Math.round(value * 255);

          if (input.val() !== value) {
            input.val(value);
          }
        });
      };

      this.update = function () {
        $('.ui-colorpicker-mode', e).each(function () {
          $(this).attr('checked', $(this).val() === inst.mode);
        });
        this.repaint();
      };
    },
    lab: function (inst) {
      var that = this,
          part = null,
          html = function () {
        var html = '';

        if (inst.options.hsv) {
          html += '<div class="ui-colorpicker-lab-l"><label>' + inst._getRegional('labL') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/></div>' + '<div class="ui-colorpicker-lab-a"><label>' + inst._getRegional('labA') + '</label><input class="ui-colorpicker-number" type="number" min="-128" max="127"/></div>' + '<div class="ui-colorpicker-lab-b"><label>' + inst._getRegional('labB') + '</label><input class="ui-colorpicker-number" type="number" min="-128" max="127"/></div>';
        }

        return '<div class="ui-colorpicker-lab">' + html + '</div>';
      };

      this.init = function () {
        var data = 0;
        part = $(html()).appendTo($('.ui-colorpicker-lab-container', inst.dialog));
        $('.ui-colorpicker-number', part).on('change keyup', function (event) {
          inst.color.setLAB(parseInt($('.ui-colorpicker-lab-l .ui-colorpicker-number', part).val(), 10) / 100, (parseInt($('.ui-colorpicker-lab-a .ui-colorpicker-number', part).val(), 10) + 128) / 255, (parseInt($('.ui-colorpicker-lab-b .ui-colorpicker-number', part).val(), 10) + 128) / 255);

          inst._change();
        });
      };

      this.repaint = function () {
        var lab = inst.color.getLAB();
        lab.l *= 100;
        lab.a = lab.a * 255 - 128;
        lab.b = lab.b * 255 - 128;
        $.each(lab, function (index, value) {
          var input = $('.ui-colorpicker-lab-' + index + ' .ui-colorpicker-number', part);
          value = Math.round(value);

          if (input.val() !== value) {
            input.val(value);
          }
        });
      };

      this.update = function () {
        this.repaint();
      };
    },
    cmyk: function (inst) {
      var that = this,
          part = null,
          html = function () {
        var html = '';

        if (inst.options.hsv) {
          html += '<div class="ui-colorpicker-cmyk-c"><label>' + inst._getRegional('cmykC') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/><span class="ui-colorpicker-unit">%</span></div>' + '<div class="ui-colorpicker-cmyk-m"><label>' + inst._getRegional('cmykM') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/><span class="ui-colorpicker-unit">%</span></div>' + '<div class="ui-colorpicker-cmyk-y"><label>' + inst._getRegional('cmykY') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/><span class="ui-colorpicker-unit">%</span></div>' + '<div class="ui-colorpicker-cmyk-k"><label>' + inst._getRegional('cmykK') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/><span class="ui-colorpicker-unit">%</span></div>';
        }

        return '<div class="ui-colorpicker-cmyk">' + html + '</div>';
      };

      this.init = function () {
        part = $(html()).appendTo($('.ui-colorpicker-cmyk-container', inst.dialog));
        $('.ui-colorpicker-number', part).on('change keyup', function (event) {
          inst.color.setCMYK(parseInt($('.ui-colorpicker-cmyk-c .ui-colorpicker-number', part).val(), 10) / 100, parseInt($('.ui-colorpicker-cmyk-m .ui-colorpicker-number', part).val(), 10) / 100, parseInt($('.ui-colorpicker-cmyk-y .ui-colorpicker-number', part).val(), 10) / 100, parseInt($('.ui-colorpicker-cmyk-k .ui-colorpicker-number', part).val(), 10) / 100);

          inst._change();
        });
      };

      this.repaint = function () {
        $.each(inst.color.getCMYK(), function (index, value) {
          var input = $('.ui-colorpicker-cmyk-' + index + ' .ui-colorpicker-number', part);
          value = Math.round(value * 100);

          if (input.val() !== value) {
            input.val(value);
          }
        });
      };

      this.update = function () {
        this.repaint();
      };
    },
    alpha: function (inst) {
      var that = this,
          e = null,
          _html;

      _html = function () {
        var html = '';

        if (inst.options.alpha) {
          html += '<div class="ui-colorpicker-a"><input class="ui-colorpicker-mode" name="mode" type="radio" value="a"/><label>' + inst._getRegional('alphaA') + '</label><input class="ui-colorpicker-number" type="number" min="0" max="100"/><span class="ui-colorpicker-unit">%</span></div>';
        }

        return '<div class="ui-colorpicker-alpha">' + html + '</div>';
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-alpha-container', inst.dialog));
        $('.ui-colorpicker-mode', e).click(function () {
          inst.mode = $(this).val();

          inst._updateAllParts();
        });
        $('.ui-colorpicker-number', e).bind('change keyup', function () {
          inst.color.setAlpha($('.ui-colorpicker-a .ui-colorpicker-number', e).val() / 100);

          inst._change();
        });
      };

      this.update = function () {
        $('.ui-colorpicker-mode', e).each(function () {
          $(this).attr('checked', $(this).val() === inst.mode);
        });
        this.repaint();
      };

      this.repaint = function () {
        var input = $('.ui-colorpicker-a .ui-colorpicker-number', e),
            value = Math.round(inst.color.getAlpha() * 100);

        if (!input.is(':focus') && input.val() !== value) {
          input.val(value);
        }
      };
    },
    hex: function (inst) {
      var that = this,
          e = null,
          _html;

      _html = function () {
        var html = '';

        if (inst.options.alpha) {
          html += '<input class="ui-colorpicker-hex-alpha" type="text" maxlength="2" size="2"/>';
        }

        html += '<input class="ui-colorpicker-hex-input" type="text" maxlength="6" size="6"/>';
        return '<div class="ui-colorpicker-hex"><label>#</label>' + html + '</div>';
      };

      this.init = function () {
        e = $(_html()).appendTo($('.ui-colorpicker-hex-container', inst.dialog)); // repeat here makes the invalid input disappear faster

        $('.ui-colorpicker-hex-input', e).bind('change keydown keyup', function (a, b, c) {
          if (/[^a-fA-F0-9]/.test($(this).val())) {
            $(this).val($(this).val().replace(/[^a-fA-F0-9]/, ''));
          }
        });
        $('.ui-colorpicker-hex-input', e).bind('change keyup', function () {
          // repeat here makes sure that the invalid input doesn't get parsed
          inst.color = _parseHex($(this).val()).setAlpha(inst.color.getAlpha());

          inst._change();
        });
        $('.ui-colorpicker-hex-alpha', e).bind('change keydown keyup', function () {
          if (/[^a-fA-F0-9]/.test($(this).val())) {
            $(this).val($(this).val().replace(/[^a-fA-F0-9]/, ''));
          }
        });
        $('.ui-colorpicker-hex-alpha', e).bind('change keyup', function () {
          inst.color.setAlpha(parseInt($('.ui-colorpicker-hex-alpha', e).val(), 16) / 255);

          inst._change();
        });
      };

      this.update = function () {
        this.repaint();
      };

      this.repaint = function () {
        if (!$('.ui-colorpicker-hex-input', e).is(':focus')) {
          $('.ui-colorpicker-hex-input', e).val(inst.color.toHex(true));
        }

        if (!$('.ui-colorpicker-hex-alpha', e).is(':focus')) {
          $('.ui-colorpicker-hex-alpha', e).val(_intToHex(inst.color.getAlpha() * 255));
        }
      };
    },
    swatches: function (inst) {
      var that = this,
          part = null,
          html = function () {
        var html = '';
        $.each(inst._getSwatches(), function (name, color) {
          var c = new Color(color.r, color.g, color.b),
              css = c.toCSS();
          html += '<div class="ui-colorpicker-swatch" style="background-color:' + css + '" title="' + name + '"></div>';
        });
        return '<div class="ui-colorpicker-swatches ui-colorpicker-border" style="width:' + inst.options.swatchesWidth + 'px">' + html + '</div>';
      };

      this.init = function () {
        part = $(html()).appendTo($('.ui-colorpicker-swatches-container', inst.dialog));
        $('.ui-colorpicker-swatch', part).click(function () {
          inst.color = inst._parseColor($(this).css('background-color'));

          inst._change();
        });
      };
    },
    footer: function (inst) {
      var that = this,
          part = null,
          id_transparent = 'ui-colorpicker-special-transparent-' + _colorpicker_index,
          id_none = 'ui-colorpicker-special-none-' + _colorpicker_index,
          html = function () {
        var html = '';

        if (inst.options.alpha || !inst.inline && inst.options.showNoneButton) {
          html += '<div class="ui-colorpicker-buttonset">';

          if (inst.options.alpha) {
            html += '<input type="radio" name="ui-colorpicker-special" id="' + id_transparent + '" class="ui-colorpicker-special-transparent"/><label for="' + id_transparent + '">' + inst._getRegional('transparent') + '</label>';
          }

          if (!inst.inline && inst.options.showNoneButton) {
            html += '<input type="radio" name="ui-colorpicker-special" id="' + id_none + '" class="ui-colorpicker-special-none"><label for="' + id_none + '">' + inst._getRegional('none') + '</label>';
          }

          html += '</div>';
        }

        if (!inst.inline) {
          html += '<div class="ui-dialog-buttonset">';

          if (inst.options.showCancelButton) {
            html += '<button class="ui-colorpicker-cancel">' + inst._getRegional('cancel') + '</button>';
          }

          html += '<button class="ui-colorpicker-ok">' + inst._getRegional('ok') + '</button>';
          html += '</div>';
        }

        return '<div class="ui-dialog-buttonpane ui-widget-content">' + html + '</div>';
      };

      this.init = function () {
        part = $(html()).appendTo(inst.dialog);
        $('.ui-colorpicker-ok', part).button().click(function () {
          inst.close();
        });
        $('.ui-colorpicker-cancel', part).button().click(function () {
          inst.color = inst.currentColor.copy();

          inst._change(inst.color.set);

          inst.close();
        }); //inst._getRegional('transparent')

        $('.ui-colorpicker-buttonset', part).buttonset();
        $('.ui-colorpicker-special-color', part).click(function () {
          inst._change();
        });
        $('#' + id_none, part).click(function () {
          inst._change(false);
        });
        $('#' + id_transparent, part).click(function () {
          inst.color.setAlpha(0);

          inst._change();
        });
      };

      this.repaint = function () {
        if (!inst.color.set) {
          $('.ui-colorpicker-special-none', part).attr('checked', true).button("refresh");
        } else if (inst.color.getAlpha() == 0) {
          $('.ui-colorpicker-special-transparent', part).attr('checked', true).button("refresh");
        } else {
          $('input', part).attr('checked', false).button("refresh");
        }

        $('.ui-colorpicker-cancel', part).button(inst.changed ? 'enable' : 'disable');
      };

      this.update = function () {};
    }
  },
      Color = function () {
    var spaces = {
      rgb: {
        r: 0,
        g: 0,
        b: 0
      },
      hsv: {
        h: 0,
        s: 0,
        v: 0
      },
      hsl: {
        h: 0,
        s: 0,
        l: 0
      },
      lab: {
        l: 0,
        a: 0,
        b: 0
      },
      cmyk: {
        c: 0,
        m: 0,
        y: 0,
        k: 1
      }
    },
        a = 1,
        args = arguments,
        _clip = function (v) {
      if (isNaN(v) || v === null) {
        return 0;
      }

      if (typeof v == 'string') {
        v = parseInt(v, 10);
      }

      return Math.max(0, Math.min(v, 1));
    },
        _hexify = function (number) {
      var digits = '0123456789abcdef',
          lsd = number % 16,
          msd = (number - lsd) / 16,
          hexified = digits.charAt(msd) + digits.charAt(lsd);
      return hexified;
    },
        _rgb_to_xyz = function (rgb) {
      var r = rgb.r > 0.04045 ? Math.pow((rgb.r + 0.055) / 1.055, 2.4) : rgb.r / 12.92,
          g = rgb.g > 0.04045 ? Math.pow((rgb.g + 0.055) / 1.055, 2.4) : rgb.g / 12.92,
          b = rgb.b > 0.04045 ? Math.pow((rgb.b + 0.055) / 1.055, 2.4) : rgb.b / 12.92;
      return {
        x: r * 0.4124 + g * 0.3576 + b * 0.1805,
        y: r * 0.2126 + g * 0.7152 + b * 0.0722,
        z: r * 0.0193 + g * 0.1192 + b * 0.9505
      };
    },
        _xyz_to_rgb = function (xyz) {
      var rgb = {
        r: xyz.x * 3.2406 + xyz.y * -1.5372 + xyz.z * -0.4986,
        g: xyz.x * -0.9689 + xyz.y * 1.8758 + xyz.z * 0.0415,
        b: xyz.x * 0.0557 + xyz.y * -0.2040 + xyz.z * 1.0570
      };
      rgb.r = rgb.r > 0.0031308 ? 1.055 * Math.pow(rgb.r, 1 / 2.4) - 0.055 : 12.92 * rgb.r;
      rgb.g = rgb.g > 0.0031308 ? 1.055 * Math.pow(rgb.g, 1 / 2.4) - 0.055 : 12.92 * rgb.g;
      rgb.b = rgb.b > 0.0031308 ? 1.055 * Math.pow(rgb.b, 1 / 2.4) - 0.055 : 12.92 * rgb.b;
      return rgb;
    },
        _rgb_to_hsv = function (rgb) {
      var minVal = Math.min(rgb.r, rgb.g, rgb.b),
          maxVal = Math.max(rgb.r, rgb.g, rgb.b),
          delta = maxVal - minVal,
          del_R,
          del_G,
          del_B,
          hsv = {
        h: 0,
        s: 0,
        v: maxVal
      };

      if (delta === 0) {
        hsv.h = 0;
        hsv.s = 0;
      } else {
        hsv.s = delta / maxVal;
        del_R = ((maxVal - rgb.r) / 6 + delta / 2) / delta;
        del_G = ((maxVal - rgb.g) / 6 + delta / 2) / delta;
        del_B = ((maxVal - rgb.b) / 6 + delta / 2) / delta;

        if (rgb.r === maxVal) {
          hsv.h = del_B - del_G;
        } else if (rgb.g === maxVal) {
          hsv.h = 1 / 3 + del_R - del_B;
        } else if (rgb.b === maxVal) {
          hsv.h = 2 / 3 + del_G - del_R;
        }

        if (hsv.h < 0) {
          hsv.h += 1;
        } else if (hsv.h > 1) {
          hsv.h -= 1;
        }
      }

      return hsv;
    },
        _hsv_to_rgb = function (hsv) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      },
          var_h,
          var_i,
          var_1,
          var_2,
          var_3;

      if (hsv.s === 0) {
        rgb.r = rgb.g = rgb.b = hsv.v;
      } else {
        var_h = hsv.h === 1 ? 0 : hsv.h * 6;
        var_i = Math.floor(var_h);
        var_1 = hsv.v * (1 - hsv.s);
        var_2 = hsv.v * (1 - hsv.s * (var_h - var_i));
        var_3 = hsv.v * (1 - hsv.s * (1 - (var_h - var_i)));

        if (var_i === 0) {
          rgb.r = hsv.v;
          rgb.g = var_3;
          rgb.b = var_1;
        } else if (var_i === 1) {
          rgb.r = var_2;
          rgb.g = hsv.v;
          rgb.b = var_1;
        } else if (var_i === 2) {
          rgb.r = var_1;
          rgb.g = hsv.v;
          rgb.b = var_3;
        } else if (var_i === 3) {
          rgb.r = var_1;
          rgb.g = var_2;
          rgb.b = hsv.v;
        } else if (var_i === 4) {
          rgb.r = var_3;
          rgb.g = var_1;
          rgb.b = hsv.v;
        } else {
          rgb.r = hsv.v;
          rgb.g = var_1;
          rgb.b = var_2;
        }
      }

      return rgb;
    },
        _rgb_to_hsl = function (rgb) {
      var minVal = Math.min(rgb.r, rgb.g, rgb.b),
          maxVal = Math.max(rgb.r, rgb.g, rgb.b),
          delta = maxVal - minVal,
          del_R,
          del_G,
          del_B,
          hsl = {
        h: 0,
        s: 0,
        l: (maxVal + minVal) / 2
      };

      if (delta === 0) {
        hsl.h = 0;
        hsl.s = 0;
      } else {
        hsl.s = hsl.l < 0.5 ? delta / (maxVal + minVal) : delta / (2 - maxVal - minVal);
        del_R = ((maxVal - rgb.r) / 6 + delta / 2) / delta;
        del_G = ((maxVal - rgb.g) / 6 + delta / 2) / delta;
        del_B = ((maxVal - rgb.b) / 6 + delta / 2) / delta;

        if (rgb.r === maxVal) {
          hsl.h = del_B - del_G;
        } else if (rgb.g === maxVal) {
          hsl.h = 1 / 3 + del_R - del_B;
        } else if (rgb.b === maxVal) {
          hsl.h = 2 / 3 + del_G - del_R;
        }

        if (hsl.h < 0) {
          hsl.h += 1;
        } else if (hsl.h > 1) {
          hsl.h -= 1;
        }
      }

      return hsl;
    },
        _hsl_to_rgb = function (hsl) {
      var var_1,
          var_2,
          hue_to_rgb = function (v1, v2, vH) {
        if (vH < 0) {
          vH += 1;
        }

        if (vH > 1) {
          vH -= 1;
        }

        if (6 * vH < 1) {
          return v1 + (v2 - v1) * 6 * vH;
        }

        if (2 * vH < 1) {
          return v2;
        }

        if (3 * vH < 2) {
          return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
        }

        return v1;
      };

      if (hsl.s === 0) {
        return {
          r: hsl.l,
          g: hsl.l,
          b: hsl.l
        };
      }

      var_2 = hsl.l < 0.5 ? hsl.l * (1 + hsl.s) : hsl.l + hsl.s - hsl.s * hsl.l;
      var_1 = 2 * hsl.l - var_2;
      return {
        r: hue_to_rgb(var_1, var_2, hsl.h + 1 / 3),
        g: hue_to_rgb(var_1, var_2, hsl.h),
        b: hue_to_rgb(var_1, var_2, hsl.h - 1 / 3)
      };
    },
        _xyz_to_lab = function (xyz) {
      // CIE-L*ab D65 1931
      var x = xyz.x / 0.95047,
          y = xyz.y,
          z = xyz.z / 1.08883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      return {
        l: (116 * y - 16) / 100,
        // [0,100]
        a: (500 * (x - y) + 128) / 255,
        // [-128,127]
        b: (200 * (y - z) + 128) / 255 // [-128,127]

      };
    },
        _lab_to_xyz = function (lab) {
      var lab2 = {
        l: lab.l * 100,
        a: lab.a * 255 - 128,
        b: lab.b * 255 - 128
      },
          xyz = {
        x: 0,
        y: (lab2.l + 16) / 116,
        z: 0
      };
      xyz.x = lab2.a / 500 + xyz.y;
      xyz.z = xyz.y - lab2.b / 200;
      xyz.x = Math.pow(xyz.x, 3) > 0.008856 ? Math.pow(xyz.x, 3) : (xyz.x - 16 / 116) / 7.787;
      xyz.y = Math.pow(xyz.y, 3) > 0.008856 ? Math.pow(xyz.y, 3) : (xyz.y - 16 / 116) / 7.787;
      xyz.z = Math.pow(xyz.z, 3) > 0.008856 ? Math.pow(xyz.z, 3) : (xyz.z - 16 / 116) / 7.787;
      xyz.x *= 0.95047;
      xyz.y *= 1;
      xyz.z *= 1.08883;
      return xyz;
    },
        _rgb_to_cmy = function (rgb) {
      return {
        c: 1 - rgb.r,
        m: 1 - rgb.g,
        y: 1 - rgb.b
      };
    },
        _cmy_to_rgb = function (cmy) {
      return {
        r: 1 - cmy.c,
        g: 1 - cmy.m,
        b: 1 - cmy.y
      };
    },
        _cmy_to_cmyk = function (cmy) {
      var K = 1;

      if (cmy.c < K) {
        K = cmy.c;
      }

      if (cmy.m < K) {
        K = cmy.m;
      }

      if (cmy.y < K) {
        K = cmy.y;
      }

      if (K == 1) {
        return {
          c: 0,
          m: 0,
          y: 0,
          k: 1
        };
      }

      return {
        c: (cmy.c - K) / (1 - K),
        m: (cmy.m - K) / (1 - K),
        y: (cmy.y - K) / (1 - K),
        k: K
      };
    },
        _cmyk_to_cmy = function (cmyk) {
      return {
        c: cmyk.c * (1 - cmyk.k) + cmyk.k,
        m: cmyk.m * (1 - cmyk.k) + cmyk.k,
        y: cmyk.y * (1 - cmyk.k) + cmyk.k
      };
    };

    this.set = true;

    this.setAlpha = function (_a) {
      if (_a !== null) {
        a = _clip(_a);
      }

      return this;
    };

    this.getAlpha = function () {
      return a;
    };

    this.setRGB = function (r, g, b) {
      spaces = {
        rgb: this.getRGB()
      };

      if (r !== null) {
        spaces.rgb.r = _clip(r);
      }

      if (g !== null) {
        spaces.rgb.g = _clip(g);
      }

      if (b !== null) {
        spaces.rgb.b = _clip(b);
      }

      return this;
    };

    this.setHSV = function (h, s, v) {
      spaces = {
        hsv: this.getHSV()
      };

      if (h !== null) {
        spaces.hsv.h = _clip(h);
      }

      if (s !== null) {
        spaces.hsv.s = _clip(s);
      }

      if (v !== null) {
        spaces.hsv.v = _clip(v);
      }

      return this;
    };

    this.setHSL = function (h, s, l) {
      spaces = {
        hsl: this.getHSL()
      };

      if (h !== null) {
        spaces.hsl.h = _clip(h);
      }

      if (s !== null) {
        spaces.hsl.s = _clip(s);
      }

      if (l !== null) {
        spaces.hsl.l = _clip(l);
      }

      return this;
    };

    this.setLAB = function (l, a, b) {
      spaces = {
        lab: this.getLAB()
      };

      if (l !== null) {
        spaces.lab.l = _clip(l);
      }

      if (a !== null) {
        spaces.lab.a = _clip(a);
      }

      if (b !== null) {
        spaces.lab.b = _clip(b);
      }

      return this;
    };

    this.setCMYK = function (c, m, y, k) {
      spaces = {
        cmyk: this.getCMYK()
      };

      if (c !== null) {
        spaces.cmyk.c = _clip(c);
      }

      if (m !== null) {
        spaces.cmyk.m = _clip(m);
      }

      if (y !== null) {
        spaces.cmyk.y = _clip(y);
      }

      if (k !== null) {
        spaces.cmyk.k = _clip(k);
      }

      return this;
    };

    this.getRGB = function () {
      if (!spaces.rgb) {
        spaces.rgb = spaces.lab ? _xyz_to_rgb(_lab_to_xyz(spaces.lab)) : spaces.hsv ? _hsv_to_rgb(spaces.hsv) : spaces.hsl ? _hsl_to_rgb(spaces.hsl) : spaces.cmyk ? _cmy_to_rgb(_cmyk_to_cmy(spaces.cmyk)) : {
          r: 0,
          g: 0,
          b: 0
        };
        spaces.rgb.r = _clip(spaces.rgb.r);
        spaces.rgb.g = _clip(spaces.rgb.g);
        spaces.rgb.b = _clip(spaces.rgb.b);
      }

      return $.extend({}, spaces.rgb);
    };

    this.getHSV = function () {
      if (!spaces.hsv) {
        spaces.hsv = spaces.lab ? _rgb_to_hsv(this.getRGB()) : spaces.rgb ? _rgb_to_hsv(spaces.rgb) : spaces.hsl ? _rgb_to_hsv(this.getRGB()) : spaces.cmyk ? _rgb_to_hsv(this.getRGB()) : {
          h: 0,
          s: 0,
          v: 0
        };
        spaces.hsv.h = _clip(spaces.hsv.h);
        spaces.hsv.s = _clip(spaces.hsv.s);
        spaces.hsv.v = _clip(spaces.hsv.v);
      }

      return $.extend({}, spaces.hsv);
    };

    this.getHSL = function () {
      if (!spaces.hsl) {
        spaces.hsl = spaces.rgb ? _rgb_to_hsl(spaces.rgb) : spaces.hsv ? _rgb_to_hsl(this.getRGB()) : spaces.cmyk ? _rgb_to_hsl(this.getRGB()) : spaces.hsv ? _rgb_to_hsl(this.getRGB()) : {
          h: 0,
          s: 0,
          l: 0
        };
        spaces.hsl.h = _clip(spaces.hsl.h);
        spaces.hsl.s = _clip(spaces.hsl.s);
        spaces.hsl.l = _clip(spaces.hsl.l);
      }

      return $.extend({}, spaces.hsl);
    };

    this.getCMYK = function () {
      if (!spaces.cmyk) {
        spaces.cmyk = spaces.rgb ? _cmy_to_cmyk(_rgb_to_cmy(spaces.rgb)) : spaces.hsv ? _cmy_to_cmyk(_rgb_to_cmy(this.getRGB())) : spaces.hsl ? _cmy_to_cmyk(_rgb_to_cmy(this.getRGB())) : spaces.lab ? _cmy_to_cmyk(_rgb_to_cmy(this.getRGB())) : {
          c: 0,
          m: 0,
          y: 0,
          k: 1
        };
        spaces.cmyk.c = _clip(spaces.cmyk.c);
        spaces.cmyk.m = _clip(spaces.cmyk.m);
        spaces.cmyk.y = _clip(spaces.cmyk.y);
        spaces.cmyk.k = _clip(spaces.cmyk.k);
      }

      return $.extend({}, spaces.cmyk);
    };

    this.getLAB = function () {
      if (!spaces.lab) {
        spaces.lab = spaces.rgb ? _xyz_to_lab(_rgb_to_xyz(spaces.rgb)) : spaces.hsv ? _xyz_to_lab(_rgb_to_xyz(this.getRGB())) : spaces.hsl ? _xyz_to_lab(_rgb_to_xyz(this.getRGB())) : spaces.cmyk ? _xyz_to_lab(_rgb_to_xyz(this.getRGB())) : {
          l: 0,
          a: 0,
          b: 0
        };
        spaces.lab.l = _clip(spaces.lab.l);
        spaces.lab.a = _clip(spaces.lab.a);
        spaces.lab.b = _clip(spaces.lab.b);
      }

      return $.extend({}, spaces.lab);
    };

    this.getChannels = function () {
      return {
        r: this.getRGB().r,
        g: this.getRGB().g,
        b: this.getRGB().b,
        a: this.getAlpha(),
        h: this.getHSV().h,
        s: this.getHSV().s,
        v: this.getHSV().v,
        c: this.getCMYK().c,
        m: this.getCMYK().m,
        y: this.getCMYK().y,
        k: this.getCMYK().k,
        L: this.getLAB().l,
        A: this.getLAB().a,
        B: this.getLAB().b
      };
    };

    this.getSpaces = function () {
      return $.extend(true, {}, spaces);
    };

    this.setSpaces = function (new_spaces) {
      spaces = new_spaces;
      return this;
    };

    this.distance = function (color) {
      var space = 'lab',
          getter = 'get' + space.toUpperCase(),
          a = this[getter](),
          b = color[getter](),
          distance = 0,
          channel;

      for (channel in a) {
        distance += Math.pow(a[channel] - b[channel], 2);
      }

      return distance;
    };

    this.equals = function (color) {
      var a = this.getRGB(),
          b = color.getRGB();
      return this.getAlpha() == color.getAlpha() && a.r == b.r && a.g == b.g && a.b == b.b;
    };

    this.limit = function (steps) {
      steps -= 1;
      var rgb = this.getRGB();
      this.setRGB(Math.round(rgb.r * steps) / steps, Math.round(rgb.g * steps) / steps, Math.round(rgb.b * steps) / steps);
    };

    this.toHex = function () {
      var rgb = this.getRGB();
      return _hexify(rgb.r * 255) + _hexify(rgb.g * 255) + _hexify(rgb.b * 255);
    };

    this.toCSS = function () {
      return '#' + this.toHex();
    };

    this.normalize = function () {
      this.setHSV(null, 1, 1);
      return this;
    };

    this.copy = function () {
      var spaces = this.getSpaces(),
          a = this.getAlpha();
      return new Color(spaces, a);
    }; // Construct


    if (args.length == 2) {
      this.setSpaces(args[0]);
      this.setAlpha(args[1] === 0 ? 0 : args[1] || 1);
    }

    if (args.length > 2) {
      this.setRGB(args[0], args[1], args[2]);
      this.setAlpha(args[3] === 0 ? 0 : args[3] || 1);
    }
  };

  $.widget("vanderlee.colorpicker", {
    options: {
      alpha: false,
      // Show alpha controls and mode
      altAlpha: true,
      // change opacity of altField as well?
      altField: '',
      // selector for DOM elements which change background color on change.
      altOnChange: true,
      // true to update on each change, false to update only on close.
      altProperties: 'background-color',
      // comma separated list of any of 'background-color', 'color', 'border-color', 'outline-color'
      autoOpen: false,
      // Open dialog automatically upon creation
      buttonColorize: false,
      buttonImage: 'images/ui-colorpicker.png',
      buttonImageOnly: false,
      buttonText: null,
      // Text on the button and/or title of button image.
      closeOnEscape: true,
      // Close the dialog when the escape key is pressed.
      closeOnOutside: true,
      // Close the dialog when clicking outside the dialog (not for inline)
      color: '#00FF00',
      // Initial color (for inline only)
      colorFormat: 'HEX',
      // Format string for output color format
      draggable: true,
      // Make popup dialog draggable if header is visible.
      duration: 'fast',
      hsv: true,
      // Show HSV controls and modes
      inline: true,
      // Show any divs as inline by default
      layout: {
        map: [0, 0, 1, 5],
        // Left, Top, Width, Height (in table cells).
        bar: [1, 0, 1, 5],
        preview: [2, 0, 1, 1],
        hsv: [2, 1, 1, 1],
        rgb: [2, 2, 1, 1],
        alpha: [2, 3, 1, 1],
        hex: [2, 4, 1, 1],
        lab: [3, 1, 1, 1],
        cmyk: [3, 2, 1, 2],
        swatches: [4, 0, 1, 5]
      },
      limit: '',
      // Limit color "resolution": '', 'websafe', 'nibble', 'binary', 'name'
      modal: false,
      // Modal dialog?
      mode: 'h',
      // Initial editing mode, h, s, v, r, g, b or a
      parts: '',
      // leave empty for automatic selection
      regional: '',
      rgb: true,
      // Show RGB controls and modes
      showAnim: 'fadeIn',
      showCancelButton: true,
      showNoneButton: false,
      showCloseButton: true,
      showOn: 'focus',
      // 'focus', 'button', 'both'
      showOptions: {},
      swatches: null,
      // null for default or kv-object or names swatches set
      swatchesWidth: 84,
      // width (in number of pixels) of swatches box.
      title: null,
      close: null,
      init: null,
      select: null,
      open: null
    },
    _create: function () {
      var that = this,
          text;
      ++_colorpicker_index;
      that.widgetEventPrefix = 'color';
      that.opened = false;
      that.generated = false;
      that.inline = false;
      that.changed = false;
      that.dialog = null;
      that.button = null;
      that.image = null;
      that.overlay = null;
      that.mode = that.options.mode;

      if (this.element[0].nodeName.toLowerCase() === 'input' || !that.options.inline) {
        that._setColor(that.element.val());

        this._callback('init');

        $('body').append(_container_popup);
        that.dialog = $('.ui-colorpicker:last'); // Click outside/inside

        $(document).delegate('html', 'touchstart click', function (event) {
          if (!that.opened || event.target === that.element[0] || that.overlay) {
            return;
          } // Check if clicked on any part of dialog


          if (that.dialog.is(event.target) || that.dialog.has(event.target).length > 0) {
            that.element.blur(); // inside window!

            return;
          } // Check if clicked on button


          var p,
              parents = $(event.target).parents();

          for (p = 0; p <= parents.length; ++p) {
            if (that.button !== null && parents[p] === that.button[0]) {
              return;
            }
          } // no closeOnOutside


          if (!that.options.closeOnOutside) {
            return;
          }

          that.close();
        });
        $(document).keydown(function (event) {
          if (event.keyCode == 27 && that.opened && that.options.closeOnEscape) {
            that.close();
          }
        });

        if (that.options.showOn === 'focus' || that.options.showOn === 'both') {
          that.element.on('focus click', function () {
            that.open();
          });
        }

        if (that.options.showOn === 'button' || that.options.showOn === 'both') {
          if (that.options.buttonImage !== '') {
            text = that.options.buttonText || that._getRegional('button');
            that.image = $('<img/>').attr({
              'src': that.options.buttonImage,
              'alt': text,
              'title': text
            });

            that._setImageBackground();
          }

          if (that.options.buttonImageOnly && that.image) {
            that.button = that.image;
          } else {
            that.button = $('<button type="button"></button>').html(that.image || that.options.buttonText).button();
            that.image = that.image ? $('img', that.button).first() : null;
          }

          that.button.insertAfter(that.element).click(function () {
            that[that.opened ? 'close' : 'open']();
          });
        }

        if (that.options.autoOpen) {
          that.open();
        }

        that.element.keydown(function (event) {
          if (event.keyCode === 9) {
            that.close();
          }
        }).keyup(function (event) {
          var color = that._parseColor(that.element.val());

          if (!that.color.equals(color)) {
            that.color = color;

            that._change();
          }
        });
      } else {
        that.inline = true;
        $(this.element).html(_container_inline);
        that.dialog = $('.ui-colorpicker', this.element);

        that._generate();

        that.opened = true;
      }

      return this;
    },
    _setOption: function (key, value) {
      var that = this;

      switch (key) {
        case "disabled":
          if (value) {
            that.dialog.addClass('ui-colorpicker-disabled');
          } else {
            that.dialog.removeClass('ui-colorpicker-disabled');
          }

          break;
      }

      $.Widget.prototype._setOption.apply(that, arguments);
    },

    /* setBackground */
    _setImageBackground: function () {
      if (this.image && this.options.buttonColorize) {
        this.image.css('background-color', this.color.set ? this._formatColor('RGBA', this.color) : '');
      }
    },

    /**
     * If an alternate field is specified, set it according to the current color.
     */
    _setAltField: function () {
      if (this.options.altOnChange && this.options.altField && this.options.altProperties) {
        var index,
            property,
            properties = this.options.altProperties.split(',');

        for (index = 0; index <= properties.length; ++index) {
          property = $.trim(properties[index]);

          switch (property) {
            case 'color':
            case 'background-color':
            case 'outline-color':
            case 'border-color':
              $(this.options.altField).css(property, this.color.set ? this.color.toCSS() : '');
              break;
          }
        }

        if (this.options.altAlpha) {
          $(this.options.altField).css('opacity', this.color.set ? this.color.getAlpha() : '');
        }
      }
    },
    _setColor: function (text) {
      this.color = this._parseColor(text);
      this.currentColor = this.color.copy();

      this._setImageBackground();

      this._setAltField();
    },
    setColor: function (text) {
      this._setColor(text);

      this._change(this.color.set);
    },
    _generate: function () {
      var that = this,
          index,
          part,
          parts_list,
          layout_parts; // Set color based on element?

      that._setColor(that.inline ? that.options.color : that.element.val()); // Determine the parts to include in this colorpicker


      if (typeof that.options.parts === 'string') {
        if (_parts_lists[that.options.parts]) {
          parts_list = _parts_lists[that.options.parts];
        } else {
          // automatic
          parts_list = _parts_lists[that.inline ? 'inline' : 'popup'];
        }
      } else {
        parts_list = that.options.parts;
      } // Add any parts to the internal parts list


      that.parts = {};
      $.each(parts_list, function (index, part) {
        if (_parts[part]) {
          that.parts[part] = new _parts[part](that);
        }
      });

      if (!that.generated) {
        layout_parts = [];
        $.each(that.options.layout, function (part, pos) {
          if (that.parts[part]) {
            layout_parts.push({
              'part': part,
              'pos': pos
            });
          }
        });
        $(_layoutTable(layout_parts, function (cell, x, y) {
          var classes = ['ui-colorpicker-' + cell.part + '-container'];

          if (x > 0) {
            classes.push('ui-colorpicker-padding-left');
          }

          if (y > 0) {
            classes.push('ui-colorpicker-padding-top');
          }

          return '<td  class="' + classes.join(' ') + '"' + (cell.pos[2] > 1 ? ' colspan="' + cell.pos[2] + '"' : '') + (cell.pos[3] > 1 ? ' rowspan="' + cell.pos[3] + '"' : '') + ' valign="top"></td>';
        })).appendTo(that.dialog).addClass('ui-dialog-content ui-widget-content');

        that._initAllParts();

        that._updateAllParts();

        that.generated = true;
      }
    },
    _effectGeneric: function (element, show, slide, fade, callback) {
      var that = this;

      if ($.effects && $.effects[that.options.showAnim]) {
        element[show](that.options.showAnim, that.options.showOptions, that.options.duration, callback);
      } else {
        element[that.options.showAnim === 'slideDown' ? slide : that.options.showAnim === 'fadeIn' ? fade : show](that.options.showAnim ? that.options.duration : null, callback);

        if (!that.options.showAnim || !that.options.duration) {
          callback();
        }
      }
    },
    _effectShow: function (element, callback) {
      this._effectGeneric(element, 'show', 'slideDown', 'fadeIn', callback);
    },
    _effectHide: function (element, callback) {
      this._effectGeneric(element, 'hide', 'slideUp', 'fadeOut', callback);
    },
    open: function () {
      var that = this,
          offset,
          bottom,
          right,
          height,
          width,
          x,
          y,
          zIndex;

      if (!that.opened) {
        that._generate();

        offset = that.element.offset();
        bottom = $(window).height() + $(window).scrollTop();
        right = $(window).width() + $(window).scrollLeft();
        height = that.dialog.outerHeight();
        width = that.dialog.outerWidth();
        x = offset.left;
        y = offset.top + that.element.outerHeight();

        if (x + width > right) {
          x = Math.max(0, right - width);
        }

        if (y + height > bottom) {
          if (offset.top - height >= $(window).scrollTop()) {
            y = offset.top - height;
          } else {
            y = Math.max(0, bottom - height);
          }
        }

        that.dialog.css({
          'left': x,
          'top': y
        }); // Automatically find highest z-index.

        zIndex = 0;
        $(that.element[0]).parents().each(function () {
          var z = $(this).css('z-index');

          if ((typeof z === 'number' || typeof z === 'string') && z !== '' && !isNaN(z)) {
            zIndex = parseInt(z);
            return false;
          }
        }); //@todo zIndexOffset option, to raise above other elements?

        that.dialog.css('z-index', zIndex += 2);
        that.overlay = that.options.modal ? new $.ui.dialog.overlay(that) : null;

        that._effectShow(this.dialog);

        that.opened = true;

        that._callback('open', true); // Without waiting for domready the width of the map is 0 and we
        // wind up with the cursor stuck in the upper left corner


        $(function () {
          that._repaintAllParts();
        });
      }
    },
    close: function () {
      var that = this;
      that.currentColor = that.color.copy();
      that.changed = false; // tear down the interface

      that._effectHide(that.dialog, function () {
        that.dialog.empty();
        that.generated = false;
        that.opened = false;

        that._callback('close', true);
      });

      if (that.overlay) {
        that.overlay.destroy();
      }
    },
    destroy: function () {
      this.element.unbind();

      if (this.image !== null) {
        this.image.remove();
      }

      if (this.button !== null) {
        this.button.remove();
      }

      if (this.dialog !== null) {
        this.dialog.remove();
      }

      if (this.overlay) {
        this.overlay.destroy();
      }
    },
    _callback: function (callback, spaces) {
      var that = this,
          data,
          lab;

      if (that.color.set) {
        data = {
          formatted: that._formatColor(that.options.colorFormat, that.color)
        };
        lab = that.color.getLAB();
        lab.a = lab.a * 2 - 1;
        lab.b = lab.b * 2 - 1;

        if (spaces === true) {
          data.a = that.color.getAlpha();
          data.rgb = that.color.getRGB();
          data.hsv = that.color.getHSV();
          data.cmyk = that.color.getCMYK();
          data.hsl = that.color.getHSL();
          data.lab = lab;
        }

        return that._trigger(callback, null, data);
      } else {
        return that._trigger(callback, null, {
          formatted: ''
        });
      }
    },
    _initAllParts: function () {
      $.each(this.parts, function (index, part) {
        if (part.init) {
          part.init();
        }
      });
    },
    _updateAllParts: function () {
      $.each(this.parts, function (index, part) {
        if (part.update) {
          part.update();
        }
      });
    },
    _repaintAllParts: function () {
      $.each(this.parts, function (index, part) {
        if (part.repaint) {
          part.repaint();
        }
      });
    },
    _change: function (set
    /* = true */
    ) {
      this.color.set = set !== false;
      this.changed = true; // Limit color palette

      switch (this.options.limit) {
        case 'websafe':
          this.color.limit(6);
          break;

        case 'nibble':
          this.color.limit(16);
          break;

        case 'binary':
          this.color.limit(2);
          break;

        case 'name':
          var swatch = this._getSwatch(this._closestName(this.color));

          this.color.setRGB(swatch.r, swatch.g, swatch.b);
          break;
      } // update input element content


      if (!this.inline) {
        if (!this.color.set) {
          this.element.val('');
        } else if (!this.color.equals(this._parseColor(this.element.val()))) {
          this.element.val(this._formatColor(this.options.colorFormat, this.color));
        }

        this._setImageBackground();

        this._setAltField();
      }

      if (this.opened) {
        this._repaintAllParts();
      } // callback


      this._callback('select');
    },
    // This will be deprecated by jQueryUI 1.9 widget
    _hoverable: function (e) {
      e.hover(function () {
        e.addClass("ui-state-hover");
      }, function () {
        e.removeClass("ui-state-hover");
      });
    },
    // This will be deprecated by jQueryUI 1.9 widget
    _focusable: function (e) {
      e.focus(function () {
        e.addClass("ui-state-focus");
      }).blur(function () {
        e.removeClass("ui-state-focus");
      });
    },
    _getRegional: function (name) {
      return $.colorpicker.regional[this.options.regional][name] !== undefined ? $.colorpicker.regional[this.options.regional][name] : $.colorpicker.regional[''][name];
    },
    _getSwatches: function () {
      if (typeof this.options.swatches === 'string') {
        return $.colorpicker.swatches[this.options.swatches];
      }

      if ($.isPlainObject(this.options.swatches)) {
        return $.colorpicker.swatches;
      }

      return $.colorpicker.swatches.html;
    },
    _getSwatch: function (name) {
      var swatches = this._getSwatches(),
          swatch = false;

      if (swatches[name] !== undefined) {
        return swatches[name];
      }

      $.each(swatches, function (swatchName, current) {
        if (swatchName.toLowerCase() == name.toLowerCase()) {
          swatch = current;
          return false;
        }

        return true;
      });
      return swatch;
    },
    _parseColor: function (color) {
      var c, m; // no color

      if (color == '') {
        return new Color();
      } // named swatch


      c = this._getSwatch($.trim(color));

      if (c) {
        return new Color(c.r, c.g, c.b);
      } // rgba(r,g,b,a)


      m = /^rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)$/.exec(color);

      if (m) {
        return new Color(m[1] / 255, m[2] / 255, m[3] / 255, parseFloat(m[4]));
      } // hsla(r,g,b,a)


      m = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)$/.exec(color);

      if (m) {
        return new Color().setHSL(m[1] / 255, m[2] / 255, m[3] / 255).setAlpha(parseFloat(m[4]));
      } // rgba(r%,g%,b%,a%)


      m = /^rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)$/.exec(color);

      if (m) {
        return new Color(m[1] / 100, m[2] / 100, m[3] / 100, m[4] / 100);
      } // hsla(r%,g%,b%,a%)


      m = /^hsla?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)$/.exec(color);

      if (m) {
        return new Color().setHSL(m[1] / 100, m[2] / 100, m[3] / 100).setAlpha(m[4] / 100);
      } // #rrggbb


      m = /^#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/.exec(color);

      if (m) {
        return new Color(parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255);
      } // #rgb


      m = /^#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/.exec(color);

      if (m) {
        return new Color(parseInt(m[1] + m[1], 16) / 255, parseInt(m[2] + m[2], 16) / 255, parseInt(m[3] + m[3], 16) / 255);
      }

      return _parseHex(color);
    },
    _exactName: function (color) {
      var name = false;
      $.each(this._getSwatches(), function (n, swatch) {
        if (color.equals(new Color(swatch.r, swatch.g, swatch.b))) {
          name = n;
          return false;
        }

        return true;
      });
      return name;
    },
    _closestName: function (color) {
      var rgb = color.getRGB(),
          distance = null,
          name = false,
          d;
      $.each(this._getSwatches(), function (n, swatch) {
        d = color.distance(new Color(swatch.r, swatch.g, swatch.b));

        if (d < distance || distance === null) {
          name = n;

          if (d == 0) {
            return false; // can't get much closer than 0
          }

          distance = d;
        }

        return true;
      });
      return name;
    },
    _formatColor: function (formats, color) {
      var that = this,
          text = null,
          types = {
        'x': function (v) {
          return _intToHex(v * 255);
        },
        'd': function (v) {
          return Math.round(v * 255);
        },
        'f': function (v) {
          return v;
        },
        'p': function (v) {
          return v * 100;
        }
      },
          channels = color.getChannels();

      if (!$.isArray(formats)) {
        formats = [formats];
      }

      $.each(formats, function (index, format) {
        if (that._formats[format]) {
          text = that._formats[format](color, that);
          return text === false;
        } else {
          text = format.replace(/\\?[argbhsvcmykLAB][xdfp]/g, function (m) {
            if (m.match(/^\\/)) {
              return m.slice(1);
            }

            return types[m.charAt(1)](channels[m.charAt(0)]);
          });
          return false;
        }
      });
      return text;
    },
    _formats: {
      '#HEX': function (color, that) {
        return that._formatColor('#rxgxbx', color);
      },
      '#HEX3': function (color, that) {
        var hex3 = that._formats.HEX3(color);

        return hex3 === false ? false : '#' + hex3;
      },
      'HEX': function (color, that) {
        return that._formatColor('rxgxbx', color);
      },
      'HEX3': function (color, that) {
        var rgb = color.getRGB(),
            r = Math.round(rgb.r * 255),
            g = Math.round(rgb.g * 255),
            b = Math.round(rgb.b * 255);

        if (r >>> 4 == (r &= 0xf) && g >>> 4 == (g &= 0xf) && b >>> 4 == (b &= 0xf)) {
          return r.toString(16) + g.toString(16) + b.toString(16);
        }

        return false;
      },
      'RGB': function (color, that) {
        return color.getAlpha() >= 1 ? that._formatColor('rgb(rd,gd,bd)', color) : false;
      },
      'RGBA': function (color, that) {
        return that._formatColor('rgba(rd,gd,bd,af)', color);
      },
      'RGB%': function (color, that) {
        return color.getAlpha() >= 1 ? that._formatColor('rgb(rp%,gp%,bp%)', color) : false;
      },
      'RGBA%': function (color, that) {
        return that._formatColor('rgba(rp%,gp%,bp%,af)', color);
      },
      'HSL': function (color, that) {
        return color.getAlpha() >= 1 ? that._formatColor('hsl(hd,sd,vd)', color) : false;
      },
      'HSLA': function (color, that) {
        return that._formatColor('hsla(hd,sd,vd,af)', color);
      },
      'HSL%': function (color, that) {
        return color.getAlpha() >= 1 ? that._formatColor('hsl(hp%,sp%,vp%)', color) : false;
      },
      'HSLA%': function (color, that) {
        return that._formatColor('hsla(hp%,sp%,vp%,af)', color);
      },
      'NAME': function (color, that) {
        return that._closestName(color);
      },
      'EXACT': function (color, that) {
        //@todo experimental. Implement a good fallback list
        return that._exactName(color);
      }
    }
  });
})(jQuery);
/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals.
    factory(jQuery);
  }
})(function ($) {
  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  function converted(s) {
    if (s.indexOf('"') === 0) {
      // This is a quoted cookie as according to RFC2068, unescape
      s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }

    try {
      return config.json ? JSON.parse(s) : s;
    } catch (er) {}
  }

  var config = $.cookie = function (key, value, options) {
    // write
    if (value !== undefined) {
      options = $.extend({}, config.defaults, options);

      if (typeof options.expires === 'number') {
        var days = options.expires,
            t = options.expires = new Date();
        t.setDate(t.getDate() + days);
      }

      value = config.json ? JSON.stringify(value) : String(value);
      return document.cookie = [config.raw ? key : encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
      options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');
    } // read


    var decode = config.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    var result = key ? undefined : {};

    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      var name = decode(parts.shift());
      var cookie = decode(parts.join('='));

      if (key && key === name) {
        result = converted(cookie);
        break;
      }

      if (!key) {
        result[name] = converted(cookie);
      }
    }

    return result;
  };

  config.defaults = {};

  $.removeCookie = function (key, options) {
    if ($.cookie(key) !== undefined) {
      // Must not alter options, thus extending a fresh object...
      $.cookie(key, '', $.extend({}, options, {
        expires: -1
      }));
      return true;
    }

    return false;
  };
});
/**
 * jquery.dump.js
 * @author Torkild Dyvik Olsen
 * @version 1.0
 *
 * A simple debug function to gather information about an object.
 * Returns a nested tree with information.
 *
 */
(function ($) {
  $.fn.dump = function () {
    return $.dump(this);
  };

  $.dump = function (object) {
    var recursion = function (obj, level) {
      if (!level) level = 0;
      var dump = '',
          p = '';

      for (i = 0; i < level; i++) p += "\t";

      t = type(obj);

      switch (t) {
        case "string":
          return '"' + obj + '"';
          break;

        case "number":
          return obj.toString();
          break;

        case "boolean":
          return obj ? 'true' : 'false';

        case "date":
          return "Date: " + obj.toLocaleString();

        case "array":
          dump += 'Array ( \n';
          $.each(obj, function (k, v) {
            dump += p + '\t' + k + ' => ' + recursion(v, level + 1) + '\n';
          });
          dump += p + ')';
          break;

        case "object":
          dump += 'Object { \n';
          $.each(obj, function (k, v) {
            dump += p + '\t' + k + ': ' + recursion(v, level + 1) + '\n';
          });
          dump += p + '}';
          break;

        case "jquery":
          dump += 'jQuery Object { \n';
          $.each(obj, function (k, v) {
            dump += p + '\t' + k + ' = ' + recursion(v, level + 1) + '\n';
          });
          dump += p + '}';
          break;

        case "regexp":
          return "RegExp: " + obj.toString();

        case "error":
          return obj.toString();

        case "document":
        case "domelement":
          dump += 'DOMElement [ \n' + p + '\tnodeName: ' + obj.nodeName + '\n' + p + '\tnodeValue: ' + obj.nodeValue + '\n' + p + '\tinnerHTML: [ \n';
          $.each(obj.childNodes, function (k, v) {
            if (k < 1) var r = 0;

            if (type(v) == "string") {
              if (v.textContent.match(/[^\s]/)) {
                dump += p + '\t\t' + (k - (r || 0)) + ' = String: ' + trim(v.textContent) + '\n';
              } else {
                r--;
              }
            } else {
              dump += p + '\t\t' + (k - (r || 0)) + ' = ' + recursion(v, level + 2) + '\n';
            }
          });
          dump += p + '\t]\n' + p + ']';
          break;

        case "function":
          var match = obj.toString().match(/^(.*)\(([^\)]*)\)/im);
          match[1] = trim(match[1].replace(new RegExp("[\\s]+", "g"), " "));
          match[2] = trim(match[2].replace(new RegExp("[\\s]+", "g"), " "));
          return match[1] + "(" + match[2] + ")";

        case "window":
        default:
          dump += 'N/A: ' + t;
          break;
      }

      return dump;
    };

    var type = function (obj) {
      var type = typeof obj;

      if (type != "object") {
        return type;
      }

      switch (obj) {
        case null:
          return 'null';

        case window:
          return 'window';

        case document:
          return 'document';

        case window.event:
          return 'event';

        default:
          break;
      }

      if (obj.jquery) {
        return 'jquery';
      }

      switch (obj.constructor) {
        case Array:
          return 'array';

        case Boolean:
          return 'boolean';

        case Date:
          return 'date';

        case Object:
          return 'object';

        case RegExp:
          return 'regexp';

        case ReferenceError:
        case Error:
          return 'error';

        case null:
        default:
          break;
      }

      switch (obj.nodeType) {
        case 1:
          return 'domelement';

        case 3:
          return 'string';

        case null:
        default:
          break;
      }

      return 'Unknown';
    };

    return recursion(object);
  };

  function trim(str) {
    return ltrim(rtrim(str));
  }

  function ltrim(str) {
    return str.replace(new RegExp("^[\\s]+", "g"), "");
  }

  function rtrim(str) {
    return str.replace(new RegExp("[\\s]+$", "g"), "");
  }
})(jQuery);
/*
 * jQuery plugin: fieldSelection - v0.1.1 - last change: 2006-12-16
 * (c) 2006 Alex Brem <alex@0xab.cd> - http://blog.0xab.cd
 */
(function () {
  var fieldSelection = {
    getSelection: function () {
      var e = this.jquery ? this[0] : this;
      return (
      /* mozilla / dom 3.0 */
      'selectionStart' in e && function () {
        var l = e.selectionEnd - e.selectionStart;
        return {
          start: e.selectionStart,
          end: e.selectionEnd,
          length: l,
          text: e.value.substr(e.selectionStart, l)
        };
      } || document.selection && function () {
        e.focus();
        var r = document.selection.createRange();

        if (r === null) {
          return {
            start: 0,
            end: e.value.length,
            length: 0
          };
        }

        var re = e.createTextRange();
        var rc = re.duplicate();
        re.moveToBookmark(r.getBookmark());
        rc.setEndPoint('EndToStart', re);
        return {
          start: rc.text.length,
          end: rc.text.length + r.text.length,
          length: r.text.length,
          text: r.text
        };
      } ||
      /* browser not supported */
      function () {
        return null;
      })();
    },
    setSelection: function () {
      var e = this.jquery ? this[0] : this;
      var args = arguments[0] || {};
      return (
      /* mozilla / dom 3.0 */
      'selectionStart' in e && function () {
        var start = typeof args == 'object' ? args.start : args;

        if (start != undefined) {
          e.selectionStart = start;
        }

        if (args.end != undefined) {
          e.selectionEnd = args.end;
        }

        e.focus();
        return this;
      } || document.selection && function () {
        e.focus();
        var r = document.selection.createRange();

        if (r === null) {
          return this;
        }

        var start = typeof args == 'object' ? args.start : args;

        if (start != undefined) {
          r.moveStart('character', -e.value.length);
          r.moveStart('character', start);
          r.collapse();
        }

        if (args.end != undefined) {
          r.moveEnd('character', args.end - start);
        }

        r.select();
        return this;
      } ||
      /* browser not supported */
      function () {
        e.focus();
        return jQuery(e);
      })();
    },
    replaceSelection: function () {
      var e = this.jquery ? this[0] : this;
      var text = arguments[0] || '';
      return (
      /* mozilla / dom 3.0 */
      'selectionStart' in e && function () {
        e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);
        return this;
      } || document.selection && function () {
        e.focus();
        document.selection.createRange().text = text;
        return this;
      } ||
      /* browser not supported */
      function () {
        e.value += text;
        return jQuery(e);
      })();
    }
  };
  jQuery.each(fieldSelection, function (i) {
    jQuery.fn[i] = this;
  });
})();
/**
* hoverIntent is similar to jQuery's built-in "hover" function except that
* instead of firing the onMouseOver event immediately, hoverIntent checks
* to see if the user's mouse has slowed down (beneath the sensitivity
* threshold) before firing the onMouseOver event.
*
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
*
* hoverIntent is currently available for use in all personal or commercial
* projects under both MIT and GPL licenses. This means that you can choose
* the license that best suits your project, and use it accordingly.
*
* // basic usage (just like .hover) receives onMouseOver and onMouseOut functions
* $("ul li").hoverIntent( showNav , hideNav );
*
* // advanced usage receives configuration object only
* $("ul li").hoverIntent({
*	sensitivity: 7, // number = sensitivity threshold (must be 1 or higher)
*	interval: 100,   // number = milliseconds of polling interval
*	over: showNav,  // function = onMouseOver callback (required)
*	timeout: 0,   // number = milliseconds delay before onMouseOut function call
*	out: hideNav    // function = onMouseOut callback (required)
* });
*
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function ($) {
  $.fn.hoverIntent = function (f, g) {
    // default configuration options
    var cfg = {
      sensitivity: 7,
      interval: 100,
      timeout: 0
    }; // override configuration options with user supplied object

    cfg = $.extend(cfg, g ? {
      over: f,
      out: g
    } : f); // instantiate variables
    // cX, cY = current X and Y position of mouse, updated by mousemove event
    // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval

    var cX, cY, pX, pY; // A private function for getting mouse position

    var track = function (ev) {
      cX = ev.pageX;
      cY = ev.pageY;
    }; // A private function for comparing current and previous mouse position


    var compare = function (ev, ob) {
      ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); // compare mouse positions to see if they've crossed the threshold

      if (Math.abs(pX - cX) + Math.abs(pY - cY) < cfg.sensitivity) {
        $(ob).unbind("mousemove", track); // set hoverIntent state to true (so mouseOut can be called)

        ob.hoverIntent_s = 1;
        return cfg.over.apply(ob, [ev]);
      } else {
        // set previous coordinates for next time
        pX = cX;
        pY = cY; // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)

        ob.hoverIntent_t = setTimeout(function () {
          compare(ev, ob);
        }, cfg.interval);
      }
    }; // A private function for delaying the mouseOut function


    var delay = function (ev, ob) {
      ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
      ob.hoverIntent_s = 0;
      return cfg.out.apply(ob, [ev]);
    }; // A private function for handling mouse 'hovering'


    var handleHover = function (e) {
      // copy objects to be passed into t (required for event object to be passed in IE)
      var ev = jQuery.extend({}, e);
      var ob = this; // cancel hoverIntent timer if it exists

      if (ob.hoverIntent_t) {
        ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
      } // if e.type == "mouseenter"


      if (e.type == "mouseenter") {
        // set "previous" X and Y position based on initial entry point
        pX = ev.pageX;
        pY = ev.pageY; // update "current" X and Y position based on mousemove

        $(ob).bind("mousemove", track); // start polling interval (self-calling timeout) to compare mouse coordinates over time

        if (ob.hoverIntent_s != 1) {
          ob.hoverIntent_t = setTimeout(function () {
            compare(ev, ob);
          }, cfg.interval);
        } // else e.type == "mouseleave"

      } else {
        // unbind expensive mousemove event
        $(ob).unbind("mousemove", track); // if hoverIntent state is true, then call the mouseOut function after the specified delay

        if (ob.hoverIntent_s == 1) {
          ob.hoverIntent_t = setTimeout(function () {
            delay(ev, ob);
          }, cfg.timeout);
        }
      }
    }; // bind the function to the two event listeners


    return this.bind('mouseenter', handleHover).bind('mouseleave', handleHover);
  };
})(jQuery);
/*
 * jQuery JSONP Core Plugin 2.4.0 (2012-08-21)
 *
 * https://github.com/jaubourg/jquery-jsonp
 *
 * Copyright (c) 2012 Julian Aubourg
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 */
(function ($) {
  // ###################### UTILITIES ##
  // Noop
  function noop() {} // Generic callback


  function genericCallback(data) {
    lastValue = [data];
  } // Call if defined


  function callIfDefined(method, object, parameters) {
    return method && method.apply(object.context || object, parameters);
  } // Give joining character given url


  function qMarkOrAmp(url) {
    return /\?/.test(url) ? "&" : "?";
  }

  var // String constants (for better minification)
  STR_ASYNC = "async",
      STR_CHARSET = "charset",
      STR_EMPTY = "",
      STR_ERROR = "error",
      STR_INSERT_BEFORE = "insertBefore",
      STR_JQUERY_JSONP = "_jqjsp",
      STR_ON = "on",
      STR_ON_CLICK = STR_ON + "click",
      STR_ON_ERROR = STR_ON + STR_ERROR,
      STR_ON_LOAD = STR_ON + "load",
      STR_ON_READY_STATE_CHANGE = STR_ON + "readystatechange",
      STR_READY_STATE = "readyState",
      STR_REMOVE_CHILD = "removeChild",
      STR_SCRIPT_TAG = "<script>",
      STR_SUCCESS = "success",
      STR_TIMEOUT = "timeout",
      // Window
  win = window,
      // Deferred
  Deferred = $.Deferred,
      // Head element
  head = $("head")[0] || document.documentElement,
      // Page cache
  pageCache = {},
      // Counter
  count = 0,
      // Last returned value
  lastValue,
      // ###################### DEFAULT OPTIONS ##
  xOptionsDefaults = {
    //beforeSend: undefined,
    //cache: false,
    callback: STR_JQUERY_JSONP,
    //callbackParameter: undefined,
    //charset: undefined,
    //complete: undefined,
    //context: undefined,
    //data: "",
    //dataFilter: undefined,
    //error: undefined,
    //pageCache: false,
    //success: undefined,
    //timeout: 0,
    //traditional: false,
    url: location.href
  },
      // opera demands sniffing :/
  opera = win.opera,
      // IE < 10
  oldIE = !!$("<div>").html("<!--[if IE]><i><![endif]-->").find("i").length; // ###################### MAIN FUNCTION ##

  function jsonp(xOptions) {
    // Build data with default
    xOptions = $.extend({}, xOptionsDefaults, xOptions); // References to xOptions members (for better minification)

    var successCallback = xOptions.success,
        errorCallback = xOptions.error,
        completeCallback = xOptions.complete,
        dataFilter = xOptions.dataFilter,
        callbackParameter = xOptions.callbackParameter,
        successCallbackName = xOptions.callback,
        cacheFlag = xOptions.cache,
        pageCacheFlag = xOptions.pageCache,
        charset = xOptions.charset,
        url = xOptions.url,
        data = xOptions.data,
        timeout = xOptions.timeout,
        pageCached,
        // Abort/done flag
    done = 0,
        // Life-cycle functions
    cleanUp = noop,
        // Support vars
    supportOnload,
        supportOnreadystatechange,
        // Request execution vars
    firstChild,
        script,
        scriptAfter,
        timeoutTimer; // If we have Deferreds:
    // - substitute callbacks
    // - promote xOptions to a promise

    Deferred && Deferred(function (defer) {
      defer.done(successCallback).fail(errorCallback);
      successCallback = defer.resolve;
      errorCallback = defer.reject;
    }).promise(xOptions); // Create the abort method

    xOptions.abort = function () {
      !done++ && cleanUp();
    }; // Call beforeSend if provided (early abort if false returned)


    if (callIfDefined(xOptions.beforeSend, xOptions, [xOptions]) === !1 || done) {
      return xOptions;
    } // Control entries


    url = url || STR_EMPTY;
    data = data ? typeof data == "string" ? data : $.param(data, xOptions.traditional) : STR_EMPTY; // Build final url

    url += data ? qMarkOrAmp(url) + data : STR_EMPTY; // Add callback parameter if provided as option

    callbackParameter && (url += qMarkOrAmp(url) + encodeURIComponent(callbackParameter) + "=?"); // Add anticache parameter if needed

    !cacheFlag && !pageCacheFlag && (url += qMarkOrAmp(url) + "_" + new Date().getTime() + "="); // Replace last ? by callback parameter

    url = url.replace(/=\?(&|$)/, "=" + successCallbackName + "$1"); // Success notifier

    function notifySuccess(json) {
      if (!done++) {
        cleanUp(); // Pagecache if needed

        pageCacheFlag && (pageCache[url] = {
          s: [json]
        }); // Apply the data filter if provided

        dataFilter && (json = dataFilter.apply(xOptions, [json])); // Call success then complete

        callIfDefined(successCallback, xOptions, [json, STR_SUCCESS, xOptions]);
        callIfDefined(completeCallback, xOptions, [xOptions, STR_SUCCESS]);
      }
    } // Error notifier


    function notifyError(type) {
      if (!done++) {
        // Clean up
        cleanUp(); // If pure error (not timeout), cache if needed

        pageCacheFlag && type != STR_TIMEOUT && (pageCache[url] = type); // Call error then complete

        callIfDefined(errorCallback, xOptions, [xOptions, type]);
        callIfDefined(completeCallback, xOptions, [xOptions, type]);
      }
    } // Check page cache


    if (pageCacheFlag && (pageCached = pageCache[url])) {
      pageCached.s ? notifySuccess(pageCached.s[0]) : notifyError(pageCached);
    } else {
      // Install the generic callback
      // (BEWARE: global namespace pollution ahoy)
      win[successCallbackName] = genericCallback; // Create the script tag

      script = $(STR_SCRIPT_TAG)[0];
      script.id = STR_JQUERY_JSONP + count++; // Set charset if provided

      if (charset) {
        script[STR_CHARSET] = charset;
      }

      opera && opera.version() < 11.60 ? (scriptAfter = $(STR_SCRIPT_TAG)[0]).text = "document.getElementById('" + script.id + "')." + STR_ON_ERROR + "()" : script[STR_ASYNC] = STR_ASYNC; // Internet Explorer: event/htmlFor trick

      if (oldIE) {
        script.htmlFor = script.id;
        script.event = STR_ON_CLICK;
      } // Attached event handlers


      script[STR_ON_LOAD] = script[STR_ON_ERROR] = script[STR_ON_READY_STATE_CHANGE] = function (result) {
        // Test readyState if it exists
        if (!script[STR_READY_STATE] || !/i/.test(script[STR_READY_STATE])) {
          try {
            script[STR_ON_CLICK] && script[STR_ON_CLICK]();
          } catch (_) {}

          result = lastValue;
          lastValue = 0;
          result ? notifySuccess(result[0]) : notifyError(STR_ERROR);
        }
      }; // Set source


      script.src = url; // Re-declare cleanUp function

      cleanUp = function (i) {
        timeoutTimer && clearTimeout(timeoutTimer);
        script[STR_ON_READY_STATE_CHANGE] = script[STR_ON_LOAD] = script[STR_ON_ERROR] = null;
        head[STR_REMOVE_CHILD](script);
        scriptAfter && head[STR_REMOVE_CHILD](scriptAfter);
      }; // Append main script


      head[STR_INSERT_BEFORE](script, firstChild = head.firstChild); // Append trailing script if needed

      scriptAfter && head[STR_INSERT_BEFORE](scriptAfter, firstChild); // If a timeout is needed, install it

      timeoutTimer = timeout > 0 && setTimeout(function () {
        notifyError(STR_TIMEOUT);
      }, timeout);
    }

    return xOptions;
  } // ###################### SETUP FUNCTION ##


  jsonp.setup = function (xOptions) {
    $.extend(xOptionsDefaults, xOptions);
  }; // ###################### INSTALL in jQuery ##


  $.jsonp = jsonp;
})(jQuery);
// ----------------------------------------------------------------------------
// markItUp! Universal MarkUp Engine, JQuery plugin
// v 1.1.x
// Dual licensed under the MIT and GPL licenses.
// ----------------------------------------------------------------------------
// Copyright (C) 2007-2012 Jay Salvat
// http://markitup.jaysalvat.com/
// ----------------------------------------------------------------------------
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ----------------------------------------------------------------------------
(function ($) {
  $.fn.markItUp = function (settings, extraSettings) {
    var method, params, options, ctrlKey, shiftKey, altKey;
    ctrlKey = shiftKey = altKey = false;

    if (typeof settings == 'string') {
      method = settings;
      params = extraSettings;
    }

    options = {
      id: '',
      nameSpace: '',
      root: '',
      previewHandler: false,
      previewInWindow: '',
      // 'width=800, height=600, resizable=yes, scrollbars=yes'
      previewInElement: '',
      previewAutoRefresh: true,
      previewPosition: 'after',
      previewTemplatePath: '~/templates/preview.html',
      previewParser: false,
      previewParserPath: '',
      previewParserVar: 'data',
      resizeHandle: true,
      beforeInsert: '',
      afterInsert: '',
      onEnter: {},
      onShiftEnter: {},
      onCtrlEnter: {},
      onTab: {},
      markupSet: [{
        /* set */
      }] // changed to Obj Array to allow for distinction between basic and advanced set

    };
    $.extend(options, settings, extraSettings); // compute markItUp! path

    if (!options.root) {
      $('script').each(function (a, tag) {
        miuScript = $(tag).get(0).src.match(/(.*)jquery\.markitup(\.pack)?\.js$/);

        if (miuScript !== null) {
          options.root = miuScript[1];
        }
      });
    } // Quick patch to keep compatibility with jQuery 1.9


    var uaMatch = function (ua) {
      ua = ua.toLowerCase();
      var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      return {
        browser: match[1] || "",
        version: match[2] || "0"
      };
    };

    var matched = uaMatch(navigator.userAgent);
    var browser = {};

    if (matched.browser) {
      browser[matched.browser] = true;
      browser.version = matched.version;
    }

    if (browser.chrome) {
      browser.webkit = true;
    } else if (browser.webkit) {
      browser.safari = true;
    }

    return this.each(function () {
      var $$, textarea, levels, scrollPosition, caretPosition, caretOffset, clicked, hash, header, footer, previewWindow, template, iFrame, abort;
      $$ = $(this);
      textarea = this;
      levels = [];
      abort = false;
      scrollPosition = caretPosition = 0;
      caretOffset = -1;
      options.previewParserPath = localize(options.previewParserPath);
      options.previewTemplatePath = localize(options.previewTemplatePath);

      if (method) {
        switch (method) {
          case 'remove':
            remove();
            break;

          case 'insert':
            markup(params);
            break;

          default:
            $.error('Method ' + method + ' does not exist on jQuery.markItUp');
        }

        return;
      } // apply the computed path to ~/


      function localize(data, inText) {
        if (inText) {
          return data.replace(/("|')~\//g, "$1" + options.root);
        }

        return data.replace(/^~\//, options.root);
      } // init and build editor


      function init() {
        id = '';
        nameSpace = '';

        if (options.id) {
          id = 'id="' + options.id + '"';
        } else if ($$.attr("id")) {
          id = 'id="markItUp' + $$.attr("id").substr(0, 1).toUpperCase() + $$.attr("id").substr(1) + '"';
        }

        if (options.nameSpace) {
          nameSpace = 'class="' + options.nameSpace + '"';
        }

        $$.wrap('<div ' + nameSpace + '></div>');
        $$.wrap('<div ' + id + ' class="markItUp"></div>');
        $$.wrap('<div class="markItUpContainer"></div>');
        $$.addClass("markItUpEditor"); // add the header before the textarea

        header = $('<div class="markItUpHeader"></div>').insertBefore($$); // $(dropMenus(options.markupSet)).appendTo(header);
        // basic

        var $basicSet = $(dropMenus(options.markupSet[0], 'miu_basic'));
        $basicSet.append('<li class="txt_link fright li_miu_advanced"><span class="toggle_miu_advanced show_miu_advanced awesome-button" role="button">' + locaKeys.moreopts + '</span></li>');
        $basicSet.appendTo(header); // advanced

        var $advancedSet = $(dropMenus(options.markupSet[1], 'miu_advanced'));
        $advancedSet.appendTo(header).hide();
        footer = $('<div class="markItUpFooter"></div>').insertAfter($$); // add the resize handle after textarea

        if (options.resizeHandle === true && browser.safari !== true) {
          resizeHandle = $('<div class="markItUpResizeHandle"></div>').insertAfter($$).bind("mousedown.markItUp", function (e) {
            var h = $$.height(),
                y = e.clientY,
                mouseMove,
                mouseUp;

            mouseMove = function (e) {
              $$.css("height", Math.max(20, e.clientY + h - y) + "px");
              return false;
            };

            mouseUp = function (e) {
              $("html").unbind("mousemove.markItUp", mouseMove).unbind("mouseup.markItUp", mouseUp);
              return false;
            };

            $("html").bind("mousemove.markItUp", mouseMove).bind("mouseup.markItUp", mouseUp);
          });
          footer.append(resizeHandle);
        } // listen key events


        $$.bind('keydown.markItUp', keyPressed).bind('keyup', keyPressed); // bind an event to catch external calls

        $$.bind("insertion.markItUp", function (e, settings) {
          if (settings.target !== false) {
            get();
          }

          if (textarea === $.markItUp.focused) {
            markup(settings);
          }
        }); // remember the last focus

        $$.bind('focus.markItUp', function () {
          $.markItUp.focused = this;
        });

        if (options.previewInElement) {
          refreshPreview();
        }
      } // recursively build header with dropMenus from markupset


      function dropMenus(markupSet, mSetClass) {
        if (!mSetClass) mSetClass = '';
        var ul = $('<ul class="' + mSetClass + '"></ul>'),
            i = 0; //$('li:hover > ul', ul).css('display', 'block');

        $.each(markupSet, function () {
          var button = this,
              t = '',
              title,
              li,
              j;
          title = button.key ? (button.name || '') + ' [Ctrl+' + button.key + ']' : button.name || '';
          key = button.key ? 'accesskey="' + button.key + '"' : '';

          if (button.separator) {
            li = $('<li class="markItUpSeparator">' + (button.separator || '') + '</li>').appendTo(ul);
          } else {
            i++;

            for (j = levels.length - 1; j >= 0; j--) {
              t += levels[j] + "-";
            }

            li = $('<li class="markItUpButton markItUpButton' + t + i + ' ' + (button.className || '') + '"><a href="" ' + key + ' title="' + title + '">' + (button.name || '') + '</a></li>').bind("contextmenu.markItUp", function () {
              // prevent contextmenu on mac and allow ctrl+click
              return false;
            }).appendTo(ul);

            if (!isMobile) {
              li.unbind('click.markItUp').bind('click.markItUp', function () {
                if (button.call) {
                  eval(button.call)();
                } else {
                  // beim 1. Aufruf verschieben... an body haengen
                  var $innerUL = $('>ul', li);

                  if ($innerUL.length > 0) {
                    // ausblenden wenn parent ausgeblendet wird
                    $innerUL.parents('.ui-dialog').find('.ui-dialog-titlebar-close').on('click', function () {
                      $innerUL.hide();
                    });
                    $innerUL.addClass('markItUpOutpost');
                    $('body').append($innerUL);
                    var randomId = Math.ceil(Math.random() * 10000);
                    li.attr('id', 'markitUpDropdown' + randomId);
                    $innerUL.attr('rel', 'markitUpDropdown' + randomId); // eine Auswahl darin soll das UL auch wieder schliessen

                    $innerUL.find('>li').bind('click.markItUp', function () {
                      $innerUL.hide();
                      li.attr('data-opened', 0);
                    });
                    $(window).on('resize', function (e) {
                      // nicht huebsch, aber benoetigt fuer allyrundmails + zoom<1
                      repositionDropdowns($innerUL, li);
                    });
                  } else {
                    // nicht erster aufruf - unterelement von body holen
                    $innerUL = $('body>ul[rel="' + li.attr('id') + '"]');
                  }

                  $('html').one('click.markItUp2', function () {
                    $innerUL.hide();
                    li.attr('data-opened', 0);
                  }); // bei jedem klick neu positionieren

                  repositionDropdowns($innerUL, li); // Sichtbarkeit toggeln

                  if ($innerUL.filter(':visible').length) {
                    $innerUL.hide();
                    li.attr('data-opened', 0);
                  } else {
                    $innerUL.show();
                    li.attr('data-opened', 1);
                  }
                }

                setTimeout(function () {
                  markup(button);
                }, 1);
                return false;
              }).bind("focusin.markItUp", function () {
                $$.focus();
              });
            } else {
              li.bind('click.markItUp', function () {
                $(header).find('ul ul').hide();

                if ($(this).find('> ul').length) {
                  $(this).find('> ul').show();
                } else {
                  if (button.call) {
                    eval(button.call)();
                  }

                  setTimeout(function () {
                    markup(button);
                  }, 1);
                }

                return false;
              });
            }

            if (button.dropMenu) {
              levels.push(i);
              $(li).addClass('markItUpDropMenu').append(dropMenus(button.dropMenu));
              var dropDownArr = $('<span class="dropdown_arr"></span>');
              $(li).append(dropDownArr);
            }
          }
        });
        levels.pop();
        return ul;
      }

      function repositionDropdowns($innerUL, li) {
        // bei jedem klick neu positionieren
        var ulHeight = $innerUL.outerHeight();
        var top;
        var dropDownTop = Math.ceil(li.offset().top);

        if (dropDownTop + li.height() + ulHeight + $('#siteFooter').outerHeight() >= $(window).innerHeight() + $(window).scrollTop()) {
          top = dropDownTop - ulHeight - 2;
        } else {
          top = dropDownTop + 29;
        }

        $innerUL.css({
          'top': top,
          'left': Math.floor(li.offset()['left'])
        });
      } // markItUp! markups


      function magicMarkups(string) {
        if (string) {
          string = string.toString();
          string = string.replace(/\(\!\(([\s\S]*?)\)\!\)/g, function (x, a) {
            var b = a.split('|!|');

            if (altKey === true) {
              return b[1] !== undefined ? b[1] : b[0];
            } else {
              return b[1] === undefined ? "" : b[0];
            }
          }); // [![prompt]!], [![prompt:!:value]!]

          string = string.replace(/\[\!\[([\s\S]*?)\]\!\]/g, function (x, a) {
            var b = a.split(':!:');

            if (abort === true) {
              return false;
            }

            value = prompt(b[0], b[1] ? b[1] : '');

            if (value === null) {
              abort = true;
            }

            return value;
          });
          return string;
        }

        return "";
      } // prepare action


      function prepare(action) {
        if ($.isFunction(action)) {
          action = action(hash);
        }

        return magicMarkups(action);
      } // build block to insert


      function build(string) {
        var openWith = prepare(clicked.openWith);
        var placeHolder = prepare(clicked.placeHolder);
        var replaceWith = prepare(clicked.replaceWith);
        var closeWith = prepare(clicked.closeWith);
        var openBlockWith = prepare(clicked.openBlockWith);
        var closeBlockWith = prepare(clicked.closeBlockWith);
        var multiline = clicked.multiline;

        if (replaceWith !== "") {
          block = openWith + replaceWith + closeWith;
        } else if (selection === '' && placeHolder !== '') {
          block = openWith + placeHolder + closeWith;
        } else {
          string = string || selection;
          var lines = [string],
              blocks = [];

          if (multiline === true) {
            lines = string.split(/\r?\n/);
          }

          for (var l = 0; l < lines.length; l++) {
            line = lines[l];
            var trailingSpaces;

            if (trailingSpaces = line.match(/ *$/)) {
              blocks.push(openWith + line.replace(/ *$/g, '') + closeWith + trailingSpaces);
            } else {
              blocks.push(openWith + line + closeWith);
            }
          }

          block = blocks.join("\n");
        }

        block = openBlockWith + block + closeBlockWith;
        return {
          block: block,
          openBlockWith: openBlockWith,
          openWith: openWith,
          replaceWith: replaceWith,
          placeHolder: placeHolder,
          closeWith: closeWith,
          closeBlockWith: closeBlockWith
        };
      } // define markup to insert


      function markup(button) {
        var len, j, n, i;
        hash = clicked = button;
        get();
        $.extend(hash, {
          line: "",
          root: options.root,
          textarea: textarea,
          selection: selection || '',
          caretPosition: caretPosition,
          ctrlKey: ctrlKey,
          shiftKey: shiftKey,
          altKey: altKey
        }); // callbacks before insertion

        prepare(options.beforeInsert);
        prepare(clicked.beforeInsert);

        if (ctrlKey === true && shiftKey === true || button.multiline === true) {
          prepare(clicked.beforeMultiInsert);
        }

        $.extend(hash, {
          line: 1
        });

        if (ctrlKey === true && shiftKey === true) {
          lines = selection.split(/\r?\n/);

          for (j = 0, n = lines.length, i = 0; i < n; i++) {
            if ($.trim(lines[i]) !== '') {
              $.extend(hash, {
                line: ++j,
                selection: lines[i]
              });
              lines[i] = build(lines[i]).block;
            } else {
              lines[i] = "";
            }
          }

          string = {
            block: lines.join('\n')
          };
          start = caretPosition;
          len = string.block.length + (browser.opera ? n - 1 : 0);
        } else if (ctrlKey === true) {
          string = build(selection);
          start = caretPosition + string.openWith.length;
          len = string.block.length - string.openWith.length - string.closeWith.length;
          len = len - (string.block.match(/ $/) ? 1 : 0);
          len -= fixIeBug(string.block);
        } else if (shiftKey === true) {
          string = build(selection);
          start = caretPosition;
          len = string.block.length;
          len -= fixIeBug(string.block);
        } else {
          string = build(selection);
          start = caretPosition + string.block.length;
          len = 0;
          start -= fixIeBug(string.block);
        }

        if (selection === '' && string.replaceWith === '') {
          caretOffset += fixOperaBug(string.block);
          start = caretPosition + string.openBlockWith.length + string.openWith.length;
          len = string.block.length - string.openBlockWith.length - string.openWith.length - string.closeWith.length - string.closeBlockWith.length;
          caretOffset = $$.val().substring(caretPosition, $$.val().length).length;
          caretOffset -= fixOperaBug($$.val().substring(0, caretPosition));
        }

        $.extend(hash, {
          caretPosition: caretPosition,
          scrollPosition: scrollPosition
        });

        if (string.block !== selection && abort === false) {
          insert(string.block);
          set(start, len);
        } else {
          caretOffset = -1;
        }

        get();
        $.extend(hash, {
          line: '',
          selection: selection
        }); // callbacks after insertion

        if (ctrlKey === true && shiftKey === true || button.multiline === true) {
          prepare(clicked.afterMultiInsert);
        }

        prepare(clicked.afterInsert);
        prepare(options.afterInsert); // refresh preview if opened

        if (previewWindow && options.previewAutoRefresh) {
          refreshPreview();
        } // reinit keyevent


        shiftKey = altKey = ctrlKey = abort = false;
      } // Substract linefeed in Opera


      function fixOperaBug(string) {
        if (browser.opera) {
          return string.length - string.replace(/\n*/g, '').length;
        }

        return 0;
      } // Substract linefeed in IE


      function fixIeBug(string) {
        if (browser.msie) {
          return string.length - string.replace(/\r*/g, '').length;
        }

        return 0;
      } // add markup


      function insert(block) {
        if (document.selection) {
          var newSelection = document.selection.createRange();
          newSelection.text = block;
        } else {
          textarea.value = textarea.value.substring(0, caretPosition) + block + textarea.value.substring(caretPosition + selection.length, textarea.value.length);
        }
      } // set a selection


      function set(start, len) {
        if (textarea.createTextRange) {
          // quick fix to make it work on Opera 9.5
          if (browser.opera && browser.version >= 9.5 && len == 0) {
            return false;
          }

          range = textarea.createTextRange();
          range.collapse(true);
          range.moveStart('character', start);
          range.moveEnd('character', len);
          range.select();
        } else if (textarea.setSelectionRange) {
          textarea.setSelectionRange(start, start + len);
        }

        textarea.scrollTop = scrollPosition;
        textarea.focus();
      } // get the selection


      function get() {
        textarea.focus();
        scrollPosition = textarea.scrollTop;

        if (document.selection) {
          selection = document.selection.createRange().text;

          if (browser.msie) {
            // ie
            var range = document.selection.createRange(),
                rangeCopy = range.duplicate();
            rangeCopy.moveToElementText(textarea);
            caretPosition = -1;

            while (rangeCopy.inRange(range)) {
              rangeCopy.moveStart('character');
              caretPosition++;
            }
          } else {
            // opera
            caretPosition = textarea.selectionStart;
          }
        } else {
          // gecko & webkit
          caretPosition = textarea.selectionStart;
          selection = textarea.value.substring(caretPosition, textarea.selectionEnd);
        }

        return selection;
      } // open preview window


      function preview() {
        if (typeof options.previewHandler === 'function') {
          previewWindow = true;
        } else if (options.previewInElement) {
          previewWindow = $(options.previewInElement);
        } else if (!previewWindow || previewWindow.closed) {
          if (options.previewInWindow) {
            previewWindow = window.open('', 'preview', options.previewInWindow);
            $(window).unload(function () {
              previewWindow.close();
            });
          } else {
            iFrame = $('<iframe class="markItUpPreviewFrame"></iframe>');

            if (options.previewPosition == 'after') {
              iFrame.insertAfter(footer);
            } else {
              iFrame.insertBefore(header);
            }

            previewWindow = iFrame[iFrame.length - 1].contentWindow || frame[iFrame.length - 1];
          }
        } else if (altKey === true) {
          if (iFrame) {
            iFrame.remove();
          } else {
            previewWindow.close();
          }

          previewWindow = iFrame = false;
        }

        if (!options.previewAutoRefresh) {
          refreshPreview();
        }

        if (options.previewInWindow) {
          previewWindow.focus();
        }
      } // refresh Preview window


      function refreshPreview() {
        renderPreview();
      }

      function renderPreview() {
        var phtml;

        if (options.previewHandler && typeof options.previewHandler === 'function') {
          options.previewHandler($$.val());
        } else if (options.previewParser && typeof options.previewParser === 'function') {
          var data = options.previewParser($$.val());
          writeInPreview(localize(data, 1));
        } else if (options.previewParserPath !== '') {
          $.ajax({
            type: 'POST',
            dataType: 'text',
            global: false,
            url: options.previewParserPath,
            data: options.previewParserVar + '=' + encodeURIComponent($$.val()),
            success: function (data) {
              writeInPreview(localize(data, 1));
            }
          });
        } else {
          if (!template) {
            $.ajax({
              url: options.previewTemplatePath,
              dataType: 'text',
              global: false,
              success: function (data) {
                writeInPreview(localize(data, 1).replace(/<!-- content -->/g, $$.val()));
              }
            });
          }
        }

        return false;
      }

      function writeInPreview(data) {
        if (options.previewInElement) {
          $(options.previewInElement).html(data);
        } else if (previewWindow && previewWindow.document) {
          try {
            sp = previewWindow.document.documentElement.scrollTop;
          } catch (e) {
            sp = 0;
          }

          previewWindow.document.open();
          previewWindow.document.write(data);
          previewWindow.document.close();
          previewWindow.document.documentElement.scrollTop = sp;
        }
      } // set keys pressed


      function keyPressed(e) {
        shiftKey = e.shiftKey;
        altKey = e.altKey;
        ctrlKey = !(e.altKey && e.ctrlKey) ? e.ctrlKey || e.metaKey : false;

        if (e.type === 'keydown') {
          if (ctrlKey === true) {
            li = $('a[accesskey="' + (e.keyCode == 13 ? '\\n' : String.fromCharCode(e.keyCode)) + '"]', header).parent('li');

            if (li.length !== 0) {
              ctrlKey = false;
              setTimeout(function () {
                li.triggerHandler('mouseup');
              }, 1);
              return false;
            }
          }

          if (e.keyCode === 13 || e.keyCode === 10) {
            // Enter key
            if (ctrlKey === true) {
              // Enter + Ctrl
              ctrlKey = false;
              markup(options.onCtrlEnter);
              return options.onCtrlEnter.keepDefault;
            } else if (shiftKey === true) {
              // Enter + Shift
              shiftKey = false;
              markup(options.onShiftEnter);
              return options.onShiftEnter.keepDefault;
            } else {
              // only Enter
              markup(options.onEnter);
              return options.onEnter.keepDefault;
            }
          }

          if (e.keyCode === 9) {
            // Tab key
            if (shiftKey == true || ctrlKey == true || altKey == true) {
              return false;
            }

            if (caretOffset !== -1) {
              get();
              caretOffset = $$.val().length - caretOffset;
              set(caretOffset, 0);
              caretOffset = -1;
              return false;
            } else {
              markup(options.onTab);
              return options.onTab.keepDefault;
            }
          }
        }
      }

      function remove() {
        $$.unbind(".markItUp").removeClass('markItUpEditor');
        $$.parent('div').parent('div.markItUp').parent('div').replaceWith($$);
        $$.data('markItUp', null);
      }

      init();
    });
  };

  $.fn.markItUpRemove = function () {
    return this.each(function () {
      $(this).markItUp('remove');
    });
  };

  $.markItUp = function (settings) {
    var options = {
      target: false
    };
    $.extend(options, settings);

    if (options.target) {
      return $(options.target).each(function () {
        $(this).focus();
        $(this).trigger('insertion', [options]);
      });
    } else {
      $('textarea').trigger('insertion', [options]);
    }
  };
})(jQuery);
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright 2015 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
!function (a) {
  "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery);
}(function (a) {
  function b(b) {
    var g = b || window.event,
        h = i.call(arguments, 1),
        j = 0,
        l = 0,
        m = 0,
        n = 0,
        o = 0,
        p = 0;

    if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
      if (1 === g.deltaMode) {
        var q = a.data(this, "mousewheel-line-height");
        j *= q, m *= q, l *= q;
      } else if (2 === g.deltaMode) {
        var r = a.data(this, "mousewheel-page-height");
        j *= r, m *= r, l *= r;
      }

      if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
        var s = this.getBoundingClientRect();
        o = b.clientX - s.left, p = b.clientY - s.top;
      }

      return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h);
    }
  }

  function c() {
    f = null;
  }

  function d(a, b) {
    return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0;
  }

  var e,
      f,
      g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
      h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
      i = Array.prototype.slice;
  if (a.event.fixHooks) for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = a.event.special.mousewheel = {
    version: "3.1.12",
    setup: function () {
      if (this.addEventListener) for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);else this.onmousewheel = b;
      a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this));
    },
    teardown: function () {
      if (this.removeEventListener) for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);else this.onmousewheel = null;
      a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height");
    },
    getLineHeight: function (b) {
      var c = a(b),
          d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
      return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16;
    },
    getPageHeight: function (b) {
      return a(b).height();
    },
    settings: {
      adjustOldDeltas: !0,
      normalizeOffset: !0
    }
  };
  a.fn.extend({
    mousewheel: function (a) {
      return a ? this.bind("mousewheel", a) : this.trigger("mousewheel");
    },
    unmousewheel: function (a) {
      return this.unbind("mousewheel", a);
    }
  });
});
(function ($) {
  $.extend({
    tablesorter: new function () {
      var parsers = [],
          widgets = [];
      this.defaults = {
        cssHeader: "header",
        cssAsc: "headerSortUp",
        cssDesc: "headerSortDown",
        cssChildRow: "expand-child",
        sortInitialOrder: "asc",
        sortMultiSortKey: "shiftKey",
        sortForce: null,
        sortAppend: null,
        sortLocaleCompare: true,
        textExtraction: "simple",
        parsers: {},
        widgets: [],
        widgetZebra: {
          css: ["even", "odd"]
        },
        headers: {},
        widthFixed: false,
        cancelSelection: true,
        sortList: [],
        headerList: [],
        dateFormat: "us",
        decimal: '/\.|\,/g',
        onRenderHeader: null,
        selectorHeaders: 'thead th',
        debug: false
      };

      function benchmark(s, d) {
        log(s + "," + (new Date().getTime() - d.getTime()) + "ms");
      }

      this.benchmark = benchmark;

      function log(s) {
        if (typeof console != "undefined" && typeof console.debug != "undefined") {
          console.log(s);
        } else {
          alert(s);
        }
      }

      function buildParserCache(table, $headers) {
        if (table.config.debug) {
          var parsersDebug = "";
        }

        if (table.tBodies.length == 0) return;
        var rows = table.tBodies[0].rows;

        if (rows[0]) {
          var list = [],
              cells = rows[0].cells,
              l = cells.length;

          for (var i = 0; i < l; i++) {
            var p = false;

            if ($.metadata && $($headers[i]).metadata() && $($headers[i]).metadata().sorter) {
              p = getParserById($($headers[i]).metadata().sorter);
            } else if (table.config.headers[i] && table.config.headers[i].sorter) {
              p = getParserById(table.config.headers[i].sorter);
            }

            if (!p) {
              p = detectParserForColumn(table, rows, -1, i);
            }

            if (table.config.debug) {
              parsersDebug += "column:" + i + " parser:" + p.id + "\n";
            }

            list.push(p);
          }
        }

        if (table.config.debug) {
          log(parsersDebug);
        }

        return list;
      }

      ;

      function detectParserForColumn(table, rows, rowIndex, cellIndex) {
        var l = parsers.length,
            node = false,
            nodeValue = false,
            keepLooking = true;

        while (nodeValue == '' && keepLooking) {
          rowIndex++;

          if (rows[rowIndex]) {
            node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);
            nodeValue = trimAndGetNodeText(table.config, node);

            if (table.config.debug) {
              log('Checking if value was empty on row:' + rowIndex);
            }
          } else {
            keepLooking = false;
          }
        }

        for (var i = 1; i < l; i++) {
          if (parsers[i].is(nodeValue, table, node)) {
            return parsers[i];
          }
        }

        return parsers[0];
      }

      function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {
        return rows[rowIndex].cells[cellIndex];
      }

      function trimAndGetNodeText(config, node) {
        return $.trim(getElementText(config, node));
      }

      function getParserById(name) {
        var l = parsers.length;

        for (var i = 0; i < l; i++) {
          if (parsers[i].id.toLowerCase() == name.toLowerCase()) {
            return parsers[i];
          }
        }

        return false;
      }

      function buildCache(table) {
        if (table.config.debug) {
          var cacheTime = new Date();
        }

        var totalRows = table.tBodies[0] && table.tBodies[0].rows.length || 0,
            totalCells = table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length || 0,
            parsers = table.config.parsers,
            cache = {
          row: [],
          normalized: []
        };

        for (var i = 0; i < totalRows; ++i) {
          var c = $(table.tBodies[0].rows[i]),
              cols = [];

          if (c.hasClass(table.config.cssChildRow)) {
            cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);
            continue;
          }

          cache.row.push(c);

          for (var j = 0; j < totalCells; ++j) {
            cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));
          }

          cols.push(cache.normalized.length);
          cache.normalized.push(cols);
          cols = null;
        }

        ;

        if (table.config.debug) {
          benchmark("Building cache for " + totalRows + " rows:", cacheTime);
        }

        return cache;
      }

      ;

      function getElementText(config, node) {
        var text = "";
        if (!node) return "";
        if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;

        if (config.textExtraction == "simple") {
          if (config.supportsTextContent) {
            text = node.textContent;
          } else {
            if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {
              text = node.childNodes[0].innerHTML;
            } else {
              text = node.innerHTML;
            }
          }
        } else {
          if (typeof config.textExtraction == "function") {
            text = config.textExtraction(node);
          } else {
            text = $(node).text();
          }
        }

        return text;
      }

      function appendToTable(table, cache) {
        if (table.config.debug) {
          var appendTime = new Date();
        }

        var c = cache,
            r = c.row,
            n = c.normalized,
            totalRows = n.length,
            checkCell = n[0].length - 1,
            tableBody = $(table.tBodies[0]),
            rows = [];

        for (var i = 0; i < totalRows; i++) {
          var pos = n[i][checkCell];
          rows.push(r[pos]);

          if (!table.config.appender) {
            var l = r[pos].length;

            for (var j = 0; j < l; j++) {
              tableBody[0].appendChild(r[pos][j]);
            }
          }
        }

        if (table.config.appender) {
          table.config.appender(table, rows);
        }

        rows = null;

        if (table.config.debug) {
          benchmark("Rebuilt table:", appendTime);
        }

        applyWidget(table);
        setTimeout(function () {
          $(table).trigger("sortEnd");
        }, 0);
      }

      ;

      function buildHeaders(table) {
        if (table.config.debug) {
          var time = new Date();
        }

        var meta = $.metadata ? true : false;
        var header_index = computeTableHeaderCellIndexes(table);
        $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {
          this.column = header_index[this.parentNode.rowIndex + "-" + this.cellIndex];
          this.order = formatSortingOrder(table.config.sortInitialOrder);
          this.count = this.order;
          if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;
          if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);

          if (!this.sortDisabled) {
            var $th = $(this).addClass(table.config.cssHeader);
            if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);
          }

          table.config.headerList[index] = this;
        });

        if (table.config.debug) {
          benchmark("Built headers:", time);
          log($tableHeaders);
        }

        return $tableHeaders;
      }

      ;

      function computeTableHeaderCellIndexes(t) {
        var matrix = [];
        var lookup = {};
        var thead = t.getElementsByTagName('THEAD')[0];
        var trs = thead.getElementsByTagName('TR');

        for (var i = 0; i < trs.length; i++) {
          var cells = trs[i].cells;

          for (var j = 0; j < cells.length; j++) {
            var c = cells[j];
            var rowIndex = c.parentNode.rowIndex;
            var cellId = rowIndex + "-" + c.cellIndex;
            var rowSpan = c.rowSpan || 1;
            var colSpan = c.colSpan || 1;
            var firstAvailCol;

            if (typeof matrix[rowIndex] == "undefined") {
              matrix[rowIndex] = [];
            }

            for (var k = 0; k < matrix[rowIndex].length + 1; k++) {
              if (typeof matrix[rowIndex][k] == "undefined") {
                firstAvailCol = k;
                break;
              }
            }

            lookup[cellId] = firstAvailCol;

            for (var k = rowIndex; k < rowIndex + rowSpan; k++) {
              if (typeof matrix[k] == "undefined") {
                matrix[k] = [];
              }

              var matrixrow = matrix[k];

              for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {
                matrixrow[l] = "x";
              }
            }
          }
        }

        return lookup;
      }

      function checkCellColSpan(table, rows, row) {
        var arr = [],
            r = table.tHead.rows,
            c = r[row].cells;

        for (var i = 0; i < c.length; i++) {
          var cell = c[i];

          if (cell.colSpan > 1) {
            arr = arr.concat(checkCellColSpan(table, headerArr, row++));
          } else {
            if (table.tHead.length == 1 || cell.rowSpan > 1 || !r[row + 1]) {
              arr.push(cell);
            }
          }
        }

        return arr;
      }

      ;

      function checkHeaderMetadata(cell) {
        if ($.metadata && $(cell).metadata().sorter === false) {
          return true;
        }

        ;
        return false;
      }

      function checkHeaderOptions(table, i) {
        if (table.config.headers[i] && table.config.headers[i].sorter === false) {
          return true;
        }

        ;
        return false;
      }

      function checkHeaderOptionsSortingLocked(table, i) {
        if (table.config.headers[i] && table.config.headers[i].lockedOrder) return table.config.headers[i].lockedOrder;
        return false;
      }

      function applyWidget(table) {
        var c = table.config.widgets;
        var l = c.length;

        for (var i = 0; i < l; i++) {
          getWidgetById(c[i]).format(table);
        }
      }

      function getWidgetById(name) {
        var l = widgets.length;

        for (var i = 0; i < l; i++) {
          if (widgets[i].id.toLowerCase() == name.toLowerCase()) {
            return widgets[i];
          }
        }
      }

      ;

      function formatSortingOrder(v) {
        if (typeof v != "Number") {
          return v.toLowerCase() == "desc" ? 1 : 0;
        } else {
          return v == 1 ? 1 : 0;
        }
      }

      function isValueInArray(v, a) {
        var l = a.length;

        for (var i = 0; i < l; i++) {
          if (a[i][0] == v) {
            return true;
          }
        }

        return false;
      }

      function setHeadersCss(table, $headers, list, css) {
        $headers.removeClass(css[0]).removeClass(css[1]);
        var h = [];
        $headers.each(function (offset) {
          if (!this.sortDisabled) {
            h[this.column] = $(this);
          }
        });
        var l = list.length;

        for (var i = 0; i < l; i++) {
          h[list[i][0]].addClass(css[list[i][1]]);
        }
      }

      function fixColumnWidth(table, $headers) {
        var c = table.config;

        if (c.widthFixed) {
          var colgroup = $('<colgroup>');
          $("tr:first td", table.tBodies[0]).each(function () {
            colgroup.append($('<col>').css('width', $(this).width()));
          });
          $(table).prepend(colgroup);
        }

        ;
      }

      function updateHeaderSortCount(table, sortList) {
        var c = table.config,
            l = sortList.length;

        for (var i = 0; i < l; i++) {
          var s = sortList[i],
              o = c.headerList[s[0]];
          o.count = s[1];
          o.count++;
        }
      }

      function multisort(table, sortList, cache) {
        if (table.config.debug) {
          var sortTime = new Date();
        }

        var dynamicExp = "var sortWrapper = function(a,b) {",
            l = sortList.length;

        for (var i = 0; i < l; i++) {
          var c = sortList[i][0];
          var order = sortList[i][1];
          var s = table.config.parsers[c].type == "text" ? order == 0 ? makeSortFunction("text", "asc", c) : makeSortFunction("text", "desc", c) : order == 0 ? makeSortFunction("numeric", "asc", c) : makeSortFunction("numeric", "desc", c);
          var e = "e" + i;
          dynamicExp += "var " + e + " = " + s;
          dynamicExp += "if(" + e + ") { return " + e + "; } ";
          dynamicExp += "else { ";
        }

        var orgOrderCol = cache.normalized[0].length - 1;
        dynamicExp += "return a[" + orgOrderCol + "]-b[" + orgOrderCol + "];";

        for (var i = 0; i < l; i++) {
          dynamicExp += "}; ";
        }

        dynamicExp += "return 0; ";
        dynamicExp += "}; ";

        if (table.config.debug) {
          benchmark("Evaling expression:" + dynamicExp, new Date());
        }

        eval(dynamicExp);
        cache.normalized.sort(sortWrapper);

        if (table.config.debug) {
          benchmark("Sorting on " + sortList.toString() + " and dir " + order + " time:", sortTime);
        }

        return cache;
      }

      ;

      function makeSortFunction(type, direction, index) {
        var a = "a[" + index + "]",
            b = "b[" + index + "]";

        if (type == 'text' && direction == 'asc') {
          return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + a + " < " + b + ") ? -1 : 1 )));";
        } else if (type == 'text' && direction == 'desc') {
          return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + b + " < " + a + ") ? -1 : 1 )));";
        } else if (type == 'numeric' && direction == 'asc') {
          return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + a + " - " + b + "));";
        } else if (type == 'numeric' && direction == 'desc') {
          return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + b + " - " + a + "));";
        }
      }

      ;

      function makeSortText(i) {
        return "((a[" + i + "] < b[" + i + "]) ? -1 : ((a[" + i + "] > b[" + i + "]) ? 1 : 0));";
      }

      ;

      function makeSortTextDesc(i) {
        return "((b[" + i + "] < a[" + i + "]) ? -1 : ((b[" + i + "] > a[" + i + "]) ? 1 : 0));";
      }

      ;

      function makeSortNumeric(i) {
        return "a[" + i + "]-b[" + i + "];";
      }

      ;

      function makeSortNumericDesc(i) {
        return "b[" + i + "]-a[" + i + "];";
      }

      ;

      function sortText(a, b) {
        if (table.config.sortLocaleCompare) return a.localeCompare(b);
        return a < b ? -1 : a > b ? 1 : 0;
      }

      ;

      function sortTextDesc(a, b) {
        if (table.config.sortLocaleCompare) return b.localeCompare(a);
        return b < a ? -1 : b > a ? 1 : 0;
      }

      ;

      function sortNumeric(a, b) {
        return a - b;
      }

      ;

      function sortNumericDesc(a, b) {
        return b - a;
      }

      ;

      function getCachedSortType(parsers, i) {
        return parsers[i].type;
      }

      ;

      this.construct = function (settings) {
        return this.each(function () {
          if (!this.tHead || !this.tBodies) return;
          var $this,
              $document,
              $headers,
              cache,
              config,
              shiftDown = 0,
              sortOrder;
          this.config = {};
          config = $.extend(this.config, $.tablesorter.defaults, settings);
          $this = $(this);
          $.data(this, "tablesorter", config);
          $headers = buildHeaders(this);
          this.config.parsers = buildParserCache(this, $headers);
          cache = buildCache(this);
          var sortCSS = [config.cssDesc, config.cssAsc];
          fixColumnWidth(this);
          $headers.click(function (e) {
            var totalRows = $this[0].tBodies[0] && $this[0].tBodies[0].rows.length || 0;

            if (!this.sortDisabled && totalRows > 0) {
              $this.trigger("sortStart");
              var $cell = $(this);
              var i = this.column;
              this.order = this.count++ % 2;
              if (this.lockedOrder) this.order = this.lockedOrder;

              if (!e[config.sortMultiSortKey]) {
                config.sortList = [];

                if (config.sortForce != null) {
                  var a = config.sortForce;

                  for (var j = 0; j < a.length; j++) {
                    if (a[j][0] != i) {
                      config.sortList.push(a[j]);
                    }
                  }
                }

                config.sortList.push([i, this.order]);
              } else {
                if (isValueInArray(i, config.sortList)) {
                  for (var j = 0; j < config.sortList.length; j++) {
                    var s = config.sortList[j],
                        o = config.headerList[s[0]];

                    if (s[0] == i) {
                      o.count = s[1];
                      o.count++;
                      s[1] = o.count % 2;
                    }
                  }
                } else {
                  config.sortList.push([i, this.order]);
                }
              }

              ;
              setTimeout(function () {
                setHeadersCss($this[0], $headers, config.sortList, sortCSS);
                appendToTable($this[0], multisort($this[0], config.sortList, cache));
              }, 1);
              return false;
            }
          }).mousedown(function () {
            if (config.cancelSelection) {
              this.onselectstart = function () {
                return false;
              };

              return false;
            }
          });
          $this.bind("update", function () {
            var me = this;
            setTimeout(function () {
              me.config.parsers = buildParserCache(me, $headers);
              cache = buildCache(me);
            }, 1);
          }).bind("updateCell", function (e, cell) {
            var config = this.config;
            var pos = [cell.parentNode.rowIndex - 1, cell.cellIndex];
            cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(getElementText(config, cell), cell);
          }).bind("sorton", function (e, list) {
            $(this).trigger("sortStart");
            config.sortList = list;
            var sortList = config.sortList;
            updateHeaderSortCount(this, sortList);
            setHeadersCss(this, $headers, sortList, sortCSS);
            appendToTable(this, multisort(this, sortList, cache));
          }).bind("appendCache", function () {
            appendToTable(this, cache);
          }).bind("applyWidgetId", function (e, id) {
            getWidgetById(id).format(this);
          }).bind("applyWidgets", function () {
            applyWidget(this);
          });

          if ($.metadata && $(this).metadata() && $(this).metadata().sortlist) {
            config.sortList = $(this).metadata().sortlist;
          }

          if (config.sortList.length > 0) {
            $this.trigger("sorton", [config.sortList]);
          }

          applyWidget(this);
        });
      };

      this.addParser = function (parser) {
        var l = parsers.length,
            a = true;

        for (var i = 0; i < l; i++) {
          if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {
            a = false;
          }
        }

        if (a) {
          parsers.push(parser);
        }

        ;
      };

      this.addWidget = function (widget) {
        widgets.push(widget);
      };

      this.formatFloat = function (s) {
        var i = parseFloat(s);
        return isNaN(i) ? 0 : i;
      };

      this.formatInt = function (s) {
        var i = parseInt(s);
        return isNaN(i) ? 0 : i;
      };

      this.isDigit = function (s, config) {
        return /^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g, '')));
      };

      this.clearTableBody = function (table) {
        if ($.browser.msie) {
          function empty() {
            while (this.firstChild) this.removeChild(this.firstChild);
          }

          empty.apply(table.tBodies[0]);
        } else {
          table.tBodies[0].innerHTML = "";
        }
      };
    }()
  });
  $.fn.extend({
    tablesorter: $.tablesorter.construct
  });
  var ts = $.tablesorter;
  ts.addParser({
    id: "text",
    is: function (s) {
      return true;
    },
    format: function (s) {
      return $.trim(s.toLocaleLowerCase());
    },
    type: "text"
  });
  ts.addParser({
    id: "digit",
    is: function (s, table) {
      var c = table.config;
      return $.tablesorter.isDigit(s, c);
    },
    format: function (s) {
      return $.tablesorter.formatFloat(s);
    },
    type: "numeric"
  });
  ts.addParser({
    id: "currency",
    is: function (s) {
      return /^[$?.]/.test(s);
    },
    format: function (s) {
      return $.tablesorter.formatFloat(s.replace(new RegExp(/[$]/g), ""));
    },
    type: "numeric"
  });
  ts.addParser({
    id: "ipAddress",
    is: function (s) {
      return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);
    },
    format: function (s) {
      var a = s.split("."),
          r = "",
          l = a.length;

      for (var i = 0; i < l; i++) {
        var item = a[i];

        if (item.length == 2) {
          r += "0" + item;
        } else {
          r += item;
        }
      }

      return $.tablesorter.formatFloat(r);
    },
    type: "numeric"
  });
  ts.addParser({
    id: "url",
    is: function (s) {
      return /^(https?|ftp|file):\/\/$/.test(s);
    },
    format: function (s) {
      return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//), ''));
    },
    type: "text"
  });
  ts.addParser({
    id: "isoDate",
    is: function (s) {
      return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);
    },
    format: function (s) {
      return $.tablesorter.formatFloat(s != "" ? new Date(s.replace(new RegExp(/-/g), "/")).getTime() : "0");
    },
    type: "numeric"
  });
  ts.addParser({
    id: "percent",
    is: function (s) {
      return /\%$/.test($.trim(s));
    },
    format: function (s) {
      return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), ""));
    },
    type: "numeric"
  });
  ts.addParser({
    id: "usLongDate",
    is: function (s) {
      return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));
    },
    format: function (s) {
      return $.tablesorter.formatFloat(new Date(s).getTime());
    },
    type: "numeric"
  });
  ts.addParser({
    id: "shortDate",
    is: function (s) {
      return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);
    },
    format: function (s, table) {
      var c = table.config;
      s = s.replace(/\-/g, "/");

      if (c.dateFormat == "us") {
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$1/$2");
      } else if (c.dateFormat == "uk") {
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$2/$1");
      } else if (c.dateFormat == "dd/mm/yy" || c.dateFormat == "dd-mm-yy") {
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, "$1/$2/$3");
      }

      return $.tablesorter.formatFloat(new Date(s).getTime());
    },
    type: "numeric"
  });
  ts.addParser({
    id: "time",
    is: function (s) {
      return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);
    },
    format: function (s) {
      return $.tablesorter.formatFloat(new Date("2000/01/01 " + s).getTime());
    },
    type: "numeric"
  });
  ts.addParser({
    id: "metadata",
    is: function (s) {
      return false;
    },
    format: function (s, table, cell) {
      var c = table.config,
          p = !c.parserMetadataName ? 'sortValue' : c.parserMetadataName;
      return $(cell).metadata()[p];
    },
    type: "numeric"
  });
  ts.addWidget({
    id: "zebra",
    format: function (table) {
      if (table.config.debug) {
        var time = new Date();
      }

      var $tr,
          row = -1,
          odd;
      $("tr:visible", table.tBodies[0]).each(function (i) {
        $tr = $(this);
        if (!$tr.hasClass(table.config.cssChildRow)) row++;
        odd = row % 2 == 0;
        $tr.removeClass(table.config.widgetZebra.css[odd ? 0 : 1]).addClass(table.config.widgetZebra.css[odd ? 1 : 0]);
      });

      if (table.config.debug) {
        $.tablesorter.benchmark("Applying Zebra widget", time);
      }
    }
  });
})(jQuery);
/*
 * Inline Form Validation Engine 2.6.2, jQuery plugin
 *
 * Copyright(c) 2010, Cedric Dugas
 * http://www.position-absolute.com
 *
 * 2.0 Rewrite by Olivier Refalo
 * http://www.crionics.com
 *
 * Form validation engine allowing custom regex rules to be added.
 * Licensed under the MIT License
 */
(function ($) {
  "use strict";

  var methods = {
    /**
     * Kind of the constructor, called before any action
     * @param {Map} user options
     */
    init: function (options) {
      var form = this;

      if (!form.data('jqv') || form.data('jqv') == null) {
        options = methods._saveOptions(form, options); // bind all formError elements to close on click

        $(document).on("click", ".formError", function () {
          $(this).fadeOut(150, function () {
            // remove prompt once invisible
            $(this).parent('.formErrorOuter').remove();
            $(this).remove();
          });
        });
      }

      return this;
    },

    /**
     * Attachs jQuery.validationEngine to form.submit and field.blur events
     * Takes an optional params: a list of options
     * ie. jQuery("#formID1").validationEngine('attach', {promptPosition : "centerRight"});
     */
    attach: function (userOptions) {
      var form = this;
      var options;
      if (userOptions) options = methods._saveOptions(form, userOptions);else options = form.data('jqv');
      options.validateAttribute = form.find("[data-validation-engine*=validate]").length ? "data-validation-engine" : "class";

      if (options.binded) {
        // delegate fields
        form.on(options.validationEventTrigger, "[" + options.validateAttribute + "*=validate]:not([type=checkbox]):not([type=radio]):not(.datepicker)", methods._onFieldEvent);
        form.on("click", "[" + options.validateAttribute + "*=validate][type=checkbox],[" + options.validateAttribute + "*=validate][type=radio]", methods._onFieldEvent);
        form.on(options.validationEventTrigger, "[" + options.validateAttribute + "*=validate][class*=datepicker]", {
          "delay": 300
        }, methods._onFieldEvent);
      }

      if (options.autoPositionUpdate) {
        $(window).bind("resize", {
          "noAnimation": true,
          "formElem": form
        }, methods.updatePromptsPosition);
      }

      form.on("click", "a[data-validation-engine-skip], a[class*='validate-skip'], button[data-validation-engine-skip], button[class*='validate-skip'], input[data-validation-engine-skip], input[class*='validate-skip']", methods._submitButtonClick);
      form.removeData('jqv_submitButton'); // bind form.submit

      form.on("submit", methods._onSubmitEvent);
      return this;
    },

    /**
     * Unregisters any bindings that may point to jQuery.validaitonEngine
     */
    detach: function () {
      var form = this;
      var options = form.data('jqv'); // unbind fields

      form.find("[" + options.validateAttribute + "*=validate]").not("[type=checkbox]").off(options.validationEventTrigger, methods._onFieldEvent);
      form.find("[" + options.validateAttribute + "*=validate][type=checkbox],[class*=validate][type=radio]").off("click", methods._onFieldEvent); // unbind form.submit

      form.off("submit", methods._onSubmitEvent);
      form.removeData('jqv');
      form.off("click", "a[data-validation-engine-skip], a[class*='validate-skip'], button[data-validation-engine-skip], button[class*='validate-skip'], input[data-validation-engine-skip], input[class*='validate-skip']", methods._submitButtonClick);
      form.removeData('jqv_submitButton');
      if (options.autoPositionUpdate) $(window).off("resize", methods.updatePromptsPosition);
      return this;
    },

    /**
     * Validates either a form or a list of fields, shows prompts accordingly.
     * Note: There is no ajax form validation with this method, only field ajax validation are evaluated
     *
     * @return true if the form validates, false if it fails
     */
    validate: function () {
      var element = $(this);
      var valid = null;

      if (element.is("form") || element.hasClass("validationEngineContainer")) {
        if (element.hasClass('validating')) {
          // form is already validating.
          // Should abort old validation and start new one. I don't know how to implement it.
          return false;
        } else {
          element.addClass('validating');
          var options = element.data('jqv');

          var valid = methods._validateFields(this); // If the form doesn't validate, clear the 'validating' class before the user has a chance to submit again


          setTimeout(function () {
            element.removeClass('validating');
          }, 100);

          if (valid && options.onSuccess) {
            options.onSuccess();
          } else if (!valid && options.onFailure) {
            options.onFailure();
          }
        }
      } else if (element.is('form') || element.hasClass('validationEngineContainer')) {
        element.removeClass('validating');
      } else {
        // field validation
        var form = element.closest('form, .validationEngineContainer'),
            options = form.data('jqv') ? form.data('jqv') : $.validationEngine.defaults,
            valid = methods._validateField(element, options);

        if (valid && options.onFieldSuccess) options.onFieldSuccess();else if (options.onFieldFailure && options.InvalidFields.length > 0) {
          options.onFieldFailure();
        }
      }

      if (options.onValidationComplete) {
        // !! ensures that an undefined return is interpreted as return false but allows a onValidationComplete() to possibly return true and have form continue processing
        return !!options.onValidationComplete(form, valid);
      }

      return valid;
    },

    /**
     *  Redraw prompts position, useful when you change the DOM state when validating
     */
    updatePromptsPosition: function (event) {
      if (event && this == window) {
        var form = event.data.formElem;
        var noAnimation = event.data.noAnimation;
      } else var form = $(this.closest('form, .validationEngineContainer'));

      var options = form.data('jqv'); // No option, take default one

      form.find('[' + options.validateAttribute + '*=validate]').not(":disabled").each(function () {
        var field = $(this);
        if (options.prettySelect && field.is(":hidden")) field = form.find("#" + options.usePrefix + field.attr('id') + options.useSuffix);

        var prompt = methods._getPrompt(field);

        var promptText = $(prompt).find(".formErrorContent").html();
        if (prompt) methods._updatePrompt(field, $(prompt), promptText, undefined, false, options, noAnimation);
      });
      return this;
    },

    /**
     * Displays a prompt on a element.
     * Note that the element needs an id!
     *
     * @param {String} promptText html text to display type
     * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
     * @param {String} possible values topLeft, topRight, bottomLeft, centerRight, bottomRight
     */
    showPrompt: function (promptText, type, promptPosition, showArrow) {
      var form = this.closest('form, .validationEngineContainer');
      var options = form.data('jqv'); // No option, take default one

      if (!options) options = methods._saveOptions(this, options);
      if (promptPosition) options.promptPosition = promptPosition;
      options.showArrow = showArrow == true;

      methods._showPrompt(this, promptText, type, false, options);

      return this;
    },

    /**
     * Closes form error prompts, CAN be invidual
     */
    hide: function () {
      var form = $(this).closest('form, .validationEngineContainer');
      var options = form.data('jqv');
      var fadeDuration = options && options.fadeDuration ? options.fadeDuration : 0.3;
      var closingtag;

      if ($(this).is("form") || $(this).hasClass("validationEngineContainer")) {
        closingtag = "parentForm" + methods._getClassName($(this).attr("id"));
      } else {
        closingtag = methods._getClassName($(this).attr("id")) + "formError";
      }

      $('.' + closingtag).fadeTo(fadeDuration, 0.3, function () {
        $(this).parent('.formErrorOuter').remove();
        $(this).remove();
      });
      return this;
    },

    /**
     * Closes all error prompts on the page
     */
    hideAll: function () {
      var form = this;
      var options = form.data('jqv');
      var duration = options ? options.fadeDuration : 300;
      $('.formError').fadeTo(duration, 300, function () {
        $(this).parent('.formErrorOuter').remove();
        $(this).remove();
      });
      return this;
    },

    /**
     * Typically called when user exists a field using tab or a mouse click, triggers a field
     * validation
     */
    _onFieldEvent: function (event) {
      var field = $(this);
      var form = field.closest('form, .validationEngineContainer');
      var options = form.data('jqv');
      options.eventTrigger = "field"; // validate the current field

      window.setTimeout(function () {
        methods._validateField(field, options);

        if (options.InvalidFields.length == 0 && options.onFieldSuccess) {
          options.onFieldSuccess();
        } else if (options.InvalidFields.length > 0 && options.onFieldFailure) {
          options.onFieldFailure();
        }
      }, event.data ? event.data.delay : 0);
    },

    /**
     * Called when the form is submited, shows prompts accordingly
     *
     * @param {jqObject}
     *            form
     * @return false if form submission needs to be cancelled
     */
    _onSubmitEvent: function () {
      var form = $(this);
      var options = form.data('jqv'); //check if it is trigger from skipped button

      if (form.data("jqv_submitButton")) {
        var submitButton = $("#" + form.data("jqv_submitButton"));

        if (submitButton) {
          if (submitButton.length > 0) {
            if (submitButton.hasClass("validate-skip") || submitButton.attr("data-validation-engine-skip") == "true") return true;
          }
        }
      }

      options.eventTrigger = "submit"; // validate each field
      // (- skip field ajax validation, not necessary IF we will perform an ajax form validation)

      var r = methods._validateFields(form);

      if (r && options.ajaxFormValidation) {
        methods._validateFormWithAjax(form, options); // cancel form auto-submission - process with async call onAjaxFormComplete


        return false;
      }

      if (options.onValidationComplete) {
        // !! ensures that an undefined return is interpreted as return false but allows a onValidationComplete() to possibly return true and have form continue processing
        return !!options.onValidationComplete(form, r);
      }

      return r;
    },

    /**
     * Return true if the ajax field validations passed so far
     * @param {Object} options
     * @return true, is all ajax validation passed so far (remember ajax is async)
     */
    _checkAjaxStatus: function (options) {
      var status = true;
      $.each(options.ajaxValidCache, function (key, value) {
        if (!value) {
          status = false; // break the each

          return false;
        }
      });
      return status;
    },

    /**
     * Return true if the ajax field is validated
     * @param {String} fieldid
     * @param {Object} options
     * @return true, if validation passed, false if false or doesn't exist
     */
    _checkAjaxFieldStatus: function (fieldid, options) {
      return options.ajaxValidCache[fieldid] == true;
    },

    /**
     * Validates form fields, shows prompts accordingly
     *
     * @param {jqObject}
     *            form
     * @param {skipAjaxFieldValidation}
     *            boolean - when set to true, ajax field validation is skipped, typically used when the submit button is clicked
     *
     * @return true if form is valid, false if not, undefined if ajax form validation is done
     */
    _validateFields: function (form) {
      var options = form.data('jqv'); // this variable is set to true if an error is found

      var errorFound = false; // Trigger hook, start validation

      form.trigger("jqv.form.validating"); // first, evaluate status of non ajax fields

      var first_err = null;
      form.find('[' + options.validateAttribute + '*=validate]').not(":disabled").each(function () {
        var field = $(this);
        var names = [];

        if ($.inArray(field.attr('name'), names) < 0) {
          errorFound |= methods._validateField(field, options);
          if (errorFound && first_err == null) if (field.is(":hidden") && options.prettySelect) first_err = field = form.find("#" + options.usePrefix + methods._jqSelector(field.attr('id')) + options.useSuffix);else {
            //Check if we need to adjust what element to show the prompt on
            //and and such scroll to instead
            if (field.data('jqv-prompt-at') instanceof jQuery) {
              field = field.data('jqv-prompt-at');
            } else if (field.data('jqv-prompt-at')) {
              field = $(field.data('jqv-prompt-at'));
            }

            first_err = field;
          }
          if (options.doNotShowAllErrosOnSubmit) return false;
          names.push(field.attr('name')); //if option set, stop checking validation rules after one error is found

          if (options.showOneMessage == true && errorFound) {
            return false;
          }
        }
      }); // second, check to see if all ajax calls completed ok
      // errorFound |= !methods._checkAjaxStatus(options);
      // third, check status and scroll the container accordingly

      form.trigger("jqv.form.result", [errorFound]);

      if (errorFound) {
        if (options.scroll) {
          var destination = first_err.offset().top;
          var fixleft = first_err.offset().left; //prompt positioning adjustment support. Usage: positionType:Xshift,Yshift (for ex.: bottomLeft:+20 or bottomLeft:-20,+10)

          var positionType = options.promptPosition;
          if (typeof positionType == 'string' && positionType.indexOf(":") != -1) positionType = positionType.substring(0, positionType.indexOf(":"));

          if (positionType != "bottomRight" && positionType != "bottomLeft") {
            var prompt_err = methods._getPrompt(first_err);

            if (prompt_err) {
              destination = prompt_err.offset().top;
            }
          } // Offset the amount the page scrolls by an amount in px to accomodate fixed elements at top of page


          if (options.scrollOffset) {
            destination -= options.scrollOffset;
          } // get the position of the first error, there should be at least one, no need to check this
          //var destination = form.find(".formError:not('.greenPopup'):first").offset().top;


          if (options.isOverflown) {
            var overflowDIV = $(options.overflownDIV);
            if (!overflowDIV.length) return false;
            var scrollContainerScroll = overflowDIV.scrollTop();
            var scrollContainerPos = -parseInt(overflowDIV.offset().top);
            destination += scrollContainerScroll + scrollContainerPos - 5;
            var scrollContainer = $(options.overflownDIV + ":not(:animated)");
            scrollContainer.animate({
              scrollTop: destination
            }, 1100, function () {
              if (options.focusFirstField) first_err.focus();
            });
          } else {
            $("html, body").animate({
              scrollTop: destination
            }, 1100, function () {
              if (options.focusFirstField) first_err.focus();
            });
            $("html, body").animate({
              scrollLeft: fixleft
            }, 1100);
          }
        } else if (options.focusFirstField) first_err.focus();

        return false;
      }

      return true;
    },

    /**
     * This method is called to perform an ajax form validation.
     * During this process all the (field, value) pairs are sent to the server which returns a list of invalid fields or true
     *
     * @param {jqObject} form
     * @param {Map} options
     */
    _validateFormWithAjax: function (form, options) {
      var data = form.serialize();
      var type = options.ajaxFormValidationMethod ? options.ajaxFormValidationMethod : "GET";
      var url = options.ajaxFormValidationURL ? options.ajaxFormValidationURL : form.attr("action");
      var dataType = options.dataType ? options.dataType : "json";
      $.ajax({
        type: type,
        url: url,
        cache: false,
        dataType: dataType,
        data: data,
        form: form,
        methods: methods,
        options: options,
        beforeSend: function () {
          return options.onBeforeAjaxFormValidation(form, options);
        },
        error: function (data, transport) {
          methods._ajaxError(data, transport);
        },
        success: function (json) {
          if (dataType == "json" && json !== true) {
            // getting to this case doesn't necessary means that the form is invalid
            // the server may return green or closing prompt actions
            // this flag helps figuring it out
            var errorInForm = false;

            for (var i = 0; i < json.length; i++) {
              var value = json[i];
              var errorFieldId = value[0];
              var errorField = $($("#" + errorFieldId)[0]); // make sure we found the element

              if (errorField.length == 1) {
                // promptText or selector
                var msg = value[2]; // if the field is valid

                if (value[1] == true) {
                  if (msg == "" || !msg) {
                    // if for some reason, status==true and error="", just close the prompt
                    methods._closePrompt(errorField);
                  } else {
                    // the field is valid, but we are displaying a green prompt
                    if (options.allrules[msg]) {
                      var txt = options.allrules[msg].alertTextOk;
                      if (txt) msg = txt;
                    }

                    if (options.showPrompts) methods._showPrompt(errorField, msg, "pass", false, options, true);
                  }
                } else {
                  // the field is invalid, show the red error prompt
                  errorInForm |= true;

                  if (options.allrules[msg]) {
                    var txt = options.allrules[msg].alertText;
                    if (txt) msg = txt;
                  }

                  if (options.showPrompts) methods._showPrompt(errorField, msg, "", false, options, true);
                }
              }
            }

            options.onAjaxFormComplete(!errorInForm, form, json, options);
          } else options.onAjaxFormComplete(true, form, json, options);
        }
      });
    },

    /**
     * Validates field, shows prompts accordingly
     *
     * @param {jqObject}
     *            field
     * @param {Array[String]}
     *            field's validation rules
     * @param {Map}
     *            user options
     * @return false if field is valid (It is inversed for *fields*, it return false on validate and true on errors.)
     */
    _validateField: function (field, options, skipAjaxValidation) {
      if (!field.attr("id")) {
        field.attr("id", "form-validation-field-" + $.validationEngine.fieldIdCounter);
        ++$.validationEngine.fieldIdCounter;
      }

      if (!options.validateNonVisibleFields && (field.is(":hidden") && !options.prettySelect || field.parent().is(":hidden"))) return false;
      var rulesParsing = field.attr(options.validateAttribute);
      var getRules = /validate\[(.*)\]/.exec(rulesParsing);
      if (!getRules) return false;
      var str = getRules[1];
      var rules = str.split(/\[|,|\]/); // true if we ran the ajax validation, tells the logic to stop messing with prompts

      var isAjaxValidator = false;
      var fieldName = field.attr("name");
      var promptText = "";
      var promptType = "";
      var required = false;
      var limitErrors = false;
      options.isError = false;
      options.showArrow = true; // If the programmer wants to limit the amount of error messages per field,

      if (options.maxErrorsPerField > 0) {
        limitErrors = true;
      }

      var form = $(field.closest("form, .validationEngineContainer")); // Fix for adding spaces in the rules

      for (var i = 0; i < rules.length; i++) {
        rules[i] = rules[i].replace(" ", ""); // Remove any parsing errors

        if (rules[i] === '') {
          delete rules[i];
        }
      }

      for (var i = 0, field_errors = 0; i < rules.length; i++) {
        // If we are limiting errors, and have hit the max, break
        if (limitErrors && field_errors >= options.maxErrorsPerField) {
          // If we haven't hit a required yet, check to see if there is one in the validation rules for this
          // field and that it's index is greater or equal to our current index
          if (!required) {
            var have_required = $.inArray('required', rules);
            required = have_required != -1 && have_required >= i;
          }

          break;
        }

        var errorMsg = undefined;

        switch (rules[i]) {
          case "required":
            required = true;
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._required);
            break;

          case "custom":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._custom);
            break;

          case "groupRequired":
            // Check is its the first of group, if not, reload validation with first field
            // AND continue normal validation on present field
            var classGroup = "[" + options.validateAttribute + "*=" + rules[i + 1] + "]";
            var firstOfGroup = form.find(classGroup).eq(0);

            if (firstOfGroup[0] != field[0]) {
              methods._validateField(firstOfGroup, options, skipAjaxValidation);

              options.showArrow = true;
            }

            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._groupRequired);
            if (errorMsg) required = true;
            options.showArrow = false;
            break;

          case "ajax":
            // AJAX defaults to returning it's loading message
            errorMsg = methods._ajax(field, rules, i, options);

            if (errorMsg) {
              promptType = "load";
            }

            break;

          case "minSize":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._minSize);
            break;

          case "maxSize":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._maxSize);
            break;

          case "min":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._min);
            break;

          case "max":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._max);
            break;

          case "past":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._past);
            break;

          case "future":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._future);
            break;

          case "dateRange":
            var classGroup = "[" + options.validateAttribute + "*=" + rules[i + 1] + "]";
            options.firstOfGroup = form.find(classGroup).eq(0);
            options.secondOfGroup = form.find(classGroup).eq(1); //if one entry out of the pair has value then proceed to run through validation

            if (options.firstOfGroup[0].value || options.secondOfGroup[0].value) {
              errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._dateRange);
            }

            if (errorMsg) required = true;
            options.showArrow = false;
            break;

          case "dateTimeRange":
            var classGroup = "[" + options.validateAttribute + "*=" + rules[i + 1] + "]";
            options.firstOfGroup = form.find(classGroup).eq(0);
            options.secondOfGroup = form.find(classGroup).eq(1); //if one entry out of the pair has value then proceed to run through validation

            if (options.firstOfGroup[0].value || options.secondOfGroup[0].value) {
              errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._dateTimeRange);
            }

            if (errorMsg) required = true;
            options.showArrow = false;
            break;

          case "maxCheckbox":
            field = $(form.find("input[name='" + fieldName + "']"));
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._maxCheckbox);
            break;

          case "minCheckbox":
            field = $(form.find("input[name='" + fieldName + "']"));
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._minCheckbox);
            break;

          case "equals":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._equals);
            break;

          case "funcCall":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._funcCall);
            break;

          case "creditCard":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._creditCard);
            break;

          case "condRequired":
            errorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._condRequired);

            if (errorMsg !== undefined) {
              required = true;
            }

            break;

          default:
        }

        var end_validation = false; // If we were passed back an message object, check what the status was to determine what to do

        if (typeof errorMsg == "object") {
          switch (errorMsg.status) {
            case "_break":
              end_validation = true;
              break;
            // If we have an error message, set errorMsg to the error message

            case "_error":
              errorMsg = errorMsg.message;
              break;
            // If we want to throw an error, but not show a prompt, return early with true

            case "_error_no_prompt":
              return true;
              break;
            // Anything else we continue on

            default:
              break;
          }
        } // If it has been specified that validation should end now, break


        if (end_validation) {
          break;
        } // If we have a string, that means that we have an error, so add it to the error message.


        if (typeof errorMsg == 'string') {
          promptText += errorMsg + "<br/>";
          options.isError = true;
          field_errors++;
        }
      } // If the rules required is not added, an empty field is not validated


      if (!required && !field.val() && field.val().length < 1) options.isError = false; // Hack for radio/checkbox group button, the validation go into the
      // first radio/checkbox of the group

      var fieldType = field.prop("type");
      var positionType = field.data("promptPosition") || options.promptPosition;

      if ((fieldType == "radio" || fieldType == "checkbox") && form.find("input[name='" + fieldName + "']").size() > 1) {
        if (positionType === 'inline') {
          field = $(form.find("input[name='" + fieldName + "'][type!=hidden]:last"));
        } else {
          field = $(form.find("input[name='" + fieldName + "'][type!=hidden]:first"));
        }

        options.showArrow = false;
      }

      if (field.is(":hidden") && options.prettySelect) {
        field = form.find("#" + options.usePrefix + methods._jqSelector(field.attr('id')) + options.useSuffix);
      }

      if (options.isError && options.showPrompts) {
        methods._showPrompt(field, promptText, promptType, false, options);
      } else {
        if (!isAjaxValidator) methods._closePrompt(field);
      }

      if (!isAjaxValidator) {
        field.trigger("jqv.field.result", [field, options.isError, promptText]);
      }
      /* Record error */


      var errindex = $.inArray(field[0], options.InvalidFields);

      if (errindex == -1) {
        if (options.isError) options.InvalidFields.push(field[0]);
      } else if (!options.isError) {
        options.InvalidFields.splice(errindex, 1);
      }

      methods._handleStatusCssClasses(field, options);
      /* run callback function for each field */


      if (options.isError && options.onFieldFailure) options.onFieldFailure(field);
      if (!options.isError && options.onFieldSuccess) options.onFieldSuccess(field);
      return options.isError;
    },

    /**
     * Handling css classes of fields indicating result of validation
     *
     * @param {jqObject}
     *            field
     * @param {Array[String]}
     *            field's validation rules
     * @private
     */
    _handleStatusCssClasses: function (field, options) {
      /* remove all classes */
      if (options.addSuccessCssClassToField) field.removeClass(options.addSuccessCssClassToField);
      if (options.addFailureCssClassToField) field.removeClass(options.addFailureCssClassToField);
      /* Add classes */

      if (options.addSuccessCssClassToField && !options.isError) field.addClass(options.addSuccessCssClassToField);
      if (options.addFailureCssClassToField && options.isError) field.addClass(options.addFailureCssClassToField);
    },

    /********************
     * _getErrorMessage
     *
     * @param form
     * @param field
     * @param rule
     * @param rules
     * @param i
     * @param options
     * @param originalValidationMethod
     * @return {*}
     * @private
     */
    _getErrorMessage: function (form, field, rule, rules, i, options, originalValidationMethod) {
      // If we are using the custon validation type, build the index for the rule.
      // Otherwise if we are doing a function call, make the call and return the object
      // that is passed back.
      var rule_index = jQuery.inArray(rule, rules);

      if (rule === "custom" || rule === "funcCall") {
        var custom_validation_type = rules[rule_index + 1];
        rule = rule + "[" + custom_validation_type + "]"; // Delete the rule from the rules array so that it doesn't try to call the
        // same rule over again

        delete rules[rule_index];
      } // Change the rule to the composite rule, if it was different from the original


      var alteredRule = rule;
      var element_classes = field.attr("data-validation-engine") ? field.attr("data-validation-engine") : field.attr("class");
      var element_classes_array = element_classes.split(" "); // Call the original validation method. If we are dealing with dates or checkboxes, also pass the form

      var errorMsg;

      if (rule == "future" || rule == "past" || rule == "maxCheckbox" || rule == "minCheckbox") {
        errorMsg = originalValidationMethod(form, field, rules, i, options);
      } else {
        errorMsg = originalValidationMethod(field, rules, i, options);
      } // If the original validation method returned an error and we have a custom error message,
      // return the custom message instead. Otherwise return the original error message.


      if (errorMsg != undefined) {
        var custom_message = methods._getCustomErrorMessage($(field), element_classes_array, alteredRule, options);

        if (custom_message) errorMsg = custom_message;
      }

      return errorMsg;
    },
    _getCustomErrorMessage: function (field, classes, rule, options) {
      var custom_message = false;
      var validityProp = /^custom\[.*\]$/.test(rule) ? methods._validityProp["custom"] : methods._validityProp[rule]; // If there is a validityProp for this rule, check to see if the field has an attribute for it

      if (validityProp != undefined) {
        custom_message = field.attr("data-errormessage-" + validityProp); // If there was an error message for it, return the message

        if (custom_message != undefined) return custom_message;
      }

      custom_message = field.attr("data-errormessage"); // If there is an inline custom error message, return it

      if (custom_message != undefined) return custom_message;
      var id = '#' + field.attr("id"); // If we have custom messages for the element's id, get the message for the rule from the id.
      // Otherwise, if we have custom messages for the element's classes, use the first class message we find instead.

      if (typeof options.custom_error_messages[id] != "undefined" && typeof options.custom_error_messages[id][rule] != "undefined") {
        custom_message = options.custom_error_messages[id][rule]['message'];
      } else if (classes.length > 0) {
        for (var i = 0; i < classes.length && classes.length > 0; i++) {
          var element_class = "." + classes[i];

          if (typeof options.custom_error_messages[element_class] != "undefined" && typeof options.custom_error_messages[element_class][rule] != "undefined") {
            custom_message = options.custom_error_messages[element_class][rule]['message'];
            break;
          }
        }
      }

      if (!custom_message && typeof options.custom_error_messages[rule] != "undefined" && typeof options.custom_error_messages[rule]['message'] != "undefined") {
        custom_message = options.custom_error_messages[rule]['message'];
      }

      return custom_message;
    },
    _validityProp: {
      "required": "value-missing",
      "custom": "custom-error",
      "groupRequired": "value-missing",
      "ajax": "custom-error",
      "minSize": "range-underflow",
      "maxSize": "range-overflow",
      "min": "range-underflow",
      "max": "range-overflow",
      "past": "type-mismatch",
      "future": "type-mismatch",
      "dateRange": "type-mismatch",
      "dateTimeRange": "type-mismatch",
      "maxCheckbox": "range-overflow",
      "minCheckbox": "range-underflow",
      "equals": "pattern-mismatch",
      "funcCall": "custom-error",
      "creditCard": "pattern-mismatch",
      "condRequired": "value-missing"
    },

    /**
     * Required validation
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @param {bool} condRequired flag when method is used for internal purpose in condRequired check
     * @return an error string if validation failed
     */
    _required: function (field, rules, i, options, condRequired) {
      switch (field.prop("type")) {
        case "text":
        case "password":
        case "textarea":
        case "file":
        case "select-one":
        case "select-multiple":
        default:
          var field_val = $.trim(field.val());
          var dv_placeholder = $.trim(field.attr("data-validation-placeholder")); //var placeholder    = $.trim( field.attr("placeholder")                 );

          if (!field_val || dv_placeholder && field_val == dv_placeholder //|| ( placeholder    && field_val == placeholder    )
          ) {
            return options.allrules[rules[i]].alertText;
          }

          break;

        case "radio":
        case "checkbox":
          // new validation style to only check dependent field
          if (condRequired) {
            if (!field.attr('checked')) {
              return options.allrules[rules[i]].alertTextCheckboxMultiple;
            }

            break;
          } // old validation style


          var form = field.closest("form, .validationEngineContainer");
          var name = field.attr("name");

          if (form.find("input[name='" + name + "']:checked").size() == 0) {
            if (form.find("input[name='" + name + "']:visible").size() == 1) return options.allrules[rules[i]].alertTextCheckboxe;else return options.allrules[rules[i]].alertTextCheckboxMultiple;
          }

          break;
      }
    },

    /**
     * Validate that 1 from the group field is required
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _groupRequired: function (field, rules, i, options) {
      var classGroup = "[" + options.validateAttribute + "*=" + rules[i + 1] + "]";
      var isValid = false; // Check all fields from the group

      field.closest("form, .validationEngineContainer").find(classGroup).each(function () {
        if (!methods._required($(this), rules, i, options)) {
          isValid = true;
          return false;
        }
      });

      if (!isValid) {
        return options.allrules[rules[i]].alertText;
      }
    },

    /**
     * Validate rules
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _custom: function (field, rules, i, options) {
      var customRule = rules[i + 1];
      var rule = options.allrules[customRule];
      var fn;

      if (!rule) {
        alert("jqv:custom rule not found - " + customRule);
        return;
      }

      if (rule["regex"]) {
        var ex = rule.regex;

        if (!ex) {
          alert("jqv:custom regex not found - " + customRule);
          return;
        }

        var pattern = new RegExp(ex);
        if (!pattern.test(field.val())) return options.allrules[customRule].alertText;
      } else if (rule["func"]) {
        fn = rule["func"];

        if (typeof fn !== "function") {
          alert("jqv:custom parameter 'function' is no function - " + customRule);
          return;
        }

        if (!fn(field, rules, i, options)) return options.allrules[customRule].alertText;
      } else {
        alert("jqv:custom type not allowed " + customRule);
        return;
      }
    },

    /**
     * Validate custom function outside of the engine scope
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _funcCall: function (field, rules, i, options) {
      var functionName = rules[i + 1];
      var fn;

      if (functionName.indexOf('.') > -1) {
        var namespaces = functionName.split('.');
        var scope = window;

        while (namespaces.length) {
          scope = scope[namespaces.shift()];
        }

        fn = scope;
      } else fn = window[functionName] || options.customFunctions[functionName];

      if (typeof fn == 'function') return fn(field, rules, i, options);
    },

    /**
     * Field match
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _equals: function (field, rules, i, options) {
      var equalsField = rules[i + 1];
      if (field.val() != $("#" + equalsField).val()) return options.allrules.equals.alertText;
    },

    /**
     * Check the maximum size (in characters)
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _maxSize: function (field, rules, i, options) {
      var max = rules[i + 1];
      var len = field.val().length;

      if (len > max) {
        var rule = options.allrules.maxSize;

        if (typeof rule.alertText2 == 'string') {
          return rule.alertText + min + rule.alertText2;
        } else {
          return rule.alertText;
        }
      }
    },

    /**
     * Check the minimum size (in characters)
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _minSize: function (field, rules, i, options) {
      var min = rules[i + 1];
      var len = field.val().length;

      if (len < min) {
        var rule = options.allrules.minSize;

        if (typeof rule.alertText2 == 'string') {
          return rule.alertText + min + rule.alertText2;
        } else {
          return rule.alertText;
        }
      }
    },

    /**
     * Check number minimum value
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _min: function (field, rules, i, options) {
      var min = parseFloat(rules[i + 1]);
      var len = parseFloat(field.val());

      if (len < min) {
        var rule = options.allrules.min;
        if (rule.alertText2) return rule.alertText + min + rule.alertText2;
        return rule.alertText + min;
      }
    },

    /**
     * Check number maximum value
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _max: function (field, rules, i, options) {
      var max = parseFloat(rules[i + 1]);
      var len = parseFloat(field.val());

      if (len > max) {
        var rule = options.allrules.max;
        if (rule.alertText2) return rule.alertText + max + rule.alertText2; //orefalo: to review, also do the translations

        return rule.alertText + max;
      }
    },

    /**
     * Checks date is in the past
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _past: function (form, field, rules, i, options) {
      var p = rules[i + 1];
      var fieldAlt = $(form.find("input[name='" + p.replace(/^#+/, '') + "']"));
      var pdate;

      if (p.toLowerCase() == "now") {
        pdate = new Date();
      } else if (undefined != fieldAlt.val()) {
        if (fieldAlt.is(":disabled")) return;
        pdate = methods._parseDate(fieldAlt.val());
      } else {
        pdate = methods._parseDate(p);
      }

      var vdate = methods._parseDate(field.val());

      if (vdate > pdate) {
        var rule = options.allrules.past;
        if (rule.alertText2) return rule.alertText + methods._dateToString(pdate) + rule.alertText2;
        return rule.alertText + methods._dateToString(pdate);
      }
    },

    /**
     * Checks date is in the future
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _future: function (form, field, rules, i, options) {
      var p = rules[i + 1];
      var fieldAlt = $(form.find("input[name='" + p.replace(/^#+/, '') + "']"));
      var pdate;

      if (p.toLowerCase() == "now") {
        pdate = new Date();
      } else if (undefined != fieldAlt.val()) {
        if (fieldAlt.is(":disabled")) return;
        pdate = methods._parseDate(fieldAlt.val());
      } else {
        pdate = methods._parseDate(p);
      }

      var vdate = methods._parseDate(field.val());

      if (vdate < pdate) {
        var rule = options.allrules.future;
        if (rule.alertText2) return rule.alertText + methods._dateToString(pdate) + rule.alertText2;
        return rule.alertText + methods._dateToString(pdate);
      }
    },

    /**
     * Checks if valid date
     *
     * @param {string} date string
     * @return a bool based on determination of valid date
     */
    _isDate: function (value) {
      var dateRegEx = new RegExp(/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$|^(?:(?:(?:0?[13578]|1[02])(\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\/|-)(?:29|30)))(\/|-)(?:[1-9]\d\d\d|\d[1-9]\d\d|\d\d[1-9]\d|\d\d\d[1-9])$|^(?:(?:0?[1-9]|1[0-2])(\/|-)(?:0?[1-9]|1\d|2[0-8]))(\/|-)(?:[1-9]\d\d\d|\d[1-9]\d\d|\d\d[1-9]\d|\d\d\d[1-9])$|^(0?2(\/|-)29)(\/|-)(?:(?:0[48]00|[13579][26]00|[2468][048]00)|(?:\d\d)?(?:0[48]|[2468][048]|[13579][26]))$/);
      return dateRegEx.test(value);
    },

    /**
     * Checks if valid date time
     *
     * @param {string} date string
     * @return a bool based on determination of valid date time
     */
    _isDateTime: function (value) {
      var dateTimeRegEx = new RegExp(/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])\s+(1[012]|0?[1-9]){1}:(0?[1-5]|[0-6][0-9]){1}:(0?[0-6]|[0-6][0-9]){1}\s+(am|pm|AM|PM){1}$|^(?:(?:(?:0?[13578]|1[02])(\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\/|-)(?:29|30)))(\/|-)(?:[1-9]\d\d\d|\d[1-9]\d\d|\d\d[1-9]\d|\d\d\d[1-9])$|^((1[012]|0?[1-9]){1}\/(0?[1-9]|[12][0-9]|3[01]){1}\/\d{2,4}\s+(1[012]|0?[1-9]){1}:(0?[1-5]|[0-6][0-9]){1}:(0?[0-6]|[0-6][0-9]){1}\s+(am|pm|AM|PM){1})$/);
      return dateTimeRegEx.test(value);
    },
    //Checks if the start date is before the end date
    //returns true if end is later than start
    _dateCompare: function (start, end) {
      return new Date(start.toString()) < new Date(end.toString());
    },

    /**
     * Checks date range
     *
     * @param {jqObject} first field name
     * @param {jqObject} second field name
     * @return an error string if validation failed
     */
    _dateRange: function (field, rules, i, options) {
      //are not both populated
      if (!options.firstOfGroup[0].value && options.secondOfGroup[0].value || options.firstOfGroup[0].value && !options.secondOfGroup[0].value) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      } //are not both dates


      if (!methods._isDate(options.firstOfGroup[0].value) || !methods._isDate(options.secondOfGroup[0].value)) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      } //are both dates but range is off


      if (!methods._dateCompare(options.firstOfGroup[0].value, options.secondOfGroup[0].value)) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      }
    },

    /**
     * Checks date time range
     *
     * @param {jqObject} first field name
     * @param {jqObject} second field name
     * @return an error string if validation failed
     */
    _dateTimeRange: function (field, rules, i, options) {
      //are not both populated
      if (!options.firstOfGroup[0].value && options.secondOfGroup[0].value || options.firstOfGroup[0].value && !options.secondOfGroup[0].value) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      } //are not both dates


      if (!methods._isDateTime(options.firstOfGroup[0].value) || !methods._isDateTime(options.secondOfGroup[0].value)) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      } //are both dates but range is off


      if (!methods._dateCompare(options.firstOfGroup[0].value, options.secondOfGroup[0].value)) {
        return options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;
      }
    },

    /**
     * Max number of checkbox selected
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _maxCheckbox: function (form, field, rules, i, options) {
      var nbCheck = rules[i + 1];
      var groupname = field.attr("name");
      var groupSize = form.find("input[name='" + groupname + "']:checked").size();

      if (groupSize > nbCheck) {
        options.showArrow = false;
        if (options.allrules.maxCheckbox.alertText2) return options.allrules.maxCheckbox.alertText + " " + nbCheck + " " + options.allrules.maxCheckbox.alertText2;
        return options.allrules.maxCheckbox.alertText;
      }
    },

    /**
     * Min number of checkbox selected
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _minCheckbox: function (form, field, rules, i, options) {
      var nbCheck = rules[i + 1];
      var groupname = field.attr("name");
      var groupSize = form.find("input[name='" + groupname + "']:checked").size();

      if (groupSize < nbCheck) {
        options.showArrow = false;
        return options.allrules.minCheckbox.alertText + " " + nbCheck + " " + options.allrules.minCheckbox.alertText2;
      }
    },

    /**
     * Checks that it is a valid credit card number according to the
     * Luhn checksum algorithm.
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return an error string if validation failed
     */
    _creditCard: function (field, rules, i, options) {
      //spaces and dashes may be valid characters, but must be stripped to calculate the checksum.
      var valid = false,
          cardNumber = field.val().replace(/ +/g, '').replace(/-+/g, '');
      var numDigits = cardNumber.length;

      if (numDigits >= 14 && numDigits <= 16 && parseInt(cardNumber) > 0) {
        var sum = 0,
            i = numDigits - 1,
            pos = 1,
            digit,
            luhn = new String();

        do {
          digit = parseInt(cardNumber.charAt(i));
          luhn += pos++ % 2 == 0 ? digit * 2 : digit;
        } while (--i >= 0);

        for (i = 0; i < luhn.length; i++) {
          sum += parseInt(luhn.charAt(i));
        }

        valid = sum % 10 == 0;
      }

      if (!valid) return options.allrules.creditCard.alertText;
    },

    /**
     * Ajax field validation
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     *            user options
     * @return nothing! the ajax validator handles the prompts itself
     */
    _ajax: function (field, rules, i, options) {
      var errorSelector = rules[i + 1];
      var rule = options.allrules[errorSelector];
      var extraData = rule.extraData;
      var extraDataDynamic = rule.extraDataDynamic;
      var data = {
        "fieldId": field.attr("id"),
        "fieldValue": field.val()
      };

      if (typeof extraData === "object") {
        $.extend(data, extraData);
      } else if (typeof extraData === "string") {
        var tempData = extraData.split("&");

        for (var i = 0; i < tempData.length; i++) {
          var values = tempData[i].split("=");

          if (values[0] && values[0]) {
            data[values[0]] = values[1];
          }
        }
      }

      if (extraDataDynamic) {
        var tmpData = [];
        var domIds = String(extraDataDynamic).split(",");

        for (var i = 0; i < domIds.length; i++) {
          var id = domIds[i];

          if ($(id).length) {
            var inputValue = field.closest("form, .validationEngineContainer").find(id).val();
            var keyValue = id.replace('#', '') + '=' + escape(inputValue);
            data[id.replace('#', '')] = inputValue;
          }
        }
      } // If a field change event triggered this we want to clear the cache for this ID


      if (options.eventTrigger == "field") {
        delete options.ajaxValidCache[field.attr("id")];
      } // If there is an error or if the the field is already validated, do not re-execute AJAX


      if (!options.isError && !methods._checkAjaxFieldStatus(field.attr("id"), options)) {
        $.ajax({
          type: options.ajaxFormValidationMethod,
          url: rule.url,
          cache: false,
          dataType: "json",
          data: data,
          field: field,
          rule: rule,
          methods: methods,
          options: options,
          beforeSend: function () {},
          error: function (data, transport) {
            methods._ajaxError(data, transport);
          },
          success: function (json) {
            // asynchronously called on success, data is the json answer from the server
            var errorFieldId = json[0]; //var errorField = $($("#" + errorFieldId)[0]);

            var errorField = $("#" + errorFieldId).eq(0); // make sure we found the element

            if (errorField.length == 1) {
              var status = json[1]; // read the optional msg from the server

              var msg = json[2];

              if (!status) {
                // Houston we got a problem - display an red prompt
                options.ajaxValidCache[errorFieldId] = false;
                options.isError = true; // resolve the msg prompt

                if (msg) {
                  if (options.allrules[msg]) {
                    var txt = options.allrules[msg].alertText;

                    if (txt) {
                      msg = txt;
                    }
                  }
                } else msg = rule.alertText;

                if (options.showPrompts) methods._showPrompt(errorField, msg, "", true, options);
              } else {
                options.ajaxValidCache[errorFieldId] = true; // resolves the msg prompt

                if (msg) {
                  if (options.allrules[msg]) {
                    var txt = options.allrules[msg].alertTextOk;

                    if (txt) {
                      msg = txt;
                    }
                  }
                } else msg = rule.alertTextOk;

                if (options.showPrompts) {
                  // see if we should display a green prompt
                  if (msg) methods._showPrompt(errorField, msg, "pass", true, options);else methods._closePrompt(errorField);
                } // If a submit form triggered this, we want to re-submit the form


                if (options.eventTrigger == "submit") field.closest("form").submit();
              }
            }

            errorField.trigger("jqv.field.result", [errorField, options.isError, msg]);
          }
        });
        return rule.alertTextLoad;
      }
    },

    /**
     * Common method to handle ajax errors
     *
     * @param {Object} data
     * @param {Object} transport
     */
    _ajaxError: function (data, transport) {
      if (data.status == 0 && transport == null) alert("The page is not served from a server! ajax call failed");else if (typeof console != "undefined") console.log("Ajax error: " + data.status + " " + transport);
    },

    /**
     * date -> string
     *
     * @param {Object} date
     */
    _dateToString: function (date) {
      return date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
    },

    /**
     * Parses an ISO date
     * @param {String} d
     */
    _parseDate: function (d) {
      var dateParts = d.split("-");
      if (dateParts == d) dateParts = d.split("/");

      if (dateParts == d) {
        dateParts = d.split(".");
        return new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);
      }

      return new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
    },

    /**
     * Builds or updates a prompt with the given information
     *
     * @param {jqObject} field
     * @param {String} promptText html text to display type
     * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
     * @param {boolean} ajaxed - use to mark fields than being validated with ajax
     * @param {Map} options user options
     */
    _showPrompt: function (field, promptText, type, ajaxed, options, ajaxform) {
      //Check if we need to adjust what element to show the prompt on
      if (field.data('jqv-prompt-at') instanceof jQuery) {
        field = field.data('jqv-prompt-at');
      } else if (field.data('jqv-prompt-at')) {
        field = $(field.data('jqv-prompt-at'));
      }

      var prompt = methods._getPrompt(field); // The ajax submit errors are not see has an error in the form,
      // When the form errors are returned, the engine see 2 bubbles, but those are ebing closed by the engine at the same time
      // Because no error was found befor submitting


      if (ajaxform) prompt = false; // Check that there is indded text

      if ($.trim(promptText)) {
        if (prompt) methods._updatePrompt(field, prompt, promptText, type, ajaxed, options);else methods._buildPrompt(field, promptText, type, ajaxed, options);
      }
    },

    /**
     * Builds and shades a prompt for the given field.
     *
     * @param {jqObject} field
     * @param {String} promptText html text to display type
     * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
     * @param {boolean} ajaxed - use to mark fields than being validated with ajax
     * @param {Map} options user options
     */
    _buildPrompt: function (field, promptText, type, ajaxed, options) {
      // create the prompt
      var prompt = $('<div>');
      prompt.addClass(methods._getClassName(field.attr("id")) + "formError"); // add a class name to identify the parent form of the prompt

      prompt.addClass("parentForm" + methods._getClassName(field.closest('form, .validationEngineContainer').attr("id")));
      prompt.addClass("formError");

      switch (type) {
        case "pass":
          prompt.addClass("greenPopup");
          break;

        case "load":
          prompt.addClass("blackPopup");
          break;

        default:
        /* it has error  */
        //alert("unknown popup type:"+type);

      }

      if (ajaxed) prompt.addClass("ajaxed"); // create the prompt content

      var promptContent = $('<div>').addClass("formErrorContent").html(promptText).appendTo(prompt); // determine position type

      var positionType = field.data("promptPosition") || options.promptPosition; // create the css arrow pointing at the field
      // note that there is no triangle on max-checkbox and radio

      if (options.showArrow) {
        var arrow = $('<div>').addClass("formErrorArrow"); //prompt positioning adjustment support. Usage: positionType:Xshift,Yshift (for ex.: bottomLeft:+20 or bottomLeft:-20,+10)

        if (typeof positionType == 'string') {
          var pos = positionType.indexOf(":");
          if (pos != -1) positionType = positionType.substring(0, pos);
        }

        switch (positionType) {
          case "bottomLeft":
          case "bottomRight":
            prompt.find(".formErrorContent").before(arrow);
            arrow.addClass("formErrorArrowBottom").html('<div class="line1"><!-- --></div><div class="line2"><!-- --></div><div class="line3"><!-- --></div><div class="line4"><!-- --></div><div class="line5"><!-- --></div><div class="line6"><!-- --></div><div class="line7"><!-- --></div><div class="line8"><!-- --></div><div class="line9"><!-- --></div><div class="line10"><!-- --></div>');
            break;

          case "topLeft":
          case "topRight":
            arrow.html('<div class="line10"><!-- --></div><div class="line9"><!-- --></div><div class="line8"><!-- --></div><div class="line7"><!-- --></div><div class="line6"><!-- --></div><div class="line5"><!-- --></div><div class="line4"><!-- --></div><div class="line3"><!-- --></div><div class="line2"><!-- --></div><div class="line1"><!-- --></div>');
            prompt.append(arrow);
            break;
        }
      } // Add custom prompt class


      if (options.addPromptClass) prompt.addClass(options.addPromptClass); // Add custom prompt class defined in element

      var requiredOverride = field.attr('data-required-class');

      if (requiredOverride !== undefined) {
        prompt.addClass(requiredOverride);
      } else {
        if (options.prettySelect) {
          if ($('#' + field.attr('id')).next().is('select')) {
            var prettyOverrideClass = $('#' + field.attr('id').substr(options.usePrefix.length).substring(options.useSuffix.length)).attr('data-required-class');

            if (prettyOverrideClass !== undefined) {
              prompt.addClass(prettyOverrideClass);
            }
          }
        }
      }

      prompt.css({
        "opacity": 0
      });

      if (positionType === 'inline') {
        prompt.addClass("inline");

        if (typeof field.attr('data-prompt-target') !== 'undefined' && $('#' + field.attr('data-prompt-target')).length > 0) {
          prompt.appendTo($('#' + field.attr('data-prompt-target')));
        } else {
          field.after(prompt);
        }
      } else {
        field.before(prompt);
      }

      var pos = methods._calculatePosition(field, prompt, options);

      prompt.css({
        'position': positionType === 'inline' ? 'relative' : 'absolute',
        "top": pos.callerTopPosition,
        "left": pos.callerleftPosition,
        "marginTop": pos.marginTopSize,
        "opacity": 0
      }).data("callerField", field);

      if (options.autoHidePrompt) {
        setTimeout(function () {
          prompt.animate({
            "opacity": 0
          }, function () {
            prompt.closest('.formErrorOuter').remove();
            prompt.remove();
          });
        }, options.autoHideDelay);
      }

      return prompt.animate({
        "opacity": 0.87
      });
    },

    /**
     * Updates the prompt text field - the field for which the prompt
     * @param {jqObject} field
     * @param {String} promptText html text to display type
     * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
     * @param {boolean} ajaxed - use to mark fields than being validated with ajax
     * @param {Map} options user options
     */
    _updatePrompt: function (field, prompt, promptText, type, ajaxed, options, noAnimation) {
      if (prompt) {
        if (typeof type !== "undefined") {
          if (type == "pass") prompt.addClass("greenPopup");else prompt.removeClass("greenPopup");
          if (type == "load") prompt.addClass("blackPopup");else prompt.removeClass("blackPopup");
        }

        if (ajaxed) prompt.addClass("ajaxed");else prompt.removeClass("ajaxed");
        prompt.find(".formErrorContent").html(promptText);

        var pos = methods._calculatePosition(field, prompt, options);

        var css = {
          "top": pos.callerTopPosition,
          "left": pos.callerleftPosition,
          "marginTop": pos.marginTopSize
        };
        if (noAnimation) prompt.css(css);else prompt.animate(css);
      }
    },

    /**
     * Closes the prompt associated with the given field
     *
     * @param {jqObject}
     *            field
     */
    _closePrompt: function (field) {
      var prompt = methods._getPrompt(field);

      if (prompt) prompt.fadeTo("fast", 0, function () {
        prompt.parent('.formErrorOuter').remove();
        prompt.remove();
      });
    },
    closePrompt: function (field) {
      return methods._closePrompt(field);
    },

    /**
     * Returns the error prompt matching the field if any
     *
     * @param {jqObject}
     *            field
     * @return undefined or the error prompt (jqObject)
     */
    _getPrompt: function (field) {
      var formId = $(field).closest('form, .validationEngineContainer').attr('id');
      var className = methods._getClassName(field.attr("id")) + "formError";
      var match = $("." + methods._escapeExpression(className) + '.parentForm' + methods._getClassName(formId))[0];
      if (match) return $(match);
    },

    /**
     * Returns the escapade classname
     *
     * @param {selector}
     *            className
     */
    _escapeExpression: function (selector) {
      return selector.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, "\\$1");
    },

    /**
     * returns true if we are in a RTLed document
     *
     * @param {jqObject} field
     */
    isRTL: function (field) {
      var $document = $(document);
      var $body = $('body');
      var rtl = field && field.hasClass('rtl') || field && (field.attr('dir') || '').toLowerCase() === 'rtl' || $document.hasClass('rtl') || ($document.attr('dir') || '').toLowerCase() === 'rtl' || $body.hasClass('rtl') || ($body.attr('dir') || '').toLowerCase() === 'rtl';
      return Boolean(rtl);
    },

    /**
     * Calculates prompt position
     *
     * @param {jqObject}
     *            field
     * @param {jqObject}
     *            the prompt
     * @param {Map}
     *            options
     * @return positions
     */
    _calculatePosition: function (field, promptElmt, options) {
      var promptTopPosition, promptleftPosition, marginTopSize;
      var fieldWidth = field.width();
      var fieldLeft = field.position().left;
      var fieldTop = field.position().top;
      var fieldHeight = field.height();
      var promptHeight = promptElmt.height(); // is the form contained in an overflown container?

      promptTopPosition = promptleftPosition = 0; // compensation for the arrow

      marginTopSize = -promptHeight; //prompt positioning adjustment support
      //now you can adjust prompt position
      //usage: positionType:Xshift,Yshift
      //for example:
      //   bottomLeft:+20 means bottomLeft position shifted by 20 pixels right horizontally
      //   topRight:20, -15 means topRight position shifted by 20 pixels to right and 15 pixels to top
      //You can use +pixels, - pixels. If no sign is provided than + is default.

      var positionType = field.data("promptPosition") || options.promptPosition;
      var shift1 = "";
      var shift2 = "";
      var shiftX = 0;
      var shiftY = 0;

      if (typeof positionType == 'string') {
        //do we have any position adjustments ?
        if (positionType.indexOf(":") != -1) {
          shift1 = positionType.substring(positionType.indexOf(":") + 1);
          positionType = positionType.substring(0, positionType.indexOf(":")); //if any advanced positioning will be needed (percents or something else) - parser should be added here
          //for now we use simple parseInt()
          //do we have second parameter?

          if (shift1.indexOf(",") != -1) {
            shift2 = shift1.substring(shift1.indexOf(",") + 1);
            shift1 = shift1.substring(0, shift1.indexOf(","));
            shiftY = parseInt(shift2);
            if (isNaN(shiftY)) shiftY = 0;
          }

          ;
          shiftX = parseInt(shift1);
          if (isNaN(shift1)) shift1 = 0;
        }

        ;
      }

      ;

      switch (positionType) {
        default:
        case "topRight":
          promptleftPosition += fieldLeft + fieldWidth - 30;
          promptTopPosition += fieldTop;
          break;

        case "topLeft":
          promptTopPosition += fieldTop;
          promptleftPosition += fieldLeft;
          break;

        case "centerRight":
          promptTopPosition = fieldTop + 4;
          marginTopSize = 0;
          promptleftPosition = fieldLeft + field.outerWidth(true) + 5;
          break;

        case "centerLeft":
          promptleftPosition = fieldLeft - (promptElmt.width() + 2);
          promptTopPosition = fieldTop + 4;
          marginTopSize = 0;
          break;

        case "bottomLeft":
          promptTopPosition = fieldTop + field.height() + 5;
          marginTopSize = 0;
          promptleftPosition = fieldLeft;
          break;

        case "bottomRight":
          promptleftPosition = fieldLeft + fieldWidth - 30;
          promptTopPosition = fieldTop + field.height() + 5;
          marginTopSize = 0;
          break;

        case "inline":
          promptleftPosition = 0;
          promptTopPosition = 0;
          marginTopSize = 0;
      }

      ; //apply adjusments if any

      promptleftPosition += shiftX;
      promptTopPosition += shiftY;
      return {
        "callerTopPosition": promptTopPosition + "px",
        "callerleftPosition": promptleftPosition + "px",
        "marginTopSize": marginTopSize + "px"
      };
    },

    /**
     * Saves the user options and variables in the form.data
     *
     * @param {jqObject}
     *            form - the form where the user option should be saved
     * @param {Map}
     *            options - the user options
     * @return the user options (extended from the defaults)
     */
    _saveOptions: function (form, options) {
      // is there a language localisation ?
      if ($.validationEngineLanguage) var allRules = $.validationEngineLanguage.allRules;else $.error("jQuery.validationEngine rules are not loaded, plz add localization files to the page"); // --- Internals DO NOT TOUCH or OVERLOAD ---
      // validation rules and i18

      $.validationEngine.defaults.allrules = allRules;
      var userOptions = $.extend(true, {}, $.validationEngine.defaults, options);
      form.data('jqv', userOptions);
      return userOptions;
    },

    /**
     * Removes forbidden characters from class name
     * @param {String} className
     */
    _getClassName: function (className) {
      if (className) return className.replace(/:/g, "_").replace(/\./g, "_");
    },

    /**
     * Escape special character for jQuery selector
     * http://totaldev.com/content/escaping-characters-get-valid-jquery-id
     * @param {String} selector
     */
    _jqSelector: function (str) {
      return str.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
    },

    /**
     * Conditionally required field
     *
     * @param {jqObject} field
     * @param {Array[String]} rules
     * @param {int} i rules index
     * @param {Map}
     * user options
     * @return an error string if validation failed
     */
    _condRequired: function (field, rules, i, options) {
      var idx, dependingField;

      for (idx = i + 1; idx < rules.length; idx++) {
        dependingField = jQuery("#" + rules[idx]).first();
        /* Use _required for determining wether dependingField has a value.
         * There is logic there for handling all field types, and default value; so we won't replicate that here
         * Indicate this special use by setting the last parameter to true so we only validate the dependingField on chackboxes and radio buttons (#462)
         */

        if (dependingField.length && methods._required(dependingField, ["required"], 0, options, true) == undefined) {
          /* We now know any of the depending fields has a value,
           * so we can validate this field as per normal required code
           */
          return methods._required(field, ["required"], 0, options);
        }
      }
    },
    _submitButtonClick: function (event) {
      var button = $(this);
      var form = button.closest('form, .validationEngineContainer');
      form.data("jqv_submitButton", button.attr("id"));
    }
  };
  /**
   * Plugin entry point.
   * You may pass an action as a parameter or a list of options.
   * if none, the init and attach methods are being called.
   * Remember: if you pass options, the attached method is NOT called automatically
   *
   * @param {String}
   *            method (optional) action
   */

  $.fn.validationEngine = function (method) {
    var form = $(this);
    if (!form[0]) return form; // stop here if the form does not exist

    if (typeof method == 'string' && method.charAt(0) != '_' && methods[method]) {
      // make sure init is called once
      if (method != "showPrompt" && method != "hide" && method != "hideAll") methods.init.apply(form);
      return methods[method].apply(form, Array.prototype.slice.call(arguments, 1));
    } else if (typeof method == 'object' || !method) {
      // default constructor with or without arguments
      methods.init.apply(form, arguments);
      return methods.attach.apply(form);
    } else {
      $.error('Method ' + method + ' does not exist in jQuery.validationEngine');
    }
  }; // LEAK GLOBAL OPTIONS


  $.validationEngine = {
    fieldIdCounter: 0,
    defaults: {
      // Name of the event triggering field validation
      validationEventTrigger: "blur",
      // Automatically scroll viewport to the first error
      scroll: true,
      // Focus on the first input
      focusFirstField: true,
      // Show prompts, set to false to disable prompts
      showPrompts: true,
      // Should we attempt to validate non-visible input fields contained in the form? (Useful in cases of tabbed containers, e.g. jQuery-UI tabs)
      validateNonVisibleFields: false,
      // Opening box position, possible locations are: topLeft,
      // topRight, bottomLeft, centerRight, bottomRight, inline
      // inline gets inserted after the validated field or into an element specified in data-prompt-target
      promptPosition: "topRight",
      bindMethod: "bind",
      // internal, automatically set to true when it parse a _ajax rule
      inlineAjax: false,
      // if set to true, the form data is sent asynchronously via ajax to the form.action url (get)
      ajaxFormValidation: false,
      // The url to send the submit ajax validation (default to action)
      ajaxFormValidationURL: false,
      // HTTP method used for ajax validation
      ajaxFormValidationMethod: 'get',
      // Ajax form validation callback method: boolean onComplete(form, status, errors, options)
      // retuns false if the form.submit event needs to be canceled.
      onAjaxFormComplete: $.noop,
      // called right before the ajax call, may return false to cancel
      onBeforeAjaxFormValidation: $.noop,
      // Stops form from submitting and execute function assiciated with it
      onValidationComplete: false,
      // Used when you have a form fields too close and the errors messages are on top of other disturbing viewing messages
      doNotShowAllErrosOnSubmit: false,
      // Object where you store custom messages to override the default error messages
      custom_error_messages: {},
      // true if you want to vind the input fields
      binded: true,
      // set to true, when the prompt arrow needs to be displayed
      showArrow: true,
      // did one of the validation fail ? kept global to stop further ajax validations
      isError: false,
      // Limit how many displayed errors a field can have
      maxErrorsPerField: false,
      // Caches field validation status, typically only bad status are created.
      // the array is used during ajax form validation to detect issues early and prevent an expensive submit
      ajaxValidCache: {},
      // Auto update prompt position after window resize
      autoPositionUpdate: false,
      InvalidFields: [],
      onFieldSuccess: false,
      onFieldFailure: false,
      onSuccess: false,
      onFailure: false,
      validateAttribute: "class",
      addSuccessCssClassToField: "",
      addFailureCssClassToField: "",
      // Auto-hide prompt
      autoHidePrompt: false,
      // Delay before auto-hide
      autoHideDelay: 10000,
      // Fade out duration while hiding the validations
      fadeDuration: 0.3,
      // Use Prettify select library
      prettySelect: false,
      // Add css class on prompt
      addPromptClass: "",
      // Custom ID uses prefix
      usePrefix: "",
      // Custom ID uses suffix
      useSuffix: "",
      // Only show one message per error prompt
      showOneMessage: false
    }
  };
  /**************************************************************
   * Modifications begin here!
   */

  var tooltipSettings = {
    hook: 'rightmiddle',
    hideOn: false,
    skin: 'cloud',
    hideOthers: false
  };

  methods._buildPrompt = function (field, promptText, type, ajaxed, options) {
    field.data("promptText", promptText);
    Tipped.create(field[0], promptText, tooltipSettings);
    Tipped.show(field[0]);
  };

  methods._closePrompt = function (field) {
    field.data("promptText", "");
    Tipped.remove(field[0]);
  };

  methods._updatePrompt = function (field, prompt, promptText, type, ajaxed, options, noAnimation) {
    if (field.data("promptText") != promptText) {
      methods._closePrompt(field);

      methods._buildPrompt(field, promptText);
    }
  };

  methods._getPrompt = function (field) {
    return Tipped.get(field[0]);
  };
  /**************************************************************
   * End of Modifications
   */


  $(function () {
    $.validationEngine.defaults.promptPosition = methods.isRTL() ? 'topLeft' : "topRight";
  });
})(jQuery);
// jQuery WipeTouch 1.2.0
// ------------------------------------------------------------------------
//
// Developed and maintained by Igor Ramadas
// http://aboutigor.com
// http://devv.com
//
// USAGE
// ------------------------------------------------------------------------
//
// $(selector).wipetouch(config);
//
// The wipe events should expect the result object with the following properties:
// speed - the wipe speed from 1 to 5
// x - how many pixels moved on the horizontal axis
// y - how many pixels moved on the vertical axis
// source - the element which triggered the wipe gesture
//
// EXAMPLE
//		$(document).wipetouch({
//			allowDiagonal: true,
//			wipeLeft: function(result) { alert("Left on speed " + result.speed) },
//			wipeTopLeft: function(result) { alert("Top left on speed " + result.speed) },
//			wipeBottomLeft: function(result) { alert("Bottom left on speed " + result.speed) }
//		});
//
//
// More details at http://wipetouch.codeplex.com/
//
// CHANGE LOG
// ------------------------------------------------------------------------
// 1.2.0
// - New: wipeMove event, triggered while moving the mouse/finger.
// - New: added "source" to the result object.
// - Bug fix: sometimes vertical wipe events would not trigger correctly.
// - Bug fix: improved tapToClick handler.
// - General code refactoring.
// - Windows Phone 7 is not supported, yet! Its behaviour is completely broken and would require some special tricks to make it work. Maybe in the future...
//
// 1.1.0
// - New: tapToClick, if true will identify taps and and trigger a click on the touched element. Default is false.
// - Changed: events wipeBottom*** and wipeTop*** renamed to wipeDown*** and wipeUp***.
// - Changed: better touch speed calculation (was always too fast before).
// - Changed: speed will be an integer now (instead of float).
// - Changed: better wipe detection (if Y movement is more than X, do a vertical wipe instead of horizontal).
// - Bug fix: added preventDefault to touchStart and touchEnd internal events (this was missing).
// - Other general tweaks to the code.
//
// The minified version of WipeTouch can be generated using Jasc: http://jasc.codeplex.com
(function ($) {
  $.fn.wipetouch = function (settings) {
    // ------------------------------------------------------------------------
    // PLUGIN SETTINGS
    // ------------------------------------------------------------------------
    var config = {
      // Variables and options
      moveX: 40,
      // minimum amount of horizontal pixels to trigger a wipe event
      moveY: 40,
      // minimum amount of vertical pixels to trigger a wipe event
      tapToClick: false,
      // if user taps the screen it will fire a click event on the touched element
      preventDefault: true,
      // if true, prevents default events (click for example)
      allowDiagonal: false,
      // if false, will trigger horizontal and vertical movements so wipeUpLeft, wipeDownLeft, wipeUpRight, wipeDownRight are ignored,
      preventDefaultWhenTriggering: true,
      // Wipe events
      wipeLeft: false,
      // called on wipe left gesture
      wipeRight: false,
      // called on wipe right gesture
      wipeUp: false,
      // called on wipe up gesture
      wipeDown: false,
      // called on wipe down gesture
      wipeUpLeft: false,
      // called on wipe top and left gesture
      wipeDownLeft: false,
      // called on wipe bottom and left gesture
      wipeUpRight: false,
      // called on wipe top and right gesture
      wipeDownRight: false,
      // called on wipe bottom and right gesture
      wipeMove: false,
      // triggered whenever touchMove acts
      // DEPRECATED EVENTS
      wipeTopLeft: false,
      // USE WIPEUPLEFT
      wipeBottomLeft: false,
      // USE WIPEDOWNLEFT
      wipeTopRight: false,
      // USE WIPEUPRIGHT
      wipeBottomRight: false // USE WIPEDOWNRIGHT

    };

    if (settings) {
      $.extend(config, settings);
    }

    this.each(function () {
      // ------------------------------------------------------------------------
      // INTERNAL VARIABLES
      // ------------------------------------------------------------------------
      var startX; // where touch has started, left

      var startY; // where touch has started, top

      var startDate = false; // used to calculate timing and aprox. acceleration

      var curX; // keeps touch X position while moving on the screen

      var curY; // keeps touch Y position while moving on the screen

      var isMoving = false; // is user touching and moving?

      var touchedElement = false; // element which user has touched
      // These are for non-touch devices!

      var useMouseEvents = false; // force using the mouse events to simulate touch

      var clickEvent = false; // holds the click event of the target, when used hasn't clicked
      // ------------------------------------------------------------------------
      // TOUCH EVENTS
      // ------------------------------------------------------------------------
      // Called when user touches the screen.

      function onTouchStart(e) {
        resetTouch();
        var start = useMouseEvents || e.originalEvent.touches && e.originalEvent.touches.length > 0;

        if (!isMoving && start) {
          if (config.preventDefault) {
            e.preventDefault();
          } // Temporary fix for deprecated events, these will be removed on next version!


          if (config.allowDiagonal) {
            if (!config.wipeDownLeft) {
              config.wipeDownLeft = config.wipeBottomLeft;
            }

            if (!config.wipeDownRight) {
              config.wipeDownRight = config.wipeBottomRight;
            }

            if (!config.wipeUpLeft) {
              config.wipeUpLeft = config.wipeTopLeft;
            }

            if (!config.wipeUpRight) {
              config.wipeUpRight = config.wipeTopRight;
            }
          } // When touch events are not present, use mouse events.


          if (useMouseEvents) {
            startX = e.pageX;
            startY = e.pageY;
            $(this).bind("mousemove", onTouchMove);
            $(this).one("mouseup", onTouchEnd);
          } else {
            startX = e.originalEvent.touches[0].pageX;
            startY = e.originalEvent.touches[0].pageY;
            $(this).bind("touchmove", onTouchMove);
          } // Set the start date and current X/Y.


          startDate = new Date().getTime();
          curX = startX;
          curY = startY;
          isMoving = true;
          touchedElement = $(e.target);
        }
      } // Called when user untouches the screen.


      function onTouchEnd(e) {
        if (config.preventDefault) {
          e.preventDefault();
        } // When touch events are not present, use mouse events.


        if (useMouseEvents) {
          $(this).unbind("mousemove", onTouchMove);
        } else {
          $(this).unbind("touchmove", onTouchMove);
        } // If is moving then calculate the touch results, otherwise reset it.


        if (isMoving) {
          touchCalculate(e);
        } else {
          resetTouch();
        }
      } // Called when user is touching and moving on the screen.


      function onTouchMove(e) {
        if (config.preventDefault) {
          e.preventDefault();
        }

        if (useMouseEvents && !isMoving) {
          onTouchStart(e);
        }

        if (isMoving) {
          if (useMouseEvents) {
            curX = e.pageX;
            curY = e.pageY;
          } else {
            curX = e.originalEvent.touches[0].pageX;
            curY = e.originalEvent.touches[0].pageY;
          } // If there's a wipeMove event, call it passing
          // current X and Y position (curX and curY).


          if (config.wipeMove) {
            triggerEvent(config.wipeMove, {
              curX: curX,
              curY: curY
            });
          }
        }
      } // ------------------------------------------------------------------------
      // CALCULATE TOUCH AND TRIGGER
      // ------------------------------------------------------------------------


      function touchCalculate(e) {
        var endDate = new Date().getTime(); // current date to calculate timing

        var ms = startDate - endDate; // duration of touch in milliseconds

        var x = curX; // current left position

        var y = curY; // current top position

        var dx = x - startX; // diff of current left to starting left

        var dy = y - startY; // diff of current top to starting top

        var ax = Math.abs(dx); // amount of horizontal movement

        var ay = Math.abs(dy); // amount of vertical movement
        // If moved less than 15 pixels, touch duration is less than 100ms,
        // and tapToClick is true then trigger a click event and stop processing.

        if (ax < 15 && ay < 15 && ms < 100) {
          clickEvent = false;

          if (config.preventDefault) {
            resetTouch();
            touchedElement.trigger("click");
            return;
          }
        } // When touch events are not present, use mouse events.
        else if (useMouseEvents) {
          var evts = touchedElement.data("events");

          if (evts) {
            // Save click event to the temp clickEvent variable.
            var clicks = evts.click;

            if (clicks && clicks.length > 0) {
              $.each(clicks, function (i, f) {
                clickEvent = f;
                return;
              });
              touchedElement.unbind("click");
            }
          }
        } // Is it moving to the right or left, top or bottom?


        var toright = dx > 0;
        var tobottom = dy > 0; // Calculate speed from 1 to 5, 1 being slower and 5 faster.

        var s = (ax + ay) * 60 / (ms / 6 * ms);
        if (s < 1) s = 1;
        if (s > 5) s = 5;
        var result = {
          speed: parseInt(s),
          x: ax,
          y: ay,
          source: touchedElement
        };

        if (ax >= config.moveX) {
          // Check if it's allowed and trigger diagonal wipe events.
          if (config.allowDiagonal && ay >= config.moveY) {
            if (toright && tobottom) {
              triggerEvent(config.wipeDownRight, result, e);
            } else if (toright && !tobottom) {
              triggerEvent(config.wipeUpRight, result, e);
            } else if (!toright && tobottom) {
              triggerEvent(config.wipeDownLeft, result, e);
            } else {
              triggerEvent(config.wipeUpLeft, result, e);
            }
          } // Otherwise trigger horizontal events if X > Y.
          else if (ax >= ay) {
            if (toright) {
              triggerEvent(config.wipeRight, result, e);
            } else {
              triggerEvent(config.wipeLeft, result, e);
            }
          }
        } // If Y > X and no diagonal, trigger vertical events.
        else if (ay >= config.moveY && ay > ax) {
          if (tobottom) {
            triggerEvent(config.wipeDown, result, e);
          } else {
            triggerEvent(config.wipeUp, result, e);
          }
        }

        resetTouch();
      } // Resets the cached variables.


      function resetTouch() {
        startX = false;
        startY = false;
        startDate = false;
        isMoving = false; // If there's a click event, bind after a few miliseconds.

        if (clickEvent) {
          window.setTimeout(function () {
            touchedElement.bind("click", clickEvent);
            clickEvent = false;
          }, 50);
        }
      } // Trigger a wipe event passing a result object with
      // speed from 1 to 5, x / y movement amount in pixels,
      // and the source element.


      function triggerEvent(wipeEvent, result, e) {
        if (wipeEvent) {
          if (config.preventDefaultWhenTriggering) {
            e.preventDefault();
          }

          wipeEvent(result);
        }
      } // ------------------------------------------------------------------------
      // ADD TOUCHSTART AND TOUCHEND EVENT LISTENERS
      // ------------------------------------------------------------------------


      if ("ontouchstart" in document.documentElement) {
        $(this).bind("touchstart", onTouchStart);
        $(this).bind("touchend", onTouchEnd);
      } else {
        useMouseEvents = true;
        $(this).bind("mousedown", onTouchStart);
        $(this).bind("mouseout mouseup", onTouchEnd);
      }
    });
    return this;
  };
})(jQuery);
/* == malihu jquery custom scrollbar plugin == Version: 3.1.5, License: MIT License (MIT) */
!function (e) {
  "function" == typeof define && define.amd ? define(["jquery"], e) : "undefined" != typeof module && module.exports ? module.exports = e : e(jQuery, window, document);
}(function (e) {
  !function (t) {
    var o = "function" == typeof define && define.amd,
        a = "undefined" != typeof module && module.exports,
        n = "https:" == document.location.protocol ? "https:" : "http:",
        i = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
    o || (a ? require("jquery-mousewheel")(e) : e.event.special.mousewheel || e("head").append(decodeURI("%3Cscript src=" + n + "//" + i + "%3E%3C/script%3E"))), t();
  }(function () {
    var t,
        o = "mCustomScrollbar",
        a = "mCS",
        n = ".mCustomScrollbar",
        i = {
      setTop: 0,
      setLeft: 0,
      axis: "y",
      scrollbarPosition: "inside",
      scrollInertia: 950,
      autoDraggerLength: !0,
      alwaysShowScrollbar: 0,
      snapOffset: 0,
      mouseWheel: {
        enable: !0,
        scrollAmount: "auto",
        axis: "y",
        deltaFactor: "auto",
        disableOver: ["select", "option", "keygen", "datalist", "textarea"]
      },
      scrollButtons: {
        scrollType: "stepless",
        scrollAmount: "auto"
      },
      keyboard: {
        enable: !0,
        scrollType: "stepless",
        scrollAmount: "auto"
      },
      contentTouchScroll: 25,
      documentTouchScroll: !0,
      advanced: {
        autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
        updateOnContentResize: !0,
        updateOnImageLoad: "auto",
        autoUpdateTimeout: 60
      },
      theme: "light",
      callbacks: {
        onTotalScrollOffset: 0,
        onTotalScrollBackOffset: 0,
        alwaysTriggerOffsets: !0
      }
    },
        r = 0,
        l = {},
        s = window.attachEvent && !window.addEventListener ? 1 : 0,
        c = !1,
        d = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
        u = {
      init: function (t) {
        var t = e.extend(!0, {}, i, t),
            o = f.call(this);

        if (t.live) {
          var s = t.liveSelector || this.selector || n,
              c = e(s);
          if ("off" === t.live) return void m(s);
          l[s] = setTimeout(function () {
            c.mCustomScrollbar(t), "once" === t.live && c.length && m(s);
          }, 500);
        } else m(s);

        return t.setWidth = t.set_width ? t.set_width : t.setWidth, t.setHeight = t.set_height ? t.set_height : t.setHeight, t.axis = t.horizontalScroll ? "x" : p(t.axis), t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia, "object" != typeof t.mouseWheel && 1 == t.mouseWheel && (t.mouseWheel = {
          enable: !0,
          scrollAmount: "auto",
          axis: "y",
          preventDefault: !1,
          deltaFactor: "auto",
          normalizeDelta: !1,
          invert: !1
        }), t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount, t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta ? t.advanced.normalizeMouseWheelDelta : t.mouseWheel.normalizeDelta, t.scrollButtons.scrollType = g(t.scrollButtons.scrollType), h(t), e(o).each(function () {
          var o = e(this);

          if (!o.data(a)) {
            o.data(a, {
              idx: ++r,
              opt: t,
              scrollRatio: {
                y: null,
                x: null
              },
              overflowed: null,
              contentReset: {
                y: null,
                x: null
              },
              bindEvents: !1,
              tweenRunning: !1,
              sequential: {},
              langDir: o.css("direction"),
              cbOffsets: null,
              trigger: null,
              poll: {
                size: {
                  o: 0,
                  n: 0
                },
                img: {
                  o: 0,
                  n: 0
                },
                change: {
                  o: 0,
                  n: 0
                }
              }
            });
            var n = o.data(a),
                i = n.opt,
                l = o.data("mcs-axis"),
                s = o.data("mcs-scrollbar-position"),
                c = o.data("mcs-theme");
            l && (i.axis = l), s && (i.scrollbarPosition = s), c && (i.theme = c, h(i)), v.call(this), n && i.callbacks.onCreate && "function" == typeof i.callbacks.onCreate && i.callbacks.onCreate.call(this), e("#mCSB_" + n.idx + "_container img:not(." + d[2] + ")").addClass(d[2]), u.update.call(null, o);
          }
        });
      },
      update: function (t, o) {
        var n = t || f.call(this);
        return e(n).each(function () {
          var t = e(this);

          if (t.data(a)) {
            var n = t.data(a),
                i = n.opt,
                r = e("#mCSB_" + n.idx + "_container"),
                l = e("#mCSB_" + n.idx),
                s = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
            if (!r.length) return;
            n.tweenRunning && Q(t), o && n && i.callbacks.onBeforeUpdate && "function" == typeof i.callbacks.onBeforeUpdate && i.callbacks.onBeforeUpdate.call(this), t.hasClass(d[3]) && t.removeClass(d[3]), t.hasClass(d[4]) && t.removeClass(d[4]), l.css("max-height", "none"), l.height() !== t.height() && l.css("max-height", t.height()), _.call(this), "y" === i.axis || i.advanced.autoExpandHorizontalScroll || r.css("width", x(r)), n.overflowed = y.call(this), M.call(this), i.autoDraggerLength && S.call(this), b.call(this), T.call(this);
            var c = [Math.abs(r[0].offsetTop), Math.abs(r[0].offsetLeft)];
            "x" !== i.axis && (n.overflowed[0] ? s[0].height() > s[0].parent().height() ? B.call(this) : (G(t, c[0].toString(), {
              dir: "y",
              dur: 0,
              overwrite: "none"
            }), n.contentReset.y = null) : (B.call(this), "y" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[1] && G(t, c[1].toString(), {
              dir: "x",
              dur: 0,
              overwrite: "none"
            }))), "y" !== i.axis && (n.overflowed[1] ? s[1].width() > s[1].parent().width() ? B.call(this) : (G(t, c[1].toString(), {
              dir: "x",
              dur: 0,
              overwrite: "none"
            }), n.contentReset.x = null) : (B.call(this), "x" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[0] && G(t, c[0].toString(), {
              dir: "y",
              dur: 0,
              overwrite: "none"
            }))), o && n && (2 === o && i.callbacks.onImageLoad && "function" == typeof i.callbacks.onImageLoad ? i.callbacks.onImageLoad.call(this) : 3 === o && i.callbacks.onSelectorChange && "function" == typeof i.callbacks.onSelectorChange ? i.callbacks.onSelectorChange.call(this) : i.callbacks.onUpdate && "function" == typeof i.callbacks.onUpdate && i.callbacks.onUpdate.call(this)), N.call(this);
          }
        });
      },
      scrollTo: function (t, o) {
        if ("undefined" != typeof t && null != t) {
          var n = f.call(this);
          return e(n).each(function () {
            var n = e(this);

            if (n.data(a)) {
              var i = n.data(a),
                  r = i.opt,
                  l = {
                trigger: "external",
                scrollInertia: r.scrollInertia,
                scrollEasing: "mcsEaseInOut",
                moveDragger: !1,
                timeout: 60,
                callbacks: !0,
                onStart: !0,
                onUpdate: !0,
                onComplete: !0
              },
                  s = e.extend(!0, {}, l, o),
                  c = Y.call(this, t),
                  d = s.scrollInertia > 0 && s.scrollInertia < 17 ? 17 : s.scrollInertia;
              c[0] = X.call(this, c[0], "y"), c[1] = X.call(this, c[1], "x"), s.moveDragger && (c[0] *= i.scrollRatio.y, c[1] *= i.scrollRatio.x), s.dur = ne() ? 0 : d, setTimeout(function () {
                null !== c[0] && "undefined" != typeof c[0] && "x" !== r.axis && i.overflowed[0] && (s.dir = "y", s.overwrite = "all", G(n, c[0].toString(), s)), null !== c[1] && "undefined" != typeof c[1] && "y" !== r.axis && i.overflowed[1] && (s.dir = "x", s.overwrite = "none", G(n, c[1].toString(), s));
              }, s.timeout);
            }
          });
        }
      },
      stop: function () {
        var t = f.call(this);
        return e(t).each(function () {
          var t = e(this);
          t.data(a) && Q(t);
        });
      },
      disable: function (t) {
        var o = f.call(this);
        return e(o).each(function () {
          var o = e(this);

          if (o.data(a)) {
            o.data(a);
            N.call(this, "remove"), k.call(this), t && B.call(this), M.call(this, !0), o.addClass(d[3]);
          }
        });
      },
      destroy: function () {
        var t = f.call(this);
        return e(t).each(function () {
          var n = e(this);

          if (n.data(a)) {
            var i = n.data(a),
                r = i.opt,
                l = e("#mCSB_" + i.idx),
                s = e("#mCSB_" + i.idx + "_container"),
                c = e(".mCSB_" + i.idx + "_scrollbar");
            r.live && m(r.liveSelector || e(t).selector), N.call(this, "remove"), k.call(this), B.call(this), n.removeData(a), $(this, "mcs"), c.remove(), s.find("img." + d[2]).removeClass(d[2]), l.replaceWith(s.contents()), n.removeClass(o + " _" + a + "_" + i.idx + " " + d[6] + " " + d[7] + " " + d[5] + " " + d[3]).addClass(d[4]);
          }
        });
      }
    },
        f = function () {
      return "object" != typeof e(this) || e(this).length < 1 ? n : this;
    },
        h = function (t) {
      var o = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
          a = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
          n = ["minimal", "minimal-dark"],
          i = ["minimal", "minimal-dark"],
          r = ["minimal", "minimal-dark"];
      t.autoDraggerLength = e.inArray(t.theme, o) > -1 ? !1 : t.autoDraggerLength, t.autoExpandScrollbar = e.inArray(t.theme, a) > -1 ? !1 : t.autoExpandScrollbar, t.scrollButtons.enable = e.inArray(t.theme, n) > -1 ? !1 : t.scrollButtons.enable, t.autoHideScrollbar = e.inArray(t.theme, i) > -1 ? !0 : t.autoHideScrollbar, t.scrollbarPosition = e.inArray(t.theme, r) > -1 ? "outside" : t.scrollbarPosition;
    },
        m = function (e) {
      l[e] && (clearTimeout(l[e]), $(l, e));
    },
        p = function (e) {
      return "yx" === e || "xy" === e || "auto" === e ? "yx" : "x" === e || "horizontal" === e ? "x" : "y";
    },
        g = function (e) {
      return "stepped" === e || "pixels" === e || "step" === e || "click" === e ? "stepped" : "stepless";
    },
        v = function () {
      var t = e(this),
          n = t.data(a),
          i = n.opt,
          r = i.autoExpandScrollbar ? " " + d[1] + "_expand" : "",
          l = ["<div id='mCSB_" + n.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_vertical" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + n.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_horizontal" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
          s = "yx" === i.axis ? "mCSB_vertical_horizontal" : "x" === i.axis ? "mCSB_horizontal" : "mCSB_vertical",
          c = "yx" === i.axis ? l[0] + l[1] : "x" === i.axis ? l[1] : l[0],
          u = "yx" === i.axis ? "<div id='mCSB_" + n.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
          f = i.autoHideScrollbar ? " " + d[6] : "",
          h = "x" !== i.axis && "rtl" === n.langDir ? " " + d[7] : "";
      i.setWidth && t.css("width", i.setWidth), i.setHeight && t.css("height", i.setHeight), i.setLeft = "y" !== i.axis && "rtl" === n.langDir ? "989999px" : i.setLeft, t.addClass(o + " _" + a + "_" + n.idx + f + h).wrapInner("<div id='mCSB_" + n.idx + "' class='mCustomScrollBox mCS-" + i.theme + " " + s + "'><div id='mCSB_" + n.idx + "_container' class='mCSB_container' style='position:relative; top:" + i.setTop + "; left:" + i.setLeft + ";' dir='" + n.langDir + "' /></div>");
      var m = e("#mCSB_" + n.idx),
          p = e("#mCSB_" + n.idx + "_container");
      "y" === i.axis || i.advanced.autoExpandHorizontalScroll || p.css("width", x(p)), "outside" === i.scrollbarPosition ? ("static" === t.css("position") && t.css("position", "relative"), t.css("overflow", "visible"), m.addClass("mCSB_outside").after(c)) : (m.addClass("mCSB_inside").append(c), p.wrap(u)), w.call(this);
      var g = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
      g[0].css("min-height", g[0].height()), g[1].css("min-width", g[1].width());
    },
        x = function (t) {
      var o = [t[0].scrollWidth, Math.max.apply(Math, t.children().map(function () {
        return e(this).outerWidth(!0);
      }).get())],
          a = t.parent().width();
      return o[0] > a ? o[0] : o[1] > a ? o[1] : "100%";
    },
        _ = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e("#mCSB_" + o.idx + "_container");

      if (n.advanced.autoExpandHorizontalScroll && "y" !== n.axis) {
        i.css({
          width: "auto",
          "min-width": 0,
          "overflow-x": "scroll"
        });
        var r = Math.ceil(i[0].scrollWidth);
        3 === n.advanced.autoExpandHorizontalScroll || 2 !== n.advanced.autoExpandHorizontalScroll && r > i.parent().width() ? i.css({
          width: r,
          "min-width": "100%",
          "overflow-x": "inherit"
        }) : i.css({
          "overflow-x": "inherit",
          position: "absolute"
        }).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
          width: Math.ceil(i[0].getBoundingClientRect().right + .4) - Math.floor(i[0].getBoundingClientRect().left),
          "min-width": "100%",
          position: "relative"
        }).unwrap();
      }
    },
        w = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e(".mCSB_" + o.idx + "_scrollbar:first"),
          r = oe(n.scrollButtons.tabindex) ? "tabindex='" + n.scrollButtons.tabindex + "'" : "",
          l = ["<a href='#' class='" + d[13] + "' " + r + " />", "<a href='#' class='" + d[14] + "' " + r + " />", "<a href='#' class='" + d[15] + "' " + r + " />", "<a href='#' class='" + d[16] + "' " + r + " />"],
          s = ["x" === n.axis ? l[2] : l[0], "x" === n.axis ? l[3] : l[1], l[2], l[3]];
      n.scrollButtons.enable && i.prepend(s[0]).append(s[1]).next(".mCSB_scrollTools").prepend(s[2]).append(s[3]);
    },
        S = function () {
      var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
          l = [n.height() / i.outerHeight(!1), n.width() / i.outerWidth(!1)],
          c = [parseInt(r[0].css("min-height")), Math.round(l[0] * r[0].parent().height()), parseInt(r[1].css("min-width")), Math.round(l[1] * r[1].parent().width())],
          d = s && c[1] < c[0] ? c[0] : c[1],
          u = s && c[3] < c[2] ? c[2] : c[3];
      r[0].css({
        height: d,
        "max-height": r[0].parent().height() - 10
      }).find(".mCSB_dragger_bar").css({
        "line-height": c[0] + "px"
      }), r[1].css({
        width: u,
        "max-width": r[1].parent().width() - 10
      });
    },
        b = function () {
      var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
          l = [i.outerHeight(!1) - n.height(), i.outerWidth(!1) - n.width()],
          s = [l[0] / (r[0].parent().height() - r[0].height()), l[1] / (r[1].parent().width() - r[1].width())];
      o.scrollRatio = {
        y: s[0],
        x: s[1]
      };
    },
        C = function (e, t, o) {
      var a = o ? d[0] + "_expanded" : "",
          n = e.closest(".mCSB_scrollTools");
      "active" === t ? (e.toggleClass(d[0] + " " + a), n.toggleClass(d[1]), e[0]._draggable = e[0]._draggable ? 0 : 1) : e[0]._draggable || ("hide" === t ? (e.removeClass(d[0]), n.removeClass(d[1])) : (e.addClass(d[0]), n.addClass(d[1])));
    },
        y = function () {
      var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = null == o.overflowed ? i.height() : i.outerHeight(!1),
          l = null == o.overflowed ? i.width() : i.outerWidth(!1),
          s = i[0].scrollHeight,
          c = i[0].scrollWidth;
      return s > r && (r = s), c > l && (l = c), [r > n.height(), l > n.width()];
    },
        B = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e("#mCSB_" + o.idx),
          r = e("#mCSB_" + o.idx + "_container"),
          l = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")];

      if (Q(t), ("x" !== n.axis && !o.overflowed[0] || "y" === n.axis && o.overflowed[0]) && (l[0].add(r).css("top", 0), G(t, "_resetY")), "y" !== n.axis && !o.overflowed[1] || "x" === n.axis && o.overflowed[1]) {
        var s = dx = 0;
        "rtl" === o.langDir && (s = i.width() - r.outerWidth(!1), dx = Math.abs(s / o.scrollRatio.x)), r.css("left", s), l[1].css("left", dx), G(t, "_resetX");
      }
    },
        T = function () {
      function t() {
        r = setTimeout(function () {
          e.event.special.mousewheel ? (clearTimeout(r), W.call(o[0])) : t();
        }, 100);
      }

      var o = e(this),
          n = o.data(a),
          i = n.opt;

      if (!n.bindEvents) {
        if (I.call(this), i.contentTouchScroll && D.call(this), E.call(this), i.mouseWheel.enable) {
          var r;
          t();
        }

        P.call(this), U.call(this), i.advanced.autoScrollOnFocus && H.call(this), i.scrollButtons.enable && F.call(this), i.keyboard.enable && q.call(this), n.bindEvents = !0;
      }
    },
        k = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + "_" + o.idx,
          r = ".mCSB_" + o.idx + "_scrollbar",
          l = e("#mCSB_" + o.idx + ",#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper," + r + " ." + d[12] + ",#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal," + r + ">a"),
          s = e("#mCSB_" + o.idx + "_container");
      n.advanced.releaseDraggableSelectors && l.add(e(n.advanced.releaseDraggableSelectors)), n.advanced.extraDraggableSelectors && l.add(e(n.advanced.extraDraggableSelectors)), o.bindEvents && (e(document).add(e(!A() || top.document)).unbind("." + i), l.each(function () {
        e(this).unbind("." + i);
      }), clearTimeout(t[0]._focusTimeout), $(t[0], "_focusTimeout"), clearTimeout(o.sequential.step), $(o.sequential, "step"), clearTimeout(s[0].onCompleteTimeout), $(s[0], "onCompleteTimeout"), o.bindEvents = !1);
    },
        M = function (t) {
      var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = e("#mCSB_" + n.idx + "_container_wrapper"),
          l = r.length ? r : e("#mCSB_" + n.idx + "_container"),
          s = [e("#mCSB_" + n.idx + "_scrollbar_vertical"), e("#mCSB_" + n.idx + "_scrollbar_horizontal")],
          c = [s[0].find(".mCSB_dragger"), s[1].find(".mCSB_dragger")];
      "x" !== i.axis && (n.overflowed[0] && !t ? (s[0].add(c[0]).add(s[0].children("a")).css("display", "block"), l.removeClass(d[8] + " " + d[10])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[0].css("display", "none"), l.removeClass(d[10])) : (s[0].css("display", "none"), l.addClass(d[10])), l.addClass(d[8]))), "y" !== i.axis && (n.overflowed[1] && !t ? (s[1].add(c[1]).add(s[1].children("a")).css("display", "block"), l.removeClass(d[9] + " " + d[11])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[1].css("display", "none"), l.removeClass(d[11])) : (s[1].css("display", "none"), l.addClass(d[11])), l.addClass(d[9]))), n.overflowed[0] || n.overflowed[1] ? o.removeClass(d[5]) : o.addClass(d[5]);
    },
        O = function (t) {
      var o = t.type,
          a = t.target.ownerDocument !== document && null !== frameElement ? [e(frameElement).offset().top, e(frameElement).offset().left] : null,
          n = A() && t.target.ownerDocument !== top.document && null !== frameElement ? [e(t.view.frameElement).offset().top, e(t.view.frameElement).offset().left] : [0, 0];

      switch (o) {
        case "pointerdown":
        case "MSPointerDown":
        case "pointermove":
        case "MSPointerMove":
        case "pointerup":
        case "MSPointerUp":
          return a ? [t.originalEvent.pageY - a[0] + n[0], t.originalEvent.pageX - a[1] + n[1], !1] : [t.originalEvent.pageY, t.originalEvent.pageX, !1];

        case "touchstart":
        case "touchmove":
        case "touchend":
          var i = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0],
              r = t.originalEvent.touches.length || t.originalEvent.changedTouches.length;
          return t.target.ownerDocument !== document ? [i.screenY, i.screenX, r > 1] : [i.pageY, i.pageX, r > 1];

        default:
          return a ? [t.pageY - a[0] + n[0], t.pageX - a[1] + n[1], !1] : [t.pageY, t.pageX, !1];
      }
    },
        I = function () {
      function t(e, t, a, n) {
        if (h[0].idleTimer = d.scrollInertia < 233 ? 250 : 0, o.attr("id") === f[1]) var i = "x",
            s = (o[0].offsetLeft - t + n) * l.scrollRatio.x;else var i = "y",
            s = (o[0].offsetTop - e + a) * l.scrollRatio.y;
        G(r, s.toString(), {
          dir: i,
          drag: !0
        });
      }

      var o,
          n,
          i,
          r = e(this),
          l = r.data(a),
          d = l.opt,
          u = a + "_" + l.idx,
          f = ["mCSB_" + l.idx + "_dragger_vertical", "mCSB_" + l.idx + "_dragger_horizontal"],
          h = e("#mCSB_" + l.idx + "_container"),
          m = e("#" + f[0] + ",#" + f[1]),
          p = d.advanced.releaseDraggableSelectors ? m.add(e(d.advanced.releaseDraggableSelectors)) : m,
          g = d.advanced.extraDraggableSelectors ? e(!A() || top.document).add(e(d.advanced.extraDraggableSelectors)) : e(!A() || top.document);
      m.bind("contextmenu." + u, function (e) {
        e.preventDefault();
      }).bind("mousedown." + u + " touchstart." + u + " pointerdown." + u + " MSPointerDown." + u, function (t) {
        if (t.stopImmediatePropagation(), t.preventDefault(), ee(t)) {
          c = !0, s && (document.onselectstart = function () {
            return !1;
          }), L.call(h, !1), Q(r), o = e(this);
          var a = o.offset(),
              l = O(t)[0] - a.top,
              u = O(t)[1] - a.left,
              f = o.height() + a.top,
              m = o.width() + a.left;
          f > l && l > 0 && m > u && u > 0 && (n = l, i = u), C(o, "active", d.autoExpandScrollbar);
        }
      }).bind("touchmove." + u, function (e) {
        e.stopImmediatePropagation(), e.preventDefault();
        var a = o.offset(),
            r = O(e)[0] - a.top,
            l = O(e)[1] - a.left;
        t(n, i, r, l);
      }), e(document).add(g).bind("mousemove." + u + " pointermove." + u + " MSPointerMove." + u, function (e) {
        if (o) {
          var a = o.offset(),
              r = O(e)[0] - a.top,
              l = O(e)[1] - a.left;
          if (n === r && i === l) return;
          t(n, i, r, l);
        }
      }).add(p).bind("mouseup." + u + " touchend." + u + " pointerup." + u + " MSPointerUp." + u, function () {
        o && (C(o, "active", d.autoExpandScrollbar), o = null), c = !1, s && (document.onselectstart = null), L.call(h, !0);
      });
    },
        D = function () {
      function o(e) {
        if (!te(e) || c || O(e)[2]) return void (t = 0);
        t = 1, b = 0, C = 0, d = 1, y.removeClass("mCS_touch_action");
        var o = I.offset();
        u = O(e)[0] - o.top, f = O(e)[1] - o.left, z = [O(e)[0], O(e)[1]];
      }

      function n(e) {
        if (te(e) && !c && !O(e)[2] && (T.documentTouchScroll || e.preventDefault(), e.stopImmediatePropagation(), (!C || b) && d)) {
          g = K();
          var t = M.offset(),
              o = O(e)[0] - t.top,
              a = O(e)[1] - t.left,
              n = "mcsLinearOut";
          if (E.push(o), W.push(a), z[2] = Math.abs(O(e)[0] - z[0]), z[3] = Math.abs(O(e)[1] - z[1]), B.overflowed[0]) var i = D[0].parent().height() - D[0].height(),
              r = u - o > 0 && o - u > -(i * B.scrollRatio.y) && (2 * z[3] < z[2] || "yx" === T.axis);
          if (B.overflowed[1]) var l = D[1].parent().width() - D[1].width(),
              h = f - a > 0 && a - f > -(l * B.scrollRatio.x) && (2 * z[2] < z[3] || "yx" === T.axis);
          r || h ? (U || e.preventDefault(), b = 1) : (C = 1, y.addClass("mCS_touch_action")), U && e.preventDefault(), w = "yx" === T.axis ? [u - o, f - a] : "x" === T.axis ? [null, f - a] : [u - o, null], I[0].idleTimer = 250, B.overflowed[0] && s(w[0], R, n, "y", "all", !0), B.overflowed[1] && s(w[1], R, n, "x", L, !0);
        }
      }

      function i(e) {
        if (!te(e) || c || O(e)[2]) return void (t = 0);
        t = 1, e.stopImmediatePropagation(), Q(y), p = K();
        var o = M.offset();
        h = O(e)[0] - o.top, m = O(e)[1] - o.left, E = [], W = [];
      }

      function r(e) {
        if (te(e) && !c && !O(e)[2]) {
          d = 0, e.stopImmediatePropagation(), b = 0, C = 0, v = K();
          var t = M.offset(),
              o = O(e)[0] - t.top,
              a = O(e)[1] - t.left;

          if (!(v - g > 30)) {
            _ = 1e3 / (v - p);
            var n = "mcsEaseOut",
                i = 2.5 > _,
                r = i ? [E[E.length - 2], W[W.length - 2]] : [0, 0];
            x = i ? [o - r[0], a - r[1]] : [o - h, a - m];
            var u = [Math.abs(x[0]), Math.abs(x[1])];
            _ = i ? [Math.abs(x[0] / 4), Math.abs(x[1] / 4)] : [_, _];
            var f = [Math.abs(I[0].offsetTop) - x[0] * l(u[0] / _[0], _[0]), Math.abs(I[0].offsetLeft) - x[1] * l(u[1] / _[1], _[1])];
            w = "yx" === T.axis ? [f[0], f[1]] : "x" === T.axis ? [null, f[1]] : [f[0], null], S = [4 * u[0] + T.scrollInertia, 4 * u[1] + T.scrollInertia];
            var y = parseInt(T.contentTouchScroll) || 0;
            w[0] = u[0] > y ? w[0] : 0, w[1] = u[1] > y ? w[1] : 0, B.overflowed[0] && s(w[0], S[0], n, "y", L, !1), B.overflowed[1] && s(w[1], S[1], n, "x", L, !1);
          }
        }
      }

      function l(e, t) {
        var o = [1.5 * t, 2 * t, t / 1.5, t / 2];
        return e > 90 ? t > 4 ? o[0] : o[3] : e > 60 ? t > 3 ? o[3] : o[2] : e > 30 ? t > 8 ? o[1] : t > 6 ? o[0] : t > 4 ? t : o[2] : t > 8 ? t : o[3];
      }

      function s(e, t, o, a, n, i) {
        e && G(y, e.toString(), {
          dur: t,
          scrollEasing: o,
          dir: a,
          overwrite: n,
          drag: i
        });
      }

      var d,
          u,
          f,
          h,
          m,
          p,
          g,
          v,
          x,
          _,
          w,
          S,
          b,
          C,
          y = e(this),
          B = y.data(a),
          T = B.opt,
          k = a + "_" + B.idx,
          M = e("#mCSB_" + B.idx),
          I = e("#mCSB_" + B.idx + "_container"),
          D = [e("#mCSB_" + B.idx + "_dragger_vertical"), e("#mCSB_" + B.idx + "_dragger_horizontal")],
          E = [],
          W = [],
          R = 0,
          L = "yx" === T.axis ? "none" : "all",
          z = [],
          P = I.find("iframe"),
          H = ["touchstart." + k + " pointerdown." + k + " MSPointerDown." + k, "touchmove." + k + " pointermove." + k + " MSPointerMove." + k, "touchend." + k + " pointerup." + k + " MSPointerUp." + k],
          U = void 0 !== document.body.style.touchAction && "" !== document.body.style.touchAction;

      I.bind(H[0], function (e) {
        o(e);
      }).bind(H[1], function (e) {
        n(e);
      }), M.bind(H[0], function (e) {
        i(e);
      }).bind(H[2], function (e) {
        r(e);
      }), P.length && P.each(function () {
        e(this).bind("load", function () {
          A(this) && e(this.contentDocument || this.contentWindow.document).bind(H[0], function (e) {
            o(e), i(e);
          }).bind(H[1], function (e) {
            n(e);
          }).bind(H[2], function (e) {
            r(e);
          });
        });
      });
    },
        E = function () {
      function o() {
        return window.getSelection ? window.getSelection().toString() : document.selection && "Control" != document.selection.type ? document.selection.createRange().text : 0;
      }

      function n(e, t, o) {
        d.type = o && i ? "stepped" : "stepless", d.scrollAmount = 10, j(r, e, t, "mcsLinearOut", o ? 60 : null);
      }

      var i,
          r = e(this),
          l = r.data(a),
          s = l.opt,
          d = l.sequential,
          u = a + "_" + l.idx,
          f = e("#mCSB_" + l.idx + "_container"),
          h = f.parent();
      f.bind("mousedown." + u, function () {
        t || i || (i = 1, c = !0);
      }).add(document).bind("mousemove." + u, function (e) {
        if (!t && i && o()) {
          var a = f.offset(),
              r = O(e)[0] - a.top + f[0].offsetTop,
              c = O(e)[1] - a.left + f[0].offsetLeft;
          r > 0 && r < h.height() && c > 0 && c < h.width() ? d.step && n("off", null, "stepped") : ("x" !== s.axis && l.overflowed[0] && (0 > r ? n("on", 38) : r > h.height() && n("on", 40)), "y" !== s.axis && l.overflowed[1] && (0 > c ? n("on", 37) : c > h.width() && n("on", 39)));
        }
      }).bind("mouseup." + u + " dragend." + u, function () {
        t || (i && (i = 0, n("off", null)), c = !1);
      });
    },
        W = function () {
      function t(t, a) {
        if (Q(o), !z(o, t.target)) {
          var r = "auto" !== i.mouseWheel.deltaFactor ? parseInt(i.mouseWheel.deltaFactor) : s && t.deltaFactor < 100 ? 100 : t.deltaFactor || 100,
              d = i.scrollInertia;
          if ("x" === i.axis || "x" === i.mouseWheel.axis) var u = "x",
              f = [Math.round(r * n.scrollRatio.x), parseInt(i.mouseWheel.scrollAmount)],
              h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.width() ? .9 * l.width() : f[0],
              m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetLeft),
              p = c[1][0].offsetLeft,
              g = c[1].parent().width() - c[1].width(),
              v = "y" === i.mouseWheel.axis ? t.deltaY || a : t.deltaX;else var u = "y",
              f = [Math.round(r * n.scrollRatio.y), parseInt(i.mouseWheel.scrollAmount)],
              h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.height() ? .9 * l.height() : f[0],
              m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetTop),
              p = c[0][0].offsetTop,
              g = c[0].parent().height() - c[0].height(),
              v = t.deltaY || a;
          "y" === u && !n.overflowed[0] || "x" === u && !n.overflowed[1] || ((i.mouseWheel.invert || t.webkitDirectionInvertedFromDevice) && (v = -v), i.mouseWheel.normalizeDelta && (v = 0 > v ? -1 : 1), (v > 0 && 0 !== p || 0 > v && p !== g || i.mouseWheel.preventDefault) && (t.stopImmediatePropagation(), t.preventDefault()), t.deltaFactor < 5 && !i.mouseWheel.normalizeDelta && (h = t.deltaFactor, d = 17), G(o, (m - v * h).toString(), {
            dir: u,
            dur: d
          }));
        }
      }

      if (e(this).data(a)) {
        var o = e(this),
            n = o.data(a),
            i = n.opt,
            r = a + "_" + n.idx,
            l = e("#mCSB_" + n.idx),
            c = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")],
            d = e("#mCSB_" + n.idx + "_container").find("iframe");
        d.length && d.each(function () {
          e(this).bind("load", function () {
            A(this) && e(this.contentDocument || this.contentWindow.document).bind("mousewheel." + r, function (e, o) {
              t(e, o);
            });
          });
        }), l.bind("mousewheel." + r, function (e, o) {
          t(e, o);
        });
      }
    },
        R = new Object(),
        A = function (t) {
      var o = !1,
          a = !1,
          n = null;
      if (void 0 === t ? a = "#empty" : void 0 !== e(t).attr("id") && (a = e(t).attr("id")), a !== !1 && void 0 !== R[a]) return R[a];

      if (t) {
        try {
          var i = t.contentDocument || t.contentWindow.document;
          n = i.body.innerHTML;
        } catch (r) {}

        o = null !== n;
      } else {
        try {
          var i = top.document;
          n = i.body.innerHTML;
        } catch (r) {}

        o = null !== n;
      }

      return a !== !1 && (R[a] = o), o;
    },
        L = function (e) {
      var t = this.find("iframe");

      if (t.length) {
        var o = e ? "auto" : "none";
        t.css("pointer-events", o);
      }
    },
        z = function (t, o) {
      var n = o.nodeName.toLowerCase(),
          i = t.data(a).opt.mouseWheel.disableOver,
          r = ["select", "textarea"];
      return e.inArray(n, i) > -1 && !(e.inArray(n, r) > -1 && !e(o).is(":focus"));
    },
        P = function () {
      var t,
          o = e(this),
          n = o.data(a),
          i = a + "_" + n.idx,
          r = e("#mCSB_" + n.idx + "_container"),
          l = r.parent(),
          s = e(".mCSB_" + n.idx + "_scrollbar ." + d[12]);
      s.bind("mousedown." + i + " touchstart." + i + " pointerdown." + i + " MSPointerDown." + i, function (o) {
        c = !0, e(o.target).hasClass("mCSB_dragger") || (t = 1);
      }).bind("touchend." + i + " pointerup." + i + " MSPointerUp." + i, function () {
        c = !1;
      }).bind("click." + i, function (a) {
        if (t && (t = 0, e(a.target).hasClass(d[12]) || e(a.target).hasClass("mCSB_draggerRail"))) {
          Q(o);
          var i = e(this),
              s = i.find(".mCSB_dragger");

          if (i.parent(".mCSB_scrollTools_horizontal").length > 0) {
            if (!n.overflowed[1]) return;
            var c = "x",
                u = a.pageX > s.offset().left ? -1 : 1,
                f = Math.abs(r[0].offsetLeft) - u * (.9 * l.width());
          } else {
            if (!n.overflowed[0]) return;
            var c = "y",
                u = a.pageY > s.offset().top ? -1 : 1,
                f = Math.abs(r[0].offsetTop) - u * (.9 * l.height());
          }

          G(o, f.toString(), {
            dir: c,
            scrollEasing: "mcsEaseInOut"
          });
        }
      });
    },
        H = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + "_" + o.idx,
          r = e("#mCSB_" + o.idx + "_container"),
          l = r.parent();
      r.bind("focusin." + i, function () {
        var o = e(document.activeElement),
            a = r.find(".mCustomScrollBox").length,
            i = 0;
        o.is(n.advanced.autoScrollOnFocus) && (Q(t), clearTimeout(t[0]._focusTimeout), t[0]._focusTimer = a ? (i + 17) * a : 0, t[0]._focusTimeout = setTimeout(function () {
          var e = [ae(o)[0], ae(o)[1]],
              a = [r[0].offsetTop, r[0].offsetLeft],
              s = [a[0] + e[0] >= 0 && a[0] + e[0] < l.height() - o.outerHeight(!1), a[1] + e[1] >= 0 && a[0] + e[1] < l.width() - o.outerWidth(!1)],
              c = "yx" !== n.axis || s[0] || s[1] ? "all" : "none";
          "x" === n.axis || s[0] || G(t, e[0].toString(), {
            dir: "y",
            scrollEasing: "mcsEaseInOut",
            overwrite: c,
            dur: i
          }), "y" === n.axis || s[1] || G(t, e[1].toString(), {
            dir: "x",
            scrollEasing: "mcsEaseInOut",
            overwrite: c,
            dur: i
          });
        }, t[0]._focusTimer));
      });
    },
        U = function () {
      var t = e(this),
          o = t.data(a),
          n = a + "_" + o.idx,
          i = e("#mCSB_" + o.idx + "_container").parent();
      i.bind("scroll." + n, function () {
        0 === i.scrollTop() && 0 === i.scrollLeft() || e(".mCSB_" + o.idx + "_scrollbar").css("visibility", "hidden");
      });
    },
        F = function () {
      var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = o.sequential,
          r = a + "_" + o.idx,
          l = ".mCSB_" + o.idx + "_scrollbar",
          s = e(l + ">a");
      s.bind("contextmenu." + r, function (e) {
        e.preventDefault();
      }).bind("mousedown." + r + " touchstart." + r + " pointerdown." + r + " MSPointerDown." + r + " mouseup." + r + " touchend." + r + " pointerup." + r + " MSPointerUp." + r + " mouseout." + r + " pointerout." + r + " MSPointerOut." + r + " click." + r, function (a) {
        function r(e, o) {
          i.scrollAmount = n.scrollButtons.scrollAmount, j(t, e, o);
        }

        if (a.preventDefault(), ee(a)) {
          var l = e(this).attr("class");

          switch (i.type = n.scrollButtons.scrollType, a.type) {
            case "mousedown":
            case "touchstart":
            case "pointerdown":
            case "MSPointerDown":
              if ("stepped" === i.type) return;
              c = !0, o.tweenRunning = !1, r("on", l);
              break;

            case "mouseup":
            case "touchend":
            case "pointerup":
            case "MSPointerUp":
            case "mouseout":
            case "pointerout":
            case "MSPointerOut":
              if ("stepped" === i.type) return;
              c = !1, i.dir && r("off", l);
              break;

            case "click":
              if ("stepped" !== i.type || o.tweenRunning) return;
              r("on", l);
          }
        }
      });
    },
        q = function () {
      function t(t) {
        function a(e, t) {
          r.type = i.keyboard.scrollType, r.scrollAmount = i.keyboard.scrollAmount, "stepped" === r.type && n.tweenRunning || j(o, e, t);
        }

        switch (t.type) {
          case "blur":
            n.tweenRunning && r.dir && a("off", null);
            break;

          case "keydown":
          case "keyup":
            var l = t.keyCode ? t.keyCode : t.which,
                s = "on";

            if ("x" !== i.axis && (38 === l || 40 === l) || "y" !== i.axis && (37 === l || 39 === l)) {
              if ((38 === l || 40 === l) && !n.overflowed[0] || (37 === l || 39 === l) && !n.overflowed[1]) return;
              "keyup" === t.type && (s = "off"), e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), a(s, l));
            } else if (33 === l || 34 === l) {
              if ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type) {
                Q(o);
                var f = 34 === l ? -1 : 1;
                if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                    m = Math.abs(c[0].offsetLeft) - f * (.9 * d.width());else var h = "y",
                    m = Math.abs(c[0].offsetTop) - f * (.9 * d.height());
                G(o, m.toString(), {
                  dir: h,
                  scrollEasing: "mcsEaseInOut"
                });
              }
            } else if ((35 === l || 36 === l) && !e(document.activeElement).is(u) && ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type)) {
              if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                  m = 35 === l ? Math.abs(d.width() - c.outerWidth(!1)) : 0;else var h = "y",
                  m = 35 === l ? Math.abs(d.height() - c.outerHeight(!1)) : 0;
              G(o, m.toString(), {
                dir: h,
                scrollEasing: "mcsEaseInOut"
              });
            }

        }
      }

      var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = n.sequential,
          l = a + "_" + n.idx,
          s = e("#mCSB_" + n.idx),
          c = e("#mCSB_" + n.idx + "_container"),
          d = c.parent(),
          u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
          f = c.find("iframe"),
          h = ["blur." + l + " keydown." + l + " keyup." + l];
      f.length && f.each(function () {
        e(this).bind("load", function () {
          A(this) && e(this.contentDocument || this.contentWindow.document).bind(h[0], function (e) {
            t(e);
          });
        });
      }), s.attr("tabindex", "0").bind(h[0], function (e) {
        t(e);
      });
    },
        j = function (t, o, n, i, r) {
      function l(e) {
        u.snapAmount && (f.scrollAmount = u.snapAmount instanceof Array ? "x" === f.dir[0] ? u.snapAmount[1] : u.snapAmount[0] : u.snapAmount);

        var o = "stepped" !== f.type,
            a = r ? r : e ? o ? p / 1.5 : g : 1e3 / 60,
            n = e ? o ? 7.5 : 40 : 2.5,
            s = [Math.abs(h[0].offsetTop), Math.abs(h[0].offsetLeft)],
            d = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
            m = "x" === f.dir[0] ? s[1] + f.dir[1] * (d[1] * n) : s[0] + f.dir[1] * (d[0] * n),
            v = "x" === f.dir[0] ? s[1] + f.dir[1] * parseInt(f.scrollAmount) : s[0] + f.dir[1] * parseInt(f.scrollAmount),
            x = "auto" !== f.scrollAmount ? v : m,
            _ = i ? i : e ? o ? "mcsLinearOut" : "mcsEaseInOut" : "mcsLinear",
            w = !!e;

        return e && 17 > a && (x = "x" === f.dir[0] ? s[1] : s[0]), G(t, x.toString(), {
          dir: f.dir[0],
          scrollEasing: _,
          dur: a,
          onComplete: w
        }), e ? void (f.dir = !1) : (clearTimeout(f.step), void (f.step = setTimeout(function () {
          l();
        }, a)));
      }

      function s() {
        clearTimeout(f.step), $(f, "step"), Q(t);
      }

      var c = t.data(a),
          u = c.opt,
          f = c.sequential,
          h = e("#mCSB_" + c.idx + "_container"),
          m = "stepped" === f.type,
          p = u.scrollInertia < 26 ? 26 : u.scrollInertia,
          g = u.scrollInertia < 1 ? 17 : u.scrollInertia;

      switch (o) {
        case "on":
          if (f.dir = [n === d[16] || n === d[15] || 39 === n || 37 === n ? "x" : "y", n === d[13] || n === d[15] || 38 === n || 37 === n ? -1 : 1], Q(t), oe(n) && "stepped" === f.type) return;
          l(m);
          break;

        case "off":
          s(), (m || c.tweenRunning && f.dir) && l(!0);
      }
    },
        Y = function (t) {
      var o = e(this).data(a).opt,
          n = [];
      return "function" == typeof t && (t = t()), t instanceof Array ? n = t.length > 1 ? [t[0], t[1]] : "x" === o.axis ? [null, t[0]] : [t[0], null] : (n[0] = t.y ? t.y : t.x || "x" === o.axis ? null : t, n[1] = t.x ? t.x : t.y || "y" === o.axis ? null : t), "function" == typeof n[0] && (n[0] = n[0]()), "function" == typeof n[1] && (n[1] = n[1]()), n;
    },
        X = function (t, o) {
      if (null != t && "undefined" != typeof t) {
        var n = e(this),
            i = n.data(a),
            r = i.opt,
            l = e("#mCSB_" + i.idx + "_container"),
            s = l.parent(),
            c = typeof t;
        o || (o = "x" === r.axis ? "x" : "y");
        var d = "x" === o ? l.outerWidth(!1) - s.width() : l.outerHeight(!1) - s.height(),
            f = "x" === o ? l[0].offsetLeft : l[0].offsetTop,
            h = "x" === o ? "left" : "top";

        switch (c) {
          case "function":
            return t();

          case "object":
            var m = t.jquery ? t : e(t);
            if (!m.length) return;
            return "x" === o ? ae(m)[1] : ae(m)[0];

          case "string":
          case "number":
            if (oe(t)) return Math.abs(t);
            if (-1 !== t.indexOf("%")) return Math.abs(d * parseInt(t) / 100);
            if (-1 !== t.indexOf("-=")) return Math.abs(f - parseInt(t.split("-=")[1]));

            if (-1 !== t.indexOf("+=")) {
              var p = f + parseInt(t.split("+=")[1]);
              return p >= 0 ? 0 : Math.abs(p);
            }

            if (-1 !== t.indexOf("px") && oe(t.split("px")[0])) return Math.abs(t.split("px")[0]);
            if ("top" === t || "left" === t) return 0;
            if ("bottom" === t) return Math.abs(s.height() - l.outerHeight(!1));
            if ("right" === t) return Math.abs(s.width() - l.outerWidth(!1));

            if ("first" === t || "last" === t) {
              var m = l.find(":" + t);
              return "x" === o ? ae(m)[1] : ae(m)[0];
            }

            return e(t).length ? "x" === o ? ae(e(t))[1] : ae(e(t))[0] : (l.css(h, t), void u.update.call(null, n[0]));
        }
      }
    },
        N = function (t) {
      function o() {
        return clearTimeout(f[0].autoUpdate), 0 === l.parents("html").length ? void (l = null) : void (f[0].autoUpdate = setTimeout(function () {
          return c.advanced.updateOnSelectorChange && (s.poll.change.n = i(), s.poll.change.n !== s.poll.change.o) ? (s.poll.change.o = s.poll.change.n, void r(3)) : c.advanced.updateOnContentResize && (s.poll.size.n = l[0].scrollHeight + l[0].scrollWidth + f[0].offsetHeight + l[0].offsetHeight + l[0].offsetWidth, s.poll.size.n !== s.poll.size.o) ? (s.poll.size.o = s.poll.size.n, void r(1)) : !c.advanced.updateOnImageLoad || "auto" === c.advanced.updateOnImageLoad && "y" === c.axis || (s.poll.img.n = f.find("img").length, s.poll.img.n === s.poll.img.o) ? void ((c.advanced.updateOnSelectorChange || c.advanced.updateOnContentResize || c.advanced.updateOnImageLoad) && o()) : (s.poll.img.o = s.poll.img.n, void f.find("img").each(function () {
            n(this);
          }));
        }, c.advanced.autoUpdateTimeout));
      }

      function n(t) {
        function o(e, t) {
          return function () {
            return t.apply(e, arguments);
          };
        }

        function a() {
          this.onload = null, e(t).addClass(d[2]), r(2);
        }

        if (e(t).hasClass(d[2])) return void r();
        var n = new Image();
        n.onload = o(n, a), n.src = t.src;
      }

      function i() {
        c.advanced.updateOnSelectorChange === !0 && (c.advanced.updateOnSelectorChange = "*");
        var e = 0,
            t = f.find(c.advanced.updateOnSelectorChange);
        return c.advanced.updateOnSelectorChange && t.length > 0 && t.each(function () {
          e += this.offsetHeight + this.offsetWidth;
        }), e;
      }

      function r(e) {
        clearTimeout(f[0].autoUpdate), u.update.call(null, l[0], e);
      }

      var l = e(this),
          s = l.data(a),
          c = s.opt,
          f = e("#mCSB_" + s.idx + "_container");
      return t ? (clearTimeout(f[0].autoUpdate), void $(f[0], "autoUpdate")) : void o();
    },
        V = function (e, t, o) {
      return Math.round(e / t) * t - o;
    },
        Q = function (t) {
      var o = t.data(a),
          n = e("#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper,#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal");
      n.each(function () {
        Z.call(this);
      });
    },
        G = function (t, o, n) {
      function i(e) {
        return s && c.callbacks[e] && "function" == typeof c.callbacks[e];
      }

      function r() {
        return [c.callbacks.alwaysTriggerOffsets || w >= S[0] + y, c.callbacks.alwaysTriggerOffsets || -B >= w];
      }

      function l() {
        var e = [h[0].offsetTop, h[0].offsetLeft],
            o = [x[0].offsetTop, x[0].offsetLeft],
            a = [h.outerHeight(!1), h.outerWidth(!1)],
            i = [f.height(), f.width()];
        t[0].mcs = {
          content: h,
          top: e[0],
          left: e[1],
          draggerTop: o[0],
          draggerLeft: o[1],
          topPct: Math.round(100 * Math.abs(e[0]) / (Math.abs(a[0]) - i[0])),
          leftPct: Math.round(100 * Math.abs(e[1]) / (Math.abs(a[1]) - i[1])),
          direction: n.dir
        };
      }

      var s = t.data(a),
          c = s.opt,
          d = {
        trigger: "internal",
        dir: "y",
        scrollEasing: "mcsEaseOut",
        drag: !1,
        dur: c.scrollInertia,
        overwrite: "all",
        callbacks: !0,
        onStart: !0,
        onUpdate: !0,
        onComplete: !0
      },
          n = e.extend(d, n),
          u = [n.dur, n.drag ? 0 : n.dur],
          f = e("#mCSB_" + s.idx),
          h = e("#mCSB_" + s.idx + "_container"),
          m = h.parent(),
          p = c.callbacks.onTotalScrollOffset ? Y.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
          g = c.callbacks.onTotalScrollBackOffset ? Y.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];

      if (s.trigger = n.trigger, 0 === m.scrollTop() && 0 === m.scrollLeft() || (e(".mCSB_" + s.idx + "_scrollbar").css("visibility", "visible"), m.scrollTop(0).scrollLeft(0)), "_resetY" !== o || s.contentReset.y || (i("onOverflowYNone") && c.callbacks.onOverflowYNone.call(t[0]), s.contentReset.y = 1), "_resetX" !== o || s.contentReset.x || (i("onOverflowXNone") && c.callbacks.onOverflowXNone.call(t[0]), s.contentReset.x = 1), "_resetY" !== o && "_resetX" !== o) {
        if (!s.contentReset.y && t[0].mcs || !s.overflowed[0] || (i("onOverflowY") && c.callbacks.onOverflowY.call(t[0]), s.contentReset.x = null), !s.contentReset.x && t[0].mcs || !s.overflowed[1] || (i("onOverflowX") && c.callbacks.onOverflowX.call(t[0]), s.contentReset.x = null), c.snapAmount) {
          var v = c.snapAmount instanceof Array ? "x" === n.dir ? c.snapAmount[1] : c.snapAmount[0] : c.snapAmount;
          o = V(o, v, c.snapOffset);
        }

        switch (n.dir) {
          case "x":
            var x = e("#mCSB_" + s.idx + "_dragger_horizontal"),
                _ = "left",
                w = h[0].offsetLeft,
                S = [f.width() - h.outerWidth(!1), x.parent().width() - x.width()],
                b = [o, 0 === o ? 0 : o / s.scrollRatio.x],
                y = p[1],
                B = g[1],
                T = y > 0 ? y / s.scrollRatio.x : 0,
                k = B > 0 ? B / s.scrollRatio.x : 0;
            break;

          case "y":
            var x = e("#mCSB_" + s.idx + "_dragger_vertical"),
                _ = "top",
                w = h[0].offsetTop,
                S = [f.height() - h.outerHeight(!1), x.parent().height() - x.height()],
                b = [o, 0 === o ? 0 : o / s.scrollRatio.y],
                y = p[0],
                B = g[0],
                T = y > 0 ? y / s.scrollRatio.y : 0,
                k = B > 0 ? B / s.scrollRatio.y : 0;
        }

        b[1] < 0 || 0 === b[0] && 0 === b[1] ? b = [0, 0] : b[1] >= S[1] ? b = [S[0], S[1]] : b[0] = -b[0], t[0].mcs || (l(), i("onInit") && c.callbacks.onInit.call(t[0])), clearTimeout(h[0].onCompleteTimeout), J(x[0], _, Math.round(b[1]), u[1], n.scrollEasing), !s.tweenRunning && (0 === w && b[0] >= 0 || w === S[0] && b[0] <= S[0]) || J(h[0], _, Math.round(b[0]), u[0], n.scrollEasing, n.overwrite, {
          onStart: function () {
            n.callbacks && n.onStart && !s.tweenRunning && (i("onScrollStart") && (l(), c.callbacks.onScrollStart.call(t[0])), s.tweenRunning = !0, C(x), s.cbOffsets = r());
          },
          onUpdate: function () {
            n.callbacks && n.onUpdate && i("whileScrolling") && (l(), c.callbacks.whileScrolling.call(t[0]));
          },
          onComplete: function () {
            if (n.callbacks && n.onComplete) {
              "yx" === c.axis && clearTimeout(h[0].onCompleteTimeout);
              var e = h[0].idleTimer || 0;
              h[0].onCompleteTimeout = setTimeout(function () {
                i("onScroll") && (l(), c.callbacks.onScroll.call(t[0])), i("onTotalScroll") && b[1] >= S[1] - T && s.cbOffsets[0] && (l(), c.callbacks.onTotalScroll.call(t[0])), i("onTotalScrollBack") && b[1] <= k && s.cbOffsets[1] && (l(), c.callbacks.onTotalScrollBack.call(t[0])), s.tweenRunning = !1, h[0].idleTimer = 0, C(x, "hide");
              }, e);
            }
          }
        });
      }
    },
        J = function (e, t, o, a, n, i, r) {
      function l() {
        S.stop || (x || m.call(), x = K() - v, s(), x >= S.time && (S.time = x > S.time ? x + f - (x - S.time) : x + f - 1, S.time < x + 1 && (S.time = x + 1)), S.time < a ? S.id = h(l) : g.call());
      }

      function s() {
        a > 0 ? (S.currVal = u(S.time, _, b, a, n), w[t] = Math.round(S.currVal) + "px") : w[t] = o + "px", p.call();
      }

      function c() {
        f = 1e3 / 60, S.time = x + f, h = window.requestAnimationFrame ? window.requestAnimationFrame : function (e) {
          return s(), setTimeout(e, .01);
        }, S.id = h(l);
      }

      function d() {
        null != S.id && (window.requestAnimationFrame ? window.cancelAnimationFrame(S.id) : clearTimeout(S.id), S.id = null);
      }

      function u(e, t, o, a, n) {
        switch (n) {
          case "linear":
          case "mcsLinear":
            return o * e / a + t;

          case "mcsLinearOut":
            return e /= a, e--, o * Math.sqrt(1 - e * e) + t;

          case "easeInOutSmooth":
            return e /= a / 2, 1 > e ? o / 2 * e * e + t : (e--, -o / 2 * (e * (e - 2) - 1) + t);

          case "easeInOutStrong":
            return e /= a / 2, 1 > e ? o / 2 * Math.pow(2, 10 * (e - 1)) + t : (e--, o / 2 * (-Math.pow(2, -10 * e) + 2) + t);

          case "easeInOut":
          case "mcsEaseInOut":
            return e /= a / 2, 1 > e ? o / 2 * e * e * e + t : (e -= 2, o / 2 * (e * e * e + 2) + t);

          case "easeOutSmooth":
            return e /= a, e--, -o * (e * e * e * e - 1) + t;

          case "easeOutStrong":
            return o * (-Math.pow(2, -10 * e / a) + 1) + t;

          case "easeOut":
          case "mcsEaseOut":
          default:
            var i = (e /= a) * e,
                r = i * e;
            return t + o * (.499999999999997 * r * i + -2.5 * i * i + 5.5 * r + -6.5 * i + 4 * e);
        }
      }

      e._mTween || (e._mTween = {
        top: {},
        left: {}
      });

      var f,
          h,
          r = r || {},
          m = r.onStart || function () {},
          p = r.onUpdate || function () {},
          g = r.onComplete || function () {},
          v = K(),
          x = 0,
          _ = e.offsetTop,
          w = e.style,
          S = e._mTween[t];

      "left" === t && (_ = e.offsetLeft);
      var b = o - _;
      S.stop = 0, "none" !== i && d(), c();
    },
        K = function () {
      return window.performance && window.performance.now ? window.performance.now() : window.performance && window.performance.webkitNow ? window.performance.webkitNow() : Date.now ? Date.now() : new Date().getTime();
    },
        Z = function () {
      var e = this;
      e._mTween || (e._mTween = {
        top: {},
        left: {}
      });

      for (var t = ["top", "left"], o = 0; o < t.length; o++) {
        var a = t[o];
        e._mTween[a].id && (window.requestAnimationFrame ? window.cancelAnimationFrame(e._mTween[a].id) : clearTimeout(e._mTween[a].id), e._mTween[a].id = null, e._mTween[a].stop = 1);
      }
    },
        $ = function (e, t) {
      try {
        delete e[t];
      } catch (o) {
        e[t] = null;
      }
    },
        ee = function (e) {
      return !(e.which && 1 !== e.which);
    },
        te = function (e) {
      var t = e.originalEvent.pointerType;
      return !(t && "touch" !== t && 2 !== t);
    },
        oe = function (e) {
      return !isNaN(parseFloat(e)) && isFinite(e);
    },
        ae = function (e) {
      var t = e.parents(".mCSB_container");
      return [e.offset().top - t.offset().top, e.offset().left - t.offset().left];
    },
        ne = function () {
      function e() {
        var e = ["webkit", "moz", "ms", "o"];
        if ("hidden" in document) return "hidden";

        for (var t = 0; t < e.length; t++) if (e[t] + "Hidden" in document) return e[t] + "Hidden";

        return null;
      }

      var t = e();
      return t ? document[t] : !1;
    };

    e.fn[o] = function (t) {
      return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments);
    }, e[o] = function (t) {
      return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments);
    }, e[o].defaults = i, window[o] = !0, e(window).bind("load", function () {
      e(n)[o](), e.extend(e.expr[":"], {
        mcsInView: e.expr[":"].mcsInView || function (t) {
          var o,
              a,
              n = e(t),
              i = n.parents(".mCSB_container");
          if (i.length) return o = i.parent(), a = [i[0].offsetTop, i[0].offsetLeft], a[0] + ae(n)[0] >= 0 && a[0] + ae(n)[0] < o.height() - n.outerHeight(!1) && a[1] + ae(n)[1] >= 0 && a[1] + ae(n)[1] < o.width() - n.outerWidth(!1);
        },
        mcsInSight: e.expr[":"].mcsInSight || function (t, o, a) {
          var n,
              i,
              r,
              l,
              s = e(t),
              c = s.parents(".mCSB_container"),
              d = "exact" === a[3] ? [[1, 0], [1, 0]] : [[.9, .1], [.6, .4]];
          if (c.length) return n = [s.outerHeight(!1), s.outerWidth(!1)], r = [c[0].offsetTop + ae(s)[0], c[0].offsetLeft + ae(s)[1]], i = [c.parent()[0].offsetHeight, c.parent()[0].offsetWidth], l = [n[0] < i[0] ? d[0] : d[1], n[1] < i[1] ? d[0] : d[1]], r[0] - i[0] * l[0][0] < 0 && r[0] + n[0] - i[0] * l[0][1] >= 0 && r[1] - i[1] * l[1][0] < 0 && r[1] + n[1] - i[1] * l[1][1] >= 0;
        },
        mcsOverflow: e.expr[":"].mcsOverflow || function (t) {
          var o = e(t).data(a);
          if (o) return o.overflowed[0] || o.overflowed[1];
        }
      });
    });
  });
});
/**
 * This is only currently needed in a separate file in libraries because
 * the javascript files are loaded alphabetically from files and we need to
 * ensure that our namespace object is loaded before all other ogame specific
 * javascript code
 */

/*
 * global javascript namespace for ogame
 */
var ogame = ogame || {};
/*!
 * Select2 4.0.0
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 = function () {
    // Restore the Select2 AMD loader so it can be used
    // Needed mostly in the language files, where the loader is not inserted
    if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
      var S2 = jQuery.fn.select2.amd;
    }

    var S2;

    (function () {
      if (!S2 || !S2.requirejs) {
        if (!S2) {
          S2 = {};
        } else {
          require = S2;
        }
        /**
         * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
         * Available via the MIT or new BSD license.
         * see: http://github.com/jrburke/almond for details
         */
        //Going sloppy to avoid 'use strict' string cost, but strict practices should
        //be followed.

        /*jslint sloppy: true */

        /*global setTimeout: false */


        var requirejs, require, define;

        (function (undef) {
          var main,
              req,
              makeMap,
              handlers,
              defined = {},
              waiting = {},
              config = {},
              defining = {},
              hasOwn = Object.prototype.hasOwnProperty,
              aps = [].slice,
              jsSuffixRegExp = /\.js$/;

          function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
          }
          /**
           * Given a relative module name, like ./something, normalize it to
           * a real name that can be mapped to a path.
           * @param {String} name the relative name
           * @param {String} baseName a real name that the name arg is relative
           * to.
           * @returns {String} normalized name
           */


          function normalize(name, baseName) {
            var nameParts,
                nameSegment,
                mapValue,
                foundMap,
                lastIndex,
                foundI,
                foundStarMap,
                starI,
                i,
                j,
                part,
                baseParts = baseName && baseName.split("/"),
                map = config.map,
                starMap = map && map['*'] || {}; //Adjust any relative paths.

            if (name && name.charAt(0) === ".") {
              //If have a base name, try to normalize against it,
              //otherwise, assume it is a top-level require that will
              //be relative to baseUrl in the end.
              if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1; // Node .js allowance:

                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                  name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name); //start trimDots

                for (i = 0; i < name.length; i += 1) {
                  part = name[i];

                  if (part === ".") {
                    name.splice(i, 1);
                    i -= 1;
                  } else if (part === "..") {
                    if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                      //End of the line. Keep at least one non-dot
                      //path segment at the front so it can be mapped
                      //correctly to disk. Otherwise, there is likely
                      //no path mapping for a path starting with '..'.
                      //This can still fail, but catches the most reasonable
                      //uses of ..
                      break;
                    } else if (i > 0) {
                      name.splice(i - 1, 2);
                      i -= 2;
                    }
                  }
                } //end trimDots


                name = name.join("/");
              } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
              }
            } //Apply map config if available.


            if ((baseParts || starMap) && map) {
              nameParts = name.split('/');

              for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                  //Find the longest baseName segment match in the config.
                  //So, do joins on the biggest to smallest lengths of baseParts.
                  for (j = baseParts.length; j > 0; j -= 1) {
                    mapValue = map[baseParts.slice(0, j).join('/')]; //baseName segment has  config, find if it has one for
                    //this name.

                    if (mapValue) {
                      mapValue = mapValue[nameSegment];

                      if (mapValue) {
                        //Match, update name to the new value.
                        foundMap = mapValue;
                        foundI = i;
                        break;
                      }
                    }
                  }
                }

                if (foundMap) {
                  break;
                } //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.


                if (!foundStarMap && starMap && starMap[nameSegment]) {
                  foundStarMap = starMap[nameSegment];
                  starI = i;
                }
              }

              if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
              }

              if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
              }
            }

            return name;
          }

          function makeRequire(relName, forceSync) {
            return function () {
              //A version of a require function that passes a moduleName
              //value for items that may need to
              //look up paths relative to the moduleName
              return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
            };
          }

          function makeNormalize(relName) {
            return function (name) {
              return normalize(name, relName);
            };
          }

          function makeLoad(depName) {
            return function (value) {
              defined[depName] = value;
            };
          }

          function callDep(name) {
            if (hasProp(waiting, name)) {
              var args = waiting[name];
              delete waiting[name];
              defining[name] = true;
              main.apply(undef, args);
            }

            if (!hasProp(defined, name) && !hasProp(defining, name)) {
              throw new Error('No ' + name);
            }

            return defined[name];
          } //Turns a plugin!resource to [plugin, resource]
          //with the plugin being undefined if the name
          //did not have a plugin prefix.


          function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;

            if (index > -1) {
              prefix = name.substring(0, index);
              name = name.substring(index + 1, name.length);
            }

            return [prefix, name];
          }
          /**
           * Makes a name map, normalizing the name, and using a plugin
           * for normalization if necessary. Grabs a ref to plugin
           * too, as an optimization.
           */


          makeMap = function (name, relName) {
            var plugin,
                parts = splitPrefix(name),
                prefix = parts[0];
            name = parts[1];

            if (prefix) {
              prefix = normalize(prefix, relName);
              plugin = callDep(prefix);
            } //Normalize according


            if (prefix) {
              if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
              } else {
                name = normalize(name, relName);
              }
            } else {
              name = normalize(name, relName);
              parts = splitPrefix(name);
              prefix = parts[0];
              name = parts[1];

              if (prefix) {
                plugin = callDep(prefix);
              }
            } //Using ridiculous property names for space reasons


            return {
              f: prefix ? prefix + '!' + name : name,
              //fullName
              n: name,
              pr: prefix,
              p: plugin
            };
          };

          function makeConfig(name) {
            return function () {
              return config && config.config && config.config[name] || {};
            };
          }

          handlers = {
            require: function (name) {
              return makeRequire(name);
            },
            exports: function (name) {
              var e = defined[name];

              if (typeof e !== 'undefined') {
                return e;
              } else {
                return defined[name] = {};
              }
            },
            module: function (name) {
              return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
              };
            }
          };

          main = function (name, deps, callback, relName) {
            var cjsModule,
                depName,
                ret,
                map,
                i,
                args = [],
                callbackType = typeof callback,
                usingExports; //Use name if no relName

            relName = relName || name; //Call the callback to define the module, if necessary.

            if (callbackType === 'undefined' || callbackType === 'function') {
              //Pull out the defined dependencies and pass the ordered
              //values to the callback.
              //Default to [require, exports, module] if no deps
              deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;

              for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f; //Fast path CommonJS standard dependencies.

                if (depName === "require") {
                  args[i] = handlers.require(name);
                } else if (depName === "exports") {
                  //CommonJS module spec 1.1
                  args[i] = handlers.exports(name);
                  usingExports = true;
                } else if (depName === "module") {
                  //CommonJS module spec 1.1
                  cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                  args[i] = callDep(depName);
                } else if (map.p) {
                  map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                  args[i] = defined[depName];
                } else {
                  throw new Error(name + ' missing ' + depName);
                }
              }

              ret = callback ? callback.apply(defined[name], args) : undefined;

              if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                  defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                  //Use the return value from the function.
                  defined[name] = ret;
                }
              }
            } else if (name) {
              //May just be an object definition for the module. Only
              //worry about defining if have a module name.
              defined[name] = callback;
            }
          };

          requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
            if (typeof deps === "string") {
              if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
              } //Just return the module wanted. In this scenario, the
              //deps arg is the module name, and second arg (if passed)
              //is just the relName.
              //Normalize module name, if it contains . or ..


              return callDep(makeMap(deps, callback).f);
            } else if (!deps.splice) {
              //deps is a config object, not an array.
              config = deps;

              if (config.deps) {
                req(config.deps, config.callback);
              }

              if (!callback) {
                return;
              }

              if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
              } else {
                deps = undef;
              }
            } //Support require(['a'])


            callback = callback || function () {}; //If relName is a function, it is an errback handler,
            //so remove it.


            if (typeof relName === 'function') {
              relName = forceSync;
              forceSync = alt;
            } //Simulate async callback;


            if (forceSync) {
              main(undef, deps, callback, relName);
            } else {
              //Using a non-zero value because of concern for what old browsers
              //do, and latest browsers "upgrade" to 4 if lower value is used:
              //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
              //If want a value immediately, use require('id') instead -- something
              //that works in almond on the global level, but not guaranteed and
              //unlikely to work in other AMD implementations.
              setTimeout(function () {
                main(undef, deps, callback, relName);
              }, 4);
            }

            return req;
          };
          /**
           * Just drops the config on the floor, but returns req in case
           * the config return value is used.
           */


          req.config = function (cfg) {
            return req(cfg);
          };
          /**
           * Expose module registry for debugging and tooling
           */


          requirejs._defined = defined;

          define = function (name, deps, callback) {
            //This module may not have dependencies
            if (!deps.splice) {
              //deps is not an array, so probably means
              //an object literal or factory function for
              //the value. Adjust args.
              callback = deps;
              deps = [];
            }

            if (!hasProp(defined, name) && !hasProp(waiting, name)) {
              waiting[name] = [name, deps, callback];
            }
          };

          define.amd = {
            jQuery: true
          };
        })();

        S2.requirejs = requirejs;
        S2.require = require;
        S2.define = define;
      }
    })();

    S2.define("almond", function () {});
    /* global jQuery:false, $:false */

    S2.define('jquery', [], function () {
      var _$ = jQuery || $;

      if (_$ == null && console && console.error) {
        console.error('Select2: An instance of jQuery or a jQuery-compatible library was not ' + 'found. Make sure that you are including jQuery before Select2 on your ' + 'web page.');
      }

      return _$;
    });
    S2.define('select2/utils', ['jquery'], function ($) {
      var Utils = {};

      Utils.Extend = function (ChildClass, SuperClass) {
        var __hasProp = {}.hasOwnProperty;

        function BaseConstructor() {
          this.constructor = ChildClass;
        }

        for (var key in SuperClass) {
          if (__hasProp.call(SuperClass, key)) {
            ChildClass[key] = SuperClass[key];
          }
        }

        BaseConstructor.prototype = SuperClass.prototype;
        ChildClass.prototype = new BaseConstructor();
        ChildClass.__super__ = SuperClass.prototype;
        return ChildClass;
      };

      function getMethods(theClass) {
        var proto = theClass.prototype;
        var methods = [];

        for (var methodName in proto) {
          var m = proto[methodName];

          if (typeof m !== 'function') {
            continue;
          }

          if (methodName === 'constructor') {
            continue;
          }

          methods.push(methodName);
        }

        return methods;
      }

      Utils.Decorate = function (SuperClass, DecoratorClass) {
        var decoratedMethods = getMethods(DecoratorClass);
        var superMethods = getMethods(SuperClass);

        function DecoratedClass() {
          var unshift = Array.prototype.unshift;
          var argCount = DecoratorClass.prototype.constructor.length;
          var calledConstructor = SuperClass.prototype.constructor;

          if (argCount > 0) {
            unshift.call(arguments, SuperClass.prototype.constructor);
            calledConstructor = DecoratorClass.prototype.constructor;
          }

          calledConstructor.apply(this, arguments);
        }

        DecoratorClass.displayName = SuperClass.displayName;

        function ctr() {
          this.constructor = DecoratedClass;
        }

        DecoratedClass.prototype = new ctr();

        for (var m = 0; m < superMethods.length; m++) {
          var superMethod = superMethods[m];
          DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
        }

        var calledMethod = function (methodName) {
          // Stub out the original method if it's not decorating an actual method
          var originalMethod = function () {};

          if (methodName in DecoratedClass.prototype) {
            originalMethod = DecoratedClass.prototype[methodName];
          }

          var decoratedMethod = DecoratorClass.prototype[methodName];
          return function () {
            var unshift = Array.prototype.unshift;
            unshift.call(arguments, originalMethod);
            return decoratedMethod.apply(this, arguments);
          };
        };

        for (var d = 0; d < decoratedMethods.length; d++) {
          var decoratedMethod = decoratedMethods[d];
          DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
        }

        return DecoratedClass;
      };

      var Observable = function () {
        this.listeners = {};
      };

      Observable.prototype.on = function (event, callback) {
        this.listeners = this.listeners || {};

        if (event in this.listeners) {
          this.listeners[event].push(callback);
        } else {
          this.listeners[event] = [callback];
        }
      };

      Observable.prototype.trigger = function (event) {
        var slice = Array.prototype.slice;
        this.listeners = this.listeners || {};

        if (event in this.listeners) {
          this.invoke(this.listeners[event], slice.call(arguments, 1));
        }

        if ('*' in this.listeners) {
          this.invoke(this.listeners['*'], arguments);
        }
      };

      Observable.prototype.invoke = function (listeners, params) {
        for (var i = 0, len = listeners.length; i < len; i++) {
          listeners[i].apply(this, params);
        }
      };

      Utils.Observable = Observable;

      Utils.generateChars = function (length) {
        var chars = '';

        for (var i = 0; i < length; i++) {
          var randomChar = Math.floor(Math.random() * 36);
          chars += randomChar.toString(36);
        }

        return chars;
      };

      Utils.bind = function (func, context) {
        return function () {
          func.apply(context, arguments);
        };
      };

      Utils._convertData = function (data) {
        for (var originalKey in data) {
          var keys = originalKey.split('-');
          var dataLevel = data;

          if (keys.length === 1) {
            continue;
          }

          for (var k = 0; k < keys.length; k++) {
            var key = keys[k]; // Lowercase the first letter
            // By default, dash-separated becomes camelCase

            key = key.substring(0, 1).toLowerCase() + key.substring(1);

            if (!(key in dataLevel)) {
              dataLevel[key] = {};
            }

            if (k == keys.length - 1) {
              dataLevel[key] = data[originalKey];
            }

            dataLevel = dataLevel[key];
          }

          delete data[originalKey];
        }

        return data;
      };

      Utils.hasScroll = function (index, el) {
        // Adapted from the function created by @ShadowScripter
        // and adapted by @BillBarry on the Stack Exchange Code Review website.
        // The original code can be found at
        // http://codereview.stackexchange.com/q/13338
        // and was designed to be used with the Sizzle selector engine.
        var $el = $(el);
        var overflowX = el.style.overflowX;
        var overflowY = el.style.overflowY; //Check both x and y declarations

        if (overflowX === overflowY && (overflowY === 'hidden' || overflowY === 'visible')) {
          return false;
        }

        if (overflowX === 'scroll' || overflowY === 'scroll') {
          return true;
        }

        return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
      };

      Utils.escapeMarkup = function (markup) {
        var replaceMap = {
          '\\': '&#92;',
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          '\'': '&#39;',
          '/': '&#47;'
        }; // Do not try to escape the markup if it's not a string

        if (typeof markup !== 'string') {
          return markup;
        }

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
          return replaceMap[match];
        });
      }; // Append an array of jQuery nodes to a given element.


      Utils.appendMany = function ($element, $nodes) {
        // jQuery 1.7.x does not support $.fn.append() with an array
        // Fall back to a jQuery object collection using $.fn.add()
        if ($.fn.jquery.substr(0, 3) === '1.7') {
          var $jqNodes = $();
          $.map($nodes, function (node) {
            $jqNodes = $jqNodes.add(node);
          });
          $nodes = $jqNodes;
        }

        $element.append($nodes);
      };

      return Utils;
    });
    S2.define('select2/results', ['jquery', './utils'], function ($, Utils) {
      function Results($element, options, dataAdapter) {
        this.$element = $element;
        this.data = dataAdapter;
        this.options = options;

        Results.__super__.constructor.call(this);
      }

      Utils.Extend(Results, Utils.Observable);

      Results.prototype.render = function () {
        var $results = $('<ul class="select2-results__options" role="tree"></ul>');

        if (this.options.get('multiple')) {
          $results.attr('aria-multiselectable', 'true');
        }

        this.$results = $results;
        return $results;
      };

      Results.prototype.clear = function () {
        this.$results.empty();
      };

      Results.prototype.displayMessage = function (params) {
        var escapeMarkup = this.options.get('escapeMarkup');
        this.clear();
        this.hideLoading();
        var $message = $('<li role="treeitem" class="select2-results__option"></li>');
        var message = this.options.get('translations').get(params.message);
        $message.append(escapeMarkup(message(params.args)));
        this.$results.append($message);
      };

      Results.prototype.append = function (data) {
        this.hideLoading();
        var $options = [];

        if (data.results == null || data.results.length === 0) {
          if (this.$results.children().length === 0) {
            this.trigger('results:message', {
              message: 'noResults'
            });
          }

          return;
        }

        data.results = this.sort(data.results);

        for (var d = 0; d < data.results.length; d++) {
          var item = data.results[d];
          var $option = this.option(item);
          $options.push($option);
        }

        this.$results.append($options);
      };

      Results.prototype.position = function ($results, $dropdown) {
        var $resultsContainer = $dropdown.find('.select2-results');
        $resultsContainer.append($results);
      };

      Results.prototype.sort = function (data) {
        var sorter = this.options.get('sorter');
        return sorter(data);
      };

      Results.prototype.setClasses = function () {
        var self = this;
        this.data.current(function (selected) {
          var selectedIds = $.map(selected, function (s) {
            return s.id.toString();
          });
          var $options = self.$results.find('.select2-results__option[aria-selected]');
          $options.each(function () {
            var $option = $(this);
            var item = $.data(this, 'data'); // id needs to be converted to a string when comparing

            var id = '' + item.id;

            if (item.element != null && item.element.selected || item.element == null && $.inArray(id, selectedIds) > -1) {
              $option.attr('aria-selected', 'true');
            } else {
              $option.attr('aria-selected', 'false');
            }
          });
          var $selected = $options.filter('[aria-selected=true]'); // Check if there are any selected options

          if ($selected.length > 0) {
            // If there are selected options, highlight the first
            $selected.first().trigger('mouseenter');
          } else {
            // If there are no selected options, highlight the first option
            // in the dropdown
            $options.first().trigger('mouseenter');
          }
        });
      };

      Results.prototype.showLoading = function (params) {
        this.hideLoading();
        var loadingMore = this.options.get('translations').get('searching');
        var loading = {
          disabled: true,
          loading: true,
          text: loadingMore(params)
        };
        var $loading = this.option(loading);
        $loading.className += ' loading-results';
        this.$results.prepend($loading);
      };

      Results.prototype.hideLoading = function () {
        this.$results.find('.loading-results').remove();
      };

      Results.prototype.option = function (data) {
        var option = document.createElement('li');
        option.className = 'select2-results__option';
        var attrs = {
          'role': 'treeitem',
          'aria-selected': 'false'
        };

        if (data.disabled) {
          delete attrs['aria-selected'];
          attrs['aria-disabled'] = 'true';
        }

        if (data.id == null) {
          delete attrs['aria-selected'];
        }

        if (data._resultId != null) {
          option.id = data._resultId;
        }

        if (data.title) {
          option.title = data.title;
        }

        if (data.children) {
          attrs.role = 'group';
          attrs['aria-label'] = data.text;
          delete attrs['aria-selected'];
        }

        for (var attr in attrs) {
          var val = attrs[attr];
          option.setAttribute(attr, val);
        }

        if (data.children) {
          var $option = $(option);
          var label = document.createElement('strong');
          label.className = 'select2-results__group';
          var $label = $(label);
          this.template(data, label);
          var $children = [];

          for (var c = 0; c < data.children.length; c++) {
            var child = data.children[c];
            var $child = this.option(child);
            $children.push($child);
          }

          var $childrenContainer = $('<ul></ul>', {
            'class': 'select2-results__options select2-results__options--nested'
          });
          $childrenContainer.append($children);
          $option.append(label);
          $option.append($childrenContainer);
        } else {
          this.template(data, option);
        }

        $.data(option, 'data', data);
        return option;
      };

      Results.prototype.bind = function (container, $container) {
        var self = this;
        var id = container.id + '-results';
        this.$results.attr('id', id);
        container.on('results:all', function (params) {
          self.clear();
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
          }
        });
        container.on('results:append', function (params) {
          self.append(params.data);

          if (container.isOpen()) {
            self.setClasses();
          }
        });
        container.on('query', function (params) {
          self.showLoading(params);
        });
        container.on('select', function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();
        });
        container.on('unselect', function () {
          if (!container.isOpen()) {
            return;
          }

          self.setClasses();
        });
        container.on('open', function () {
          // When the dropdown is open, aria-expended="true"
          self.$results.attr('aria-expanded', 'true');
          self.$results.attr('aria-hidden', 'false');
          self.setClasses();
          self.ensureHighlightVisible();
        });
        container.on('close', function () {
          // When the dropdown is closed, aria-expended="false"
          self.$results.attr('aria-expanded', 'false');
          self.$results.attr('aria-hidden', 'true');
          self.$results.removeAttr('aria-activedescendant');
        });
        container.on('results:toggle', function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          $highlighted.trigger('mouseup');
        });
        container.on('results:select', function () {
          var $highlighted = self.getHighlightedResults();

          if ($highlighted.length === 0) {
            return;
          }

          var data = $highlighted.data('data');

          if ($highlighted.attr('aria-selected') == 'true') {
            self.trigger('close');
          } else {
            self.trigger('select', {
              data: data
            });
          }
        });
        container.on('results:previous', function () {
          var $highlighted = self.getHighlightedResults();
          var $options = self.$results.find('[aria-selected]');
          var currentIndex = $options.index($highlighted); // If we are already at te top, don't move further

          if (currentIndex === 0) {
            return;
          }

          var nextIndex = currentIndex - 1; // If none are highlighted, highlight the first

          if ($highlighted.length === 0) {
            nextIndex = 0;
          }

          var $next = $options.eq(nextIndex);
          $next.trigger('mouseenter');
          var currentOffset = self.$results.offset().top;
          var nextTop = $next.offset().top;
          var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextTop - currentOffset < 0) {
            self.$results.scrollTop(nextOffset);
          }
        });
        container.on('results:next', function () {
          var $highlighted = self.getHighlightedResults();
          var $options = self.$results.find('[aria-selected]');
          var currentIndex = $options.index($highlighted);
          var nextIndex = currentIndex + 1; // If we are at the last option, stay there

          if (nextIndex >= $options.length) {
            return;
          }

          var $next = $options.eq(nextIndex);
          $next.trigger('mouseenter');
          var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
          var nextBottom = $next.offset().top + $next.outerHeight(false);
          var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

          if (nextIndex === 0) {
            self.$results.scrollTop(0);
          } else if (nextBottom > currentOffset) {
            self.$results.scrollTop(nextOffset);
          }
        });
        container.on('results:focus', function (params) {
          params.element.addClass('select2-results__option--highlighted');
        });
        container.on('results:message', function (params) {
          self.displayMessage(params);
        });

        if ($.fn.mousewheel) {
          this.$results.on('mousewheel', function (e) {
            var top = self.$results.scrollTop();
            var bottom = self.$results.get(0).scrollHeight - self.$results.scrollTop() + e.deltaY;
            var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
            var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

            if (isAtTop) {
              self.$results.scrollTop(0);
              e.preventDefault();
              e.stopPropagation();
            } else if (isAtBottom) {
              self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height());
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        this.$results.on('mouseup', '.select2-results__option[aria-selected]', function (evt) {
          var $this = $(this);
          var data = $this.data('data');

          if ($this.attr('aria-selected') === 'true') {
            if (self.options.get('multiple')) {
              self.trigger('unselect', {
                originalEvent: evt,
                data: data
              });
            } else {
              self.trigger('close');
            }

            return;
          }

          self.trigger('select', {
            originalEvent: evt,
            data: data
          });
        });
        this.$results.on('mouseenter', '.select2-results__option[aria-selected]', function (evt) {
          var data = $(this).data('data');
          self.getHighlightedResults().removeClass('select2-results__option--highlighted');
          self.trigger('results:focus', {
            data: data,
            element: $(this)
          });
        });
      };

      Results.prototype.getHighlightedResults = function () {
        var $highlighted = this.$results.find('.select2-results__option--highlighted');
        return $highlighted;
      };

      Results.prototype.destroy = function () {
        this.$results.remove();
      };

      Results.prototype.ensureHighlightVisible = function () {
        var $highlighted = this.getHighlightedResults();

        if ($highlighted.length === 0) {
          return;
        }

        var $options = this.$results.find('[aria-selected]');
        var currentIndex = $options.index($highlighted);
        var currentOffset = this.$results.offset().top;
        var nextTop = $highlighted.offset().top;
        var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
        var offsetDelta = nextTop - currentOffset;
        nextOffset -= $highlighted.outerHeight(false) * 2;

        if (currentIndex <= 2) {
          this.$results.scrollTop(0);
        } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
          this.$results.scrollTop(nextOffset);
        }
      };

      Results.prototype.template = function (result, container) {
        var template = this.options.get('templateResult');
        var escapeMarkup = this.options.get('escapeMarkup');
        var content = template(result);

        if (content == null) {
          container.style.display = 'none';
        } else if (typeof content === 'string') {
          container.innerHTML = escapeMarkup(content);
        } else {
          $(container).append(content);
        }
      };

      return Results;
    });
    S2.define('select2/keys', [], function () {
      var KEYS = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46
      };
      return KEYS;
    });
    S2.define('select2/selection/base', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
      function BaseSelection($element, options) {
        this.$element = $element;
        this.options = options;

        BaseSelection.__super__.constructor.call(this);
      }

      Utils.Extend(BaseSelection, Utils.Observable);

      BaseSelection.prototype.render = function () {
        var $selection = $('<span class="select2-selection" role="combobox" ' + 'aria-autocomplete="list" aria-haspopup="true" aria-expanded="false">' + '</span>');
        this._tabindex = 0;

        if (this.$element.data('old-tabindex') != null) {
          this._tabindex = this.$element.data('old-tabindex');
        } else if (this.$element.attr('tabindex') != null) {
          this._tabindex = this.$element.attr('tabindex');
        }

        $selection.attr('title', this.$element.attr('title'));
        $selection.attr('tabindex', this._tabindex);
        this.$selection = $selection;
        return $selection;
      };

      BaseSelection.prototype.bind = function (container, $container) {
        var self = this;
        var id = container.id + '-container';
        var resultsId = container.id + '-results';
        this.container = container;
        this.$selection.on('focus', function (evt) {
          self.trigger('focus', evt);
        });
        this.$selection.on('blur', function (evt) {
          self.trigger('blur', evt);
        });
        this.$selection.on('keydown', function (evt) {
          self.trigger('keypress', evt);

          if (evt.which === KEYS.SPACE) {
            evt.preventDefault();
          }
        });
        container.on('results:focus', function (params) {
          self.$selection.attr('aria-activedescendant', params.data._resultId);
        });
        container.on('selection:update', function (params) {
          self.update(params.data);
        });
        container.on('open', function () {
          // When the dropdown is open, aria-expanded="true"
          self.$selection.attr('aria-expanded', 'true');
          self.$selection.attr('aria-owns', resultsId);

          self._attachCloseHandler(container);
        });
        container.on('close', function () {
          // When the dropdown is closed, aria-expanded="false"
          self.$selection.attr('aria-expanded', 'false');
          self.$selection.removeAttr('aria-activedescendant');
          self.$selection.removeAttr('aria-owns');
          self.$selection.focus();

          self._detachCloseHandler(container);
        });
        container.on('enable', function () {
          self.$selection.attr('tabindex', self._tabindex);
        });
        container.on('disable', function () {
          self.$selection.attr('tabindex', '-1');
        });
      };

      BaseSelection.prototype._attachCloseHandler = function (container) {
        var self = this;
        $(document.body).on('mousedown.select2.' + container.id, function (e) {
          var $target = $(e.target);
          var $select = $target.closest('.select2');
          var $all = $('.select2.select2-container--open');
          $all.each(function () {
            var $this = $(this);

            if (this == $select[0]) {
              return;
            }

            var $element = $this.data('element');
            $element.select2('close');
          });
        });
      };

      BaseSelection.prototype._detachCloseHandler = function (container) {
        $(document.body).off('mousedown.select2.' + container.id);
      };

      BaseSelection.prototype.position = function ($selection, $container) {
        var $selectionContainer = $container.find('.selection');
        $selectionContainer.append($selection);
      };

      BaseSelection.prototype.destroy = function () {
        this._detachCloseHandler(this.container);
      };

      BaseSelection.prototype.update = function (data) {
        throw new Error('The `update` method must be defined in child classes.');
      };

      return BaseSelection;
    });
    S2.define('select2/selection/single', ['jquery', './base', '../utils', '../keys'], function ($, BaseSelection, Utils, KEYS) {
      function SingleSelection() {
        SingleSelection.__super__.constructor.apply(this, arguments);
      }

      Utils.Extend(SingleSelection, BaseSelection);

      SingleSelection.prototype.render = function () {
        var $selection = SingleSelection.__super__.render.call(this);

        $selection.addClass('select2-selection--single');
        $selection.html('<span class="select2-selection__rendered"></span>' + '<span class="select2-selection__arrow" role="presentation">' + '<b role="presentation"></b>' + '</span>');
        return $selection;
      };

      SingleSelection.prototype.bind = function (container, $container) {
        var self = this;

        SingleSelection.__super__.bind.apply(this, arguments);

        var id = container.id + '-container';
        this.$selection.find('.select2-selection__rendered').attr('id', id);
        this.$selection.attr('aria-labelledby', id);
        this.$selection.on('mousedown', function (evt) {
          // Only respond to left clicks
          if (evt.which !== 1) {
            return;
          }

          self.trigger('toggle', {
            originalEvent: evt
          });
        });
        this.$selection.on('focus', function (evt) {// User focuses on the container
        });
        this.$selection.on('blur', function (evt) {// User exits the container
        });
        container.on('selection:update', function (params) {
          self.update(params.data);
        });
      };

      SingleSelection.prototype.clear = function () {
        this.$selection.find('.select2-selection__rendered').empty();
      };

      SingleSelection.prototype.display = function (data) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
        return escapeMarkup(template(data));
      };

      SingleSelection.prototype.selectionContainer = function () {
        return $('<span></span>');
      };

      SingleSelection.prototype.update = function (data) {
        if (data.length === 0) {
          this.clear();
          return;
        }

        var selection = data[0];
        var formatted = this.display(selection);
        var $rendered = this.$selection.find('.select2-selection__rendered');
        $rendered.empty().append(formatted);
        $rendered.prop('title', selection.title || selection.text);
      };

      return SingleSelection;
    });
    S2.define('select2/selection/multiple', ['jquery', './base', '../utils'], function ($, BaseSelection, Utils) {
      function MultipleSelection($element, options) {
        MultipleSelection.__super__.constructor.apply(this, arguments);
      }

      Utils.Extend(MultipleSelection, BaseSelection);

      MultipleSelection.prototype.render = function () {
        var $selection = MultipleSelection.__super__.render.call(this);

        $selection.addClass('select2-selection--multiple');
        $selection.html('<ul class="select2-selection__rendered"></ul>');
        return $selection;
      };

      MultipleSelection.prototype.bind = function (container, $container) {
        var self = this;

        MultipleSelection.__super__.bind.apply(this, arguments);

        this.$selection.on('click', function (evt) {
          self.trigger('toggle', {
            originalEvent: evt
          });
        });
        this.$selection.on('click', '.select2-selection__choice__remove', function (evt) {
          var $remove = $(this);
          var $selection = $remove.parent();
          var data = $selection.data('data');
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        });
      };

      MultipleSelection.prototype.clear = function () {
        this.$selection.find('.select2-selection__rendered').empty();
      };

      MultipleSelection.prototype.display = function (data) {
        var template = this.options.get('templateSelection');
        var escapeMarkup = this.options.get('escapeMarkup');
        return escapeMarkup(template(data));
      };

      MultipleSelection.prototype.selectionContainer = function () {
        var $container = $('<li class="select2-selection__choice">' + '<span class="select2-selection__choice__remove" role="presentation">' + '&times;' + '</span>' + '</li>');
        return $container;
      };

      MultipleSelection.prototype.update = function (data) {
        this.clear();

        if (data.length === 0) {
          return;
        }

        var $selections = [];

        for (var d = 0; d < data.length; d++) {
          var selection = data[d];
          var formatted = this.display(selection);
          var $selection = this.selectionContainer();
          $selection.append(formatted);
          $selection.prop('title', selection.title || selection.text);
          $selection.data('data', selection);
          $selections.push($selection);
        }

        var $rendered = this.$selection.find('.select2-selection__rendered');
        Utils.appendMany($rendered, $selections);
      };

      return MultipleSelection;
    });
    S2.define('select2/selection/placeholder', ['../utils'], function (Utils) {
      function Placeholder(decorated, $element, options) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
        decorated.call(this, $element, options);
      }

      Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }

        return placeholder;
      };

      Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
        var $placeholder = this.selectionContainer();
        $placeholder.html(this.display(placeholder));
        $placeholder.addClass('select2-selection__placeholder').removeClass('select2-selection__choice');
        return $placeholder;
      };

      Placeholder.prototype.update = function (decorated, data) {
        var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
        var multipleSelections = data.length > 1;

        if (multipleSelections || singlePlaceholder) {
          return decorated.call(this, data);
        }

        this.clear();
        var $placeholder = this.createPlaceholder(this.placeholder);
        this.$selection.find('.select2-selection__rendered').append($placeholder);
      };

      return Placeholder;
    });
    S2.define('select2/selection/allowClear', ['jquery', '../keys'], function ($, KEYS) {
      function AllowClear() {}

      AllowClear.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);

        if (this.placeholder == null) {
          if (this.options.get('debug') && window.console && console.error) {
            console.error('Select2: The `allowClear` option should be used in combination ' + 'with the `placeholder` option.');
          }
        }

        this.$selection.on('mousedown', '.select2-selection__clear', function (evt) {
          self._handleClear(evt);
        });
        container.on('keypress', function (evt) {
          self._handleKeyboardClear(evt, container);
        });
      };

      AllowClear.prototype._handleClear = function (_, evt) {
        // Ignore the event if it is disabled
        if (this.options.get('disabled')) {
          return;
        }

        var $clear = this.$selection.find('.select2-selection__clear'); // Ignore the event if nothing has been selected

        if ($clear.length === 0) {
          return;
        }

        evt.stopPropagation();
        var data = $clear.data('data');

        for (var d = 0; d < data.length; d++) {
          var unselectData = {
            data: data[d]
          }; // Trigger the `unselect` event, so people can prevent it from being
          // cleared.

          this.trigger('unselect', unselectData); // If the event was prevented, don't clear it out.

          if (unselectData.prevented) {
            return;
          }
        }

        this.$element.val(this.placeholder.id).trigger('change');
        this.trigger('toggle');
      };

      AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
        if (container.isOpen()) {
          return;
        }

        if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
          this._handleClear(evt);
        }
      };

      AllowClear.prototype.update = function (decorated, data) {
        decorated.call(this, data);

        if (this.$selection.find('.select2-selection__placeholder').length > 0 || data.length === 0) {
          return;
        }

        var $remove = $('<span class="select2-selection__clear">' + '&times;' + '</span>');
        $remove.data('data', data);
        this.$selection.find('.select2-selection__rendered').prepend($remove);
      };

      return AllowClear;
    });
    S2.define('select2/selection/search', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
      function Search(decorated, $element, options) {
        decorated.call(this, $element, options);
      }

      Search.prototype.render = function (decorated) {
        var $search = $('<li class="select2-search select2-search--inline">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="off"' + ' spellcheck="false" role="textbox" />' + '</li>');
        this.$searchContainer = $search;
        this.$search = $search.find('input');
        var $rendered = decorated.call(this);
        return $rendered;
      };

      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('open', function () {
          self.$search.attr('tabindex', 0);
          self.$search.focus();
        });
        container.on('close', function () {
          self.$search.attr('tabindex', -1);
          self.$search.val('');
          self.$search.focus();
        });
        container.on('enable', function () {
          self.$search.prop('disabled', false);
        });
        container.on('disable', function () {
          self.$search.prop('disabled', true);
        });
        this.$selection.on('focusin', '.select2-search--inline', function (evt) {
          self.trigger('focus', evt);
        });
        this.$selection.on('focusout', '.select2-search--inline', function (evt) {
          self.trigger('blur', evt);
        });
        this.$selection.on('keydown', '.select2-search--inline', function (evt) {
          evt.stopPropagation();
          self.trigger('keypress', evt);
          self._keyUpPrevented = evt.isDefaultPrevented();
          var key = evt.which;

          if (key === KEYS.BACKSPACE && self.$search.val() === '') {
            var $previousChoice = self.$searchContainer.prev('.select2-selection__choice');

            if ($previousChoice.length > 0) {
              var item = $previousChoice.data('data');
              self.searchRemoveChoice(item);
              evt.preventDefault();
            }
          }
        }); // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.

        this.$selection.on('input', '.select2-search--inline', function (evt) {
          // Unbind the duplicated `keyup` event
          self.$selection.off('keyup.search');
        });
        this.$selection.on('keyup.search input', '.select2-search--inline', function (evt) {
          self.handleSearch(evt);
        });
      };

      Search.prototype.createPlaceholder = function (decorated, placeholder) {
        this.$search.attr('placeholder', placeholder.text);
      };

      Search.prototype.update = function (decorated, data) {
        this.$search.attr('placeholder', '');
        decorated.call(this, data);
        this.$selection.find('.select2-selection__rendered').append(this.$searchContainer);
        this.resizeSearch();
      };

      Search.prototype.handleSearch = function () {
        this.resizeSearch();

        if (!this._keyUpPrevented) {
          var input = this.$search.val();
          this.trigger('query', {
            term: input
          });
        }

        this._keyUpPrevented = false;
      };

      Search.prototype.searchRemoveChoice = function (decorated, item) {
        this.trigger('unselect', {
          data: item
        });
        this.trigger('open');
        this.$search.val(item.text + ' ');
      };

      Search.prototype.resizeSearch = function () {
        this.$search.css('width', '25px');
        var width = '';

        if (this.$search.attr('placeholder') !== '') {
          width = this.$selection.find('.select2-selection__rendered').innerWidth();
        } else {
          var minimumWidth = this.$search.val().length + 1;
          width = minimumWidth * 0.75 + 'em';
        }

        this.$search.css('width', width);
      };

      return Search;
    });
    S2.define('select2/selection/eventRelay', ['jquery'], function ($) {
      function EventRelay() {}

      EventRelay.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var relayEvents = ['open', 'opening', 'close', 'closing', 'select', 'selecting', 'unselect', 'unselecting'];
        var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];
        decorated.call(this, container, $container);
        container.on('*', function (name, params) {
          // Ignore events that should not be relayed
          if ($.inArray(name, relayEvents) === -1) {
            return;
          } // The parameters should always be an object


          params = params || {}; // Generate the jQuery event for the Select2 event

          var evt = $.Event('select2:' + name, {
            params: params
          });
          self.$element.trigger(evt); // Only handle preventable events if it was one

          if ($.inArray(name, preventableEvents) === -1) {
            return;
          }

          params.prevented = evt.isDefaultPrevented();
        });
      };

      return EventRelay;
    });
    S2.define('select2/translation', ['jquery', 'require'], function ($, require) {
      function Translation(dict) {
        this.dict = dict || {};
      }

      Translation.prototype.all = function () {
        return this.dict;
      };

      Translation.prototype.get = function (key) {
        return this.dict[key];
      };

      Translation.prototype.extend = function (translation) {
        this.dict = $.extend({}, translation.all(), this.dict);
      }; // Static functions


      Translation._cache = {};

      Translation.loadPath = function (path) {
        if (!(path in Translation._cache)) {
          var translations = require(path);

          Translation._cache[path] = translations;
        }

        return new Translation(Translation._cache[path]);
      };

      return Translation;
    });
    S2.define('select2/diacritics', [], function () {
      var diacritics = {
        '\u24B6': 'A',
        '\uFF21': 'A',
        '\u00C0': 'A',
        '\u00C1': 'A',
        '\u00C2': 'A',
        '\u1EA6': 'A',
        '\u1EA4': 'A',
        '\u1EAA': 'A',
        '\u1EA8': 'A',
        '\u00C3': 'A',
        '\u0100': 'A',
        '\u0102': 'A',
        '\u1EB0': 'A',
        '\u1EAE': 'A',
        '\u1EB4': 'A',
        '\u1EB2': 'A',
        '\u0226': 'A',
        '\u01E0': 'A',
        '\u00C4': 'A',
        '\u01DE': 'A',
        '\u1EA2': 'A',
        '\u00C5': 'A',
        '\u01FA': 'A',
        '\u01CD': 'A',
        '\u0200': 'A',
        '\u0202': 'A',
        '\u1EA0': 'A',
        '\u1EAC': 'A',
        '\u1EB6': 'A',
        '\u1E00': 'A',
        '\u0104': 'A',
        '\u023A': 'A',
        '\u2C6F': 'A',
        '\uA732': 'AA',
        '\u00C6': 'AE',
        '\u01FC': 'AE',
        '\u01E2': 'AE',
        '\uA734': 'AO',
        '\uA736': 'AU',
        '\uA738': 'AV',
        '\uA73A': 'AV',
        '\uA73C': 'AY',
        '\u24B7': 'B',
        '\uFF22': 'B',
        '\u1E02': 'B',
        '\u1E04': 'B',
        '\u1E06': 'B',
        '\u0243': 'B',
        '\u0182': 'B',
        '\u0181': 'B',
        '\u24B8': 'C',
        '\uFF23': 'C',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010A': 'C',
        '\u010C': 'C',
        '\u00C7': 'C',
        '\u1E08': 'C',
        '\u0187': 'C',
        '\u023B': 'C',
        '\uA73E': 'C',
        '\u24B9': 'D',
        '\uFF24': 'D',
        '\u1E0A': 'D',
        '\u010E': 'D',
        '\u1E0C': 'D',
        '\u1E10': 'D',
        '\u1E12': 'D',
        '\u1E0E': 'D',
        '\u0110': 'D',
        '\u018B': 'D',
        '\u018A': 'D',
        '\u0189': 'D',
        '\uA779': 'D',
        '\u01F1': 'DZ',
        '\u01C4': 'DZ',
        '\u01F2': 'Dz',
        '\u01C5': 'Dz',
        '\u24BA': 'E',
        '\uFF25': 'E',
        '\u00C8': 'E',
        '\u00C9': 'E',
        '\u00CA': 'E',
        '\u1EC0': 'E',
        '\u1EBE': 'E',
        '\u1EC4': 'E',
        '\u1EC2': 'E',
        '\u1EBC': 'E',
        '\u0112': 'E',
        '\u1E14': 'E',
        '\u1E16': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u00CB': 'E',
        '\u1EBA': 'E',
        '\u011A': 'E',
        '\u0204': 'E',
        '\u0206': 'E',
        '\u1EB8': 'E',
        '\u1EC6': 'E',
        '\u0228': 'E',
        '\u1E1C': 'E',
        '\u0118': 'E',
        '\u1E18': 'E',
        '\u1E1A': 'E',
        '\u0190': 'E',
        '\u018E': 'E',
        '\u24BB': 'F',
        '\uFF26': 'F',
        '\u1E1E': 'F',
        '\u0191': 'F',
        '\uA77B': 'F',
        '\u24BC': 'G',
        '\uFF27': 'G',
        '\u01F4': 'G',
        '\u011C': 'G',
        '\u1E20': 'G',
        '\u011E': 'G',
        '\u0120': 'G',
        '\u01E6': 'G',
        '\u0122': 'G',
        '\u01E4': 'G',
        '\u0193': 'G',
        '\uA7A0': 'G',
        '\uA77D': 'G',
        '\uA77E': 'G',
        '\u24BD': 'H',
        '\uFF28': 'H',
        '\u0124': 'H',
        '\u1E22': 'H',
        '\u1E26': 'H',
        '\u021E': 'H',
        '\u1E24': 'H',
        '\u1E28': 'H',
        '\u1E2A': 'H',
        '\u0126': 'H',
        '\u2C67': 'H',
        '\u2C75': 'H',
        '\uA78D': 'H',
        '\u24BE': 'I',
        '\uFF29': 'I',
        '\u00CC': 'I',
        '\u00CD': 'I',
        '\u00CE': 'I',
        '\u0128': 'I',
        '\u012A': 'I',
        '\u012C': 'I',
        '\u0130': 'I',
        '\u00CF': 'I',
        '\u1E2E': 'I',
        '\u1EC8': 'I',
        '\u01CF': 'I',
        '\u0208': 'I',
        '\u020A': 'I',
        '\u1ECA': 'I',
        '\u012E': 'I',
        '\u1E2C': 'I',
        '\u0197': 'I',
        '\u24BF': 'J',
        '\uFF2A': 'J',
        '\u0134': 'J',
        '\u0248': 'J',
        '\u24C0': 'K',
        '\uFF2B': 'K',
        '\u1E30': 'K',
        '\u01E8': 'K',
        '\u1E32': 'K',
        '\u0136': 'K',
        '\u1E34': 'K',
        '\u0198': 'K',
        '\u2C69': 'K',
        '\uA740': 'K',
        '\uA742': 'K',
        '\uA744': 'K',
        '\uA7A2': 'K',
        '\u24C1': 'L',
        '\uFF2C': 'L',
        '\u013F': 'L',
        '\u0139': 'L',
        '\u013D': 'L',
        '\u1E36': 'L',
        '\u1E38': 'L',
        '\u013B': 'L',
        '\u1E3C': 'L',
        '\u1E3A': 'L',
        '\u0141': 'L',
        '\u023D': 'L',
        '\u2C62': 'L',
        '\u2C60': 'L',
        '\uA748': 'L',
        '\uA746': 'L',
        '\uA780': 'L',
        '\u01C7': 'LJ',
        '\u01C8': 'Lj',
        '\u24C2': 'M',
        '\uFF2D': 'M',
        '\u1E3E': 'M',
        '\u1E40': 'M',
        '\u1E42': 'M',
        '\u2C6E': 'M',
        '\u019C': 'M',
        '\u24C3': 'N',
        '\uFF2E': 'N',
        '\u01F8': 'N',
        '\u0143': 'N',
        '\u00D1': 'N',
        '\u1E44': 'N',
        '\u0147': 'N',
        '\u1E46': 'N',
        '\u0145': 'N',
        '\u1E4A': 'N',
        '\u1E48': 'N',
        '\u0220': 'N',
        '\u019D': 'N',
        '\uA790': 'N',
        '\uA7A4': 'N',
        '\u01CA': 'NJ',
        '\u01CB': 'Nj',
        '\u24C4': 'O',
        '\uFF2F': 'O',
        '\u00D2': 'O',
        '\u00D3': 'O',
        '\u00D4': 'O',
        '\u1ED2': 'O',
        '\u1ED0': 'O',
        '\u1ED6': 'O',
        '\u1ED4': 'O',
        '\u00D5': 'O',
        '\u1E4C': 'O',
        '\u022C': 'O',
        '\u1E4E': 'O',
        '\u014C': 'O',
        '\u1E50': 'O',
        '\u1E52': 'O',
        '\u014E': 'O',
        '\u022E': 'O',
        '\u0230': 'O',
        '\u00D6': 'O',
        '\u022A': 'O',
        '\u1ECE': 'O',
        '\u0150': 'O',
        '\u01D1': 'O',
        '\u020C': 'O',
        '\u020E': 'O',
        '\u01A0': 'O',
        '\u1EDC': 'O',
        '\u1EDA': 'O',
        '\u1EE0': 'O',
        '\u1EDE': 'O',
        '\u1EE2': 'O',
        '\u1ECC': 'O',
        '\u1ED8': 'O',
        '\u01EA': 'O',
        '\u01EC': 'O',
        '\u00D8': 'O',
        '\u01FE': 'O',
        '\u0186': 'O',
        '\u019F': 'O',
        '\uA74A': 'O',
        '\uA74C': 'O',
        '\u01A2': 'OI',
        '\uA74E': 'OO',
        '\u0222': 'OU',
        '\u24C5': 'P',
        '\uFF30': 'P',
        '\u1E54': 'P',
        '\u1E56': 'P',
        '\u01A4': 'P',
        '\u2C63': 'P',
        '\uA750': 'P',
        '\uA752': 'P',
        '\uA754': 'P',
        '\u24C6': 'Q',
        '\uFF31': 'Q',
        '\uA756': 'Q',
        '\uA758': 'Q',
        '\u024A': 'Q',
        '\u24C7': 'R',
        '\uFF32': 'R',
        '\u0154': 'R',
        '\u1E58': 'R',
        '\u0158': 'R',
        '\u0210': 'R',
        '\u0212': 'R',
        '\u1E5A': 'R',
        '\u1E5C': 'R',
        '\u0156': 'R',
        '\u1E5E': 'R',
        '\u024C': 'R',
        '\u2C64': 'R',
        '\uA75A': 'R',
        '\uA7A6': 'R',
        '\uA782': 'R',
        '\u24C8': 'S',
        '\uFF33': 'S',
        '\u1E9E': 'S',
        '\u015A': 'S',
        '\u1E64': 'S',
        '\u015C': 'S',
        '\u1E60': 'S',
        '\u0160': 'S',
        '\u1E66': 'S',
        '\u1E62': 'S',
        '\u1E68': 'S',
        '\u0218': 'S',
        '\u015E': 'S',
        '\u2C7E': 'S',
        '\uA7A8': 'S',
        '\uA784': 'S',
        '\u24C9': 'T',
        '\uFF34': 'T',
        '\u1E6A': 'T',
        '\u0164': 'T',
        '\u1E6C': 'T',
        '\u021A': 'T',
        '\u0162': 'T',
        '\u1E70': 'T',
        '\u1E6E': 'T',
        '\u0166': 'T',
        '\u01AC': 'T',
        '\u01AE': 'T',
        '\u023E': 'T',
        '\uA786': 'T',
        '\uA728': 'TZ',
        '\u24CA': 'U',
        '\uFF35': 'U',
        '\u00D9': 'U',
        '\u00DA': 'U',
        '\u00DB': 'U',
        '\u0168': 'U',
        '\u1E78': 'U',
        '\u016A': 'U',
        '\u1E7A': 'U',
        '\u016C': 'U',
        '\u00DC': 'U',
        '\u01DB': 'U',
        '\u01D7': 'U',
        '\u01D5': 'U',
        '\u01D9': 'U',
        '\u1EE6': 'U',
        '\u016E': 'U',
        '\u0170': 'U',
        '\u01D3': 'U',
        '\u0214': 'U',
        '\u0216': 'U',
        '\u01AF': 'U',
        '\u1EEA': 'U',
        '\u1EE8': 'U',
        '\u1EEE': 'U',
        '\u1EEC': 'U',
        '\u1EF0': 'U',
        '\u1EE4': 'U',
        '\u1E72': 'U',
        '\u0172': 'U',
        '\u1E76': 'U',
        '\u1E74': 'U',
        '\u0244': 'U',
        '\u24CB': 'V',
        '\uFF36': 'V',
        '\u1E7C': 'V',
        '\u1E7E': 'V',
        '\u01B2': 'V',
        '\uA75E': 'V',
        '\u0245': 'V',
        '\uA760': 'VY',
        '\u24CC': 'W',
        '\uFF37': 'W',
        '\u1E80': 'W',
        '\u1E82': 'W',
        '\u0174': 'W',
        '\u1E86': 'W',
        '\u1E84': 'W',
        '\u1E88': 'W',
        '\u2C72': 'W',
        '\u24CD': 'X',
        '\uFF38': 'X',
        '\u1E8A': 'X',
        '\u1E8C': 'X',
        '\u24CE': 'Y',
        '\uFF39': 'Y',
        '\u1EF2': 'Y',
        '\u00DD': 'Y',
        '\u0176': 'Y',
        '\u1EF8': 'Y',
        '\u0232': 'Y',
        '\u1E8E': 'Y',
        '\u0178': 'Y',
        '\u1EF6': 'Y',
        '\u1EF4': 'Y',
        '\u01B3': 'Y',
        '\u024E': 'Y',
        '\u1EFE': 'Y',
        '\u24CF': 'Z',
        '\uFF3A': 'Z',
        '\u0179': 'Z',
        '\u1E90': 'Z',
        '\u017B': 'Z',
        '\u017D': 'Z',
        '\u1E92': 'Z',
        '\u1E94': 'Z',
        '\u01B5': 'Z',
        '\u0224': 'Z',
        '\u2C7F': 'Z',
        '\u2C6B': 'Z',
        '\uA762': 'Z',
        '\u24D0': 'a',
        '\uFF41': 'a',
        '\u1E9A': 'a',
        '\u00E0': 'a',
        '\u00E1': 'a',
        '\u00E2': 'a',
        '\u1EA7': 'a',
        '\u1EA5': 'a',
        '\u1EAB': 'a',
        '\u1EA9': 'a',
        '\u00E3': 'a',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u1EB1': 'a',
        '\u1EAF': 'a',
        '\u1EB5': 'a',
        '\u1EB3': 'a',
        '\u0227': 'a',
        '\u01E1': 'a',
        '\u00E4': 'a',
        '\u01DF': 'a',
        '\u1EA3': 'a',
        '\u00E5': 'a',
        '\u01FB': 'a',
        '\u01CE': 'a',
        '\u0201': 'a',
        '\u0203': 'a',
        '\u1EA1': 'a',
        '\u1EAD': 'a',
        '\u1EB7': 'a',
        '\u1E01': 'a',
        '\u0105': 'a',
        '\u2C65': 'a',
        '\u0250': 'a',
        '\uA733': 'aa',
        '\u00E6': 'ae',
        '\u01FD': 'ae',
        '\u01E3': 'ae',
        '\uA735': 'ao',
        '\uA737': 'au',
        '\uA739': 'av',
        '\uA73B': 'av',
        '\uA73D': 'ay',
        '\u24D1': 'b',
        '\uFF42': 'b',
        '\u1E03': 'b',
        '\u1E05': 'b',
        '\u1E07': 'b',
        '\u0180': 'b',
        '\u0183': 'b',
        '\u0253': 'b',
        '\u24D2': 'c',
        '\uFF43': 'c',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010B': 'c',
        '\u010D': 'c',
        '\u00E7': 'c',
        '\u1E09': 'c',
        '\u0188': 'c',
        '\u023C': 'c',
        '\uA73F': 'c',
        '\u2184': 'c',
        '\u24D3': 'd',
        '\uFF44': 'd',
        '\u1E0B': 'd',
        '\u010F': 'd',
        '\u1E0D': 'd',
        '\u1E11': 'd',
        '\u1E13': 'd',
        '\u1E0F': 'd',
        '\u0111': 'd',
        '\u018C': 'd',
        '\u0256': 'd',
        '\u0257': 'd',
        '\uA77A': 'd',
        '\u01F3': 'dz',
        '\u01C6': 'dz',
        '\u24D4': 'e',
        '\uFF45': 'e',
        '\u00E8': 'e',
        '\u00E9': 'e',
        '\u00EA': 'e',
        '\u1EC1': 'e',
        '\u1EBF': 'e',
        '\u1EC5': 'e',
        '\u1EC3': 'e',
        '\u1EBD': 'e',
        '\u0113': 'e',
        '\u1E15': 'e',
        '\u1E17': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u00EB': 'e',
        '\u1EBB': 'e',
        '\u011B': 'e',
        '\u0205': 'e',
        '\u0207': 'e',
        '\u1EB9': 'e',
        '\u1EC7': 'e',
        '\u0229': 'e',
        '\u1E1D': 'e',
        '\u0119': 'e',
        '\u1E19': 'e',
        '\u1E1B': 'e',
        '\u0247': 'e',
        '\u025B': 'e',
        '\u01DD': 'e',
        '\u24D5': 'f',
        '\uFF46': 'f',
        '\u1E1F': 'f',
        '\u0192': 'f',
        '\uA77C': 'f',
        '\u24D6': 'g',
        '\uFF47': 'g',
        '\u01F5': 'g',
        '\u011D': 'g',
        '\u1E21': 'g',
        '\u011F': 'g',
        '\u0121': 'g',
        '\u01E7': 'g',
        '\u0123': 'g',
        '\u01E5': 'g',
        '\u0260': 'g',
        '\uA7A1': 'g',
        '\u1D79': 'g',
        '\uA77F': 'g',
        '\u24D7': 'h',
        '\uFF48': 'h',
        '\u0125': 'h',
        '\u1E23': 'h',
        '\u1E27': 'h',
        '\u021F': 'h',
        '\u1E25': 'h',
        '\u1E29': 'h',
        '\u1E2B': 'h',
        '\u1E96': 'h',
        '\u0127': 'h',
        '\u2C68': 'h',
        '\u2C76': 'h',
        '\u0265': 'h',
        '\u0195': 'hv',
        '\u24D8': 'i',
        '\uFF49': 'i',
        '\u00EC': 'i',
        '\u00ED': 'i',
        '\u00EE': 'i',
        '\u0129': 'i',
        '\u012B': 'i',
        '\u012D': 'i',
        '\u00EF': 'i',
        '\u1E2F': 'i',
        '\u1EC9': 'i',
        '\u01D0': 'i',
        '\u0209': 'i',
        '\u020B': 'i',
        '\u1ECB': 'i',
        '\u012F': 'i',
        '\u1E2D': 'i',
        '\u0268': 'i',
        '\u0131': 'i',
        '\u24D9': 'j',
        '\uFF4A': 'j',
        '\u0135': 'j',
        '\u01F0': 'j',
        '\u0249': 'j',
        '\u24DA': 'k',
        '\uFF4B': 'k',
        '\u1E31': 'k',
        '\u01E9': 'k',
        '\u1E33': 'k',
        '\u0137': 'k',
        '\u1E35': 'k',
        '\u0199': 'k',
        '\u2C6A': 'k',
        '\uA741': 'k',
        '\uA743': 'k',
        '\uA745': 'k',
        '\uA7A3': 'k',
        '\u24DB': 'l',
        '\uFF4C': 'l',
        '\u0140': 'l',
        '\u013A': 'l',
        '\u013E': 'l',
        '\u1E37': 'l',
        '\u1E39': 'l',
        '\u013C': 'l',
        '\u1E3D': 'l',
        '\u1E3B': 'l',
        '\u017F': 'l',
        '\u0142': 'l',
        '\u019A': 'l',
        '\u026B': 'l',
        '\u2C61': 'l',
        '\uA749': 'l',
        '\uA781': 'l',
        '\uA747': 'l',
        '\u01C9': 'lj',
        '\u24DC': 'm',
        '\uFF4D': 'm',
        '\u1E3F': 'm',
        '\u1E41': 'm',
        '\u1E43': 'm',
        '\u0271': 'm',
        '\u026F': 'm',
        '\u24DD': 'n',
        '\uFF4E': 'n',
        '\u01F9': 'n',
        '\u0144': 'n',
        '\u00F1': 'n',
        '\u1E45': 'n',
        '\u0148': 'n',
        '\u1E47': 'n',
        '\u0146': 'n',
        '\u1E4B': 'n',
        '\u1E49': 'n',
        '\u019E': 'n',
        '\u0272': 'n',
        '\u0149': 'n',
        '\uA791': 'n',
        '\uA7A5': 'n',
        '\u01CC': 'nj',
        '\u24DE': 'o',
        '\uFF4F': 'o',
        '\u00F2': 'o',
        '\u00F3': 'o',
        '\u00F4': 'o',
        '\u1ED3': 'o',
        '\u1ED1': 'o',
        '\u1ED7': 'o',
        '\u1ED5': 'o',
        '\u00F5': 'o',
        '\u1E4D': 'o',
        '\u022D': 'o',
        '\u1E4F': 'o',
        '\u014D': 'o',
        '\u1E51': 'o',
        '\u1E53': 'o',
        '\u014F': 'o',
        '\u022F': 'o',
        '\u0231': 'o',
        '\u00F6': 'o',
        '\u022B': 'o',
        '\u1ECF': 'o',
        '\u0151': 'o',
        '\u01D2': 'o',
        '\u020D': 'o',
        '\u020F': 'o',
        '\u01A1': 'o',
        '\u1EDD': 'o',
        '\u1EDB': 'o',
        '\u1EE1': 'o',
        '\u1EDF': 'o',
        '\u1EE3': 'o',
        '\u1ECD': 'o',
        '\u1ED9': 'o',
        '\u01EB': 'o',
        '\u01ED': 'o',
        '\u00F8': 'o',
        '\u01FF': 'o',
        '\u0254': 'o',
        '\uA74B': 'o',
        '\uA74D': 'o',
        '\u0275': 'o',
        '\u01A3': 'oi',
        '\u0223': 'ou',
        '\uA74F': 'oo',
        '\u24DF': 'p',
        '\uFF50': 'p',
        '\u1E55': 'p',
        '\u1E57': 'p',
        '\u01A5': 'p',
        '\u1D7D': 'p',
        '\uA751': 'p',
        '\uA753': 'p',
        '\uA755': 'p',
        '\u24E0': 'q',
        '\uFF51': 'q',
        '\u024B': 'q',
        '\uA757': 'q',
        '\uA759': 'q',
        '\u24E1': 'r',
        '\uFF52': 'r',
        '\u0155': 'r',
        '\u1E59': 'r',
        '\u0159': 'r',
        '\u0211': 'r',
        '\u0213': 'r',
        '\u1E5B': 'r',
        '\u1E5D': 'r',
        '\u0157': 'r',
        '\u1E5F': 'r',
        '\u024D': 'r',
        '\u027D': 'r',
        '\uA75B': 'r',
        '\uA7A7': 'r',
        '\uA783': 'r',
        '\u24E2': 's',
        '\uFF53': 's',
        '\u00DF': 's',
        '\u015B': 's',
        '\u1E65': 's',
        '\u015D': 's',
        '\u1E61': 's',
        '\u0161': 's',
        '\u1E67': 's',
        '\u1E63': 's',
        '\u1E69': 's',
        '\u0219': 's',
        '\u015F': 's',
        '\u023F': 's',
        '\uA7A9': 's',
        '\uA785': 's',
        '\u1E9B': 's',
        '\u24E3': 't',
        '\uFF54': 't',
        '\u1E6B': 't',
        '\u1E97': 't',
        '\u0165': 't',
        '\u1E6D': 't',
        '\u021B': 't',
        '\u0163': 't',
        '\u1E71': 't',
        '\u1E6F': 't',
        '\u0167': 't',
        '\u01AD': 't',
        '\u0288': 't',
        '\u2C66': 't',
        '\uA787': 't',
        '\uA729': 'tz',
        '\u24E4': 'u',
        '\uFF55': 'u',
        '\u00F9': 'u',
        '\u00FA': 'u',
        '\u00FB': 'u',
        '\u0169': 'u',
        '\u1E79': 'u',
        '\u016B': 'u',
        '\u1E7B': 'u',
        '\u016D': 'u',
        '\u00FC': 'u',
        '\u01DC': 'u',
        '\u01D8': 'u',
        '\u01D6': 'u',
        '\u01DA': 'u',
        '\u1EE7': 'u',
        '\u016F': 'u',
        '\u0171': 'u',
        '\u01D4': 'u',
        '\u0215': 'u',
        '\u0217': 'u',
        '\u01B0': 'u',
        '\u1EEB': 'u',
        '\u1EE9': 'u',
        '\u1EEF': 'u',
        '\u1EED': 'u',
        '\u1EF1': 'u',
        '\u1EE5': 'u',
        '\u1E73': 'u',
        '\u0173': 'u',
        '\u1E77': 'u',
        '\u1E75': 'u',
        '\u0289': 'u',
        '\u24E5': 'v',
        '\uFF56': 'v',
        '\u1E7D': 'v',
        '\u1E7F': 'v',
        '\u028B': 'v',
        '\uA75F': 'v',
        '\u028C': 'v',
        '\uA761': 'vy',
        '\u24E6': 'w',
        '\uFF57': 'w',
        '\u1E81': 'w',
        '\u1E83': 'w',
        '\u0175': 'w',
        '\u1E87': 'w',
        '\u1E85': 'w',
        '\u1E98': 'w',
        '\u1E89': 'w',
        '\u2C73': 'w',
        '\u24E7': 'x',
        '\uFF58': 'x',
        '\u1E8B': 'x',
        '\u1E8D': 'x',
        '\u24E8': 'y',
        '\uFF59': 'y',
        '\u1EF3': 'y',
        '\u00FD': 'y',
        '\u0177': 'y',
        '\u1EF9': 'y',
        '\u0233': 'y',
        '\u1E8F': 'y',
        '\u00FF': 'y',
        '\u1EF7': 'y',
        '\u1E99': 'y',
        '\u1EF5': 'y',
        '\u01B4': 'y',
        '\u024F': 'y',
        '\u1EFF': 'y',
        '\u24E9': 'z',
        '\uFF5A': 'z',
        '\u017A': 'z',
        '\u1E91': 'z',
        '\u017C': 'z',
        '\u017E': 'z',
        '\u1E93': 'z',
        '\u1E95': 'z',
        '\u01B6': 'z',
        '\u0225': 'z',
        '\u0240': 'z',
        '\u2C6C': 'z',
        '\uA763': 'z',
        '\u0386': '\u0391',
        '\u0388': '\u0395',
        '\u0389': '\u0397',
        '\u038A': '\u0399',
        '\u03AA': '\u0399',
        '\u038C': '\u039F',
        '\u038E': '\u03A5',
        '\u03AB': '\u03A5',
        '\u038F': '\u03A9',
        '\u03AC': '\u03B1',
        '\u03AD': '\u03B5',
        '\u03AE': '\u03B7',
        '\u03AF': '\u03B9',
        '\u03CA': '\u03B9',
        '\u0390': '\u03B9',
        '\u03CC': '\u03BF',
        '\u03CD': '\u03C5',
        '\u03CB': '\u03C5',
        '\u03B0': '\u03C5',
        '\u03C9': '\u03C9',
        '\u03C2': '\u03C3'
      };
      return diacritics;
    });
    S2.define('select2/data/base', ['../utils'], function (Utils) {
      function BaseAdapter($element, options) {
        BaseAdapter.__super__.constructor.call(this);
      }

      Utils.Extend(BaseAdapter, Utils.Observable);

      BaseAdapter.prototype.current = function (callback) {
        throw new Error('The `current` method must be defined in child classes.');
      };

      BaseAdapter.prototype.query = function (params, callback) {
        throw new Error('The `query` method must be defined in child classes.');
      };

      BaseAdapter.prototype.bind = function (container, $container) {// Can be implemented in subclasses
      };

      BaseAdapter.prototype.destroy = function () {// Can be implemented in subclasses
      };

      BaseAdapter.prototype.generateResultId = function (container, data) {
        var id = container.id + '-result-';
        id += Utils.generateChars(4);

        if (data.id != null) {
          id += '-' + data.id.toString();
        } else {
          id += '-' + Utils.generateChars(4);
        }

        return id;
      };

      return BaseAdapter;
    });
    S2.define('select2/data/select', ['./base', '../utils', 'jquery'], function (BaseAdapter, Utils, $) {
      function SelectAdapter($element, options) {
        this.$element = $element;
        this.options = options;

        SelectAdapter.__super__.constructor.call(this);
      }

      Utils.Extend(SelectAdapter, BaseAdapter);

      SelectAdapter.prototype.current = function (callback) {
        var data = [];
        var self = this;
        this.$element.find(':selected').each(function () {
          var $option = $(this);
          var option = self.item($option);
          data.push(option);
        });
        callback(data);
      };

      SelectAdapter.prototype.select = function (data) {
        var self = this;
        data.selected = true; // If data.element is a DOM node, use it instead

        if ($(data.element).is('option')) {
          data.element.selected = true;
          this.$element.trigger('change');
          return;
        }

        if (this.$element.prop('multiple')) {
          this.current(function (currentData) {
            var val = [];
            data = [data];
            data.push.apply(data, currentData);

            for (var d = 0; d < data.length; d++) {
              var id = data[d].id;

              if ($.inArray(id, val) === -1) {
                val.push(id);
              }
            }

            self.$element.val(val);
            self.$element.trigger('change');
          });
        } else {
          var val = data.id;
          this.$element.val(val);
          this.$element.trigger('change');
        }
      };

      SelectAdapter.prototype.unselect = function (data) {
        var self = this;

        if (!this.$element.prop('multiple')) {
          return;
        }

        data.selected = false;

        if ($(data.element).is('option')) {
          data.element.selected = false;
          this.$element.trigger('change');
          return;
        }

        this.current(function (currentData) {
          var val = [];

          for (var d = 0; d < currentData.length; d++) {
            var id = currentData[d].id;

            if (id !== data.id && $.inArray(id, val) === -1) {
              val.push(id);
            }
          }

          self.$element.val(val);
          self.$element.trigger('change');
        });
      };

      SelectAdapter.prototype.bind = function (container, $container) {
        var self = this;
        this.container = container;
        container.on('select', function (params) {
          self.select(params.data);
        });
        container.on('unselect', function (params) {
          self.unselect(params.data);
        });
      };

      SelectAdapter.prototype.destroy = function () {
        // Remove anything added to child elements
        this.$element.find('*').each(function () {
          // Remove any custom data set by Select2
          $.removeData(this, 'data');
        });
      };

      SelectAdapter.prototype.query = function (params, callback) {
        var data = [];
        var self = this;
        var $options = this.$element.children();
        $options.each(function () {
          var $option = $(this);

          if (!$option.is('option') && !$option.is('optgroup')) {
            return;
          }

          var option = self.item($option);
          var matches = self.matches(params, option);

          if (matches !== null) {
            data.push(matches);
          }
        });
        callback({
          results: data
        });
      };

      SelectAdapter.prototype.addOptions = function ($options) {
        Utils.appendMany(this.$element, $options);
      };

      SelectAdapter.prototype.option = function (data) {
        var option;

        if (data.children) {
          option = document.createElement('optgroup');
          option.label = data.text;
        } else {
          option = document.createElement('option');

          if (option.textContent !== undefined) {
            option.textContent = data.text;
          } else {
            option.innerText = data.text;
          }
        }

        if (data.id) {
          option.value = data.id;
        }

        if (data.disabled) {
          option.disabled = true;
        }

        if (data.selected) {
          option.selected = true;
        }

        if (data.title) {
          option.title = data.title;
        }

        var $option = $(option);

        var normalizedData = this._normalizeItem(data);

        normalizedData.element = option; // Override the option's data with the combined data

        $.data(option, 'data', normalizedData);
        return $option;
      };

      SelectAdapter.prototype.item = function ($option) {
        var data = {};
        data = $.data($option[0], 'data');

        if (data != null) {
          return data;
        }

        if ($option.is('option')) {
          data = {
            id: $option.val(),
            text: $option.text(),
            disabled: $option.prop('disabled'),
            selected: $option.prop('selected'),
            title: $option.prop('title')
          };
        } else if ($option.is('optgroup')) {
          data = {
            text: $option.prop('label'),
            children: [],
            title: $option.prop('title')
          };
          var $children = $option.children('option');
          var children = [];

          for (var c = 0; c < $children.length; c++) {
            var $child = $($children[c]);
            var child = this.item($child);
            children.push(child);
          }

          data.children = children;
        }

        data = this._normalizeItem(data);
        data.element = $option[0];
        $.data($option[0], 'data', data);
        return data;
      };

      SelectAdapter.prototype._normalizeItem = function (item) {
        if (!$.isPlainObject(item)) {
          item = {
            id: item,
            text: item
          };
        }

        item = $.extend({}, {
          text: ''
        }, item);
        var defaults = {
          selected: false,
          disabled: false
        };

        if (item.id != null) {
          item.id = item.id.toString();
        }

        if (item.text != null) {
          item.text = item.text.toString();
        }

        if (item._resultId == null && item.id && this.container != null) {
          item._resultId = this.generateResultId(this.container, item);
        }

        return $.extend({}, defaults, item);
      };

      SelectAdapter.prototype.matches = function (params, data) {
        var matcher = this.options.get('matcher');
        return matcher(params, data);
      };

      return SelectAdapter;
    });
    S2.define('select2/data/array', ['./select', '../utils', 'jquery'], function (SelectAdapter, Utils, $) {
      function ArrayAdapter($element, options) {
        var data = options.get('data') || [];

        ArrayAdapter.__super__.constructor.call(this, $element, options);

        this.addOptions(this.convertToOptions(data));
      }

      Utils.Extend(ArrayAdapter, SelectAdapter);

      ArrayAdapter.prototype.select = function (data) {
        var $option = this.$element.find('option').filter(function (i, elm) {
          return elm.value == data.id.toString();
        });

        if ($option.length === 0) {
          $option = this.option(data);
          this.addOptions($option);
        }

        ArrayAdapter.__super__.select.call(this, data);
      };

      ArrayAdapter.prototype.convertToOptions = function (data) {
        var self = this;
        var $existing = this.$element.find('option');
        var existingIds = $existing.map(function () {
          return self.item($(this)).id;
        }).get();
        var $options = []; // Filter out all items except for the one passed in the argument

        function onlyItem(item) {
          return function () {
            return $(this).val() == item.id;
          };
        }

        for (var d = 0; d < data.length; d++) {
          var item = this._normalizeItem(data[d]); // Skip items which were pre-loaded, only merge the data


          if ($.inArray(item.id, existingIds) >= 0) {
            var $existingOption = $existing.filter(onlyItem(item));
            var existingData = this.item($existingOption);
            var newData = $.extend(true, {}, existingData, item);
            var $newOption = this.option(existingData);
            $existingOption.replaceWith($newOption);
            continue;
          }

          var $option = this.option(item);

          if (item.children) {
            var $children = this.convertToOptions(item.children);
            Utils.appendMany($option, $children);
          }

          $options.push($option);
        }

        return $options;
      };

      return ArrayAdapter;
    });
    S2.define('select2/data/ajax', ['./array', '../utils', 'jquery'], function (ArrayAdapter, Utils, $) {
      function AjaxAdapter($element, options) {
        this.ajaxOptions = this._applyDefaults(options.get('ajax'));

        if (this.ajaxOptions.processResults != null) {
          this.processResults = this.ajaxOptions.processResults;
        }

        ArrayAdapter.__super__.constructor.call(this, $element, options);
      }

      Utils.Extend(AjaxAdapter, ArrayAdapter);

      AjaxAdapter.prototype._applyDefaults = function (options) {
        var defaults = {
          data: function (params) {
            return {
              q: params.term
            };
          },
          transport: function (params, success, failure) {
            var $request = $.ajax(params);
            $request.then(success);
            $request.fail(failure);
            return $request;
          }
        };
        return $.extend({}, defaults, options, true);
      };

      AjaxAdapter.prototype.processResults = function (results) {
        return results;
      };

      AjaxAdapter.prototype.query = function (params, callback) {
        var matches = [];
        var self = this;

        if (this._request != null) {
          // JSONP requests cannot always be aborted
          if ($.isFunction(this._request.abort)) {
            this._request.abort();
          }

          this._request = null;
        }

        var options = $.extend({
          type: 'GET'
        }, this.ajaxOptions);

        if (typeof options.url === 'function') {
          options.url = options.url(params);
        }

        if (typeof options.data === 'function') {
          options.data = options.data(params);
        }

        function request() {
          var $request = options.transport(options, function (data) {
            var results = self.processResults(data, params);

            if (self.options.get('debug') && window.console && console.error) {
              // Check to make sure that the response included a `results` key.
              if (!results || !results.results || !$.isArray(results.results)) {
                console.error('Select2: The AJAX results did not return an array in the ' + '`results` key of the response.');
              }
            }

            callback(results);
          }, function () {// TODO: Handle AJAX errors
          });
          self._request = $request;
        }

        if (this.ajaxOptions.delay && params.term !== '') {
          if (this._queryTimeout) {
            window.clearTimeout(this._queryTimeout);
          }

          this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
        } else {
          request();
        }
      };

      return AjaxAdapter;
    });
    S2.define('select2/data/tags', ['jquery'], function ($) {
      function Tags(decorated, $element, options) {
        var tags = options.get('tags');
        var createTag = options.get('createTag');

        if (createTag !== undefined) {
          this.createTag = createTag;
        }

        decorated.call(this, $element, options);

        if ($.isArray(tags)) {
          for (var t = 0; t < tags.length; t++) {
            var tag = tags[t];

            var item = this._normalizeItem(tag);

            var $option = this.option(item);
            this.$element.append($option);
          }
        }
      }

      Tags.prototype.query = function (decorated, params, callback) {
        var self = this;

        this._removeOldTags();

        if (params.term == null || params.page != null) {
          decorated.call(this, params, callback);
          return;
        }

        function wrapper(obj, child) {
          var data = obj.results;

          for (var i = 0; i < data.length; i++) {
            var option = data[i];
            var checkChildren = option.children != null && !wrapper({
              results: option.children
            }, true);
            var checkText = option.text === params.term;

            if (checkText || checkChildren) {
              if (child) {
                return false;
              }

              obj.data = data;
              callback(obj);
              return;
            }
          }

          if (child) {
            return true;
          }

          var tag = self.createTag(params);

          if (tag != null) {
            var $option = self.option(tag);
            $option.attr('data-select2-tag', true);
            self.addOptions([$option]);
            self.insertTag(data, tag);
          }

          obj.results = data;
          callback(obj);
        }

        decorated.call(this, params, wrapper);
      };

      Tags.prototype.createTag = function (decorated, params) {
        var term = $.trim(params.term);

        if (term === '') {
          return null;
        }

        return {
          id: term,
          text: term
        };
      };

      Tags.prototype.insertTag = function (_, data, tag) {
        data.unshift(tag);
      };

      Tags.prototype._removeOldTags = function (_) {
        var tag = this._lastTag;
        var $options = this.$element.find('option[data-select2-tag]');
        $options.each(function () {
          if (this.selected) {
            return;
          }

          $(this).remove();
        });
      };

      return Tags;
    });
    S2.define('select2/data/tokenizer', ['jquery'], function ($) {
      function Tokenizer(decorated, $element, options) {
        var tokenizer = options.get('tokenizer');

        if (tokenizer !== undefined) {
          this.tokenizer = tokenizer;
        }

        decorated.call(this, $element, options);
      }

      Tokenizer.prototype.bind = function (decorated, container, $container) {
        decorated.call(this, container, $container);
        this.$search = container.dropdown.$search || container.selection.$search || $container.find('.select2-search__field');
      };

      Tokenizer.prototype.query = function (decorated, params, callback) {
        var self = this;

        function select(data) {
          self.select(data);
        }

        params.term = params.term || '';
        var tokenData = this.tokenizer(params, this.options, select);

        if (tokenData.term !== params.term) {
          // Replace the search term if we have the search box
          if (this.$search.length) {
            this.$search.val(tokenData.term);
            this.$search.focus();
          }

          params.term = tokenData.term;
        }

        decorated.call(this, params, callback);
      };

      Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
        var separators = options.get('tokenSeparators') || [];
        var term = params.term;
        var i = 0;

        var createTag = this.createTag || function (params) {
          return {
            id: params.term,
            text: params.term
          };
        };

        while (i < term.length) {
          var termChar = term[i];

          if ($.inArray(termChar, separators) === -1) {
            i++;
            continue;
          }

          var part = term.substr(0, i);
          var partParams = $.extend({}, params, {
            term: part
          });
          var data = createTag(partParams);
          callback(data); // Reset the term to not include the tokenized portion

          term = term.substr(i + 1) || '';
          i = 0;
        }

        return {
          term: term
        };
      };

      return Tokenizer;
    });
    S2.define('select2/data/minimumInputLength', [], function () {
      function MinimumInputLength(decorated, $e, options) {
        this.minimumInputLength = options.get('minimumInputLength');
        decorated.call(this, $e, options);
      }

      MinimumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';

        if (params.term.length < this.minimumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooShort',
            args: {
              minimum: this.minimumInputLength,
              input: params.term,
              params: params
            }
          });
          return;
        }

        decorated.call(this, params, callback);
      };

      return MinimumInputLength;
    });
    S2.define('select2/data/maximumInputLength', [], function () {
      function MaximumInputLength(decorated, $e, options) {
        this.maximumInputLength = options.get('maximumInputLength');
        decorated.call(this, $e, options);
      }

      MaximumInputLength.prototype.query = function (decorated, params, callback) {
        params.term = params.term || '';

        if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
          this.trigger('results:message', {
            message: 'inputTooLong',
            args: {
              maximum: this.maximumInputLength,
              input: params.term,
              params: params
            }
          });
          return;
        }

        decorated.call(this, params, callback);
      };

      return MaximumInputLength;
    });
    S2.define('select2/data/maximumSelectionLength', [], function () {
      function MaximumSelectionLength(decorated, $e, options) {
        this.maximumSelectionLength = options.get('maximumSelectionLength');
        decorated.call(this, $e, options);
      }

      MaximumSelectionLength.prototype.query = function (decorated, params, callback) {
        var self = this;
        this.current(function (currentData) {
          var count = currentData != null ? currentData.length : 0;

          if (self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength) {
            self.trigger('results:message', {
              message: 'maximumSelected',
              args: {
                maximum: self.maximumSelectionLength
              }
            });
            return;
          }

          decorated.call(self, params, callback);
        });
      };

      return MaximumSelectionLength;
    });
    S2.define('select2/dropdown', ['jquery', './utils'], function ($, Utils) {
      function Dropdown($element, options) {
        this.$element = $element;
        this.options = options;

        Dropdown.__super__.constructor.call(this);
      }

      Utils.Extend(Dropdown, Utils.Observable);

      Dropdown.prototype.render = function () {
        var $dropdown = $('<span class="select2-dropdown">' + '<span class="select2-results"></span>' + '</span>');
        $dropdown.attr('dir', this.options.get('dir'));
        this.$dropdown = $dropdown;
        return $dropdown;
      };

      Dropdown.prototype.position = function ($dropdown, $container) {// Should be implmented in subclasses
      };

      Dropdown.prototype.destroy = function () {
        // Remove the dropdown from the DOM
        this.$dropdown.remove();
      };

      return Dropdown;
    });
    S2.define('select2/dropdown/search', ['jquery', '../utils'], function ($, Utils) {
      function Search() {}

      Search.prototype.render = function (decorated) {
        var $rendered = decorated.call(this);
        var $search = $('<span class="select2-search select2-search--dropdown">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="off"' + ' spellcheck="false" role="textbox" />' + '</span>');
        this.$searchContainer = $search;
        this.$search = $search.find('input');
        $rendered.prepend($search);
        return $rendered;
      };

      Search.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        this.$search.on('keydown', function (evt) {
          self.trigger('keypress', evt);
          self._keyUpPrevented = evt.isDefaultPrevented();
        }); // Workaround for browsers which do not support the `input` event
        // This will prevent double-triggering of events for browsers which support
        // both the `keyup` and `input` events.

        this.$search.on('input', function (evt) {
          // Unbind the duplicated `keyup` event
          $(this).off('keyup');
        });
        this.$search.on('keyup input', function (evt) {
          self.handleSearch(evt);
        });
        container.on('open', function () {
          self.$search.attr('tabindex', 0);
          self.$search.focus();
          window.setTimeout(function () {
            self.$search.focus();
          }, 0);
        });
        container.on('close', function () {
          self.$search.attr('tabindex', -1);
          self.$search.val('');
        });
        container.on('results:all', function (params) {
          if (params.query.term == null || params.query.term === '') {
            var showSearch = self.showSearch(params);

            if (showSearch) {
              self.$searchContainer.removeClass('select2-search--hide');
            } else {
              self.$searchContainer.addClass('select2-search--hide');
            }
          }
        });
      };

      Search.prototype.handleSearch = function (evt) {
        if (!this._keyUpPrevented) {
          var input = this.$search.val();
          this.trigger('query', {
            term: input
          });
        }

        this._keyUpPrevented = false;
      };

      Search.prototype.showSearch = function (_, params) {
        return true;
      };

      return Search;
    });
    S2.define('select2/dropdown/hidePlaceholder', [], function () {
      function HidePlaceholder(decorated, $element, options, dataAdapter) {
        this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
        decorated.call(this, $element, options, dataAdapter);
      }

      HidePlaceholder.prototype.append = function (decorated, data) {
        data.results = this.removePlaceholder(data.results);
        decorated.call(this, data);
      };

      HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
        if (typeof placeholder === 'string') {
          placeholder = {
            id: '',
            text: placeholder
          };
        }

        return placeholder;
      };

      HidePlaceholder.prototype.removePlaceholder = function (_, data) {
        var modifiedData = data.slice(0);

        for (var d = data.length - 1; d >= 0; d--) {
          var item = data[d];

          if (this.placeholder.id === item.id) {
            modifiedData.splice(d, 1);
          }
        }

        return modifiedData;
      };

      return HidePlaceholder;
    });
    S2.define('select2/dropdown/infiniteScroll', ['jquery'], function ($) {
      function InfiniteScroll(decorated, $element, options, dataAdapter) {
        this.lastParams = {};
        decorated.call(this, $element, options, dataAdapter);
        this.$loadingMore = this.createLoadingMore();
        this.loading = false;
      }

      InfiniteScroll.prototype.append = function (decorated, data) {
        this.$loadingMore.remove();
        this.loading = false;
        decorated.call(this, data);

        if (this.showLoadingMore(data)) {
          this.$results.append(this.$loadingMore);
        }
      };

      InfiniteScroll.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('query', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
        container.on('query:append', function (params) {
          self.lastParams = params;
          self.loading = true;
        });
        this.$results.on('scroll', function () {
          var isLoadMoreVisible = $.contains(document.documentElement, self.$loadingMore[0]);

          if (self.loading || !isLoadMoreVisible) {
            return;
          }

          var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
          var loadingMoreOffset = self.$loadingMore.offset().top + self.$loadingMore.outerHeight(false);

          if (currentOffset + 50 >= loadingMoreOffset) {
            self.loadMore();
          }
        });
      };

      InfiniteScroll.prototype.loadMore = function () {
        this.loading = true;
        var params = $.extend({}, {
          page: 1
        }, this.lastParams);
        params.page++;
        this.trigger('query:append', params);
      };

      InfiniteScroll.prototype.showLoadingMore = function (_, data) {
        return data.pagination && data.pagination.more;
      };

      InfiniteScroll.prototype.createLoadingMore = function () {
        var $option = $('<li class="option load-more" role="treeitem"></li>');
        var message = this.options.get('translations').get('loadingMore');
        $option.html(message(this.lastParams));
        return $option;
      };

      return InfiniteScroll;
    });
    S2.define('select2/dropdown/attachBody', ['jquery', '../utils'], function ($, Utils) {
      function AttachBody(decorated, $element, options) {
        this.$dropdownParent = options.get('dropdownParent') || document.body;
        decorated.call(this, $element, options);
      }

      AttachBody.prototype.bind = function (decorated, container, $container) {
        var self = this;
        var setupResultsEvents = false;
        decorated.call(this, container, $container);
        container.on('open', function () {
          self._showDropdown();

          self._attachPositioningHandler(container);

          if (!setupResultsEvents) {
            setupResultsEvents = true;
            container.on('results:all', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            container.on('results:append', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
          }
        });
        container.on('close', function () {
          self._hideDropdown();

          self._detachPositioningHandler(container);
        });
        this.$dropdownContainer.on('mousedown', function (evt) {
          evt.stopPropagation();
        });
      };

      AttachBody.prototype.position = function (decorated, $dropdown, $container) {
        // Clone all of the container classes
        $dropdown.attr('class', $container.attr('class'));
        $dropdown.removeClass('select2');
        $dropdown.addClass('select2-container--open');
        $dropdown.css({
          position: 'absolute',
          top: -999999
        });
        this.$container = $container;
      };

      AttachBody.prototype.render = function (decorated) {
        var $container = $('<span></span>');
        var $dropdown = decorated.call(this);
        $container.append($dropdown);
        this.$dropdownContainer = $container;
        return $container;
      };

      AttachBody.prototype._hideDropdown = function (decorated) {
        this.$dropdownContainer.detach();
      };

      AttachBody.prototype._attachPositioningHandler = function (container) {
        var self = this;
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.each(function () {
          $(this).data('select2-scroll-position', {
            x: $(this).scrollLeft(),
            y: $(this).scrollTop()
          });
        });
        $watchers.on(scrollEvent, function (ev) {
          var position = $(this).data('select2-scroll-position');
          $(this).scrollTop(position.y);
        });
        $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent, function (e) {
          self._positionDropdown();

          self._resizeDropdown();
        });
      };

      AttachBody.prototype._detachPositioningHandler = function (container) {
        var scrollEvent = 'scroll.select2.' + container.id;
        var resizeEvent = 'resize.select2.' + container.id;
        var orientationEvent = 'orientationchange.select2.' + container.id;
        var $watchers = this.$container.parents().filter(Utils.hasScroll);
        $watchers.off(scrollEvent);
        $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
      };

      AttachBody.prototype._positionDropdown = function () {
        var $window = $(window);
        var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
        var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');
        var newDirection = null;
        var position = this.$container.position();
        var offset = this.$container.offset();
        offset.bottom = offset.top + this.$container.outerHeight(false);
        var container = {
          height: this.$container.outerHeight(false)
        };
        container.top = offset.top;
        container.bottom = offset.top + container.height;
        var dropdown = {
          height: this.$dropdown.outerHeight(false)
        };
        var viewport = {
          top: $window.scrollTop(),
          bottom: $window.scrollTop() + $window.height()
        };
        var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
        var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
        var css = {
          left: offset.left,
          top: container.bottom
        };

        if (!isCurrentlyAbove && !isCurrentlyBelow) {
          newDirection = 'below';
        }

        if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
          newDirection = 'above';
        } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
          newDirection = 'below';
        }

        if (newDirection == 'above' || isCurrentlyAbove && newDirection !== 'below') {
          css.top = container.top - dropdown.height;
        }

        if (newDirection != null) {
          this.$dropdown.removeClass('select2-dropdown--below select2-dropdown--above').addClass('select2-dropdown--' + newDirection);
          this.$container.removeClass('select2-container--below select2-container--above').addClass('select2-container--' + newDirection);
        }

        this.$dropdownContainer.css(css);
      };

      AttachBody.prototype._resizeDropdown = function () {
        this.$dropdownContainer.width();
        var css = {
          width: this.$container.outerWidth(false) + 'px'
        };

        if (this.options.get('dropdownAutoWidth')) {
          css.minWidth = css.width;
          css.width = 'auto';
        }

        this.$dropdown.css(css);
      };

      AttachBody.prototype._showDropdown = function (decorated) {
        this.$dropdownContainer.appendTo(this.$dropdownParent);

        this._positionDropdown();

        this._resizeDropdown();
      };

      return AttachBody;
    });
    S2.define('select2/dropdown/minimumResultsForSearch', [], function () {
      function countResults(data) {
        var count = 0;

        for (var d = 0; d < data.length; d++) {
          var item = data[d];

          if (item.children) {
            count += countResults(item.children);
          } else {
            count++;
          }
        }

        return count;
      }

      function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
        this.minimumResultsForSearch = options.get('minimumResultsForSearch');

        if (this.minimumResultsForSearch < 0) {
          this.minimumResultsForSearch = Infinity;
        }

        decorated.call(this, $element, options, dataAdapter);
      }

      MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
        if (countResults(params.data.results) < this.minimumResultsForSearch) {
          return false;
        }

        return decorated.call(this, params);
      };

      return MinimumResultsForSearch;
    });
    S2.define('select2/dropdown/selectOnClose', [], function () {
      function SelectOnClose() {}

      SelectOnClose.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('close', function () {
          self._handleSelectOnClose();
        });
      };

      SelectOnClose.prototype._handleSelectOnClose = function () {
        var $highlightedResults = this.getHighlightedResults();

        if ($highlightedResults.length < 1) {
          return;
        }

        this.trigger('select', {
          data: $highlightedResults.data('data')
        });
      };

      return SelectOnClose;
    });
    S2.define('select2/dropdown/closeOnSelect', [], function () {
      function CloseOnSelect() {}

      CloseOnSelect.prototype.bind = function (decorated, container, $container) {
        var self = this;
        decorated.call(this, container, $container);
        container.on('select', function (evt) {
          self._selectTriggered(evt);
        });
        container.on('unselect', function (evt) {
          self._selectTriggered(evt);
        });
      };

      CloseOnSelect.prototype._selectTriggered = function (_, evt) {
        var originalEvent = evt.originalEvent; // Don't close if the control key is being held

        if (originalEvent && originalEvent.ctrlKey) {
          return;
        }

        this.trigger('close');
      };

      return CloseOnSelect;
    });
    S2.define('select2/i18n/en', [], function () {
      // English
      return {
        errorLoading: function () {
          return 'The results could not be loaded.';
        },
        inputTooLong: function (args) {
          var overChars = args.input.length - args.maximum;
          var message = 'Please delete ' + overChars + ' character';

          if (overChars != 1) {
            message += 's';
          }

          return message;
        },
        inputTooShort: function (args) {
          var remainingChars = args.minimum - args.input.length;
          var message = 'Please enter ' + remainingChars + ' or more characters';
          return message;
        },
        loadingMore: function () {
          return 'Loading more results';
        },
        maximumSelected: function (args) {
          var message = 'You can only select ' + args.maximum + ' item';

          if (args.maximum != 1) {
            message += 's';
          }

          return message;
        },
        noResults: function () {
          return 'No results found';
        },
        searching: function () {
          return 'Searching';
        }
      };
    });
    S2.define('select2/defaults', ['jquery', 'require', './results', './selection/single', './selection/multiple', './selection/placeholder', './selection/allowClear', './selection/search', './selection/eventRelay', './utils', './translation', './diacritics', './data/select', './data/array', './data/ajax', './data/tags', './data/tokenizer', './data/minimumInputLength', './data/maximumInputLength', './data/maximumSelectionLength', './dropdown', './dropdown/search', './dropdown/hidePlaceholder', './dropdown/infiniteScroll', './dropdown/attachBody', './dropdown/minimumResultsForSearch', './dropdown/selectOnClose', './dropdown/closeOnSelect', './i18n/en'], function ($, require, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
      function Defaults() {
        this.reset();
      }

      Defaults.prototype.apply = function (options) {
        options = $.extend({}, this.defaults, options);

        if (options.dataAdapter == null) {
          if (options.ajax != null) {
            options.dataAdapter = AjaxData;
          } else if (options.data != null) {
            options.dataAdapter = ArrayData;
          } else {
            options.dataAdapter = SelectData;
          }

          if (options.minimumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength);
          }

          if (options.maximumInputLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength);
          }

          if (options.maximumSelectionLength > 0) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength);
          }

          if (options.tags) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
          }

          if (options.tokenSeparators != null || options.tokenizer != null) {
            options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer);
          }

          if (options.query != null) {
            var Query = require(options.amdBase + 'compat/query');

            options.dataAdapter = Utils.Decorate(options.dataAdapter, Query);
          }

          if (options.initSelection != null) {
            var InitSelection = require(options.amdBase + 'compat/initSelection');

            options.dataAdapter = Utils.Decorate(options.dataAdapter, InitSelection);
          }
        }

        if (options.resultsAdapter == null) {
          options.resultsAdapter = ResultsList;

          if (options.ajax != null) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll);
          }

          if (options.placeholder != null) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder);
          }

          if (options.selectOnClose) {
            options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose);
          }
        }

        if (options.dropdownAdapter == null) {
          if (options.multiple) {
            options.dropdownAdapter = Dropdown;
          } else {
            var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
            options.dropdownAdapter = SearchableDropdown;
          }

          if (options.minimumResultsForSearch !== 0) {
            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch);
          }

          if (options.closeOnSelect) {
            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect);
          }

          if (options.dropdownCssClass != null || options.dropdownCss != null || options.adaptDropdownCssClass != null) {
            var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

            options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
          }

          options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
        }

        if (options.selectionAdapter == null) {
          if (options.multiple) {
            options.selectionAdapter = MultipleSelection;
          } else {
            options.selectionAdapter = SingleSelection;
          } // Add the placeholder mixin if a placeholder was specified


          if (options.placeholder != null) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder);
          }

          if (options.allowClear) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear);
          }

          if (options.multiple) {
            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch);
          }

          if (options.containerCssClass != null || options.containerCss != null || options.adaptContainerCssClass != null) {
            var ContainerCSS = require(options.amdBase + 'compat/containerCss');

            options.selectionAdapter = Utils.Decorate(options.selectionAdapter, ContainerCSS);
          }

          options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
        }

        if (typeof options.language === 'string') {
          // Check if the language is specified with a region
          if (options.language.indexOf('-') > 0) {
            // Extract the region information if it is included
            var languageParts = options.language.split('-');
            var baseLanguage = languageParts[0];
            options.language = [options.language, baseLanguage];
          } else {
            options.language = [options.language];
          }
        }

        if ($.isArray(options.language)) {
          var languages = new Translation();
          options.language.push('en');
          var languageNames = options.language;

          for (var l = 0; l < languageNames.length; l++) {
            var name = languageNames[l];
            var language = {};

            try {
              // Try to load it with the original name
              language = Translation.loadPath(name);
            } catch (e) {
              try {
                // If we couldn't load it, check if it wasn't the full path
                name = this.defaults.amdLanguageBase + name;
                language = Translation.loadPath(name);
              } catch (ex) {
                // The translation could not be loaded at all. Sometimes this is
                // because of a configuration problem, other times this can be
                // because of how Select2 helps load all possible translation files.
                if (options.debug && window.console && console.warn) {
                  console.warn('Select2: The language file for "' + name + '" could not be ' + 'automatically loaded. A fallback will be used instead.');
                }

                continue;
              }
            }

            languages.extend(language);
          }

          options.translations = languages;
        } else {
          var baseTranslation = Translation.loadPath(this.defaults.amdLanguageBase + 'en');
          var customTranslation = new Translation(options.language);
          customTranslation.extend(baseTranslation);
          options.translations = customTranslation;
        }

        return options;
      };

      Defaults.prototype.reset = function () {
        function stripDiacritics(text) {
          // Used 'uni range + named function' from http://jsperf.com/diacritics/18
          function match(a) {
            return DIACRITICS[a] || a;
          }

          return text.replace(/[^\u0000-\u007E]/g, match);
        }

        function matcher(params, data) {
          // Always return the object if there is nothing to compare
          if ($.trim(params.term) === '') {
            return data;
          } // Do a recursive check for options with children


          if (data.children && data.children.length > 0) {
            // Clone the data object if there are children
            // This is required as we modify the object to remove any non-matches
            var match = $.extend(true, {}, data); // Check each child of the option

            for (var c = data.children.length - 1; c >= 0; c--) {
              var child = data.children[c];
              var matches = matcher(params, child); // If there wasn't a match, remove the object in the array

              if (matches == null) {
                match.children.splice(c, 1);
              }
            } // If any children matched, return the new object


            if (match.children.length > 0) {
              return match;
            } // If there were no matching children, check just the plain object


            return matcher(params, match);
          }

          var original = stripDiacritics(data.text).toUpperCase();
          var term = stripDiacritics(params.term).toUpperCase(); // Check if the text contains the term

          if (original.indexOf(term) > -1) {
            return data;
          } // If it doesn't contain the term, don't return anything


          return null;
        }

        this.defaults = {
          amdBase: './',
          amdLanguageBase: './i18n/',
          closeOnSelect: true,
          debug: false,
          dropdownAutoWidth: false,
          escapeMarkup: Utils.escapeMarkup,
          language: EnglishTranslation,
          matcher: matcher,
          minimumInputLength: 0,
          maximumInputLength: 0,
          maximumSelectionLength: 0,
          minimumResultsForSearch: 0,
          selectOnClose: false,
          sorter: function (data) {
            return data;
          },
          templateResult: function (result) {
            return result.text;
          },
          templateSelection: function (selection) {
            return selection.text;
          },
          theme: 'default',
          width: 'resolve'
        };
      };

      Defaults.prototype.set = function (key, value) {
        var camelKey = $.camelCase(key);
        var data = {};
        data[camelKey] = value;

        var convertedData = Utils._convertData(data);

        $.extend(this.defaults, convertedData);
      };

      var defaults = new Defaults();
      return defaults;
    });
    S2.define('select2/options', ['require', 'jquery', './defaults', './utils'], function (require, $, Defaults, Utils) {
      function Options(options, $element) {
        this.options = options;

        if ($element != null) {
          this.fromElement($element);
        }

        this.options = Defaults.apply(this.options);

        if ($element && $element.is('input')) {
          var InputCompat = require(this.get('amdBase') + 'compat/inputData');

          this.options.dataAdapter = Utils.Decorate(this.options.dataAdapter, InputCompat);
        }
      }

      Options.prototype.fromElement = function ($e) {
        var excludedData = ['select2'];

        if (this.options.multiple == null) {
          this.options.multiple = $e.prop('multiple');
        }

        if (this.options.disabled == null) {
          this.options.disabled = $e.prop('disabled');
        }

        if (this.options.language == null) {
          if ($e.prop('lang')) {
            this.options.language = $e.prop('lang').toLowerCase();
          } else if ($e.closest('[lang]').prop('lang')) {
            this.options.language = $e.closest('[lang]').prop('lang');
          }
        }

        if (this.options.dir == null) {
          if ($e.prop('dir')) {
            this.options.dir = $e.prop('dir');
          } else if ($e.closest('[dir]').prop('dir')) {
            this.options.dir = $e.closest('[dir]').prop('dir');
          } else {
            this.options.dir = 'ltr';
          }
        }

        $e.prop('disabled', this.options.disabled);
        $e.prop('multiple', this.options.multiple);

        if ($e.data('select2Tags')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn('Select2: The `data-select2-tags` attribute has been changed to ' + 'use the `data-data` and `data-tags="true"` attributes and will be ' + 'removed in future versions of Select2.');
          }

          $e.data('data', $e.data('select2Tags'));
          $e.data('tags', true);
        }

        if ($e.data('ajaxUrl')) {
          if (this.options.debug && window.console && console.warn) {
            console.warn('Select2: The `data-ajax-url` attribute has been changed to ' + '`data-ajax--url` and support for the old attribute will be removed' + ' in future versions of Select2.');
          }

          $e.attr('ajax--url', $e.data('ajaxUrl'));
          $e.data('ajax--url', $e.data('ajaxUrl'));
        }

        var dataset = {}; // Prefer the element's `dataset` attribute if it exists
        // jQuery 1.x does not correctly handle data attributes with multiple dashes

        if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
          dataset = $.extend(true, {}, $e[0].dataset, $e.data());
        } else {
          dataset = $e.data();
        }

        var data = $.extend(true, {}, dataset);
        data = Utils._convertData(data);

        for (var key in data) {
          if ($.inArray(key, excludedData) > -1) {
            continue;
          }

          if ($.isPlainObject(this.options[key])) {
            $.extend(this.options[key], data[key]);
          } else {
            this.options[key] = data[key];
          }
        }

        return this;
      };

      Options.prototype.get = function (key) {
        return this.options[key];
      };

      Options.prototype.set = function (key, val) {
        this.options[key] = val;
      };

      return Options;
    });
    S2.define('select2/core', ['jquery', './options', './utils', './keys'], function ($, Options, Utils, KEYS) {
      var Select2 = function ($element, options) {
        if ($element.data('select2') != null) {
          $element.data('select2').destroy();
        }

        this.$element = $element;
        this.id = this._generateId($element);
        options = options || {};
        this.options = new Options(options, $element);

        Select2.__super__.constructor.call(this); // Set up the tabindex


        var tabindex = $element.attr('tabindex') || 0;
        $element.data('old-tabindex', tabindex);
        $element.attr('tabindex', '-1'); // Set up containers and adapters

        var DataAdapter = this.options.get('dataAdapter');
        this.dataAdapter = new DataAdapter($element, this.options);
        var $container = this.render();

        this._placeContainer($container);

        var SelectionAdapter = this.options.get('selectionAdapter');
        this.selection = new SelectionAdapter($element, this.options);
        this.$selection = this.selection.render();
        this.selection.position(this.$selection, $container);
        var DropdownAdapter = this.options.get('dropdownAdapter');
        this.dropdown = new DropdownAdapter($element, this.options);
        this.$dropdown = this.dropdown.render();
        this.dropdown.position(this.$dropdown, $container);
        var ResultsAdapter = this.options.get('resultsAdapter');
        this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
        this.$results = this.results.render();
        this.results.position(this.$results, this.$dropdown); // Bind events

        var self = this; // Bind the container to all of the adapters

        this._bindAdapters(); // Register any DOM event handlers


        this._registerDomEvents(); // Register any internal event handlers


        this._registerDataEvents();

        this._registerSelectionEvents();

        this._registerDropdownEvents();

        this._registerResultsEvents();

        this._registerEvents(); // Set the initial state


        this.dataAdapter.current(function (initialData) {
          self.trigger('selection:update', {
            data: initialData
          });
        }); // Hide the original select

        $element.addClass('select2-hidden-accessible');
        $element.attr('aria-hidden', 'true'); // Synchronize any monitored attributes

        this._syncAttributes();

        $element.data('select2', this);
      };

      Utils.Extend(Select2, Utils.Observable);

      Select2.prototype._generateId = function ($element) {
        var id = '';

        if ($element.attr('id') != null) {
          id = $element.attr('id');
        } else if ($element.attr('name') != null) {
          id = $element.attr('name') + '-' + Utils.generateChars(2);
        } else {
          id = Utils.generateChars(4);
        }

        id = 'select2-' + id;
        return id;
      };

      Select2.prototype._placeContainer = function ($container) {
        $container.insertAfter(this.$element);

        var width = this._resolveWidth(this.$element, this.options.get('width'));

        if (width != null) {
          $container.css('width', width);
        }
      };

      Select2.prototype._resolveWidth = function ($element, method) {
        var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

        if (method == 'resolve') {
          var styleWidth = this._resolveWidth($element, 'style');

          if (styleWidth != null) {
            return styleWidth;
          }

          return this._resolveWidth($element, 'element');
        }

        if (method == 'element') {
          var elementWidth = $element.outerWidth(false);

          if (elementWidth <= 0) {
            return 'auto';
          }

          return elementWidth + 'px';
        }

        if (method == 'style') {
          var style = $element.attr('style');

          if (typeof style !== 'string') {
            return null;
          }

          var attrs = style.split(';');

          for (var i = 0, l = attrs.length; i < l; i = i + 1) {
            var attr = attrs[i].replace(/\s/g, '');
            var matches = attr.match(WIDTH);

            if (matches !== null && matches.length >= 1) {
              return matches[1];
            }
          }

          return null;
        }

        return method;
      };

      Select2.prototype._bindAdapters = function () {
        this.dataAdapter.bind(this, this.$container);
        this.selection.bind(this, this.$container);
        this.dropdown.bind(this, this.$container);
        this.results.bind(this, this.$container);
      };

      Select2.prototype._registerDomEvents = function () {
        var self = this;
        this.$element.on('change.select2', function () {
          self.dataAdapter.current(function (data) {
            self.trigger('selection:update', {
              data: data
            });
          });
        });
        this._sync = Utils.bind(this._syncAttributes, this);

        if (this.$element[0].attachEvent) {
          this.$element[0].attachEvent('onpropertychange', this._sync);
        }

        var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

        if (observer != null) {
          this._observer = new observer(function (mutations) {
            $.each(mutations, self._sync);
          });

          this._observer.observe(this.$element[0], {
            attributes: true,
            subtree: false
          });
        } else if (this.$element[0].addEventListener) {
          this.$element[0].addEventListener('DOMAttrModified', self._sync, false);
        }
      };

      Select2.prototype._registerDataEvents = function () {
        var self = this;
        this.dataAdapter.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerSelectionEvents = function () {
        var self = this;
        var nonRelayEvents = ['toggle'];
        this.selection.on('toggle', function () {
          self.toggleDropdown();
        });
        this.selection.on('*', function (name, params) {
          if ($.inArray(name, nonRelayEvents) !== -1) {
            return;
          }

          self.trigger(name, params);
        });
      };

      Select2.prototype._registerDropdownEvents = function () {
        var self = this;
        this.dropdown.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerResultsEvents = function () {
        var self = this;
        this.results.on('*', function (name, params) {
          self.trigger(name, params);
        });
      };

      Select2.prototype._registerEvents = function () {
        var self = this;
        this.on('open', function () {
          self.$container.addClass('select2-container--open');
        });
        this.on('close', function () {
          self.$container.removeClass('select2-container--open');
        });
        this.on('enable', function () {
          self.$container.removeClass('select2-container--disabled');
        });
        this.on('disable', function () {
          self.$container.addClass('select2-container--disabled');
        });
        this.on('focus', function () {
          self.$container.addClass('select2-container--focus');
        });
        this.on('blur', function () {
          self.$container.removeClass('select2-container--focus');
        });
        this.on('query', function (params) {
          if (!self.isOpen()) {
            self.trigger('open');
          }

          this.dataAdapter.query(params, function (data) {
            self.trigger('results:all', {
              data: data,
              query: params
            });
          });
        });
        this.on('query:append', function (params) {
          this.dataAdapter.query(params, function (data) {
            self.trigger('results:append', {
              data: data,
              query: params
            });
          });
        });
        this.on('keypress', function (evt) {
          var key = evt.which;

          if (self.isOpen()) {
            if (key === KEYS.ENTER) {
              self.trigger('results:select');
              evt.preventDefault();
            } else if (key === KEYS.SPACE && evt.ctrlKey) {
              self.trigger('results:toggle');
              evt.preventDefault();
            } else if (key === KEYS.UP) {
              self.trigger('results:previous');
              evt.preventDefault();
            } else if (key === KEYS.DOWN) {
              self.trigger('results:next');
              evt.preventDefault();
            } else if (key === KEYS.ESC || key === KEYS.TAB) {
              self.close();
              evt.preventDefault();
            }
          } else {
            if (key === KEYS.ENTER || key === KEYS.SPACE || (key === KEYS.DOWN || key === KEYS.UP) && evt.altKey) {
              self.open();
              evt.preventDefault();
            }
          }
        });
      };

      Select2.prototype._syncAttributes = function () {
        this.options.set('disabled', this.$element.prop('disabled'));

        if (this.options.get('disabled')) {
          if (this.isOpen()) {
            this.close();
          }

          this.trigger('disable');
        } else {
          this.trigger('enable');
        }
      };
      /**
       * Override the trigger method to automatically trigger pre-events when
       * there are events that can be prevented.
       */


      Select2.prototype.trigger = function (name, args) {
        var actualTrigger = Select2.__super__.trigger;
        var preTriggerMap = {
          'open': 'opening',
          'close': 'closing',
          'select': 'selecting',
          'unselect': 'unselecting'
        };

        if (name in preTriggerMap) {
          var preTriggerName = preTriggerMap[name];
          var preTriggerArgs = {
            prevented: false,
            name: name,
            args: args
          };
          actualTrigger.call(this, preTriggerName, preTriggerArgs);

          if (preTriggerArgs.prevented) {
            args.prevented = true;
            return;
          }
        }

        actualTrigger.call(this, name, args);
      };

      Select2.prototype.toggleDropdown = function () {
        if (this.options.get('disabled')) {
          return;
        }

        if (this.isOpen()) {
          this.close();
        } else {
          this.open();
        }
      };

      Select2.prototype.open = function () {
        if (this.isOpen()) {
          return;
        }

        this.trigger('query', {});
        this.trigger('open');
      };

      Select2.prototype.close = function () {
        if (!this.isOpen()) {
          return;
        }

        this.trigger('close');
      };

      Select2.prototype.isOpen = function () {
        return this.$container.hasClass('select2-container--open');
      };

      Select2.prototype.enable = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn('Select2: The `select2("enable")` method has been deprecated and will' + ' be removed in later Select2 versions. Use $element.prop("disabled")' + ' instead.');
        }

        if (args == null || args.length === 0) {
          args = [true];
        }

        var disabled = !args[0];
        this.$element.prop('disabled', disabled);
      };

      Select2.prototype.data = function () {
        if (this.options.get('debug') && arguments.length > 0 && window.console && console.warn) {
          console.warn('Select2: Data can no longer be set using `select2("data")`. You ' + 'should consider setting the value instead using `$element.val()`.');
        }

        var data = [];
        this.dataAdapter.current(function (currentData) {
          data = currentData;
        });
        return data;
      };

      Select2.prototype.val = function (args) {
        if (this.options.get('debug') && window.console && console.warn) {
          console.warn('Select2: The `select2("val")` method has been deprecated and will be' + ' removed in later Select2 versions. Use $element.val() instead.');
        }

        if (args == null || args.length === 0) {
          return this.$element.val();
        }

        var newVal = args[0];

        if ($.isArray(newVal)) {
          newVal = $.map(newVal, function (obj) {
            return obj.toString();
          });
        }

        this.$element.val(newVal).trigger('change');
      };

      Select2.prototype.destroy = function () {
        this.$container.remove();

        if (this.$element[0].detachEvent) {
          this.$element[0].detachEvent('onpropertychange', this._sync);
        }

        if (this._observer != null) {
          this._observer.disconnect();

          this._observer = null;
        } else if (this.$element[0].removeEventListener) {
          this.$element[0].removeEventListener('DOMAttrModified', this._sync, false);
        }

        this._sync = null;
        this.$element.off('.select2');
        this.$element.attr('tabindex', this.$element.data('old-tabindex'));
        this.$element.removeClass('select2-hidden-accessible');
        this.$element.attr('aria-hidden', 'false');
        this.$element.removeData('select2');
        this.dataAdapter.destroy();
        this.selection.destroy();
        this.dropdown.destroy();
        this.results.destroy();
        this.dataAdapter = null;
        this.selection = null;
        this.dropdown = null;
        this.results = null;
      };

      Select2.prototype.render = function () {
        var $container = $('<span class="select2 select2-container">' + '<span class="selection"></span>' + '<span class="dropdown-wrapper" aria-hidden="true"></span>' + '</span>');
        $container.attr('dir', this.options.get('dir'));
        this.$container = $container;
        this.$container.addClass('select2-container--' + this.options.get('theme'));
        $container.data('element', this.$element);
        return $container;
      };

      return Select2;
    });
    S2.define('jquery.select2', ['jquery', 'require', './select2/core', './select2/defaults'], function ($, require, Select2, Defaults) {
      // Force jQuery.mousewheel to be loaded if it hasn't already
      require('jquery.mousewheel');

      if ($.fn.select2 == null) {
        // All methods that should return the element
        var thisMethods = ['open', 'close', 'destroy'];

        $.fn.select2 = function (options) {
          options = options || {};

          if (typeof options === 'object') {
            this.each(function () {
              var instanceOptions = $.extend({}, options, true);
              var instance = new Select2($(this), instanceOptions);
            });
            return this;
          } else if (typeof options === 'string') {
            var instance = this.data('select2');

            if (instance == null && window.console && console.error) {
              console.error('The select2(\'' + options + '\') method was called on an ' + 'element that is not using Select2.');
            }

            var args = Array.prototype.slice.call(arguments, 1);
            var ret = instance[options](args); // Check if we should be returning `this`

            if ($.inArray(options, thisMethods) > -1) {
              return this;
            }

            return ret;
          } else {
            throw new Error('Invalid arguments for Select2: ' + options);
          }
        };
      }

      if ($.fn.select2.defaults == null) {
        $.fn.select2.defaults = Defaults;
      }

      return Select2;
    });
    S2.define('jquery.mousewheel', ['jquery'], function ($) {
      // Used to shim jQuery.mousewheel for non-full builds.
      return $;
    }); // Return the AMD loader configuration so it can be used outside of this file

    return {
      define: S2.define,
      require: S2.require
    };
  }(); // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe


  var select2 = S2.require('jquery.select2'); // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.


  jQuery.fn.select2.amd = S2; // Return the Select2 instance for anyone who is importing it.

  return select2;
});
/*!
 * Spinners 3.0.0
 * (c) 2010-2012 Nick Stakenburg - http://www.nickstakenburg.com
 *
 * Spinners is freely distributable under the terms of an MIT-style license.
 *
 * GitHub: http://github.com/staaky/spinners
 */
;
var Spinners = {
  version: "3.0.0"
};

(function (a) {
  function b(a) {
    return a * Math.PI / 180;
  }

  function c(a) {
    this.element = a;
  }

  function d(b, c) {
    b && (this.element = b, h.remove(b), h.removeDetached(), this._position = 0, this._state = "stopped", this.setOptions(a.extend({
      color: "#000",
      dashes: 12,
      radius: 5,
      height: 5,
      width: 1.8,
      opacity: 1,
      padding: 3,
      rotation: 700
    }, c || {})), this.drawPosition(0), h.add(this));
  }

  var e = {
    scroll: function (a, b) {
      if (!b) return a;
      var c = a.slice(0, b);
      return a.slice(b, a.length).concat(c);
    },
    isElement: function (a) {
      return a && 1 == a.nodeType;
    },
    element: {
      isAttached: function () {
        return function (a) {
          for (; a && a.parentNode;) a = a.parentNode;

          return !!a && !!a.body;
        };
      }()
    }
  },
      f = {
    drawRoundedRectangle: function (c, d) {
      var e = a.extend({
        top: 0,
        left: 0,
        width: 0,
        height: 0,
        radius: 0
      }, d || {}),
          f = e.left,
          g = e.top,
          h = e.width,
          i = e.height,
          e = e.radius;
      c.beginPath(), c.moveTo(f + e, g), c.arc(f + h - e, g + e, e, b(-90), b(0), !1), c.arc(f + h - e, g + i - e, e, b(0), b(90), !1), c.arc(f + e, g + i - e, e, b(90), b(180), !1), c.arc(f + e, g + e, e, b(-180), b(-90), !1), c.closePath(), c.fill();
    }
  },
      g = function () {
    function a(a) {
      var c = [];
      0 == a.indexOf("#") && (a = a.substring(1)), a = a.toLowerCase();
      if ("" != a.replace(b, "")) return null;
      3 == a.length ? (c[0] = a.charAt(0) + a.charAt(0), c[1] = a.charAt(1) + a.charAt(1), c[2] = a.charAt(2) + a.charAt(2)) : (c[0] = a.substring(0, 2), c[1] = a.substring(2, 4), c[2] = a.substring(4));

      for (a = 0; a < c.length; a++) c[a] = parseInt(c[a], 16);

      return c.red = c[0], c.green = c[1], c.blue = c[2], c;
    }

    var b = RegExp("[0123456789abcdef]", "g"),
        c = function () {
      function a(a, b, c) {
        return a = a.toString(c || 10), Array(b - a.length).join("0") + a;
      }

      return function (b, c, d) {
        return "#" + a(b, 2, 16) + a(c, 2, 16) + a(d, 2, 16);
      };
    }();

    return {
      hex2rgb: a,
      hex2fill: function (b, c) {
        "undefined" == typeof c && (c = 1);
        var d = c,
            e = a(b);
        return e[3] = d, e.opacity = d, "rgba(" + e.join() + ")";
      },
      rgb2hex: c
    };
  }();

  a.extend(Spinners, {
    enabled: !1,
    support: {
      canvas: function () {
        var b = a("<canvas>")[0];
        return !!b.getContext && !!b.getContext("2d");
      }()
    },
    init: function () {
      if (this.support.canvas || window.G_vmlCanvasManager && window.attachEvent && -1 === navigator.userAgent.indexOf("Opera")) window.G_vmlCanvasManager && window.G_vmlCanvasManager.init_(document), this.enabled = !0;
    },
    create: function (a, b) {
      return c.create(a, b), this.get(a);
    },
    get: function (a) {
      return new c(a);
    },
    play: function (a) {
      return this.get(a).play(), this;
    },
    pause: function (a) {
      return this.get(a).pause(), this;
    },
    toggle: function (a) {
      return this.get(a).toggle(), this;
    },
    stop: function (a) {
      return this.get(a).stop(), this;
    },
    remove: function (a) {
      return this.get(a).remove(), this;
    },
    removeDetached: function () {
      return h.removeDetached(), this;
    },
    center: function (a) {
      return this.get(a).center(), this;
    },
    setOptions: function (a, b) {
      return this.get(a).setOptions(b), this;
    },
    getDimensions: function (a) {
      return a = 2 * h.get(a)[0].getLayout().workspace.radius, {
        width: a,
        height: a
      };
    }
  });
  var h = {
    spinners: [],
    get: function (b) {
      if (b) {
        var c = [];
        return a.each(this.spinners, function (d, f) {
          f && (e.isElement(b) ? f.element == b : a(f.element).is(b)) && c.push(f);
        }), c;
      }
    },
    add: function (a) {
      this.spinners.push(a);
    },
    remove: function (b) {
      a(a.map(this.spinners, function (c) {
        if (e.isElement(b) ? c.element == b : a(c.element).is(b)) return c.element;
      })).each(a.proxy(function (a, b) {
        this.removeByElement(b);
      }, this));
    },
    removeByElement: function (b) {
      var c = this.get(b)[0];
      c && (c.remove(), this.spinners = a.grep(this.spinners, function (a) {
        return a.element != b;
      }));
    },
    removeDetached: function () {
      a.each(this.spinners, a.proxy(function (a, b) {
        b && b.element && !e.element.isAttached(b.element) && this.remove(b.element);
      }, this));
    }
  };
  a.extend(c, {
    create: function (b, c) {
      if (b) {
        var f = c || {},
            g = [];
        return e.isElement(b) ? g.push(new d(b, f)) : a(b).each(function (a, b) {
          g.push(new d(b, f));
        }), g;
      }
    }
  }), a.extend(c.prototype, {
    items: function () {
      return h.get(this.element);
    },
    play: function () {
      return a.each(this.items(), function (a, b) {
        b.play();
      }), this;
    },
    stop: function () {
      return a.each(this.items(), function (a, b) {
        b.stop();
      }), this;
    },
    pause: function () {
      return a.each(this.items(), function (a, b) {
        b.pause();
      }), this;
    },
    toggle: function () {
      return a.each(this.items(), function (a, b) {
        b.toggle();
      }), this;
    },
    center: function () {
      return a.each(this.items(), function (a, b) {
        b.center();
      }), this;
    },
    setOptions: function (b) {
      return a.each(this.items(), function (a, c) {
        c.setOptions(b);
      }), this;
    },
    remove: function () {
      return h.remove(this.element), this;
    }
  }), a.extend(d.prototype, {
    setOptions: function (b) {
      this.options = a.extend({}, this.options, b || {}), this.options.radii && (b = this.options.radii, this.options.radius = Math.min(b[0], b[1]), this.options.height = Math.max(b[0], b[1]) - this.options.radius), this.options.dashWidth && (this.options.width = this.options.dashWidth), this.options.speed && (this.options.duration = 1e3 * this.options.speed);
      var b = this._state,
          c = this._position;
      this._layout = null, this.build(), c && c >= this.options.dashes - 1 && (this._position = this.options.dashes - 1);

      switch (b) {
        case "playing":
          this.play();
          break;

        case "paused":
        case "stopped":
          this.drawPosition(this._position);
      }

      this._centered && this.center();
    },
    remove: function () {
      this.canvas && (this.pause(), a(this.canvas).remove(), this.ctx = this.canvas = null);
    },
    build: function () {
      this.remove();
      var b = this.getLayout().workspace.radius;
      return a(document.body).append(this.canvas = a("<canvas>").attr({
        width: 2 * b,
        height: 2 * b
      }).css({
        zoom: 1
      })), window.G_vmlCanvasManager && G_vmlCanvasManager.initElement(this.canvas[0]), this.ctx = this.canvas[0].getContext("2d"), this.ctx.globalAlpha = this.options.opacity, a(this.element).append(this.canvas), this.ctx.translate(b, b), this;
    },
    drawPosition: function (a) {
      var c = this.getLayout().workspace,
          a = e.scroll(c.opacities, -1 * a),
          d = c.radius,
          c = this.options.dashes,
          f = b(360 / c);
      this.ctx.clearRect(-1 * d, -1 * d, 2 * d, 2 * d);

      for (d = 0; d < c; d++) this.drawDash(a[d], this.options.color), this.ctx.rotate(f);
    },
    drawDash: function (a, b) {
      this.ctx.fillStyle = g.hex2fill(b, a);
      var c = this.getLayout(),
          d = c.workspace.radius,
          e = c.dash.position,
          c = c.dash.dimensions;
      f.drawRoundedRectangle(this.ctx, {
        top: e.top - d,
        left: e.left - d,
        width: c.width,
        height: c.height,
        radius: Math.min(c.height, c.width) / 2
      });
    },
    _nextPosition: function () {
      var b = this.options.rotation / this.options.dashes;
      this.nextPosition(), this._playTimer = window.setTimeout(a.proxy(this._nextPosition, this), b);
    },
    nextPosition: function () {
      this._position == this.options.dashes - 1 && (this._position = -1), this._position++, this.drawPosition(this._position);
    },
    play: function () {
      if ("playing" != this._state) {
        this._state = "playing";
        var b = this.options.rotation / this.options.dashes;
        return this._playTimer = window.setTimeout(a.proxy(this._nextPosition, this), b), this;
      }
    },
    pause: function () {
      if ("paused" != this._state) return this._pause(), this._state = "paused", this;
    },
    _pause: function () {
      this._playTimer && (window.clearTimeout(this._playTimer), this._playTimer = null);
    },
    stop: function () {
      if ("stopped" != this._state) return this._pause(), this._position = 0, this.drawPosition(0), this._state = "stopped", this;
    },
    toggle: function () {
      return this["playing" == this._state ? "pause" : "play"](), this;
    },
    getLayout: function () {
      if (this._layout) return this._layout;

      for (var a = this.options, b = a.dashes, c = a.width, d = a.radius, e = a.radius + a.height, f = Math.max(c, e), f = Math.ceil(Math.max(f, Math.sqrt(e * e + c / 2 * (c / 2)))), a = f += a.padding, g = 1 / b, h = [], i = 0; i < b; i++) h.push((i + 1) * g);

      return this._layout = b = {
        workspace: {
          radius: a,
          opacities: h
        },
        dash: {
          position: {
            top: f - e,
            left: f - c / 2
          },
          dimensions: {
            width: c,
            height: e - d
          }
        }
      };
    },
    center: function () {
      var b = 2 * this.getLayout().workspace.radius;
      a(this.element.parentNode).css({
        position: "relative"
      }), a(this.element).css({
        position: "absolute",
        height: b + "px",
        width: b + "px",
        top: "50%",
        left: "50%",
        marginLeft: -0.5 * b + "px",
        marginTop: -0.5 * b + "px"
      }), this._centered = !0;
    }
  }), Spinners.init(), Spinners.enabled || (c.create = function () {
    return [];
  });
})(jQuery);
/*!
 * Tipped - A Complete Javascript Tooltip Solution - v4.7.0
 * (c) 2012-2019 Nick Stakenburg
 *
 * http://www.tippedjs.com
 *
 * @license: https://creativecommons.org/licenses/by/4.0
 */
!function (t, i) {
  "function" == typeof define && define.amd ? define(["jquery"], i) : "object" == typeof module && module.exports ? module.exports = i(require("jquery")) : t.Tipped = i(jQuery);
}(this, function ($) {
  var Tipped = {};
  $.extend(Tipped, {
    version: "4.7.0"
  }), Tipped.Skins = {
    base: {
      afterUpdate: !1,
      ajax: {},
      cache: !0,
      container: !1,
      containment: {
        selector: "viewport",
        padding: 5
      },
      close: !1,
      detach: !0,
      fadeIn: 200,
      fadeOut: 200,
      showDelay: 75,
      hideDelay: 25,
      hideAfter: !1,
      hideOn: {
        element: "mouseleave"
      },
      hideOthers: !1,
      position: "top",
      inline: !1,
      offset: {
        x: 0,
        y: 0
      },
      onHide: !1,
      onShow: !1,
      padding: !0,
      radius: !0,
      shadow: !0,
      showOn: {
        element: "mousemove"
      },
      size: "medium",
      spinner: !0,
      stem: !0,
      target: "element",
      voila: !0
    },
    reset: {
      ajax: !1,
      hideOn: {
        element: "mouseleave",
        tooltip: "mouseleave"
      },
      showOn: {
        element: "mouseenter",
        tooltip: "mouseenter"
      }
    }
  }, $.each("dark light gray red green blue lightyellow lightblue lightpink".split(" "), function (t, i) {
    Tipped.Skins[i] = {};
  });
  var Browser = (e = navigator.userAgent, {
    IE: !(!window.attachEvent || -1 !== e.indexOf("Opera")) && f("MSIE "),
    Opera: -1 < e.indexOf("Opera") && (!!window.opera && opera.version && parseFloat(opera.version()) || 7.55),
    WebKit: -1 < e.indexOf("AppleWebKit/") && f("AppleWebKit/"),
    Gecko: -1 < e.indexOf("Gecko") && -1 === e.indexOf("KHTML") && f("rv:"),
    MobileSafari: !!e.match(/Apple.*Mobile.*Safari/),
    Chrome: -1 < e.indexOf("Chrome") && f("Chrome/"),
    ChromeMobile: -1 < e.indexOf("CrMo") && f("CrMo/"),
    Android: -1 < e.indexOf("Android") && f("Android "),
    IEMobile: -1 < e.indexOf("IEMobile") && f("IEMobile/")
  }),
      e;

  function f(t) {
    var i = new RegExp(t + "([\\d.]+)").exec(e);
    return !i || parseFloat(i[1]);
  }

  var Support = (i = document.createElement("div"), j = "Webkit Moz O ms Khtml".split(" "), {
    css: {
      animation: m("animation"),
      transform: m("transform"),
      prefixed: function (t) {
        return m(t, "prefix");
      }
    },
    shadow: m("boxShadow") && m("pointerEvents"),
    touch: function () {
      try {
        return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
      } catch (t) {
        return !1;
      }
    }()
  }),
      i,
      j;

  function m(t, e) {
    var s = t.charAt(0).toUpperCase() + t.substr(1);
    return function (t, e) {
      for (var s in t) if (void 0 !== i.style[t[s]]) return "prefix" !== e || t[s];

      return !1;
    }((t + " " + j.join(s + " ") + s).split(" "), e);
  }

  var _slice = Array.prototype.slice,
      _ = {
    wrap: function (t, i) {
      var e = t;
      return function () {
        var t = [$.proxy(e, this)].concat(_slice.call(arguments));
        return i.apply(this, t);
      };
    },
    isElement: function (t) {
      return t && 1 === t.nodeType;
    },
    isText: function (t) {
      return t && 3 === t.nodeType;
    },
    isDocumentFragment: function (t) {
      return t && 11 === t.nodeType;
    },
    delay: function (t, i) {
      var e = _slice.call(arguments, 2);

      return setTimeout(function () {
        return t.apply(t, e);
      }, i);
    },
    defer: function (t) {
      return _.delay.apply(this, [t, 1].concat(_slice.call(arguments, 1)));
    },
    pointer: function (t) {
      return {
        x: t.pageX,
        y: t.pageY
      };
    },
    element: {
      isAttached: function (t) {
        var i = function (t) {
          for (var i = t; i && i.parentNode;) i = i.parentNode;

          return i;
        }(t);

        return !(!i || !i.body);
      }
    }
  };

  function degrees(t) {
    return 180 * t / Math.PI;
  }

  function radian(t) {
    return t * Math.PI / 180;
  }

  function sec(t) {
    return 1 / Math.cos(t);
  }

  function sfcc(t) {
    return String.fromCharCode.apply(String, t.replace(" ", "").split(","));
  }

  function deepExtend(t, i) {
    for (var e in i) i[e] && i[e].constructor && i[e].constructor === Object ? (t[e] = $.extend({}, t[e]) || {}, deepExtend(t[e], i[e])) : t[e] = i[e];

    return t;
  }

  var getUID = (U = 0, function (t) {
    for (t = t || "_tipped-uid-", U++; document.getElementById(t + U);) U++;

    return t + U;
  }),
      U,
      Position = {
    positions: ["topleft", "topmiddle", "topright", "righttop", "rightmiddle", "rightbottom", "bottomright", "bottommiddle", "bottomleft", "leftbottom", "leftmiddle", "lefttop"],
    regex: {
      toOrientation: /^(top|left|bottom|right)(top|left|bottom|right|middle|center)$/,
      horizontal: /^(top|bottom)/,
      isCenter: /(middle|center)/,
      side: /^(top|bottom|left|right)/
    },
    toDimension: (X = {
      top: "height",
      left: "width",
      bottom: "height",
      right: "width"
    }, function (t) {
      return X[t];
    }),
    isCenter: function (t) {
      return !!t.toLowerCase().match(this.regex.isCenter);
    },
    isCorner: function (t) {
      return !this.isCenter(t);
    },
    getOrientation: function (t) {
      return t.toLowerCase().match(this.regex.horizontal) ? "horizontal" : "vertical";
    },
    getSide: function (t) {
      var i = null,
          e = t.toLowerCase().match(this.regex.side);
      return e && e[1] && (i = e[1]), i;
    },
    split: function (t) {
      return t.toLowerCase().match(this.regex.toOrientation);
    },
    _flip: {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    },
    flip: function (t, i) {
      var e = this.split(t);
      return i ? this.inverseCornerPlane(this.flip(this.inverseCornerPlane(t))) : this._flip[e[1]] + e[2];
    },
    inverseCornerPlane: function (t) {
      if (Position.isCorner(t)) {
        var i = this.split(t);
        return i[2] + i[1];
      }

      return t;
    },
    adjustOffsetBasedOnPosition: function (t, i, e) {
      var s = $.extend({}, t),
          o = {
        horizontal: "x",
        vertical: "y"
      },
          n = Position.getOrientation(i);

      if (n === Position.getOrientation(e)) {
        if (Position.getSide(i) !== Position.getSide(e)) s[{
          x: "y",
          y: "x"
        }[o[n]]] *= -1;
      } else {
        var r = s.x;
        s.x = s.y, s.y = r;
        var h = {
          top: {
            right: "x"
          },
          bottom: {
            left: "x"
          },
          left: {
            bottom: "y"
          },
          right: {
            top: "y"
          }
        }[Position.getSide(i)][Position.getSide(e)];
        h && (s[h] *= -1), s[o[Position.getOrientation(e)]] = 0;
      }

      return s;
    },
    getBoxFromPoints: function (t, i, e, s) {
      var o = Math.min(t, e),
          n = Math.max(t, e),
          r = Math.min(i, s),
          h = Math.max(i, s);
      return {
        left: o,
        top: r,
        width: Math.max(n - o, 0),
        height: Math.max(h - r, 0)
      };
    },
    isPointWithinBox: function (t, i, e, s, o, n) {
      var r = this.getBoxFromPoints(e, s, o, n);
      return t >= r.left && t <= r.left + r.width && i >= r.top && i <= r.top + r.height;
    },
    isPointWithinBoxLayout: function (t, i, e) {
      return this.isPointWithinBox(t, i, e.position.left, e.position.top, e.position.left + e.dimensions.width, e.position.top + e.dimensions.height);
    },
    getDistance: function (t, i, e, s) {
      return Math.sqrt(Math.pow(Math.abs(e - t), 2) + Math.pow(Math.abs(s - i), 2));
    },
    intersectsLine: function (t, i, e, s, o, n, r, h, a) {
      return a ? (u = ((l = r - o) * (i - n) - (c = h - n) * (t - o)) / (-l * (p = s - i) + (d = e - t) * c), 0 <= (f = (-p * (t - o) + d * (i - n)) / (-l * p + d * c)) && f <= 1 && 0 <= u && u <= 1 && {
        x: t + u * d,
        y: i + u * p
      }) : Sa(t, i, o, n, r, h) != Sa(e, s, o, n, r, h) && Sa(t, i, e, s, o, n) != Sa(t, i, e, s, r, h);
      var d, p, l, c, f, u;
    }
  },
      X;

  function Sa(t, i, e, s, o, n) {
    var r = (n - i) * (e - t) - (s - i) * (o - t);
    return 0 < r || !(r < 0);
  }

  var Bounds = {
    viewport: function () {
      return Browser.MobileSafari || Browser.Android && Browser.Gecko ? {
        width: window.innerWidth,
        height: window.innerHeight
      } : {
        height: $(window).height(),
        width: $(window).width()
      };
    }
  },
      Mouse = {
    _buffer: {
      pageX: 0,
      pageY: 0
    },
    _dimensions: {
      width: 30,
      height: 30
    },
    _shift: {
      x: 2,
      y: 10
    },
    getPosition: function (t) {
      var i = this.getActualPosition(t);
      return {
        left: i.left - Math.round(.5 * this._dimensions.width) + this._shift.x,
        top: i.top - Math.round(.5 * this._dimensions.height) + this._shift.y
      };
    },
    getActualPosition: function (t) {
      var i = t && "number" === $.type(t.pageX) ? t : this._buffer;
      return {
        left: i.pageX,
        top: i.pageY
      };
    },
    getDimensions: function () {
      return this._dimensions;
    }
  },
      Color = (ub = {
    _default: "#000000",
    aqua: "#00ffff",
    black: "#000000",
    blue: "#0000ff",
    fuchsia: "#ff00ff",
    gray: "#808080",
    green: "#008000",
    lime: "#00ff00",
    maroon: "#800000",
    navy: "#000080",
    olive: "#808000",
    purple: "#800080",
    red: "#ff0000",
    silver: "#c0c0c0",
    teal: "#008080",
    white: "#ffffff",
    yellow: "#ffff00"
  }, {
    toRGB: function (t) {
      if (/^rgba?\(/.test(t)) return function (t) {
        return "#" + vb((t = t.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/))[1]) + vb(t[2]) + vb(t[3]);
      }(t);
      ub[t] && (t = ub[t]);
      var i = t.replace("#", "");
      return /^(?:[0-9a-fA-F]{3}){1,2}$/.test(i) ? (3 == i.length && (i = i.charAt(0) + i.charAt(0) + i.charAt(1) + i.charAt(1) + i.charAt(2) + i.charAt(2)), "#" + i) : ub._default;
    }
  }),
      ub;

  function vb(t) {
    return ("0" + parseInt(t).toString(16)).slice(-2);
  }

  function Spin() {
    return this.initialize.apply(this, _slice.call(arguments));
  }

  function Visible() {
    return this.initialize.apply(this, _slice.call(arguments));
  }

  Spin.supported = Support.css.transform && Support.css.animation, $.extend(Spin.prototype, {
    initialize: function () {
      this.options = $.extend({}, arguments[0] || {}), this.build(), this.start();
    },
    build: function () {
      var t = 2 * (this.options.length + this.options.radius),
          i = {
        height: t,
        width: t
      };
      this.element = $("<div>").addClass("tpd-spin").css(i), this.element.append(this._rotate = $("<div>").addClass("tpd-spin-rotate")), this.element.css({
        "margin-left": -.5 * i.width,
        "margin-top": -.5 * i.height
      });

      for (var e = this.options.lines, s = 0; s < e; s++) {
        var o, n;
        this._rotate.append(o = $("<div>").addClass("tpd-spin-frame").append(n = $("<div>").addClass("tpd-spin-line"))), n.css({
          "background-color": this.options.color,
          width: this.options.width,
          height: this.options.length,
          "margin-left": -.5 * this.options.width,
          "border-radius": Math.round(.5 * this.options.width)
        }), o.css({
          opacity: (1 / e * (s + 1)).toFixed(2)
        });
        var r = {};
        r[Support.css.prefixed("transform")] = "rotate(" + 360 / e * (s + 1) + "deg)", o.css(r);
      }
    },
    start: function () {
      var t = {};
      t[Support.css.prefixed("animation")] = "tpd-spin 1s infinite steps(" + this.options.lines + ")", this._rotate.css(t);
    },
    stop: function () {
      var t = {};
      t[Support.css.prefixed("animation")] = "none", this._rotate.css(t), this.element.detach();
    }
  }), $.extend(Visible.prototype, {
    initialize: function (t) {
      return t = "array" == $.type(t) ? t : [t], this.elements = t, this._restore = [], $.each(t, $.proxy(function (t, i) {
        var e = $(i).is(":visible");
        e || $(i).show(), this._restore.push({
          element: i,
          visible: e
        });
      }, this)), this;
    },
    restore: function () {
      $.each(this._restore, function (t, i) {
        i.visible || $(i.element).show();
      }), this._restore = null;
    }
  });

  var AjaxCache = (Qb = [], {
    get: function (t) {
      for (var i = null, e = 0; e < Qb.length; e++) Qb[e] && Qb[e].url === t.url && (Qb[e].type || "GET").toUpperCase() === (t.type || "GET").toUpperCase() && $.param(Qb[e].data || {}) === $.param(t.data || {}) && (i = Qb[e]);

      return i;
    },
    set: function (t, i, e) {
      var s = this.get(t);
      s || (s = $.extend({
        callbacks: {}
      }, t), Qb.push(s)), s.callbacks[i] = e;
    },
    remove: function (t) {
      for (var i = 0; i < Qb.length; i++) Qb[i] && Qb[i].url === t && delete Qb[i];
    },
    clear: function () {
      Qb = [];
    }
  }),
      Qb,
      Voila = function (r) {
    function h(t, i, e) {
      if (!(this instanceof h)) return new h(t, i, e);
      var s = r.type(i),
          o = "object" === s ? i : {},
          n = "function" === s ? i : "function" === r.type(e) && e;
      return this.options = r.extend({
        method: "onload"
      }, o), this.deferred = new jQuery.Deferred(), n && this.always(n), this._processed = 0, this.images = [], this._add(t), this;
    }

    r.extend(h.prototype, {
      _add: function (t) {
        var i = "string" == r.type(t) ? r(t) : t instanceof jQuery || 0 < t.length ? t : [t];
        r.each(i, r.proxy(function (t, i) {
          var e = r(),
              s = r(i);
          (e = s.is("img") ? e.add(s) : e.add(s.find("img"))).each(r.proxy(function (t, i) {
            this.images.push(new o(i, r.proxy(function (t) {
              this._progress(t);
            }, this), r.proxy(function (t) {
              this._progress(t);
            }, this), this.options));
          }, this));
        }, this)), this.images.length < 1 && setTimeout(r.proxy(function () {
          this._resolve();
        }, this));
      },
      abort: function () {
        this._progress = this._notify = this._reject = this._resolve = function () {}, r.each(this.images, function (t, i) {
          i.abort();
        }), this.images = [];
      },
      _progress: function (t) {
        this._processed++, t.isLoaded || (this._broken = !0), this._notify(t), this._processed === this.images.length && this[this._broken ? "_reject" : "_resolve"]();
      },
      _notify: function (t) {
        this.deferred.notify(this, t);
      },
      _reject: function () {
        this.deferred.reject(this);
      },
      _resolve: function () {
        this.deferred.resolve(this);
      },
      always: function (t) {
        return this.deferred.always(t), this;
      },
      done: function (t) {
        return this.deferred.done(t), this;
      },
      fail: function (t) {
        return this.deferred.fail(t), this;
      },
      progress: function (t) {
        return this.deferred.progress(t), this;
      }
    });

    var o = function (n) {
      function t() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
      }

      n.extend(t.prototype, {
        initialize: function () {
          this.options = n.extend({
            test: function () {},
            success: function () {},
            timeout: function () {},
            callAt: !1,
            intervals: [[0, 0], [1e3, 10], [2e3, 50], [4e3, 100], [2e4, 500]]
          }, arguments[0] || {}), this._test = this.options.test, this._success = this.options.success, this._timeout = this.options.timeout, this._ipos = 0, this._time = 0, this._delay = this.options.intervals[this._ipos][1], this._callTimeouts = [], this.poll(), this._createCallsAt();
        },
        poll: function () {
          this._polling = setTimeout(n.proxy(function () {
            if (this._test()) this.success();else {
              if (this._time += this._delay, this._time >= this.options.intervals[this._ipos][0]) {
                if (!this.options.intervals[this._ipos + 1]) return void ("function" == n.type(this._timeout) && this._timeout());
                this._ipos++, this._delay = this.options.intervals[this._ipos][1];
              }

              this.poll();
            }
          }, this), this._delay);
        },
        success: function () {
          this.abort(), this._success();
        },
        _createCallsAt: function () {
          this.options.callAt && n.each(this.options.callAt, n.proxy(function (t, i) {
            var e = i[0],
                s = i[1],
                o = setTimeout(n.proxy(function () {
              s();
            }, this), e);

            this._callTimeouts.push(o);
          }, this));
        },
        _stopCallTimeouts: function () {
          n.each(this._callTimeouts, function (t, i) {
            clearTimeout(i);
          }), this._callTimeouts = [];
        },
        abort: function () {
          this._stopCallTimeouts(), this._polling && (clearTimeout(this._polling), this._polling = null);
        }
      });

      function i() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
      }

      return n.extend(i.prototype, {
        supports: {
          naturalWidth: "naturalWidth" in new Image()
        },
        initialize: function (t, i, e) {
          this.img = n(t)[0], this.successCallback = i, this.errorCallback = e, this.isLoaded = !1, this.options = n.extend({
            method: "onload",
            pollFallbackAfter: 1e3
          }, arguments[3] || {}), "onload" != this.options.method && this.supports.naturalWidth ? this.poll() : this.load();
        },
        poll: function () {
          this._poll = new t({
            test: n.proxy(function () {
              return 0 < this.img.naturalWidth;
            }, this),
            success: n.proxy(function () {
              this.success();
            }, this),
            timeout: n.proxy(function () {
              this.error();
            }, this),
            callAt: [[this.options.pollFallbackAfter, n.proxy(function () {
              this.load();
            }, this)]]
          });
        },
        load: function () {
          this._loading = setTimeout(n.proxy(function () {
            var t = new Image();
            (this._onloadImage = t).onload = n.proxy(function () {
              t.onload = function () {}, this.supports.naturalWidth || (this.img.naturalWidth = t.width, this.img.naturalHeight = t.height, t.naturalWidth = t.width, t.naturalHeight = t.height), this.success();
            }, this), t.onerror = n.proxy(this.error, this), t.src = this.img.src;
          }, this));
        },
        success: function () {
          this._calledSuccess || (this._calledSuccess = !0, this.abort(), this.waitForRender(n.proxy(function () {
            this.isLoaded = !0, this.successCallback(this);
          }, this)));
        },
        error: function () {
          this._calledError || (this._calledError = !0, this.abort(), this._errorRenderTimeout = setTimeout(n.proxy(function () {
            this.errorCallback && this.errorCallback(this);
          }, this)));
        },
        abort: function () {
          this.stopLoading(), this.stopPolling(), this.stopWaitingForRender();
        },
        stopPolling: function () {
          this._poll && (this._poll.abort(), this._poll = null);
        },
        stopLoading: function () {
          this._loading && (clearTimeout(this._loading), this._loading = null), this._onloadImage && (this._onloadImage.onload = function () {}, this._onloadImage.onerror = function () {});
        },
        waitForRender: function (t) {
          this._renderTimeout = setTimeout(t);
        },
        stopWaitingForRender: function () {
          this._renderTimeout && (clearTimeout(this._renderTimeout), this._renderTimeout = null), this._errorRenderTimeout && (clearTimeout(this._errorRenderTimeout), this._errorRenderTimeout = null);
        }
      }), i;
    }(jQuery);

    return h;
  }(jQuery);

  Tipped.Behaviors = {
    hide: {
      showOn: {
        element: "mouseenter",
        tooltip: !1
      },
      hideOn: {
        element: "mouseleave",
        tooltip: "mouseenter"
      }
    },
    mouse: {
      showOn: {
        element: "mouseenter",
        tooltip: !1
      },
      hideOn: {
        element: "mouseleave",
        tooltip: "mouseenter"
      },
      target: "mouse",
      showDelay: 100,
      fadeIn: 0,
      hideDelay: 0,
      fadeOut: 0
    },
    sticky: {
      showOn: {
        element: "mouseenter",
        tooltip: "mouseenter"
      },
      hideOn: {
        element: "mouseleave",
        tooltip: "mouseleave"
      },
      showDelay: 150,
      target: "mouse",
      fixed: !0
    }
  };
  var Options = {
    create: Rc
  },
      Oc,
      Pc;

  function Rc(t) {
    return Oc = Tipped.Skins.base, Pc = deepExtend($.extend({}, Oc), Tipped.Skins.reset), (Rc = Uc)(t);
  }

  function Sc(t) {
    return t.match(/^(top|left|bottom|right)$/) && (t += "middle"), t.replace("center", "middle").replace(" ", ""), t;
  }

  function Tc(t) {
    var i;
    return t.behavior && (i = Tipped.Behaviors[t.behavior]) ? deepExtend($.extend({}, i), t) : t;
  }

  function Uc(t) {
    var i = t.skin ? t.skin : Tooltips.options.defaultSkin,
        e = $.extend({}, Tipped.Skins[i] || {});
    e.skin || (e.skin = Tooltips.options.defaultSkin || "dark");
    var s,
        o = deepExtend($.extend({}, Pc), Tc(e)),
        n = deepExtend($.extend({}, o), Tc(t));

    if (n.ajax) {
      Pc.ajax;
      var r = Oc.ajax;
      "boolean" === $.type(n.ajax) && (n.ajax = {}), n.ajax = deepExtend($.extend({}, r), n.ajax);
    }

    var h = h = n.position && n.position.target || "string" === $.type(n.position) && n.position || Pc.position && Pc.position.target || "string" === $.type(Pc.position) && Pc.position || Oc.position && Oc.position.target || Oc.position;
    h = Sc(h);
    var a,
        d = n.position && n.position.tooltip || Pc.position && Pc.position.tooltip || Oc.position && Oc.position.tooltip || Tooltips.Position.getInversedPosition(h);

    if (d = Sc(d), n.position ? "string" === $.type(n.position) ? (n.position = Sc(n.position), s = {
      target: n.position,
      tooltip: Tooltips.Position.getTooltipPositionFromTarget(n.position)
    }) : (s = {
      tooltip: d,
      target: h
    }, n.position.tooltip && (s.tooltip = Sc(n.position.tooltip)), n.position.target && (s.target = Sc(n.position.target))) : s = {
      tooltip: d,
      target: h
    }, Position.isCorner(s.target) && Position.getOrientation(s.target) !== Position.getOrientation(s.tooltip) && (s.target = Position.inverseCornerPlane(s.target)), "mouse" === n.target) {
      var p = Position.getOrientation(s.target);
      s.target = "horizontal" === p ? s.target.replace(/(left|right)/, "middle") : s.target.replace(/(top|bottom)/, "middle");
    }

    if (n.position = s, "mouse" === n.target ? (a = $.extend({}, Oc.offset), $.extend(a, Tipped.Skins.reset.offset || {}), t.skin && $.extend(a, (Tipped.Skins[t.skin] || Tipped.Skins[Tooltips.options.defaultSkin] || {}).offset || {}), a = Position.adjustOffsetBasedOnPosition(Oc.offset, Oc.position, s.target, !0), t.offset && (a = $.extend(a, t.offset || {}))) : a = {
      x: n.offset.x,
      y: n.offset.y
    }, n.offset = a, n.hideOn && "click-outside" === n.hideOn && (n.hideOnClickOutside = !0, n.hideOn = !1, n.fadeOut = 0), n.showOn) {
      var l = n.showOn;
      "string" === $.type(l) && (l = {
        element: l
      }), n.showOn = l;
    }

    if (n.hideOn) {
      var c = n.hideOn;
      "string" === $.type(c) && (c = {
        element: c
      }), n.hideOn = c;
    }

    return n.inline && "string" !== $.type(n.inline) && (n.inline = !1), Browser.IE && Browser.IE < 9 && $.extend(n, {
      fadeIn: 0,
      fadeOut: 0,
      hideDelay: 0
    }), n.spinner && (Spin.supported ? "boolean" === $.type(n.spinner) && (n.spinner = Pc.spinner || Oc.spinner || {}) : n.spinner = !1), n.container || (n.container = document.body), n.containment && "string" === $.type(n.containment) && (n.containment = {
      selector: n.containment,
      padding: Pc.containment && Pc.containment.padding || Oc.padding && Oc.containment.padding
    }), n.shadow && (n.shadow = Support.shadow), n;
  }

  function Skin() {
    this.initialize.apply(this, _slice.call(arguments));
  }

  function Stem() {
    this.initialize.apply(this, _slice.call(arguments));
  }

  $.extend(Skin.prototype, {
    initialize: function (t) {
      this.tooltip = t, this.element = t._skin;
      var i,
          e,
          s,
          o,
          n = this.tooltip.options;

      this.tooltip._tooltip[(n.shadow ? "remove" : "add") + "Class"]("tpd-no-shadow")[(n.radius ? "remove" : "add") + "Class"]("tpd-no-radius")[(n.stem ? "remove" : "add") + "Class"]("tpd-no-stem");

      var r = Support.css.prefixed("borderTopLeftRadius");
      this.element.append(i = $("<div>").addClass("tpd-frames").append($("<div>").addClass("tpd-frame").append($("<div>").addClass("tpd-backgrounds").append(e = $("<div>").addClass("tpd-background").append(s = $("<div>").addClass("tpd-background-content")))))).append(o = $("<div>").addClass("tpd-spinner")), e.css({
        width: 999,
        height: 999,
        zoom: 1
      }), this._css = {
        border: parseFloat(e.css("border-top-width")),
        radius: parseFloat(r ? e.css(r) : 0),
        padding: parseFloat(t._content.css("padding-top")),
        borderColor: e.css("border-top-color"),
        backgroundColor: s.css("background-color"),
        backgroundOpacity: s.css("opacity"),
        spinner: {
          dimensions: {
            width: o.innerWidth(),
            height: o.innerHeight()
          }
        }
      }, o.remove(), i.remove(), this._side = Position.getSide(t.options.position.tooltip) || "top", this._vars = {};
    },
    destroy: function () {
      this.frames && ($.each("top right bottom left".split(" "), $.proxy(function (t, i) {
        this["stem_" + i] && this["stem_" + i].destroy();
      }, this)), this.frames.remove(), this.frames = null);
    },
    build: function () {
      this.frames || (this.element.append(this.frames = $("<div>").addClass("tpd-frames")), $.each("top right bottom left".split(" "), $.proxy(function (t, i) {
        this.insertFrame(i);
      }, this)), this._spinner || this.tooltip._tooltip.append(this._spinner = $("<div>").addClass("tpd-spinner").hide().append($("<div>").addClass("tpd-spinner-spin"))));
    },
    _frame: function () {
      var e,
          t = $("<div>").addClass("tpd-frame").append(e = $("<div>").addClass("tpd-backgrounds").append($("<div>").addClass("tpd-background-shadow"))).append($("<div>").addClass("tpd-shift-stem").append($("<div>").addClass("tpd-shift-stem-side tpd-shift-stem-side-before")).append($("<div>").addClass("tpd-stem")).append($("<div>").addClass("tpd-shift-stem-side tpd-shift-stem-side-after")));
      return $.each("top right bottom left".split(" "), $.proxy(function (t, i) {
        e.append($("<div>").addClass("tpd-background-box tpd-background-box-" + i).append($("<div>").addClass("tpd-background-box-shift").append($("<div>").addClass("tpd-background-box-shift-further").append($("<div>").addClass("tpd-background").append($("<div>").addClass("tpd-background-title")).append($("<div>").addClass("tpd-background-content"))).append($("<div>").addClass("tpd-background tpd-background-loading")).append($("<div>").addClass("tpd-background-border-hack").hide()))));
      }, this)), t;
    }(),
    _getFrame: function (t) {
      var i = this._frame.clone();

      i.addClass("tpd-frame-" + t), i.find(".tpd-background-shadow").css({
        "border-radius": this._css.radius
      }), this.tooltip.options.stem && i.find(".tpd-stem").attr("data-stem-position", t);
      var e = Math.max(this._css.radius - this._css.border, 0);
      i.find(".tpd-background-title").css({
        "border-top-left-radius": e,
        "border-top-right-radius": e
      }), i.find(".tpd-background-content").css({
        "border-bottom-left-radius": e,
        "border-bottom-right-radius": e
      }), i.find(".tpd-background-loading").css({
        "border-radius": e
      });
      var s = {
        backgroundColor: this._css.borderColor
      };
      s["horizontal" === Position.getOrientation(t) ? "height" : "width"] = this._css.border + "px";
      return s[{
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[t]] = 0, i.find(".tpd-shift-stem-side").css(s), i;
    },
    insertFrame: function (t) {
      var i = this["frame_" + t] = this._getFrame(t);

      if (this.frames.append(i), this.tooltip.options.stem) {
        var e = i.find(".tpd-stem");
        this["stem_" + t] = new Stem(e, this, {});
      }
    },
    startLoading: function () {
      this.tooltip.supportsLoading && (this.build(), this._spinner || this.tooltip.is("resize-to-content") || this.setDimensions(this._css.spinner.dimensions), this._spinner && this._spinner.show());
    },
    stopLoading: function () {
      this.tooltip.supportsLoading && this._spinner && (this.build(), this._spinner.hide());
    },
    updateBackground: function () {
      var t = this._vars.frames[this._side],
          i = $.extend({}, t.background.dimensions);

      if (this.tooltip.title && !this.tooltip.is("loading")) {
        this.element.find(".tpd-background-title, .tpd-background-content").show(), this.element.find(".tpd-background").css({
          "background-color": "transparent"
        });

        var e = $.extend({}, i),
            s = Math.max(this._css.radius - this._css.border, 0),
            o = {
          "border-top-left-radius": s,
          "border-top-right-radius": s,
          "border-bottom-left-radius": s,
          "border-bottom-right-radius": s
        },
            n = new Visible(this.tooltip._tooltip),
            r = this.tooltip._titleWrapper.innerHeight();

        e.height -= r, this.element.find(".tpd-background-title").css({
          height: r,
          width: i.width
        }), o["border-top-left-radius"] = 0, o["border-top-right-radius"] = 0, n.restore(), this.element.find(".tpd-background-content").css(e).css(o), this.element.find(".tpd-background-loading").css({
          "background-color": this._css.backgroundColor
        });
      } else this.element.find(".tpd-background-title, .tpd-background-content").hide(), this.element.find(".tpd-background").css({
        "background-color": this._css.backgroundColor
      });

      this._css.border && (this.element.find(".tpd-background").css({
        "border-color": "transparent"
      }), this.element.find(".tpd-background-border-hack").css({
        width: i.width,
        height: i.height,
        "border-radius": this._css.radius,
        "border-width": this._css.border,
        "border-color": this._css.borderColor
      }).show());
    },
    paint: function () {
      if (!this._paintedDimensions || this._paintedDimensions.width !== this._dimensions.width || this._paintedDimensions.height !== this._dimensions.height || this._paintedStemPosition !== this._stemPosition) {
        this._paintedDimensions = this._dimensions, this._paintedStemPosition = this._stemPosition, this.element.removeClass("tpd-visible-frame-top tpd-visible-frame-bottom tpd-visible-frame-left tpd-visible-frame-right").addClass("tpd-visible-frame-" + this._side);
        var t = this._vars.frames[this._side],
            i = $.extend({}, t.background.dimensions);
        this.element.find(".tpd-background").css(i), this.element.find(".tpd-background-shadow").css({
          width: i.width + 2 * this._css.border,
          height: i.height + 2 * this._css.border
        }), this.updateBackground(), this.element.find(".tpd-background-box-shift, .tpd-background-box-shift-further").removeAttr("style"), this.element.add(this.frames).add(this.tooltip._tooltip).css(t.dimensions);
        var e = this._side,
            s = this._vars.frames[e],
            o = this.element.find(".tpd-frame-" + this._side),
            n = this._vars.frames[e].dimensions;
        o.css(n), o.find(".tpd-backgrounds").css($.extend({}, s.background.position, {
          width: n.width - s.background.position.left,
          height: n.height - s.background.position.top
        }));
        var r = Position.getOrientation(e);
        if (this.tooltip.options.stem) if (o.find(".tpd-shift-stem").css($.extend({}, s.shift.dimensions, s.shift.position)), "vertical" === r) {
          (a = o.find(".tpd-background-box-top, .tpd-background-box-bottom")).css({
            height: this._vars.cut,
            width: this._css.border
          }), o.find(".tpd-background-box-bottom").css({
            top: s.dimensions.height - this._vars.cut
          }).find(".tpd-background-box-shift").css({
            "margin-top": -1 * s.dimensions.height + this._vars.cut
          });
          var h = "right" === e ? s.dimensions.width - s.stemPx - this._css.border : 0;
          a.css({
            left: h
          }).find(".tpd-background-box-shift").css({
            "margin-left": -1 * h
          }), o.find(".tpd-background-box-" + ("left" == e ? "left" : "right")).hide(), "right" === e ? o.find(".tpd-background-box-left").css({
            width: s.dimensions.width - s.stemPx - this._css.border
          }) : o.find(".tpd-background-box-right").css({
            "margin-left": this._css.border
          }).find(".tpd-background-box-shift").css({
            "margin-left": -1 * this._css.border
          }), (d = o.find(".tpd-background-box-" + this._side)).css({
            height: s.dimensions.height - 2 * this._vars.cut,
            "margin-top": this._vars.cut
          }), d.find(".tpd-background-box-shift").css({
            "margin-top": -1 * this._vars.cut
          });
        } else {
          var a;
          (a = o.find(".tpd-background-box-left, .tpd-background-box-right")).css({
            width: this._vars.cut,
            height: this._css.border
          }), o.find(".tpd-background-box-right").css({
            left: s.dimensions.width - this._vars.cut
          }).find(".tpd-background-box-shift").css({
            "margin-left": -1 * s.dimensions.width + this._vars.cut
          });
          var d;
          h = "bottom" === e ? s.dimensions.height - s.stemPx - this._css.border : 0;
          a.css({
            top: h
          }).find(".tpd-background-box-shift").css({
            "margin-top": -1 * h
          }), o.find(".tpd-background-box-" + ("top" === e ? "top" : "bottom")).hide(), "bottom" === e ? o.find(".tpd-background-box-top").css({
            height: s.dimensions.height - s.stemPx - this._css.border
          }) : o.find(".tpd-background-box-bottom").css({
            "margin-top": this._css.border
          }).find(".tpd-background-box-shift").css({
            "margin-top": -1 * this._css.border
          }), (d = o.find(".tpd-background-box-" + this._side)).css({
            width: s.dimensions.width - 2 * this._vars.cut,
            "margin-left": this._vars.cut
          }), d.find(".tpd-background-box-shift").css({
            "margin-left": -1 * this._vars.cut
          });
        }
        var p = t.background,
            l = p.position,
            c = p.dimensions;

        this._spinner.css({
          top: l.top + this._css.border + (.5 * c.height - .5 * this._css.spinner.dimensions.height),
          left: l.left + this._css.border + (.5 * c.width - .5 * this._css.spinner.dimensions.width)
        });
      }
    },
    getVars: function () {
      this._css.padding, this._css.radius;
      var r = this._css.border,
          t = this._vars.maxStemHeight || 0,
          h = $.extend({}, this._dimensions || {}),
          a = {
        frames: {},
        dimensions: h,
        maxStemHeight: t
      };
      a.cut = Math.max(this._css.border, this._css.radius) || 0;
      var d = {
        width: 0,
        height: 0
      },
          i = 0,
          p = 0;
      return this.tooltip.options.stem && (d = this.stem_top.getMath().dimensions.outside, i = this.stem_top._css.offset, p = Math.max(d.height - this._css.border, 0)), a.stemDimensions = d, a.stemOffset = i, $.each("top right bottom left".split(" "), $.proxy(function (t, i) {
        var e = "vertical" === Position.getOrientation(i),
            s = {
          width: h.width + 2 * r,
          height: h.height + 2 * r
        },
            o = s[e ? "height" : "width"] - 2 * a.cut,
            n = {
          dimensions: s,
          stemPx: p,
          position: {
            top: 0,
            left: 0
          },
          background: {
            dimensions: $.extend({}, h),
            position: {
              top: 0,
              left: 0
            }
          }
        };

        switch ((a.frames[i] = n).dimensions[e ? "width" : "height"] += p, "top" !== i && "left" !== i || (n.background.position[i] += p), $.extend(n, {
          shift: {
            position: {
              top: 0,
              left: 0
            },
            dimensions: {
              width: e ? d.height : o,
              height: e ? o : d.height
            }
          }
        }), i) {
          case "top":
          case "bottom":
            n.shift.position.left += a.cut, "bottom" === i && (n.shift.position.top += s.height - r - p);
            break;

          case "left":
          case "right":
            n.shift.position.top += a.cut, "right" === i && (n.shift.position.left += s.width - r - p);
        }
      }, this)), a.connections = {}, $.each(Position.positions, $.proxy(function (t, i) {
        a.connections[i] = this.getConnectionLayout(i, a);
      }, this)), a;
    },
    setDimensions: function (t) {
      this.build();
      var i = this._dimensions;
      i && i.width === t.width && i.height === t.height || (this._dimensions = t, this._vars = this.getVars());
    },
    setSide: function (t) {
      this._side = t, this._vars = this.getVars();
    },
    getConnectionLayout: function (t, i) {
      var e = Position.getSide(t),
          s = Position.getOrientation(t),
          o = (i.dimensions, i.cut),
          n = this["stem_" + e],
          r = i.stemOffset,
          h = this.tooltip.options.stem ? n.getMath().dimensions.outside.width : 0,
          a = o + r + .5 * h,
          d = {
        stem: {}
      },
          p = {
        left: 0,
        right: 0,
        up: 0,
        down: 0
      },
          l = {
        top: 0,
        left: 0
      },
          c = {
        top: 0,
        left: 0
      },
          f = i.frames[e];
      a = 0;

      if ("horizontal" == s) {
        var u = f.dimensions.width;
        this.tooltip.options.stem && ((u = f.shift.dimensions.width) - h < 2 * r && (r = Math.floor(.5 * (u - h)) || 0), a = o + r + .5 * h);
        var m = u - 2 * r,
            g = r;

        switch ((v = Position.split(t))[2]) {
          case "left":
            p.right = m - h, l.left = a;
            break;

          case "middle":
            g += Math.round(.5 * m - .5 * h), p.left = g - r, p.right = g - r, l.left = c.left = Math.round(.5 * f.dimensions.width);
            break;

          case "right":
            g += m - h, p.left = m - h, l.left = f.dimensions.width - a, c.left = f.dimensions.width;
        }

        "bottom" === v[1] && (l.top += f.dimensions.height, c.top += f.dimensions.height), $.extend(d.stem, {
          position: {
            left: g
          },
          before: {
            width: g
          },
          after: {
            left: g + h,
            width: u - g - h + 1
          }
        });
      } else {
        var b = f.dimensions.height;
        this.tooltip.options.stem && ((b = f.shift.dimensions.height) - h < 2 * r && (r = Math.floor(.5 * (b - h)) || 0), a = o + r + .5 * h);

        var v,
            _ = b - 2 * r,
            x = r;

        switch ((v = Position.split(t))[2]) {
          case "top":
            p.down = _ - h, l.top = a;
            break;

          case "middle":
            x += Math.round(.5 * _ - .5 * h), p.up = x - r, p.down = x - r, l.top = c.top = Math.round(.5 * f.dimensions.height);
            break;

          case "bottom":
            x += _ - h, p.up = _ - h, l.top = f.dimensions.height - a, c.top = f.dimensions.height;
        }

        "right" === v[1] && (l.left += f.dimensions.width, c.left += f.dimensions.width), $.extend(d.stem, {
          position: {
            top: x
          },
          before: {
            height: x
          },
          after: {
            top: x + h,
            height: b - x - h + 1
          }
        });
      }

      return d.move = p, d.stem.connection = l, d.connection = c, d;
    },
    setStemPosition: function (t, i) {
      if (this._stemPosition !== t) {
        this._stemPosition = t;
        var e = Position.getSide(t);
        this.setSide(e);
      }

      this.tooltip.options.stem && this.setStemShift(t, i);
    },
    setStemShift: function (t, i) {
      var e = this._shift,
          s = this._dimensions;

      if (!e || e.stemPosition !== t || e.shift.x !== i.x || e.shift.y !== i.y || !s || e.dimensions.width !== s.width || e.dimensions.height !== s.height) {
        this._shift = {
          stemPosition: t,
          shift: i,
          dimensions: s
        };
        var o = Position.getSide(t),
            n = {
          horizontal: "x",
          vertical: "y"
        }[Position.getOrientation(t)],
            r = {
          x: {
            left: "left",
            width: "width"
          },
          y: {
            left: "top",
            width: "height"
          }
        }[n],
            h = this["stem_" + o],
            a = deepExtend({}, this._vars.connections[t].stem);
        i && 0 !== i[n] && (a.before[r.width] += i[n], a.position[r.left] += i[n], a.after[r.left] += i[n], a.after[r.width] -= i[n]), h.element.css(a.position), h.element.siblings(".tpd-shift-stem-side-before").css(a.before), h.element.siblings(".tpd-shift-stem-side-after").css(a.after);
      }
    }
  }), $.extend(Stem.prototype, {
    initialize: function (t, i) {
      this.element = $(t), this.element[0] && (this.skin = i, this.element.removeClass("tpd-stem-reset"), this._css = $.extend({}, i._css, {
        width: this.element.innerWidth(),
        height: this.element.innerHeight(),
        offset: parseFloat(this.element.css("margin-left")),
        spacing: parseFloat(this.element.css("margin-top"))
      }), this.element.addClass("tpd-stem-reset"), this.options = $.extend({}, arguments[2] || {}), this._position = this.element.attr("data-stem-position") || "top", this._m = 100, this.build());
    },
    destroy: function () {
      this.element.html("");
    },
    build: function () {
      this.destroy();
      var t = this._css.backgroundColor,
          i = -1 < t.indexOf("rgba") && parseFloat(t.replace(/^.*,(.+)\)/, "$1")),
          e = i && i < 1;
      this._useTransform = e && Support.css.transform, this._css.border || (this._useTransform = !1), this[(this._useTransform ? "build" : "buildNo") + "Transform"]();
    },
    buildTransform: function () {
      this.element.append(this.spacer = $("<div>").addClass("tpd-stem-spacer").append(this.downscale = $("<div>").addClass("tpd-stem-downscale").append(this.transform = $("<div>").addClass("tpd-stem-transform").append(this.first = $("<div>").addClass("tpd-stem-side").append(this.border = $("<div>").addClass("tpd-stem-border")).append($("<div>").addClass("tpd-stem-border-corner")).append($("<div>").addClass("tpd-stem-triangle")))))), this.transform.append(this.last = this.first.clone().addClass("tpd-stem-side-inversed")), this.sides = this.first.add(this.last);
      var t = this.getMath(),
          i = t.dimensions,
          e = this._m,
          s = Position.getSide(this._position);

      if (this.element.find(".tpd-stem-spacer").css({
        width: l ? i.inside.height : i.inside.width,
        height: l ? i.inside.width : i.inside.height
      }), "top" === s || "left" === s) {
        var o = {};
        "top" === s ? (o.bottom = 0, o.top = "auto") : "left" === s && (o.right = 0, o.left = "auto"), this.element.find(".tpd-stem-spacer").css(o);
      }

      this.transform.css({
        width: i.inside.width * e,
        height: i.inside.height * e
      });
      var n = Support.css.prefixed("transform"),
          r = {
        "background-color": "transparent",
        "border-bottom-color": this._css.backgroundColor,
        "border-left-width": .5 * i.inside.width * e,
        "border-bottom-width": i.inside.height * e
      };
      r[n] = "translate(" + t.border * e + "px, 0)", this.element.find(".tpd-stem-triangle").css(r);
      var h = this._css.borderColor;
      alpha = -1 < h.indexOf("rgba") && parseFloat(h.replace(/^.*,(.+)\)/, "$1")), alpha && alpha < 1 ? h = (h.substring(0, h.lastIndexOf(",")) + ")").replace("rgba", "rgb") : alpha = 1;
      var a = {
        "background-color": "transparent",
        "border-right-width": t.border * e,
        width: t.border * e,
        "margin-left": -2 * t.border * e,
        "border-color": h,
        opacity: alpha
      };
      a[n] = "skew(" + t.skew + "deg) translate(" + t.border * e + "px, " + -1 * this._css.border * e + "px)", this.element.find(".tpd-stem-border").css(a);
      h = this._css.borderColor;
      alpha = -1 < h.indexOf("rgba") && parseFloat(h.replace(/^.*,(.+)\)/, "$1")), alpha && alpha < 1 ? h = (h.substring(0, h.lastIndexOf(",")) + ")").replace("rgba", "rgb") : alpha = 1;
      var d = {
        width: t.border * e,
        "border-right-width": t.border * e,
        "border-right-color": h,
        background: h,
        opacity: alpha,
        "margin-left": -2 * t.border * e
      };

      if (d[n] = "skew(" + t.skew + "deg) translate(" + t.border * e + "px, " + (i.inside.height - this._css.border) * e + "px)", this.element.find(".tpd-stem-border-corner").css(d), this.setPosition(this._position), 1 < e) {
        var p = {};
        p[n] = "scale(" + 1 / e + "," + 1 / e + ")", this.downscale.css(p);
      }

      var l = /^(left|right)$/.test(this._position);
      this._css.border || this.element.find(".tpd-stem-border, .tpd-stem-border-corner").hide(), this.element.css({
        width: l ? i.outside.height : i.outside.width,
        height: l ? i.outside.width : i.outside.height
      });
    },
    buildNoTransform: function () {
      this.element.append(this.spacer = $("<div>").addClass("tpd-stem-spacer").append($("<div>").addClass("tpd-stem-notransform").append($("<div>").addClass("tpd-stem-border").append($("<div>").addClass("tpd-stem-border-corner")).append($("<div>").addClass("tpd-stem-border-center-offset").append($("<div>").addClass("tpd-stem-border-center-offset-inverse").append($("<div>").addClass("tpd-stem-border-center"))))).append($("<div>").addClass("tpd-stem-triangle"))));
      var t = this.getMath(),
          i = t.dimensions,
          e = /^(left|right)$/.test(this._position),
          s = /^(bottom)$/.test(this._position),
          o = /^(right)$/.test(this._position),
          n = Position.getSide(this._position);

      if (this.element.css({
        width: e ? i.outside.height : i.outside.width,
        height: e ? i.outside.width : i.outside.height
      }), this.element.find(".tpd-stem-notransform").add(this.element.find(".tpd-stem-spacer")).css({
        width: e ? i.inside.height : i.inside.width,
        height: e ? i.inside.width : i.inside.height
      }), "top" === n || "left" === n) {
        var r = {};
        "top" === n ? (r.bottom = 0, r.top = "auto") : "left" === n && (r.right = 0, r.left = "auto"), this.element.find(".tpd-stem-spacer").css(r);
      }

      this.element.find(".tpd-stem-border").css({
        width: "100%",
        background: "transparent"
      });
      var h = {
        opacity: 1
      };
      h[e ? "height" : "width"] = "100%", h[e ? "width" : "height"] = this._css.border, h[s ? "top" : "bottom"] = 0, $.extend(h, o ? {
        left: 0
      } : {
        right: 0
      }), this.element.find(".tpd-stem-border-corner").css(h);
      var a = {
        width: 0,
        "background-color": "transparent",
        opacity: 1
      },
          d = .5 * i.inside.width + "px solid transparent",
          p = {
        "background-color": "transparent"
      };
      i.inside.width, t.border;

      if (e) {
        l = {
          left: "auto",
          top: "50%",
          "margin-top": -.5 * i.inside.width,
          "border-top": d,
          "border-bottom": d
        };
        $.extend(a, l), a[o ? "right" : "left"] = 0, a[o ? "border-left" : "border-right"] = i.inside.height + "px solid " + this._css.borderColor, $.extend(p, l), p[o ? "border-left" : "border-right"] = i.inside.height + "px solid " + this._css.backgroundColor, p[o ? "right" : "left"] = t.top, p[o ? "left" : "right"] = "auto", this.element.find(".tpd-stem-border-center-offset").css({
          "margin-left": -1 * this._css.border * (o ? -1 : 1)
        }).find(".tpd-stem-border-center-offset-inverse").css({
          "margin-left": this._css.border * (o ? -1 : 1)
        });
      } else {
        var l = {
          "margin-left": -.5 * i.inside.width,
          "border-left": d,
          "border-right": d
        };
        $.extend(a, l), a[s ? "border-top" : "border-bottom"] = i.inside.height + "px solid " + this._css.borderColor, $.extend(p, l), p[s ? "border-top" : "border-bottom"] = i.inside.height + "px solid " + this._css.backgroundColor, p[s ? "bottom" : "top"] = t.top, p[s ? "top" : "bottom"] = "auto", this.element.find(".tpd-stem-border-center-offset").css({
          "margin-top": -1 * this._css.border * (s ? -1 : 1)
        }).find(".tpd-stem-border-center-offset-inverse").css({
          "margin-top": this._css.border * (s ? -1 : 1)
        });
      }

      this.element.find(".tpd-stem-border-center").css(a), this.element.find(".tpd-stem-border-corner").css({
        "background-color": this._css.borderColor
      }), this.element.find(".tpd-stem-triangle").css(p), this._css.border || this.element.find(".tpd-stem-border").hide();
    },
    setPosition: function (t) {
      this._position = t, this.transform.attr("class", "tpd-stem-transform tpd-stem-transform-" + t);
    },
    getMath: function () {
      var t = this._css.height,
          i = this._css.width,
          e = this._css.border;
      this._useTransform && Math.floor(i) % 2 && (i = Math.max(Math.floor(i) - 1, 0));
      var s = degrees(Math.atan(.5 * i / t)),
          o = 90 - s,
          n = {
        width: i + 2 * (e / Math.cos((90 - o) * Math.PI / 180)),
        height: t + (c = e / Math.cos((90 - s) * Math.PI / 180))
      };
      Math.max(e, this._css.radius);
      t = n.height, i = .5 * n.width;
      var r = 90 - degrees(Math.atan(t / i)),
          h = e / Math.cos(r * Math.PI / 180),
          a = 180 * Math.atan(t / i) / Math.PI,
          d = -1 * (90 - a),
          p = 90 - a,
          l = e * Math.tan(p * Math.PI / 180),
          c = e / Math.cos((90 - p) * Math.PI / 180),
          f = $.extend({}, n),
          u = $.extend({}, n);
      u.height += this._css.spacing, u.height = Math.ceil(u.height);
      var m = !0;
      return n.width <= 2 * e && (m = !1), {
        enabled: m,
        outside: u,
        dimensions: {
          inside: f,
          outside: u
        },
        top: c,
        border: h,
        skew: d,
        corner: l
      };
    }
  });
  var Tooltips = {
    tooltips: {},
    options: {
      defaultSkin: "dark",
      startingZIndex: 999999
    },
    _emptyClickHandler: function () {},
    init: function () {
      this.reset(), this._resizeHandler = $.proxy(this.onWindowResize, this), $(window).bind("resize orientationchange", this._resizeHandler), Browser.MobileSafari && $("body").bind("click", this._emptyClickHandler);
    },
    reset: function () {
      Tooltips.removeAll(), Delegations.removeAll(), this._resizeHandler && $(window).unbind("resize orientationchange", this._resizeHandler), Browser.MobileSafari && $("body").unbind("click", this._emptyClickHandler);
    },
    onWindowResize: function () {
      this._resizeTimer && (window.clearTimeout(this._resizeTimer), this._resizeTimer = null), this._resizeTimer = _.delay($.proxy(function () {
        var t = this.getVisible();
        $.each(t, function (t, i) {
          i.clearUpdatedTo(), i.position();
        });
      }, this), 15);
    },
    _getTooltips: function (t, i) {
      var e,
          s = [],
          o = [];

      if (_.isElement(t) ? (e = $(t).data("tipped-uids")) && (s = s.concat(e)) : $(t).each(function (t, i) {
        (e = $(i).data("tipped-uids")) && (s = s.concat(e));
      }), !s[0] && !i) {
        var n = this.getTooltipByTooltipElement($(t).closest(".tpd-tooltip")[0]);
        n && n.element && (e = $(n.element).data("tipped-uids") || []) && (s = s.concat(e));
      }

      return 0 < s.length && $.each(s, $.proxy(function (t, i) {
        var e;
        (e = this.tooltips[i]) && o.push(e);
      }, this)), o;
    },
    findElement: function (t) {
      var i = [];
      return _.isElement(t) && (i = this._getTooltips(t)), i[0] && i[0].element;
    },
    get: function (e) {
      var t = $.extend({
        api: !1
      }, arguments[1] || {}),
          s = [];
      return _.isElement(e) ? s = this._getTooltips(e) : e instanceof $ ? e.each($.proxy(function (t, i) {
        var e = this._getTooltips(i, !0);

        0 < e.length && (s = s.concat(e));
      }, this)) : "string" === $.type(e) && $.each(this.tooltips, function (t, i) {
        i.element && $(i.element).is(e) && s.push(i);
      }), t.api && $.each(s, function (t, i) {
        i.is("api", !0);
      }), s;
    },
    getTooltipByTooltipElement: function (e) {
      if (!e) return null;
      var s = null;
      return $.each(this.tooltips, function (t, i) {
        i.is("build") && i._tooltip[0] === e && (s = i);
      }), s;
    },
    getBySelector: function (e) {
      var s = [];
      return $.each(this.tooltips, function (t, i) {
        i.element && $(i.element).is(e) && s.push(i);
      }), s;
    },
    getNests: function () {
      var e = [];
      return $.each(this.tooltips, function (t, i) {
        i.is("nest") && e.push(i);
      }), e;
    },
    show: function (t) {
      $(this.get(t)).each(function (t, i) {
        i.show(!1, !0);
      });
    },
    hide: function (t) {
      $(this.get(t)).each(function (t, i) {
        i.hide();
      });
    },
    toggle: function (t) {
      $(this.get(t)).each(function (t, i) {
        i.toggle();
      });
    },
    hideAll: function (e) {
      $.each(this.getVisible(), function (t, i) {
        e && e === i || i.hide();
      });
    },
    refresh: function (t) {
      var i;
      i = t ? $.grep(this.get(t), function (t, i) {
        return t.is("visible");
      }) : this.getVisible(), $.each(i, function (t, i) {
        i.refresh();
      });
    },
    getVisible: function () {
      var e = [];
      return $.each(this.tooltips, function (t, i) {
        i.visible() && e.push(i);
      }), e;
    },
    isVisibleByElement: function (e) {
      var s = !1;
      return _.isElement(e) && $.each(this.getVisible() || [], function (t, i) {
        if (i.element === e) return !(s = !0);
      }), s;
    },
    getHighestTooltip: function () {
      var e,
          s = 0;
      return $.each(this.tooltips, function (t, i) {
        i.zIndex > s && (s = i.zIndex, e = i);
      }), e;
    },
    resetZ: function () {
      this.getVisible().length <= 1 && $.each(this.tooltips, function (t, i) {
        i.is("build") && !i.options.zIndex && i._tooltip.css({
          zIndex: i.zIndex = +Tooltips.options.startingZIndex
        });
      });
    },
    clearAjaxCache: function () {
      $.each(this.tooltips, $.proxy(function (t, i) {
        i.options.ajax && (i._cache && i._cache.xhr && (i._cache.xhr.abort(), i._cache.xhr = null), i.is("updated", !1), i.is("updating", !1), i.is("sanitized", !1));
      }, this)), AjaxCache.clear();
    },
    add: function (t) {
      this.tooltips[t.uid] = t;
    },
    remove: function (t) {
      var i = this._getTooltips(t);

      this.removeTooltips(i);
    },
    removeTooltips: function (t) {
      t && $.each(t, $.proxy(function (t, i) {
        var e = i.uid;
        delete this.tooltips[e], i.remove();
      }, this));
    },
    removeDetached: function () {
      var t = this.getNests(),
          e = [];
      0 < t.length && $.each(t, function (t, i) {
        i.is("detached") && (e.push(i), i.attach());
      }), $.each(this.tooltips, $.proxy(function (t, i) {
        i.element && !_.element.isAttached(i.element) && this.remove(i.element);
      }, this)), $.each(e, function (t, i) {
        i.detach();
      });
    },
    removeAll: function () {
      $.each(this.tooltips, $.proxy(function (t, i) {
        i.element && this.remove(i.element);
      }, this)), this.tooltips = {};
    },
    setDefaultSkin: function (t) {
      this.options.defaultSkin = t || "dark";
    },
    setStartingZIndex: function (t) {
      this.options.startingZIndex = t || 0;
    }
  };

  function Tooltip() {
    this.initialize.apply(this, _slice.call(arguments));
  }

  Tooltips.Position = {
    inversedPosition: {
      left: "right",
      right: "left",
      top: "bottom",
      bottom: "top",
      middle: "middle",
      center: "center"
    },
    getInversedPosition: function (t) {
      var i = Position.split(t),
          e = i[1],
          s = i[2],
          o = Position.getOrientation(t),
          n = $.extend({
        horizontal: !0,
        vertical: !0
      }, arguments[1] || {});
      return "horizontal" === o ? (n.vertical && (e = this.inversedPosition[e]), n.horizontal && (s = this.inversedPosition[s])) : (n.vertical && (s = this.inversedPosition[s]), n.horizontal && (e = this.inversedPosition[e])), e + s;
    },
    getTooltipPositionFromTarget: function (t) {
      var i = Position.split(t);
      return this.getInversedPosition(i[1] + this.inversedPosition[i[2]]);
    }
  }, $.extend(Tooltip.prototype, {
    supportsLoading: Support.css.transform && Support.css.animation,
    initialize: function (element, content) {
      if (this.element = element, this.element) {
        var options;
        "object" !== $.type(content) || _.isElement(content) || _.isText(content) || _.isDocumentFragment(content) || content instanceof $ ? options = arguments[2] || {} : (options = content, content = null);
        var dataOptions = $(element).data("tipped-options");
        dataOptions && (options = deepExtend($.extend({}, options), eval("({" + dataOptions + "})"))), this.options = Options.create(options), this._cache = {
          dimensions: {
            width: 0,
            height: 0
          },
          events: [],
          timers: {},
          layouts: {},
          is: {},
          fnCallFn: "",
          updatedTo: {}
        }, this.queues = {
          showhide: $({})
        };
        var title = $(element).attr("title") || $(element).data("tipped-restore-title");

        if (!content) {
          var dt = $(element).attr("data-tipped");

          if (dt ? content = dt : title && (content = title), content) {
            var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
            content = content.replace(SCRIPT_REGEX, "");
          }
        }

        if (!(!content || content instanceof $ && !content[0]) || this.options.ajax && this.options.ajax.url || this.options.inline) {
          title && ($(element).data("tipped-restore-title", title), $(element)[0].setAttribute("title", "")), this.content = content, this.title = $(this.element).data("tipped-title"), "undefined" != $.type(this.options.title) && (this.title = this.options.title), this.zIndex = this.options.zIndex || +Tooltips.options.startingZIndex;
          var uids = $(element).data("tipped-uids");
          uids = uids || [];
          var uid = getUID();
          this.uid = uid, uids.push(uid), $(element).data("tipped-uids", uids);
          var parentTooltipElement = $(this.element).closest(".tpd-tooltip")[0],
              parentTooltip;
          parentTooltipElement && (parentTooltip = Tooltips.getTooltipByTooltipElement(parentTooltipElement)) && parentTooltip.is("nest", !0);
          var target = this.options.target;
          this.target = "mouse" === target ? this.element : "element" !== target && target ? _.isElement(target) ? target : target instanceof $ && target[0] ? target[0] : this.element : this.element, this.options.inline && (this.content = $("#" + this.options.inline)[0]), this.options.ajax && (this.__content = this.content), "function" === $.type(this.content) && (this._fn = this.content), this.preBuild(), Tooltips.add(this);
        } else this._aborted = !0;
      }
    },
    remove: function () {
      this.unbind(), this.clearTimers(), this.restoreElementToMarker(), this.stopLoading(), this.abort(), this.is("build") && this._tooltip && (this._tooltip.remove(), this._tooltip = null);
      var t = $(this.element).data("tipped-uids") || [],
          i = $.inArray(this.uid, t);

      if (-1 < i && (t.splice(i, 1), $(this.element).data("tipped-uids", t)), t.length < 1) {
        var e,
            s = "tipped-restore-title";
        (e = $(this.element).data(s)) && ("" != !$(this.element)[0].getAttribute("title") && $(this.element).attr("title", e), $(this.element).removeData(s)), $(this.element).removeData("tipped-uids");
      }

      var o = ($(this.element).attr("class") || "").replace(/(tpd-delegation-uid-)\d+/g, "").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      $(this.element).attr("class", o);
    },
    detach: function () {
      this.options.detach && !this.is("detached") && (this._tooltip && this._tooltip.detach(), this.is("detached", !0));
    },
    attach: function () {
      if (this.is("detached")) {
        var t;

        if ("string" === $.type(this.options.container)) {
          var i = this.target;
          "mouse" === i && (i = this.element), t = $($(i).closest(this.options.container).first());
        } else t = $(this.options.container);

        t[0] || (t = $(document.body)), t.append(this._tooltip), this.is("detached", !1);
      }
    },
    preBuild: function () {
      this.is("detached", !0);
      var t = {
        left: "-10000px",
        top: "-10000px",
        opacity: 0,
        zIndex: this.zIndex
      };
      this._tooltip = $("<div>").addClass("tpd-tooltip").addClass("tpd-skin-" + this.options.skin).addClass("tpd-size-" + this.options.size).css(t).hide(), this.createPreBuildObservers();
    },
    build: function () {
      this.is("build") || (this.attach(), this._tooltip.append(this._skin = $("<div>").addClass("tpd-skin")).append(this._contentWrapper = $("<div>").addClass("tpd-content-wrapper").append(this._contentSpacer = $("<div>").addClass("tpd-content-spacer").append(this._titleWrapper = $("<div>").addClass("tpd-title-wrapper").append(this._titleSpacer = $("<div>").addClass("tpd-title-spacer").append(this._titleRelative = $("<div>").addClass("tpd-title-relative").append(this._titleRelativePadder = $("<div>").addClass("tpd-title-relative-padder").append(this._title = $("<div>").addClass("tpd-title"))))).append(this._close = $("<div>").addClass("tpd-close").append($("<div>").addClass("tpd-close-icon").html("&times;")))).append(this._contentRelative = $("<div>").addClass("tpd-content-relative").append(this._contentRelativePadder = $("<div>").addClass("tpd-content-relative-padder").append(this._content = $("<div>").addClass("tpd-content"))).append(this._inner_close = $("<div>").addClass("tpd-close").append($("<div>").addClass("tpd-close-icon").html("&times;")))))), this.skin = new Skin(this), this._contentSpacer.css({
        "border-radius": Math.max(this.skin._css.radius - this.skin._css.border, 0)
      }), this.createPostBuildObservers(), this.is("build", !0));
    },
    createPostBuildObservers: function () {
      this._tooltip.delegate(".tpd-close, .close-tooltip", "click", $.proxy(function (t) {
        t.stopPropagation(), t.preventDefault(), this.is("api", !1), this.hide(!0);
      }, this));
    },
    createPreBuildObservers: function () {
      this.bind(this.element, "mouseenter", this.setActive), this.bind(this._tooltip, Support.touch && Browser.MobileSafari ? "touchstart" : "mouseenter", this.setActive), this.bind(this.element, "mouseleave", function (t) {
        this.setIdle(t);
      }), this.bind(this._tooltip, "mouseleave", function (t) {
        this.setIdle(t);
      }), this.options.showOn && ($.each(this.options.showOn, $.proxy(function (t, i) {
        var e,
            s = !1;

        switch (t) {
          case "element":
            e = this.element, this.options.hideOn && this.options.showOn && "click" === this.options.hideOn.element && "click" === this.options.showOn.element && (s = !0, this.is("toggleable", s));
            break;

          case "tooltip":
            e = this._tooltip;
            break;

          case "target":
            e = this.target;
        }

        if (e && i) {
          var o = i;
          this.bind(e, o, "click" === i && s ? function (t) {
            this.is("api", !1), this.toggle();
          } : function (t) {
            this.is("api", !1), this.showDelayed();
          });
        }
      }, this)), Support.touch && Browser.MobileSafari && this.bind(this._tooltip, "touchend", function () {
        this._tooltipTouchEndTime = new Date().getTime();
      })), this.options.hideOn && $.each(this.options.hideOn, $.proxy(function (t, i) {
        var e;

        switch (t) {
          case "element":
            if (this.is("toggleable") && "click" === i) return;
            e = this.element;
            break;

          case "tooltip":
            e = this._tooltip;
            break;

          case "target":
            e = this.target;
        }

        if (e && i) {
          var s = i;
          Support.touch && Browser.MobileSafari && /^(target|element)/.test(t) && /mouse(leave|out)/.test(s) ? this.bind(e, s, function (t) {
            if (this._tooltipTouchEndTime && /^mouse(leave|out)$/.test(t.type) && new Date().getTime() - this._tooltipTouchEndTime < 450) return;
            this.is("api", !1), this.hideDelayed();
          }) : this.bind(e, s, function (t) {
            this.is("api", !1), this.hideDelayed();
          });
        }
      }, this)), this.options.hideOnClickOutside && ($(this.element).addClass("tpd-hideOnClickOutside"), this.bind(document.documentElement, "click touchend", $.proxy(function (t) {
        if (this.visible()) {
          var i = $(t.target).closest(".tpd-tooltip, .tpd-hideOnClickOutside")[0];
          (!i || i && i !== this._tooltip[0] && i !== this.element) && this.hide();
        }
      }, this))), "mouse" === this.options.target && this.bind(this.element, "mouseenter mousemove", $.proxy(function (t) {
        this._cache.event = t;
      }, this));
      var t = !1;
      this.options.showOn && "mouse" === this.options.target && !this.options.fixed && (t = !0), t && this.bind(this.element, "mousemove", function (t) {
        this.is("build") && (this.is("api", !1), this.position());
      });
    }
  }), $.extend(Tooltip.prototype, {
    stop: function () {
      this._tooltip && (this.queues.showhide.queue([]), this._tooltip.stop(1, 0));
    },
    showDelayed: function (t) {
      this.is("disabled") || (this.clearTimer("hide"), this.is("visible") || this.getTimer("show") || this.setTimer("show", $.proxy(function () {
        this.clearTimer("show"), this.show();
      }, this), this.options.showDelay || 1));
    },
    show: function () {
      if (this.clearTimer("hide"), !this.visible() && !this.is("disabled") && $(this.target).is(":visible")) {
        this.is("visible", !0), this.attach(), this.stop();
        var t = this.queues.showhide;
        this.is("updated") || this.is("updating") || t.queue($.proxy(function (i) {
          this._onResizeDimensions = {
            width: 0,
            height: 0
          }, this.update($.proxy(function (t) {
            if (t) return this.is("visible", !1), void this.detach();
            i();
          }, this));
        }, this)), t.queue($.proxy(function (t) {
          this.is("sanitized") ? (this.stopLoading(), this._contentWrapper.css({
            visibility: "visible"
          }), this.is("resize-to-content", !0), t()) : (this._contentWrapper.css({
            visibility: "hidden"
          }), this.startLoading(), this.sanitize($.proxy(function () {
            this.stopLoading(), this._contentWrapper.css({
              visibility: "visible"
            }), this.is("resize-to-content", !0), t();
          }, this)));
        }, this)), t.queue($.proxy(function (t) {
          this.position(), this.raise(), t();
        }, this)), t.queue($.proxy(function (t) {
          if (this.is("updated") && "function" === $.type(this.options.onShow)) {
            var i = new Visible(this._tooltip);
            this.options.onShow(this._content[0], this.element), i.restore(), t();
          } else t();
        }, this)), t.queue($.proxy(function (t) {
          this._show(this.options.fadeIn, function () {
            t();
          });
        }, this));
      }
    },
    _show: function (t, i) {
      t = ("number" === $.type(t) ? t : this.options.fadeIn) || 0, i = i || "function" == $.type(t) && t, this.options.hideOthers && Tooltips.hideAll(this), this._tooltip.fadeTo(t, 1, $.proxy(function () {
        i && i();
      }, this));
    },
    hideDelayed: function () {
      this.clearTimer("show"), this.getTimer("hide") || !this.visible() || this.is("disabled") || this.setTimer("hide", $.proxy(function () {
        this.clearTimer("hide"), this.hide();
      }, this), this.options.hideDelay || 1);
    },
    hide: function (i, e) {
      if (this.clearTimer("show"), this.visible() && !this.is("disabled")) {
        this.is("visible", !1), this.stop();
        var t = this.queues.showhide;
        t.queue($.proxy(function (t) {
          this.abort(), t();
        }, this)), t.queue($.proxy(function (t) {
          this._hide(i, t);
        }, this)), t.queue(function (t) {
          Tooltips.resetZ(), t();
        }), t.queue($.proxy(function (t) {
          this.clearUpdatedTo(), t();
        }, this)), "function" === $.type(this.options.afterHide) && this.is("updated") && t.queue($.proxy(function (t) {
          this.options.afterHide(this._content[0], this.element), t();
        }, this)), this.options.cache || !this.options.ajax && !this._fn || t.queue($.proxy(function (t) {
          this.is("updated", !1), this.is("updating", !1), this.is("sanitized", !1), t();
        }, this)), "function" === $.type(e) && t.queue(function (t) {
          e(), t();
        }), t.queue($.proxy(function (t) {
          this.detach(), t();
        }, this));
      }
    },
    _hide: function (t, i) {
      i = i || "function" === $.type(t) && t, this.attach(), this._tooltip.fadeTo(t ? 0 : this.options.fadeOut, 0, $.proxy(function () {
        this.stopLoading(), this.is("resize-to-content", !1), this._tooltip.hide(), i && i();
      }, this));
    },
    toggle: function () {
      this.is("disabled") || this[this.visible() ? "hide" : "show"]();
    },
    raise: function () {
      if (this.is("build") && !this.options.zIndex) {
        var t = Tooltips.getHighestTooltip();
        t && t !== this && this.zIndex <= t.zIndex && (this.zIndex = t.zIndex + 1, this._tooltip.css({
          "z-index": this.zIndex
        }), this._tooltipShadow && (this._tooltipShadow.css({
          "z-index": this.zIndex
        }), this.zIndex = t.zIndex + 2, this._tooltip.css({
          "z-index": this.zIndex
        })));
      }
    }
  }), $.extend(Tooltip.prototype, {
    createElementMarker: function (t) {
      !this.elementMarker && this.content && _.element.isAttached(this.content) && ($(this.content).data("tpd-restore-inline-display", $(this.content).css("display")), this.elementMarker = $("<div>").hide(), $(this.content).before($(this.elementMarker).hide()));
    },
    restoreElementToMarker: function () {
      var t;
      this.elementMarker && this.content && ((t = $(this.content).data("tpd-restore-inline-display")) && $(this.content).css({
        display: t
      }), $(this.elementMarker).before(this.content).remove());
    },
    startLoading: function () {
      this.is("loading") || (this.build(), this.is("loading", !0), this.options.spinner && (this._tooltip.addClass("tpd-is-loading"), this.skin.startLoading(), this.is("resize-to-content") || (this.position(), this.raise(), this._show())));
    },
    stopLoading: function () {
      this.build(), this.is("loading", !1), this.options.spinner && (this._tooltip.removeClass("tpd-is-loading"), this.skin.stopLoading());
    },
    abort: function () {
      this.abortAjax(), this.abortSanitize(), this.is("refreshed-before-sanitized", !1);
    },
    abortSanitize: function () {
      this._cache.voila && (this._cache.voila.abort(), this._cache.voila = null);
    },
    abortAjax: function () {
      this._cache.xhr && (this._cache.xhr.abort(), this._cache.xhr = null, this.is("updated", !1), this.is("updating", !1));
    },
    update: function (n) {
      if (!this.is("updating")) {
        this.is("updating", !0), this.build();
        var t = this.options.inline ? "inline" : this.options.ajax ? "ajax" : _.isElement(this.content) || _.isText(this.content) || _.isDocumentFragment(this.content) ? "element" : this._fn ? "function" : "html";

        switch (this._contentWrapper.css({
          visibility: "hidden"
        }), t) {
          case "html":
          case "element":
          case "inline":
            if (this.is("updated")) return void (n && n());

            this._update(this.content, n);

            break;

          case "function":
            if (this.is("updated")) return void (n && n());

            var i = this._fn(this.element);

            if (!i) return this.is("updating", !1), void (n && n(!0));

            this._update(i, n);

            break;

          case "ajax":
            var e = this.options.ajax || {},
                s = e.url || this.__content,
                o = e.dataType,
                r = {
              url: s,
              data: e.data || {}
            };
            (t = e.type || "GET") && $.extend(r, {
              type: t
            }), o && $.extend(r, {
              dataType: o
            });
            var h,
                a = $.extend({}, r, e);
            if (a.method && delete (a = $.extend({}, a)).method, $.each("complete error success".split(" "), $.proxy(function (t, o) {
              a[o] || (a[o] = "success" === o ? function (t, i, e) {
                return e.responseText;
              } : function () {}), a[o] = _.wrap(a[o], $.proxy(function (t) {
                var i = _slice.call(arguments, 1),
                    e = $.type("object" === i[0]) ? i[0] : i[2];

                if (!e.statusText || "abort" !== e.statusText) {
                  this.options.cache && AjaxCache.set({
                    url: a.url,
                    type: a.type,
                    data: a.data
                  }, o, i), this._cache.xhr = null;
                  var s = t.apply(this, i);
                  s && this._update(s, n);
                }
              }, this));
            }, this)), this.options.cache && (h = AjaxCache.get(a)) && h.callbacks.success) return void $.each(h.callbacks, $.proxy(function (t, i) {
              "function" === $.type(a[t]) && a[t].apply(this, i);
            }, this));
            this.startLoading(), this._cache.xhr = $.ajax(a);
        }
      }
    },
    _update: function (t, i) {
      var e = {
        title: this.options.title,
        close: this.options.close
      };
      "string" === $.type(t) || _.isElement(t) || _.isText(t) || _.isDocumentFragment(t) || t instanceof $ ? e.content = t : $.extend(e, t);
      t = e.content;
      var s = e.title,
          o = e.close;
      this.content = t, this.title = s, this.close = o, this.createElementMarker(), (_.isElement(t) || t instanceof $) && $(t).show(), this._content.html(this.content), this._title.html(s && "string" === $.type(s) ? s : ""), this._titleWrapper[s ? "show" : "hide"](), this._close[(this.title || this.options.title) && o ? "show" : "hide"]();
      var n = o && !(this.options.title || this.title),
          r = o && !(this.options.title || this.title) && "overlap" !== o,
          h = o && (this.options.title || this.title) && "overlap" !== o;
      this._inner_close[n ? "show" : "hide"](), this._tooltip[(r ? "add" : "remove") + "Class"]("tpd-has-inner-close"), this._tooltip[(h ? "add" : "remove") + "Class"]("tpd-has-title-close"), this._content[(this.options.padding ? "remove" : "add") + "Class"]("tpd-content-no-padding"), this.finishUpdate(i);
    },
    sanitize: function (i) {
      if (!this.options.voila || this._content.find("img").length < 1) return this.is("sanitized", !0), void (i && i());
      this._cache.voila = Voila(this._content, {
        method: "onload"
      }, $.proxy(function (t) {
        this._markImagesAsSanitized(t.images), this.is("refreshed-before-sanitized") ? (this.is("refreshed-before-sanitized", !1), this.sanitize(i)) : (this.is("sanitized", !0), i && i());
      }, this));
    },
    _markImagesAsSanitized: function (t) {
      $.each(t, function (t, i) {
        var e = i.img;
        $(e).data("completed-src", i.img.src);
      });
    },
    _hasAllImagesSanitized: function () {
      var s = !0;
      return this._content.find("img").each(function (t, i) {
        var e = $(i).data("completed-src");
        if (!e || i.src !== e) return s = !1;
      }), s;
    },
    refresh: function () {
      this.visible() && (this.is("sanitized") ? (this.is("refreshing", !0), this.clearTimer("refresh-spinner"), !this.options.voila || this._content.find("img").length < 1 || this._hasAllImagesSanitized() ? (this.is("should-update-dimensions", !0), this.position(), this.is("refreshing", !1)) : (this.is("sanitized", !1), this._contentWrapper.css({
        visibility: "hidden"
      }), this.startLoading(), this.sanitize($.proxy(function () {
        this._contentWrapper.css({
          visibility: "visible"
        }), this.stopLoading(), this.is("should-update-dimensions", !0), this.position(), this.is("refreshing", !1);
      }, this)))) : this.is("refreshed-before-sanitized", !0));
    },
    finishUpdate: function (t) {
      if (this.is("updated", !0), this.is("updating", !1), "function" === $.type(this.options.afterUpdate)) {
        var i = this._contentWrapper.css("visibility");

        i && this._contentWrapper.css({
          visibility: "visible"
        }), this.options.afterUpdate(this._content[0], this.element), i && this._contentWrapper.css({
          visibility: "hidden"
        });
      }

      t && t();
    }
  }), $.extend(Tooltip.prototype, {
    clearUpdatedTo: function () {
      this._cache.updatedTo = {};
    },
    updateDimensionsToContent: function (t, i) {
      this.skin.build();
      var e = this.is("loading"),
          s = this._cache.updatedTo;

      if ((this._maxWidthPass || this.is("api") || this.is("should-update-dimensions") || s.stemPosition !== i || s.loading !== e) && (!e || !this.is("resize-to-content"))) {
        this._cache.updatedTo = {
          type: this.is("resize-to-content") ? "content" : "spinner",
          loading: this.is("loading"),
          stemPosition: i
        }, this.is("should-update-dimensions") && this.is("should-update-dimensions", !1), t = t || this.options.position.target, i = i || this.options.position.tooltip;
        var o = Position.getSide(i),
            n = Position.getOrientation(i),
            r = this.skin._css.border;

        this._tooltip.addClass("tpd-tooltip-measuring");

        var h = this._tooltip.attr("style");

        this._tooltip.removeAttr("style");

        var a = {
          top: r,
          right: r,
          bottom: r,
          left: r
        },
            d = 0;

        if ("vertical" === Position.getOrientation(i)) {
          this.options.stem && (a[o] = this.skin["stem_" + o].getMath().dimensions.outside.height);
          var p = this.getMouseRoom();
          p[Position._flip[o]] && (a[o] += p[Position._flip[o]]);
          var l = this.getContainmentLayout(i),
              c = this.getPaddingLine(t),
              f = !1;
          if (Position.isPointWithinBoxLayout(c.x1, c.y1, l) || Position.isPointWithinBoxLayout(c.x2, c.y2, l)) f = !0;else {
            $.each("top right bottom left".split(" "), $.proxy(function (t, i) {
              var e = this.getSideLine(l, i);
              if (Position.intersectsLine(c.x1, c.y1, c.x2, c.y2, e.x1, e.y1, e.x2, e.y2)) return !(f = !0);
            }, this));
          }
          f && (d = "left" === o ? c.x1 - l.position.left : l.position.left + l.dimensions.width - c.x1, a[o] += d);
        }

        if (this.options.offset && "vertical" === n) {
          var u = Position.adjustOffsetBasedOnPosition(this.options.offset, this.options.position.target, t);
          0 !== u.x && (a.right += Math.abs(u.x));
        }

        this.options.containment && (d = this.options.containment.padding) && ($.each(a, function (t, i) {
          a[t] += d;
        }), "vertical" === n ? a["left" === o ? "left" : "right"] -= d : a["top" === o ? "top" : "bottom"] -= d);
        var m = Bounds.viewport(),
            g = {
          width: 0,
          height: 0
        };
        this.close && "overlap" !== this.close && !this.title && (g = this._innerCloseDimensions || {
          width: this._inner_close.outerWidth(!0),
          height: this._inner_close.outerHeight(!0)
        }, this._innerCloseDimensions = g), this._contentRelativePadder.css({
          "padding-right": g.width
        }), this._contentSpacer.css({
          width: m.width - a.left - a.right
        });
        var b = {
          width: this._content.innerWidth() + g.width,
          height: Math.max(this._content.innerHeight(), g.height || 0)
        },
            v = {
          width: 0,
          height: 0
        };

        if (this.title) {
          var _ = {
            width: 0,
            height: 0
          };
          this._titleWrapper.add(this._titleSpacer).css({
            width: "auto",
            height: "auto"
          }), this.close && "overlap" !== this.close && (_ = {
            width: this._close.outerWidth(!0),
            height: this._close.outerHeight(!0)
          }, this._close.hide()), this._maxWidthPass && b.width > this.options.maxWidth && this._titleRelative.css({
            width: b.width
          }), this._titleRelativePadder.css({
            "padding-right": _.width
          });
          var x = parseFloat(this._titleWrapper.css("border-bottom-width"));
          (v = {
            width: this.title ? this._titleWrapper.innerWidth() : 0,
            height: Math.max(this.title ? this._titleWrapper.innerHeight() + x : 0, _.height + x)
          }).width > m.width - a.left - a.right && (v.width = m.width - a.left - a.right, this._titleSpacer.css({
            width: v.width
          }), v.height = Math.max(this.title ? this._titleWrapper.innerHeight() + x : 0, _.height + x)), b.width = Math.max(v.width, b.width), b.height += v.height, this._titleWrapper.css({
            height: Math.max(this.title ? this._titleWrapper.innerHeight() : 0, _.height)
          }), this.close && this._close.show();
        }

        if (this.options.stem) {
          var w = "vertical" === n ? "height" : "width",
              y = this.skin["stem_" + o].getMath().outside.width + 2 * this.skin._css.radius;

          b[w] < y && (b[w] = y);
        }

        if (this._contentSpacer.css({
          width: b.width
        }), b.height !== Math.max(this._content.innerHeight(), g.height) + (this.title ? this._titleRelative.outerHeight() : 0) && b.width++, this.is("resize-to-content") || (b = this.skin._css.spinner.dimensions), this.setDimensions(b), a = {
          top: r,
          right: r,
          bottom: r,
          left: r
        }, this.options.stem) {
          var T = Position.getSide(i);
          a[T] = this.skin.stem_top.getMath().dimensions.outside.height;
        }

        this._contentSpacer.css({
          "margin-top": a.top,
          "margin-left": +a.left,
          width: b.width
        }), (this.title || this.close) && this._titleWrapper.css({
          height: this._titleWrapper.innerHeight(),
          width: b.width
        }), this._tooltip.removeClass("tpd-tooltip-measuring"), this._tooltip.attr("style", h);

        var k = this._contentRelative.add(this._titleRelative);

        this.options.maxWidth && b.width > this.options.maxWidth && !this._maxWidthPass && this.is("resize-to-content") && (k.css({
          width: this.options.maxWidth
        }), this._maxWidthPass = !0, this.updateDimensionsToContent(t, i), this._maxWidthPass = !1, k.css({
          width: "auto"
        }));
      }
    },
    setDimensions: function (t) {
      this.skin.setDimensions(t);
    },
    getContainmentSpace: function (t, i) {
      var e = this.getContainmentLayout(t, i),
          s = this.getTargetLayout(),
          o = s.position,
          n = s.dimensions,
          r = e.position,
          h = e.dimensions,
          a = {
        top: Math.max(o.top - r.top, 0),
        bottom: Math.max(r.top + h.height - (o.top + n.height), 0),
        left: Math.max(o.left - r.left, 0),
        right: Math.max(r.left + h.width - (o.left + n.width), 0)
      };
      return o.top > r.top + h.height && (a.top -= o.top - (r.top + h.height)), o.top + n.height < r.top && (a.bottom -= r.top - (o.top + n.height)), o.left > r.left + h.width && r.left + h.width >= o.left && (a.left -= o.left - (r.left + h.width)), o.left + n.width < r.left && (a.right -= r.left - (o.left + n.width)), this._cache.layouts.containmentSpace = a;
    },
    position: function (t) {
      if (this.visible()) {
        this.is("positioning", !0), this._cache.layouts = {};
        this._cache.dimensions;
        var i = this.options.position.target,
            e = this.options.position.tooltip,
            s = e,
            o = i;
        this.updateDimensionsToContent(o, s);
        var n = deepExtend(this.getPositionBasedOnTarget(o, s)),
            r = [];

        if (this.options.containment) {
          var h = !1,
              a = {};
          if ($.each("top right bottom left".split(" "), $.proxy(function (t, i) {
            (a[i] = this.isSideWithinContainment(i, s, !0)) && (h = !0);
          }, this)), h || (n.contained = !0), n.contained) this.setPosition(n);else if (r.unshift({
            position: n,
            targetPosition: o,
            stemPosition: s
          }), o = Position.flip(i), s = Position.flip(e), a[Position.getSide(o)] ? (this.updateDimensionsToContent(o, s), n = this.getPositionBasedOnTarget(o, s)) : n.contained = !1, n.contained) this.setPosition(n, s);else {
            r.unshift({
              position: n,
              targetPosition: o,
              stemPosition: s
            });
            var d = i,
                p = this.getContainmentSpace(s, !0),
                l = "horizontal" === Position.getOrientation(d) ? ["left", "right"] : ["top", "bottom"],
                c = (p[l[0]] === p[l[1]] ? "horizontal" === Position.getOrientation(d) ? "left" : "top" : l[p[l[0]] > p[l[1]] ? 0 : 1]) + Position.split(d)[1],
                f = Position.flip(c);
            if (o = c, s = f, a[Position.getSide(o)] ? (this.updateDimensionsToContent(o, s), n = this.getPositionBasedOnTarget(o, s)) : n.contained = !1, n.contained) this.setPosition(n, s);else {
              var u;
              r.unshift({
                position: n,
                targetPosition: o,
                stemPosition: s
              });
              var m = [];

              if ($.each(r, function (t, i) {
                if (0 <= i.position.top && 0 <= i.position.left) u = i;else {
                  var e = 0 <= i.position.top ? 1 : Math.abs(i.position.top),
                      s = 0 <= i.position.left ? 1 : Math.abs(i.position.left);
                  m.push({
                    result: i,
                    negativity: e * s
                  });
                }
              }), !u) {
                var g = m[m.length - 1];
                $.each(m, function (t, i) {
                  i.negativity < g.negativity && (g = i);
                }), u = g.result;
              }

              this.updateDimensionsToContent(u.targetPosition, u.stemPosition, !0), this.setPosition(u.position, u.stemPosition);
            }
          }
        } else this.setPosition(n);

        this._cache.dimensions = this.skin._vars.dimensions, this.skin.paint(), this.is("positioning", !1);
      }
    },
    getPositionBasedOnTarget: function (t, i) {
      i = i || this.options.position.tooltip;
      var e,
          s = this.getTargetDimensions(),
          o = {
        left: 0,
        top: 0
      },
          n = {
        left: 0,
        top: 0
      },
          r = (Position.getSide(t), this.skin._vars),
          h = r.frames[Position.getSide(i)],
          a = Position.getOrientation(t),
          d = Position.split(t);

      if ("horizontal" === a) {
        switch (e = Math.floor(.5 * s.width), d[2]) {
          case "left":
            n.left = e;
            break;

          case "middle":
            o.left = s.width - e, n.left = o.left;
            break;

          case "right":
            o.left = s.width, n.left = s.width - e;
        }

        "bottom" === d[1] && (o.top = s.height, n.top = s.height);
      } else {
        switch (e = Math.floor(.5 * s.height), d[2]) {
          case "top":
            n.top = e;
            break;

          case "middle":
            o.top = s.height - e, n.top = o.top;
            break;

          case "bottom":
            n.top = s.height - e, o.top = s.height;
        }

        "right" === d[1] && (o.left = s.width, n.left = s.width);
      }

      var p = this.getTargetPosition(),
          l = $.extend({}, s, {
        top: p.top,
        left: p.left,
        connection: o,
        max: n
      }),
          c = {
        width: h.dimensions.width,
        height: h.dimensions.height,
        top: 0,
        left: 0,
        connection: r.connections[i].connection,
        stem: r.connections[i].stem
      };

      if (c.top = l.top + l.connection.top, c.left = l.left + l.connection.left, c.top -= c.connection.top, c.left -= c.connection.left, this.options.stem) {
        var f = r.stemDimensions.width,
            u = {
          stem: {
            top: c.top + c.stem.connection.top,
            left: c.left + c.stem.connection.left
          },
          connection: {
            top: l.top + l.connection.top,
            left: l.left + l.connection.left
          },
          max: {
            top: l.top + l.max.top,
            left: l.left + l.max.left
          }
        };

        if (!Position.isPointWithinBox(u.stem.left, u.stem.top, u.connection.left, u.connection.top, u.max.left, u.max.top)) {
          u = {
            stem: {
              top: c.top + c.stem.connection.top,
              left: c.left + c.stem.connection.left
            },
            connection: {
              top: l.top + l.connection.top,
              left: l.left + l.connection.left
            },
            max: {
              top: l.top + l.max.top,
              left: l.left + l.max.left
            }
          };
          var m = {
            connection: Position.getDistance(u.stem.left, u.stem.top, u.connection.left, u.connection.top),
            max: Position.getDistance(u.stem.left, u.stem.top, u.max.left, u.max.top)
          },
              g = Math.min(m.connection, m.max),
              b = u[m.connection <= m.max ? "connection" : "max"],
              v = "horizontal" === Position.getOrientation(i) ? "left" : "top";

          if (f <= Position.getDistance(u.connection.left, u.connection.top, u.max.left, u.max.top)) {
            var _ = {
              top: 0,
              left: 0
            },
                x = b[v] < u.stem[v] ? -1 : 1;
            _[v] = g * x, _[v] += Math.floor(.5 * f) * x, c.left += _.left, c.top += _.top;
          } else {
            $.extend(u, {
              center: {
                top: Math.round(l.top + .5 * s.height),
                left: Math.round(l.left + .5 * s.left)
              }
            });
            g = m[Position.getDistance(u.center.left, u.center.top, u.connection.left, u.connection.top) <= Position.getDistance(u.center.left, u.center.top, u.max.left, u.max.top) ? "connection" : "max"];
            var w = {
              top: 0,
              left: 0
            };
            x = b[v] < u.stem[v] ? -1 : 1;
            w[v] = g * x, c.left += w.left, c.top += w.top;
          }
        }
      }

      if (this.options.offset) {
        var y = $.extend({}, this.options.offset);
        y = Position.adjustOffsetBasedOnPosition(y, this.options.position.target, t), c.top += y.y, c.left += y.x;
      }

      var T = this.getContainment({
        top: c.top,
        left: c.left
      }, i),
          k = T.horizontal && T.vertical,
          P = {
        x: 0,
        y: 0
      },
          C = Position.getOrientation(i);

      if (!T[C]) {
        var S = "horizontal" === C,
            O = S ? ["left", "right"] : ["up", "down"],
            M = S ? "x" : "y",
            z = S ? "left" : "top",
            D = T.correction[M],
            I = this.getContainmentLayout(i),
            A = I.position[S ? "left" : "top"];

        if (0 !== D) {
          var W = r.connections[i].move,
              E = W[O[-1 * D < 0 ? 0 : 1]],
              L = D < 0 ? -1 : 1;
          if (D * L <= E && c[z] + D >= A) c[z] += D, P[M] = -1 * D, k = !0;else if (Position.getOrientation(t) === Position.getOrientation(i)) {
            if (c[z] += E * L, P[M] = E * L * -1, c[z] < A) {
              var j = A - c[z],
                  B = W[O[0]] + W[O[1]];
              j = Math.min(j, B), c[z] += j;
              var H = P[M] - j;
              H >= r.connections[i].move[O[0]] && H <= r.connections[i].move[O[1]] && (P[M] -= j);
            }

            var R = (T = this.getContainment({
              top: c.top,
              left: c.left
            }, i)).correction[M],
                F = deepExtend({}, c);
            this.options.offset && (F.left -= this.options.offset.x, F.top -= this.options.offset.y), (u = {
              stem: {
                top: F.top + c.stem.connection.top,
                left: F.left + c.stem.connection.left
              }
            }).stem[z] += P[M];
            var q = this.getTargetLayout(),
                U = (f = r.stemDimensions.width, Math.floor(.5 * f)),
                Q = A + I.dimensions[S ? "width" : "height"];

            if ("x" == M) {
              var V = q.position.left + U;
              0 < R && (V += q.dimensions.width - 2 * U), (R < 0 && u.stem.left + R >= V && F.left + R >= A || 0 < R && u.stem.left + R <= V && F.left + R <= Q) && (F.left += R);
            } else {
              var G = q.position.top + U;
              0 < R && (G += q.dimensions.height - 2 * U), (R < 0 && u.stem.top + R >= G && F.top + R >= A || 0 < R && u.stem.top + R <= G && F.top + R <= Q) && (F.top += R);
            }

            c = F, this.options.offset && (c.left += this.options.offset.x, c.top += this.options.offset.y);
          }
        }

        k = (T = this.getContainment({
          top: c.top,
          left: c.left
        }, i)).horizontal && T.vertical;
      }

      return {
        top: c.top,
        left: c.left,
        contained: k,
        shift: P
      };
    },
    setPosition: function (t, i) {
      var e = this._position;

      if (!e || e.top !== t.top || e.left !== t.left) {
        var s;

        if (this.options.container !== document.body) {
          if ("string" === $.type(this.options.container)) {
            var o = this.target;
            "mouse" === o && (o = this.element), s = $($(o).closest(this.options.container).first());
          } else s = $(s);

          if (s[0]) {
            var n = $(s).offset(),
                r = Math.round(n.top),
                h = Math.round(n.left),
                a = Math.round($(s).scrollTop()),
                d = Math.round($(s).scrollLeft());
            t.top -= r, t.top += a, t.left -= h, t.left += d;
          }
        }

        this._position = t, this._tooltip.css({
          top: t.top,
          left: t.left
        });
      }

      this.skin.setStemPosition(i || this.options.position.tooltip, t.shift || {
        x: 0,
        y: 0
      });
    },
    getSideLine: function (t, i) {
      var e = t.position.left,
          s = t.position.top,
          o = t.position.left,
          n = t.position.top;

      switch (i) {
        case "top":
          o += t.dimensions.width;
          break;

        case "bottom":
          s += t.dimensions.height, o += t.dimensions.width, n += t.dimensions.height;
          break;

        case "left":
          n += t.dimensions.height;
          break;

        case "right":
          e += t.dimensions.width, o += t.dimensions.width, n += t.dimensions.height;
      }

      return {
        x1: e,
        y1: s,
        x2: o,
        y2: n
      };
    },
    isSideWithinContainment: function (t, i, e) {
      var s = this.getContainmentLayout(i, e),
          o = this.getTargetLayout(),
          n = this.getSideLine(o, t);
      if (Position.isPointWithinBoxLayout(n.x1, n.y1, s) || Position.isPointWithinBoxLayout(n.x2, n.y2, s)) return !0;
      var r = !1;
      return $.each("top right bottom left".split(" "), $.proxy(function (t, i) {
        var e = this.getSideLine(s, i);
        if (Position.intersectsLine(n.x1, n.y1, n.x2, n.y2, e.x1, e.y1, e.x2, e.y2)) return !(r = !0);
      }, this)), r;
    },
    getContainment: function (t, i) {
      var e = {
        horizontal: !0,
        vertical: !0,
        correction: {
          y: 0,
          x: 0
        }
      };

      if (this.options.containment) {
        var s = this.getContainmentLayout(i),
            o = this.skin._vars.frames[Position.getSide(i)].dimensions;

        this.options.containment && ((t.left < s.position.left || t.left + o.width > s.position.left + s.dimensions.width) && (e.horizontal = !1, t.left < s.position.left ? e.correction.x = s.position.left - t.left : e.correction.x = s.position.left + s.dimensions.width - (t.left + o.width)), (t.top < s.position.top || t.top + o.height > s.position.top + s.dimensions.height) && (e.vertical = !1, t.top < s.position.top ? e.correction.y = s.position.top - t.top : e.correction.y = s.position.top + s.dimensions.height - (t.top + o.height)));
      }

      return e;
    },
    getContainmentLayout: function (t, i) {
      var e = {
        top: $(window).scrollTop(),
        left: $(window).scrollLeft()
      },
          s = this.target;
      "mouse" === s && (s = this.element);
      var o,
          n = $(s).closest(this.options.containment.selector).first()[0];
      o = n && "viewport" !== this.options.containment.selector ? {
        dimensions: {
          width: $(n).innerWidth(),
          height: $(n).innerHeight()
        },
        position: $(n).offset()
      } : {
        dimensions: Bounds.viewport(),
        position: e
      };
      var r = this.options.containment.padding;

      if (r && !i) {
        var h = Math.max(o.dimensions.height, o.dimensions.width);
        if (h < 2 * r && (r = Math.max(Math.floor(.5 * h), 0)), r) o.dimensions.width -= 2 * r, o.dimensions.height -= 2 * r, o.position.top += r, o.position.left += r, "vertical" === Position.getOrientation(t) ? (o.dimensions.width += r, "left" === Position.getSide(t) && (o.position.left -= r)) : (o.dimensions.height += r, "top" === Position.getSide(t) && (o.position.top -= r));
      }

      return this._cache.layouts.containmentLayout = o;
    },
    getMouseRoom: function () {
      var t = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };

      if ("mouse" === this.options.target && !this.is("api")) {
        var i = Mouse.getActualPosition(this._cache.event),
            e = $(this.element).offset(),
            s = $(this.element).innerWidth(),
            o = $(this.element).innerHeight();
        t = {
          top: Math.max(0, i.top - e.top),
          bottom: Math.max(0, e.top + o - i.top),
          left: Math.max(0, i.left - e.left),
          right: Math.max(0, e.left + s - i.left)
        };
      }

      return t;
    },
    getTargetPosition: function () {
      var t, i;
      return t = "mouse" === this.options.target ? this.is("api") ? (i = $(this.element).offset(), {
        top: Math.round(i.top),
        left: Math.round(i.left)
      }) : Mouse.getPosition(this._cache.event) : (i = $(this.target).offset(), {
        top: Math.round(i.top),
        left: Math.round(i.left)
      }), this._cache.layouts.targetPosition = t;
    },
    getTargetDimensions: function () {
      return this._cache.layouts.targetDimensions ? this._cache.layouts.targetDimensions : (t = "mouse" === this.options.target ? Mouse.getDimensions() : {
        width: $(this.target).innerWidth(),
        height: $(this.target).innerHeight()
      }, this._cache.layouts.targetDimensions = t);
      var t;
    },
    getTargetLayout: function () {
      if (this._cache.layouts.targetLayout) return this._cache.layouts.targetLayout;
      var t = {
        position: this.getTargetPosition(),
        dimensions: this.getTargetDimensions()
      };
      return this._cache.layouts.targetLayout = t;
    },
    getPaddingLine: function (t) {
      var i = this.getTargetLayout(),
          e = "left";
      if ("vertical" === Position.getOrientation(t)) return this.getSideLine(i, Position.getSide(t));

      if (Position.isCorner(t)) {
        var s = Position.inverseCornerPlane(t);
        return e = Position.getSide(s), this.getSideLine(i, e);
      }

      var o = this.getSideLine(i, e),
          n = Math.round(.5 * i.dimensions.width);
      return o.x1 += n, o.x2 += n, o;
    }
  }), $.extend(Tooltip.prototype, {
    setActive: function () {
      this.is("active", !0), this.visible() && this.raise(), this.options.hideAfter && this.clearTimer("idle");
    },
    setIdle: function () {
      this.is("active", !1), this.options.hideAfter && this.setTimer("idle", $.proxy(function () {
        this.clearTimer("idle"), this.is("active") || this.hide();
      }, this), this.options.hideAfter);
    }
  }), $.extend(Tooltip.prototype, {
    bind: function (t, i, e, s) {
      var o = $.proxy(e, s || this);
      this._cache.events.push({
        element: t,
        eventName: i,
        handler: o
      }), $(t).bind(i, o);
    },
    unbind: function () {
      $.each(this._cache.events, function (t, i) {
        $(i.element).unbind(i.eventName, i.handler);
      }), this._cache.events = [];
    }
  }), $.extend(Tooltip.prototype, {
    disable: function () {
      this.is("disabled") || this.is("disabled", !0);
    },
    enable: function () {
      this.is("disabled") && this.is("disabled", !1);
    }
  }), $.extend(Tooltip.prototype, {
    is: function (t, i) {
      return "boolean" === $.type(i) && (this._cache.is[t] = i), this._cache.is[t];
    },
    visible: function () {
      return this.is("visible");
    }
  }), $.extend(Tooltip.prototype, {
    setTimer: function (t, i, e) {
      this._cache.timers[t] = _.delay(i, e);
    },
    getTimer: function (t) {
      return this._cache.timers[t];
    },
    clearTimer: function (t) {
      this._cache.timers[t] && (clearTimeout(this._cache.timers[t]), delete this._cache.timers[t]);
    },
    clearTimers: function () {
      $.each(this._cache.timers, function (t, i) {
        clearTimeout(i);
      }), this._cache.timers = {};
    }
  }), $.extend(Tipped, {
    init: function () {
      Tooltips.init();
    },
    create: function (t, e) {
      var s = $.extend({}, arguments[2] || {}),
          o = [];
      return _.isElement(t) ? o.push(new Tooltip(t, e, s)) : $(t).each(function (t, i) {
        o.push(new Tooltip(i, e, s));
      }), new Collection(o);
    },
    get: function (t) {
      return new Collection(Tooltips.get(t));
    },
    findElement: function (t) {
      return Tooltips.findElement(t);
    },
    hideAll: function () {
      return Tooltips.hideAll(), this;
    },
    setDefaultSkin: function (t) {
      return Tooltips.setDefaultSkin(t), this;
    },
    visible: function (t) {
      if (_.isElement(t)) return Tooltips.isVisibleByElement(t);
      if ("undefined" === $.type(t)) return Tooltips.getVisible().length;
      var i = $(t),
          e = 0;
      return $.each(i, function (t, i) {
        Tooltips.isVisibleByElement(i) && e++;
      }), e;
    },
    clearAjaxCache: function () {
      return Tooltips.clearAjaxCache(), this;
    },
    refresh: function (t, i, e) {
      return Tooltips.refresh(t, i, e), this;
    },
    setStartingZIndex: function (t) {
      return Tooltips.setStartingZIndex(t), this;
    },
    remove: function (t) {
      return Tooltips.remove(t), this;
    }
  }), $.each("show hide toggle disable enable".split(" "), function (t, i) {
    Tipped[i] = function (t) {
      return this.get(t)[i](), this;
    };
  }), $.extend(Tipped, {
    delegate: function () {
      Delegations.add.apply(Delegations, _slice.call(arguments));
    },
    undelegate: function () {
      Delegations.remove.apply(Delegations, _slice.call(arguments));
    }
  });
  var Delegations = {
    _uid: 0,
    _delegations: {},
    add: function (t, e, s) {
      "object" !== $.type(e) || _.isElement(e) ? s = s || {} : (s = e, e = null);
      var o = ++this._uid,
          i = Options.create($.extend({}, s));
      this._delegations[o] = {
        uid: o,
        selector: t,
        content: e,
        options: i
      };

      function n(t) {
        $(this).addClass("tpd-delegation-uid-" + o);
        var i = new Tooltip(this, e, s);
        i._cache.event = t, i.setActive(), i.showDelayed();
      }

      this._delegations[o].removeTitleHandler = $.proxy(this.removeTitle, this), $(document).delegate(t + ":not(.tpd-delegation-uid-" + o + ")", "mouseenter", this._delegations[o].removeTitleHandler), this._delegations[o].handler = n, $(document).delegate(t + ":not(.tpd-delegation-uid-" + o + ")", i.showOn.element, n);
    },
    removeTitle: function (t) {
      var i = t.currentTarget,
          e = $(i).attr("title");
      e && ($(i).data("tipped-restore-title", e), $(i)[0].setAttribute("title", ""));
    },
    remove: function (e) {
      $.each(this._delegations, $.proxy(function (t, i) {
        i.selector === e && ($(document).undelegate(e + ":not(.tpd-delegation-uid-" + t + ")", "mouseenter", i.removeTitleHandler).undelegate(e + ":not(.tpd-delegation-uid-" + t + ")", i.options.showOn.element, i.handler), delete this._delegations[t]);
      }, this));
    },
    removeAll: function () {
      $.each(this._delegations, $.proxy(function (t, i) {
        $(document).undelegate(i.selector + ":not(.tpd-delegation-uid-" + t + ")", "mouseenter", i.removeTitleHandler).undelegate(i.selector + ":not(.tpd-delegation-uid-" + t + ")", i.options.showOn.element, i.handler), delete this._delegations[t];
      }, this));
    }
  };

  function Collection() {
    this.initialize.apply(this, _slice.call(arguments));
  }

  return $.extend(Collection.prototype, {
    initialize: function (t) {
      return this.tooltips = t, this;
    },
    items: function () {
      return $.each(this.tooltips, function (t, i) {
        i.is("api", !0);
      }), this.tooltips;
    },
    refresh: function (t) {
      return $.each(this._tooltips, function (t, i) {
        i.is("visible") && i.refresh();
      }), this;
    },
    remove: function () {
      return Tooltips.removeTooltips(this.tooltips), this.tooltips = [], this;
    }
  }), $.each("show hide toggle disable enable".split(" "), function (t, e) {
    Collection.prototype[e] = function () {
      return $.each(this.tooltips, function (t, i) {
        i.is("api", !0), i[e]();
      }), this;
    };
  }), Tipped.init(), Tipped;
});
function reloadRightmenu(url) {
  $.get(url, {}, displayRightmenu);
}

function displayRightmenu(data) {
  $("#rechts").replaceWith(data);
  initPlanetSorting();
}

function ajaxFormSubmit(form, url, okFunction, additionalParams) {
  var params = $("#" + form + "").serialize();

  if (typeof additionalParams === 'object') {
    for (var key in additionalParams) {
      if (!additionalParams.hasOwnProperty(key)) {
        continue;
      }

      params += '&' + key + '=' + additionalParams[key];
    }
  }

  var successFunction = null;

  if (okFunction != null && typeof okFunction == "function") {
    successFunction = okFunction;
  }

  $.ajax({
    type: "POST",
    url: url,
    data: params,
    success: successFunction
  });
}

function initConnectionErrorFunction() {
  if (isMobile) {
    document.addEventListener("deviceready", function () {
      $(document).ajaxError(function (e, xhr, settings, exception) {
        HostApp.ShowNoConnectionScreen();
      });
    }, false);
  }
}
// page: ainfo.js
function initAllianceInfo() {
  initConnectionErrorFunction();
  initTooltips();
  initOverlays();
  initHideElements();
}

$('[data-homepage-link]').on('click', function (e) {
  e.preventDefault();
  errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.redirectMessage, LocalizationStrings.yes, LocalizationStrings.no, function () {
    window.location.href = 'redir.php?url=' + encodeURIComponent(allyHome);
  }, false, false);
});
// ----------------------------------------------------------------------------
// markItUp!
// ----------------------------------------------------------------------------
// Copyright (C) 2011 Jay Salvat
// http://markitup.jaysalvat.com/
// ----------------------------------------------------------------------------
// Html tags
// http://en.wikipedia.org/wiki/html
// ----------------------------------------------------------------------------
// Basic set. Feel free to add more tags
// ----------------------------------------------------------------------------

/**
 * Ogame specific initialisation code for the markItUp Editor
 *
 * @param locaKeys { Object }
 * @param itemArray { Object }
 * @param imagesAllowed { Boolean }
 * @param selector { String } - is specified, only init editor for this selector
 * @param maxChars { Number } - maximum length of entered text
 * @param lite { bool } - limits possible functions
 **/
function initBBCodeEditor(locaKeys, itemArray, imagesAllowed, selector, maxChars, lite) {
  var $textareas;

  if (typeof selector == 'undefined' || selector == null) {
    $textareas = $('textarea:not(.markItUpEditor)');
  } else {
    $textareas = $(selector).filter(':not(.markItUpEditor)');
  }

  if ($textareas.length == 0) {
    return;
  }

  var imagesAllowed = imagesAllowed || false;
  var fontSizeArray = [];

  for (var fontSizeCounter = 6; fontSizeCounter <= 30; fontSizeCounter += 2) {
    fontSizeArray.push({
      name: fontSizeCounter,
      openWith: '[size=' + fontSizeCounter + ']',
      closeWith: '[/size]',
      placeHolder: 'Text',
      className: 'fontSize' + fontSizeCounter
    });
  }

  var itemDropdownArray = [];
  $.each(itemArray, function (uuid, name) {
    itemDropdownArray.push({
      name: name,
      replaceWith: '[item]' + uuid + '[/item]'
    });
  });

  function multiInsertSelectionFix(e) {
    if (e.selection.length == 0) {
      return;
    }

    var $textarea = $(e.textarea);
    var range = $textarea.getSelection();
    var listItemStart = $textarea.val().indexOf(e.openWith, range.start);
    var rangeValue = listItemStart + e.openWith.length;
    var placeHolderLength = typeof e.placeHolder == 'string' ? e.placeHolder.length : 0;
    var newRange = {
      start: rangeValue,
      end: rangeValue + placeHolderLength
    };
    $textarea.setSelection(newRange);
  }

  function colorPicker(e) {
    var openWith = e.openWith;
    var $textarea = $(e.textarea);
    var selection = $textarea.getSelection();
    $textarea.siblings('.colorpicker').val('').colorpicker('open').colorpicker('option', 'close', function (e, color) {
      var replaceBy = openWith.replace(/%colorCode%/, color.formatted); // determine new text selection

      var selectionOffset = "%colorCode%".length - color.formatted.length;
      selection.start = selection.start - selectionOffset;
      selection.end = selection.end - selectionOffset;
      $textarea.val($textarea.val().replace(openWith, replaceBy)).setSelection(selection);
    });
    var $button = $textarea.siblings('.markItUpHeader').find('.' + e.className);
    $('.ui-colorpicker:visible').css('top', $button.offset().top + $button.height()).css('left', $button.offset().left);
    $('.ui-colorpicker').draggable();
    $('.ui-colorpicker-rgb-r .ui-colorpicker-number').focus();
    return e;
  }

  function backgroundImage(e) {
    var $textarea = $(e.textarea);
    var selection = $textarea.getSelection();
    var openWith = e.openWith;
    var $imagePickerOverlay = $('#backgroundImagePicker');

    if ($imagePickerOverlay.is(':visible')) {
      $imagePickerOverlay.dialog('close');
    }

    $imagePickerOverlay.find('input:checked').prop('checked', false);
    $imagePickerOverlay.find('.url').val('http://').focus();
    openOverlay($imagePickerOverlay, {
      type: 'inline',
      title: locaKeys.backgroundImage,
      close: function () {
        var imageText = $imagePickerOverlay.find('.url').val();
        var checkedX = $imagePickerOverlay.find('.repeatX:checked').length;
        var checkedY = $imagePickerOverlay.find('.repeatY:checked').length;
        var repeat = "";

        if (checkedX && checkedY) {
          repeat = "yes";
        } else if (checkedX) {
          repeat = "yes-x";
        } else if (checkedY) {
          repeat = "yes-y";
        }

        if (repeat.length) {
          imageText += " image-repeat=" + repeat;
        }

        var replaceBy = openWith.replace(/%image%/, imageText); // determine new text selection

        var selectionOffset = "%image%".length - imageText.length;
        selection.start = selection.start - selectionOffset;
        selection.end = selection.end - selectionOffset;
        $textarea.val($textarea.val().replace(openWith, replaceBy)).setSelection(selection);
      }
    });
    var $button = $textarea.siblings('.markItUpHeader').find('.' + e.className);
    $imagePickerOverlay.parent().css('top', $button.offset().top + $button.height()).css('left', $button.offset().left);
    return e;
  } // END function backgroundImage(e)


  var markupSetBasic = lite ? [{
    name: locaKeys.bold,
    key: 'B',
    openWith: '[b]',
    closeWith: '[/b]',
    className: 'bold'
  }, {
    name: locaKeys.italic,
    key: 'I',
    openWith: '[i]',
    closeWith: '[/i]',
    className: 'italic'
  }, {
    name: locaKeys.fontColor,
    afterInsert: colorPicker,
    openWith: '[color=%colorCode%]',
    closeWith: '[/color]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'fontColor'
  }, {
    name: locaKeys.fontSize,
    className: 'fontSize',
    dropMenu: fontSizeArray
  }, {
    name: locaKeys.list,
    openWith: '[*]',
    multiline: true,
    openBlockWith: '[list]\n',
    closeBlockWith: '\n[/list]',
    className: 'list',
    afterMultiInsert: multiInsertSelectionFix,
    placeHolder: locaKeys.textPlaceHolder
  }, {
    name: locaKeys.coordinates,
    openWith: '[coordinates]',
    closeWith: '[/coordinates]',
    placeHolder: locaKeys.coordinatePlaceHolder,
    className: 'coordinates'
  }] : [{
    name: locaKeys.bold,
    key: 'B',
    openWith: '[b]',
    closeWith: '[/b]',
    className: 'bold'
  }, {
    name: locaKeys.italic,
    key: 'I',
    openWith: '[i]',
    closeWith: '[/i]',
    className: 'italic'
  }, {
    name: locaKeys.fontColor,
    afterInsert: colorPicker,
    openWith: '[color=%colorCode%]',
    closeWith: '[/color]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'fontColor'
  }, {
    name: locaKeys.fontSize,
    className: 'fontSize',
    dropMenu: fontSizeArray
  }, {
    name: locaKeys.list,
    openWith: '[*]',
    multiline: true,
    openBlockWith: '[list]\n',
    closeBlockWith: '\n[/list]',
    className: 'list',
    afterMultiInsert: multiInsertSelectionFix,
    placeHolder: locaKeys.textPlaceHolder
  }, {
    name: locaKeys.link,
    key: 'L',
    openWith: '[url=[![' + locaKeys.link + ':!:http://]!]]',
    closeWith: '[/url]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'link'
  }, {
    name: locaKeys.coordinates,
    openWith: '[coordinates]',
    closeWith: '[/coordinates]',
    placeHolder: locaKeys.coordinatePlaceHolder,
    className: 'coordinates'
  }];
  var markupSetAdvanced = lite ? [{
    name: locaKeys.underline,
    key: 'U',
    openWith: '[u]',
    closeWith: '[/u]',
    className: 'underline'
  }, {
    name: locaKeys.stroke,
    key: 'S',
    openWith: '[s]',
    closeWith: '[/s]',
    className: 'strikeThrough'
  }, {
    name: locaKeys.sub,
    openWith: '[sub]',
    closeWith: '[/sub]',
    className: 'sub'
  }, {
    name: locaKeys.sup,
    openWith: '[sup]',
    closeWith: '[/sup]',
    className: 'sup'
  }, {
    separator: '-'
  }, {
    name: locaKeys.item,
    className: 'item',
    dropMenu: itemDropdownArray
  }, {
    name: locaKeys.player,
    openWith: '[player]',
    closeWith: '[/player]',
    placeHolder: locaKeys.playerPlaceHolder,
    className: 'player'
  }, {
    separator: '-'
  }, {
    name: locaKeys.alignLeft,
    openWith: '[align=left]',
    closeWith: '[/align]',
    className: 'leftAlign'
  }, {
    name: locaKeys.alignCenter,
    openWith: '[align=center]',
    closeWith: '[/align]',
    className: 'centerAlign'
  }, {
    name: locaKeys.alignRight,
    openWith: '[align=right]',
    closeWith: '[/align]',
    className: 'rightAlign'
  }, {
    name: locaKeys.alignJustify,
    openWith: '[align=justify]',
    closeWith: '[/align]',
    className: 'justifyAlign'
  }, {
    separator: '-'
  }, {
    name: locaKeys.code,
    openWith: '[code]',
    closeWith: '[/code]',
    className: 'code'
  }, {
    separator: '-'
  }, {
    name: locaKeys.email,
    key: 'E',
    openWith: '[email=[![' + locaKeys.email + ':!:]!]]',
    closeWith: '[/email]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'email'
  }, {
    name: locaKeys.preview,
    className: 'preview',
    call: 'preview'
  }] : [{
    name: locaKeys.underline,
    key: 'U',
    openWith: '[u]',
    closeWith: '[/u]',
    className: 'underline'
  }, {
    name: locaKeys.stroke,
    key: 'S',
    openWith: '[s]',
    closeWith: '[/s]',
    className: 'strikeThrough'
  }, {
    name: locaKeys.sub,
    openWith: '[sub]',
    closeWith: '[/sub]',
    className: 'sub'
  }, {
    name: locaKeys.sup,
    openWith: '[sup]',
    closeWith: '[/sup]',
    className: 'sup'
  }, {
    name: locaKeys.backgroundColor,
    afterInsert: colorPicker,
    openWith: '[background color=%colorCode%]',
    closeWith: '[/background]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'backgroundColor'
  }, {
    name: locaKeys.backgroundImage,
    afterInsert: backgroundImage,
    openWith: '[background image=%image%]',
    closeWith: '[/background]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'backgroundImage'
  }, {
    separator: '-'
  }, {
    name: locaKeys.item,
    className: 'item',
    dropMenu: itemDropdownArray
  }, {
    name: locaKeys.player,
    openWith: '[player]',
    closeWith: '[/player]',
    placeHolder: locaKeys.playerPlaceHolder,
    className: 'player'
  }, {
    name: locaKeys.tooltip,
    openWith: '[tooltip position="top" text="[![Tooltip Text:!:Tooltip Text]!]"]',
    closeWith: '[/tooltip]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'tooltip'
  }, {
    separator: '-'
  }, {
    name: locaKeys.alignLeft,
    openWith: '[align=left]',
    closeWith: '[/align]',
    className: 'leftAlign'
  }, {
    name: locaKeys.alignCenter,
    openWith: '[align=center]',
    closeWith: '[/align]',
    className: 'centerAlign'
  }, {
    name: locaKeys.alignRight,
    openWith: '[align=right]',
    closeWith: '[/align]',
    className: 'rightAlign'
  }, {
    name: locaKeys.alignJustify,
    openWith: '[align=justify]',
    closeWith: '[/align]',
    className: 'justifyAlign'
  }, {
    separator: '-'
  }, {
    name: locaKeys.block,
    openWith: '[p]',
    closeWith: '[/p]',
    className: 'block'
  }, {
    name: locaKeys.code,
    openWith: '[code]',
    closeWith: '[/code]',
    className: 'code'
  }, {
    name: locaKeys.spoiler,
    openWith: '[spoiler]',
    closeWith: '[/spoiler]',
    className: 'spoiler'
  }, {
    separator: '-'
  }, {
    name: locaKeys.hr,
    openWith: '[hr]',
    className: 'hr'
  }, {
    separator: '-'
  }, {
    name: locaKeys.picture,
    key: 'Z',
    replaceWith: '[img][![' + locaKeys.picture + ':!:http://]!][/img]',
    className: 'picture'
  }, {
    name: locaKeys.email,
    key: 'E',
    openWith: '[email=[![' + locaKeys.email + ':!:]!]]',
    closeWith: '[/email]',
    placeHolder: locaKeys.textPlaceHolder,
    className: 'email'
  }, {
    name: locaKeys.preview,
    className: 'preview',
    call: 'preview'
  }];

  if (!imagesAllowed) {
    $.each(markupSetAdvanced, function (index) {
      if (this.className == 'picture' || this.className == 'backgroundImage') {
        markupSetAdvanced.splice(index, 1);
      }
    });
  }

  if (isMobile) {
    // dont show colorpickers on ipad
    $.each(markupSetBasic, function (index) {
      if (this.className == 'fontColor' || this.className == 'backgroundColor') {
        markupSetBasic.splice(index, 1);
      }
    });
    $.each(markupSetAdvanced, function (index) {
      if (this.className == 'fontColor' || this.className == 'backgroundColor') {
        markupSetAdvanced.splice(index, 1);
      }
    });
  }

  var editorSettings = {
    onShiftEnter: {
      keepDefault: false,
      replaceWith: '\n'
    },
    onCtrlEnter: {
      keepDefault: false,
      openWith: '\n[p]',
      closeWith: '[/p]'
    },
    onTab: {
      keepDefault: false,
      replaceWith: '\t'
    },
    markupSet: [markupSetBasic, markupSetAdvanced],
    resizeHandle: false,
    previewParserPath: bbcodePreviewUrl + "&imgAllowed=" + (imagesAllowed ? 1 : 0),
    previewAutoRefresh: true,
    previewParserVar: 'text',
    previewInElement: $('<div class="miu_preview_container"></div>'),
    afterInsert: function (e) {
      $(e.textarea).trigger('keyup');
    }
  };
  $.colorpicker.regional['custom'] = locaKeys.colorPicker;
  $textareas.each(function () {
    var $this = $(this);
    $this.markItUp(editorSettings) // create colorpicker
    .after($('<input type="hidden" class="colorpicker"/>').colorpicker({
      color: '#000000',
      colorFormat: "#HEX",
      hsv: false,
      parts: 'popup',
      regional: 'custom',
      showCancelButton: false
    })); // The preview element needs to be inserted after creation of editor to be in the right place

    editorSettings.previewInElement.insertAfter($this); // preview action as link and not as set button

    $('.miu_advanced .preview').hide(); // create a footer for char count and preview link

    var $miuFooter = $('<div class="miu_footer clearfix"></div>');
    $miuFooter.append('<a role="button" class="fright txt_link btn_blue preview_link">' + locaKeys.preview + '</a>').append('<span class="fleft"><span class="cnt_chars">' + maxChars + '</span> ' + locaKeys.charsLeft + '</span>');
    $miuFooter.insertAfter($this);
    $this.on('keyup.bbCodeEditor', function () {
      if ($this.val().length > maxChars) {
        $this.val($this.val().substr(0, maxChars));
      }

      $this.closest('.markItUpContainer').find('.cnt_chars').html(maxChars - $this.val().length);
    });
    $('.miu_preview_container').hide();
    $('.preview_link').on('click.bbCodeEditor', function () {
      editorSettings.previewInElement.insertAfter($(event.target).closest('.markItUpContainer').find('.miu_footer'));
      $(event.target).closest('.markItUpContainer').find('.miu_preview_container').show();
      $(event.target).closest('.markItUpContainer').find('.preview').click();
    });

    if (isMobile) {
      $this.siblings(".markItUpHeader").find("a").attr('title', '');
      $this.siblings(".markItUpHeader").find("li:not(.markItUpDropMenu) a").bind('mouseup', function () {
        // open keyboard again
        $this.focus();
      });
    } else {
      $this.siblings(".markItUpHeader").find("ul ul a").attr('title', '');
    }

    if ($('#backgroundImagePicker').length == 0) {
      $("body").append($('<div id="backgroundImagePicker" style="display: none;"><table>' + '<tr><td>' + locaKeys.backgroundImage + ':</td><td><input type="text" class="url"/></td></tr>' + '<tr><td>' + locaKeys.backgroundImagePicker.repeatX + ':</td><td><input type="checkbox" class="repeatX"/></td></tr>' + '<tr><td>' + locaKeys.backgroundImagePicker.repeatY + ':</td><td><input type="checkbox" class="repeatY"/></td></tr>' + '</table>' + '<div><a href="javascript:void(0);" class="btn_blue">' + locaKeys.backgroundImagePicker.ok + '</a></div>' + '</div>'));
      $('#backgroundImagePicker').find('a').bind('click', function () {
        $('#backgroundImagePicker').dialog('close');
      });
    }
  });
  /* *** adding additional event listeners *** */

  $('.toggle_miu_advanced').on('click.bbCodeEditor', function () {
    if ($('.miu_advanced').is(':visible')) {
      $('.miu_advanced').hide();
      $(this).removeClass('hide_miu_advanced').addClass('show_miu_advanced');
    } else {
      $('.miu_advanced').show();
      $(this).removeClass('show_miu_advanced').addClass('hide_miu_advanced');
    }
  });
}

function initBBCodes() {
  $(document).undelegate('.spoilerHeader', 'click').delegate('.spoilerHeader', 'click', function () {
    var thisObj = this;
    $(this).next('.spoilerText').toggle(0, function () {
      Tipped.refresh(thisObj);
    });
  });
}
ogame.buddies = {
  initBuddyList: function () {
    $.tablesorter.addParser({
      id: 'coordinates',
      is: function (s) {
        return false;
      },
      format: function (s) {
        // format your data for normalization
        var res = $.trim(s).slice(1, -1).split(':');
        var result = res[0] * 16384 + res[1] * 32 + res[2] * 1;
        return result;
      },
      type: 'numeric'
    });
    $.tablesorter.addParser({
      id: "commaDigit",
      is: function (s, table) {
        var c = table.config;
        return jQuery.tablesorter.isDigit(s.replace(/\./g, ""), c);
      },
      format: function (s) {
        return jQuery.tablesorter.formatFloat(s.replace(/\./g, ""));
      },
      type: "numeric"
    });
    $('.content_table').tablesorter({
      widgets: ['zebra'],
      headers: {
        0: {
          sorter: false
        },
        2: {
          sorter: 'commaDigit'
        },
        5: {
          sorter: 'coordinates'
        },
        6: {
          sorter: false
        }
      },
      cssHeader: 'ct_sortable_title',
      cssAsc: 'ct_sort_asc',
      cssDesc: 'ct_sort_desc'
    });
    $('#buddylist').off('.buddyList');
    $('#buddylist').on('click.buddyList', '.deleteBuddy', deleteBuddy);
    $('#chatContent').on('click.chat_info', '.deleteBuddy', deleteBuddy);
  },

  /*
  * Initializes that is needed for the buddies page
  * @returns {undefined}
  */
  initBuddies: function () {
    // adding hover style for tables
    $('.zebra tr').mouseover(function () {
      $(this).addClass("over");
    }).mouseout(function () {
      $(this).removeClass("over");
    }); // toggles the buddy requests section

    $('.js_accordion').accordion({
      collapsible: true,
      heightStyle: 'content'
    }); // for buddy requests

    $('.js_tabs').tabs();
    $(".js_scrollbar").mCustomScrollbar({
      theme: "ogame"
    });
  }
};

function initInviteCodes() {
  $("#buddyinvite .code").click(function () {
    $(this).selectText();
  });
}

function incrementBuddyCount() {
  var buddyCount = parseInt($("#buddyCount").text()) + 1;
  var requestCount = parseInt($("#newRequestCount").text()) - 1;
  updateRequestCount(requestCount);
  updateBuddyCount(buddyCount);
}

function updateRequestCount(count) {
  $("#newRequestCount").html(count);
}

function updateBuddyCount(count) {
  $("#buddyCount").html(count);
}

function reportMessage(id, fromPlayer, toPlayer) {
  $.ajax({
    type: 'POST',
    url: '?page=reportSpam_ajax',
    dataType: 'json',
    data: {
      messageId: id,
      from: fromPlayer,
      to: toPlayer
    },
    success: function (data) {
      fadeBox(data.message, !data.result);
    },
    error: function () {}
  });
}

function reportAllyMessage(id, fromPlayer) {
  $.ajax({
    type: 'POST',
    url: '?page=reportSpam_ajax',
    dataType: 'json',
    data: {
      messageId: id,
      from: fromPlayer
    },
    success: function (data) {
      fadeBox(data.message, !data.result);
    },
    error: function () {}
  });
}

var elem, messageId, senderId;

function reportAllyRoundMessage(_elem, _messageId, _senderId, _question) {
  elem = _elem;
  messageId = _messageId;
  senderId = _senderId;
  errorBoxDecision(LocalizationStrings.attention, _question, LocalizationStrings.yes, LocalizationStrings.no, reportMessageCallback);
}

function reportMessageCallback() {
  elem.hide();
  reportAllyMessage(messageId, senderId);
}

function requestsReady() {
  $(document).on('click', '.acceptRequest', acceptRequest);
  $(document).on('click', '.rejectRequest', rejectRequest);
  $(document).on('click', '.cancelRequest', cancelRequest);
  $(document).on('click', '.reportRequest', reportRequest);
}

function initBuddyRequestForm() {
  $(".overlayDiv .buddyRequest form").unbind('submit').bind('submit', function (e) {
    var $thisObj = $(this);
    e.preventDefault();
    $.post($thisObj.attr('action'), $thisObj.serialize(), "html").done(function (data) {
      document.open();
      document.write(data);
      document.close();
    }).fail(function () {
      var currentlocation = window.location.href;
      window.location = currentlocation.substring(0, currentlocation.indexOf('?')) + '?page=ingame&component=buddies';
    }).always(function () {
      return false;
    });
  });
  $('.buddyRequest').each(function () {
    var $thisObj = $(this);
    var $overlayTitle = $thisObj.parents('.ui-dialog').find('.ui-dialog-title');

    if (!$overlayTitle.find('span.buddyName').length) {
      $overlayTitle.append($(document.createElement('span')).addClass('buddyName').text(' (' + $thisObj.attr('data-title') + ')'));
    }
  });
}
function initBuyResourceOverlay(isLastBuildingSlot, showLastBuildingSlotWarning, localization) {
  $('.close_buyResourceOverlay').on('click', function () {
    $('#buyResourceOverlayBody').closest('.ui-dialog').find('.ui-icon-closethick').click();
  });

  var sendStuff = function () {
    if (isLastBuildingSlot && showLastBuildingSlotWarning) {
      errorBoxDecision(localization.allNetworkAttention, localization.slotWarning, localization.allYes, localization.allNo, sendDMAcceptanceForm);
    } else {
      sendDMAcceptanceForm();
    }
  };

  $('#premiumConfirmButton').on('click', function (event) {
    event.preventDefault();
    sendStuff();
  });
  $(document).on("ajaxShowOverlay", function (event) {
    $('#premiumConfirmButton').focus();
  });
  $('#premiumConfirmButton').on('keyup', function (event) {
    event.stopPropagation();

    if (event.keyCode == 13) {
      sendStuff();
    }
  });
}

function sendDMAcceptanceForm() {
  $('#premiumAcceptForm').submit();
}

function openBuyResourceDialog(buyResourceDialogLink) {
  openOverlay(buyResourceDialogLink, {
    'class': "buyResourceDialog"
  });
}

function abortBuyResource() {
  $('.overlaydiv .abort_button').on('click', function () {
    $('.overlaydiv').dialog('close');
  });
}

function initBuyResources() {
  refreshBars('bar_container', 'filllevel_bar');
  $('.fill_resource').on('click', '.fillup', onChangeToPremium).on('click', '.btn_premium', submitBuyRequest);
  $('.fillup').on('keyup', '.resource_name input', handleInputForResourcePackages);
  initThousandSeparator();
}

function onChangeToPremium(e) {
  var $btn = $(e.currentTarget).find('.btn_blue'),
      $fillup = $btn.closest('.fillup'),
      $premiumBar = $btn.closest('.fill_resource_ctn').find('.premium_bar'); // reset

  $('.fillup').removeClass('premium').parent().find('.current_stock span').removeClass('premium_txt').each(function () {
    // color of the current amount of the selected resource
    var $this = $(this);
    $this.text($this.data('currentAmount')); // reset stock text to current amount
  });
  $('.fill_resource .btn_premium').html(loca.fillUpResource).attr('class', 'btn_blue');
  $('.premium_bar').css('width', '0%').data('premiumPercent', 0); // do not highlight disabled buttons

  if ($btn.attr('disabled') === 'disabled') {
    return;
  }

  updateBuyTextAndActivatePackage($btn, $fillup);
  $fillup.parent().find('.current_stock span').addClass('premium_txt') // color of the current amount of the selected resource
  .text($btn.data('newValueFormatted')); // set stock text to the amount the player will have after buying the package

  $premiumBar.data('premiumPercent', $btn.data('premiumPercent'));
  changeTooltip($premiumBar, '+' + tsdpkt(Math.floor($btn.data('premiumValue'))));
  refreshBars('bar_container', 'filllevel_bar', 'premium_bar');
}

function submitBuyRequest(event, confirmedProductionLoweredWarning) {
  let $btn = $(event.currentTarget),
      userInputAmounts = {},
      changed = false;

  if ($('.buy_resources.content_inner').hasClass('productionBasedPackages') && $btn.data('sufficientDarkMatter') === 0) {
    redirectBuyPremium();
    return;
  }

  if (typeof confirmedProductionLoweredWarning === 'undefined') {
    confirmedProductionLoweredWarning = false;
  } else {
    $btn = confirmedProductionLoweredWarning;
    confirmedProductionLoweredWarning = true;
  }

  let isCapped = parseInt($btn.data('isCapped')),
      productionLowered = parseInt($btn.data('productionLowered'));
  $btn.parents('.fillup').find('.resource_box').each(function () {
    let $elem = $(this);
    let resourceName = $elem.find('.resource_name > input').data('resourceType');
    let $input = $elem.find('.resource_name input');
    userInputAmounts[resourceName] = parseInt($input.val().split(LocalizationStrings.thousandSeperator).join(''));
    changed = changed || $input.data('original') !== userInputAmounts[resourceName];
  });

  if (changed === false) {
    userInputAmounts = {};
  }

  if (productionLowered && confirmedProductionLoweredWarning !== true) {
    errorBoxDecision(loca.buyNow, loca.warnProductionLowered, loca.yes, loca.no, function () {
      submitBuyRequest(event, $btn);
    });
    return;
  }

  if (isCapped === 1 && changed === false) {
    // this can only happen for production based packages
    errorBoxDecision(loca.buyNow, loca.warnCapped, loca.yes, loca.no, function () {
      reallySubmitBuyRequest($btn);
    });
    return;
  }

  reallySubmitBuyRequest($btn, userInputAmounts);
}

function reallySubmitBuyRequest($btn, userInputAmounts) {
  let costs = $btn.data('premiumCosts'),
      itemuuid = $btn.data('itemuuid');
  $.ajax({
    url: buyResourcesLink,
    data: {
      itemUuid: itemuuid,
      costs: costs,
      _token: token,
      userInputAmounts: userInputAmounts
    },
    type: "POST",
    dataType: "json",
    success: function (dataFromBuy) {
      token = dataFromBuy.newAjaxToken;

      if (dataFromBuy.status === 'failure') {
        let error = dataFromBuy.errors[0] || undefined;

        if (error && error.message) {
          fadeBox(error.message, true);
        } else {
          fadeBox(loca["error"], true);
        }

        return;
      } else {
        window.location.reload();
      }
    },
    error: function () {}
  });
}

function handleInputForResourcePackages(e) {
  let regex;

  if (LocalizationStrings.thousandSeperator === '.') {
    regex = new RegExp('\\' + LocalizationStrings.thousandSeperator, 'g');
  } else {
    regex = new RegExp(LocalizationStrings.thousandSeperator, 'g');
  }

  let $input = $(e.target),
      val = parseInt($input.val().replace(regex, '')) || 0,
      original = $input.data('original'),
      modified = false;

  if (e.which !== 75 && e.which >= 65 && e.which <= 90) {
    // prevent a-z. "k" is handled before.
    val = 0;
    modified = true;
  }

  if (val > original) {
    val = original;
    modified = true;
  }

  if (modified === true) {
    $input.val(tsdpkt(val));
  }

  updateCostsAfterUserModification($input);
}

function updateCostsAfterUserModification($clickedInput) {
  let $package = $clickedInput.parents('.fillup'),
      $button = $package.find('.btn_wrap>a'),
      $priceDisplay = $package.find('.premium_txt'),
      $resourceBoxes = $package.find('.resource_box'),
      newPrice = 0,
      darkMatter = $('.buy_resources').data('darkMatter');
  $resourceBoxes.each(function () {
    let $input = $(this).find('.resource_name input');
    let currentInputValue = parseInt($input.val().split(LocalizationStrings.thousandSeperator).join('')) || 0;
    let currentPrice = 0;

    if ($input.data('original') > 0) {
      currentPrice = Math.round($input.data('originalPrice') * currentInputValue / $input.data('dailyProduction'));
    }

    if (currentInputValue > 0 && currentPrice < $button.data('minPremiumCosts')) {
      currentPrice = $button.data('minPremiumCosts');
    }

    newPrice += currentPrice;
  });
  $priceDisplay.html(tsdpkt(newPrice));
  $button.data('premiumCosts', newPrice);

  if (darkMatter < newPrice) {
    $priceDisplay.addClass('overmark');
    $button.data('sufficientDarkMatter', 0);
  } else {
    $priceDisplay.removeClass('overmark');
    $button.data('sufficientDarkMatter', 1);
  } // switch text and set to premium


  updateBuyTextAndActivatePackage($button, $package);
}

function updatePercentageBasedPackages(dataFromBuy, myPackageType, $myButton, $currentPackage, $largePackageNumber) {
  if (!dataFromBuy['isBuyable']) {
    $myButton.attr('disabled', 'disabled');
    $currentPackage.attr('disabled', 'disabled');
    $currentPackage.addClass('disabled');
  }

  $myButton.data('premiumCosts', dataFromBuy['costs']);
  $myButton.data('premiumValue', dataFromBuy['resources']);
  $myButton.data('newValueFormatted', dataFromBuy['newValueFormatted']);

  if (dataFromBuy['displayCosts']) {
    $currentPackage.find('.fillup_cost .premium_txt').html(dataFromBuy['formattedCosts']);
  } else {
    $currentPackage.find('.fillup_cost').addClass('overmark').html('-'); // also kills span with .premium_txt
  }

  if (myPackageType === $largePackageNumber) {
    var buyButtonClass = $myButton.data('buyButtonClass');

    if (!dataFromBuy['isCapped'] && $currentPackage.children("." + buyButtonClass).length) {
      // package was capped but isn't capped anymore
      $currentPackage.children("." + buyButtonClass).removeClass(buyButtonClass).addClass('fillup_100percent');
      $currentPackage.children('.fillup_txt').html(loca.fillUpTo);
    }
  }
}

function updateProductionBasedPackages(collectionData, myPackageType, $myButton, $currentPackage, darkMatter) {
  if (!collectionData['isBuyable']) {
    $myButton.attr('disabled', 'disabled');
    $currentPackage.attr('disabled', 'disabled');
    $currentPackage.addClass('disabled');
    $currentPackage.find('.fillup_cost').addClass('overmark').html('-');
  } else if (darkMatter < collectionData['displayCosts']) {
    $currentPackage.find('.fillup_cost .premium_txt').addClass('overmark').html(tsdpkt(collectionData['displayCosts']));
    $currentPackage.find('.btn_wrap>a').data('sufficientDarkMatter', 0);
  } else {
    $currentPackage.find('.fillup_cost .premium_txt').html(tsdpkt(collectionData['displayCosts']));
  }

  $myButton.data('premiumCosts', collectionData['displayCosts']);
  $currentPackage.find('.resource_box').each(function () {
    let $box = $(this);

    for (let resourceName in collectionData['amounts']) {
      if ($box.find('.resource_img').hasClass(resourceName)) {
        let $amountDisplay = $box.find('.resource_name');
        $amountDisplay.find('input').val(collectionData['amounts'][resourceName]).data('original', collectionData['amounts'][resourceName]);

        if (collectionData['isResourceCapped'][resourceName]) {
          $amountDisplay.addClass('overmark');
        }

        if (collectionData['isCapped']) {
          $myButton.data('isCapped', 1);
        } else {
          $myButton.data('isCapped', 0);
        }
      }
    }
  });
}

function updateBuyTextAndActivatePackage($buttonElem, $package) {
  $buttonElem.html(!$('.buy_resources.content_inner').hasClass('productionBasedPackages') || $buttonElem.data('sufficientDarkMatter') ? loca.buyNow : loca.getDM).attr('class', 'btn_premium small');
  $package.addClass('premium');
}
/**/
ogame.chat = {
  socket: null,
  connected: false,
  connecting: false,
  timeout: null,
  retryInterval: 5000,
  playerId: null,
  associationId: null,
  data: {
    association: {}
  },
  playernames: {},
  playerList: null,
  isLoadingPlayerList: false,
  playerListSelector: new Array(),

  /**
   * Initialize connection to the socket
   */
  initConnection: function () {
    var $this = ogame.chat; // if its connected or on connecting do nothing

    if ($this.connecting || $this.connected || $this.isMobile) {
      if (this.socket) {
        $this.socket.disconnect();
      }
    }

    $this.connecting = true; // try to connect

    try {
      $this.socket = io.connect(":" + nodePort + "/chat", nodeParams);
      $this.socket.on('connect', function () {
        clearTimeout(this.timeout); // send session for authorize... on success set it to connected else disconnect socket

        $this.socket.emit("authorize", session, function (success) {
          $this.connecting = false;

          if (success) {
            $this.connected = true;
          } else {
            $this.socket.disconnect();
          }
        });
      });
      $this.socket.on("chat", function (data) {
        $this.messageReceived(data);
      });
      $this.socket.on('disconnect', function () {
        $this.connected = false;
        $this.connecting = false; //$this.retryConnection();
      });
    } catch (e) {
      // TODO: Ursache fuer doppelten Aufruf auf der Chat-Seite finden
      $this.connecting = false; // wichtig, damit 2. Aufruf durch geht
    }
  },

  /**
   * initialize connection and chatlog
   */
  initialize: function () {
    if (typeof nodeUrl === 'undefined') {
      return;
    }

    var $this = ogame.chat;
    loadScript(nodeUrl, $this.initConnection);
    $(".new_msg_count[data-playerid]").each(function () {
      $this.saveMessageCounter($(this).data('new-messages'), $(this).data('playerid'));
    });
    this.updateTotalNewChatCounter(); // Aufrufe von Chats ueber die Spielerliste

    $('.js_playerlist').on('click', '.playerlist_item', function () {
      var nothing2load = $(this).hasClass('nothingThere');

      if (!nothing2load) {
        var msgid = $(this).data('msgid');

        if (msgid) {
          $this.loadChatLogWithPlayer(this, msgid);
        } else {
          $this.loadChatLogWithPlayer(this);
        }
      }
    }); // Aufruf von Alli/Kolaitions-Chats ueber die Spielerliste

    $('.js_playerlist').on('click', '.openAssociationChat', function () {
      var msgid = $(this).data('msgid');

      if (msgid) {
        $this.loadChatLogWithAssociation(this, msgid);
      } else {
        $this.loadChatLogWithAssociation(this);
      }
    }); // Aufrufe von Chats ueber die Chatliste

    $('#chatMsgList').on('click', '.msg', function () {
      var msgPlayerId = $(this).data('playerid');
      var msgAssociationId = $(this).data('associationid');

      if (msgPlayerId !== undefined && msgPlayerId > 0) {
        $this.saveMessageCounter(0, msgPlayerId);
        ogame.messagemarker.setPartnerId(msgPlayerId);
        ogame.messagemarker.updateNewMarker();
        ogame.chat.updateTotalNewChatCounter();
        var msgid = $('.playerlist .playerlist_item[data-playerId=' + msgPlayerId + ']').data('msgid');

        if (msgid) {
          $this.loadChatLogWithPlayer(this, msgid);
        } else {
          $this.loadChatLogWithPlayer(this);
        }
      } else {
        var msgid = $('.playerlist .playerlist_item[data-associationId=' + msgAssociationId + ']').data('msgid');
        $this.saveMessageCounterAssociation(0, msgAssociationId);

        if (msgid) {
          $this.loadChatLogWithAssociation(this, msgid);
        } else {
          $this.loadChatLogWithAssociation(this);
        }
      }
    });
    $('.chat').on('click', '.sys_msg', function (event) {
      var playerIdOfclickedChat = $(this).data('foreign-player-id');
      var associationIdOfclickedChat = $(this).data('foreign-association-id');
      var ajaxData = {
        playerId: playerIdOfclickedChat,
        associationId: associationIdOfclickedChat,
        ajax: 1
      };
      $.ajax({
        url: chatUrlLoadMoreMessages,
        type: 'POST',
        dataType: 'html',
        data: ajaxData,
        success: function (data) {
          //Finding the right chat window
          $('.chat').each(function (index, element) {
            if (playerIdOfclickedChat !== undefined && playerIdOfclickedChat == $(element).data('foreign-player-id')) {
              $(element).html(data); //Replace the content of the chat-window with the new data from the backend.
            } else if (associationIdOfclickedChat !== undefined && associationIdOfclickedChat == $(element).data('foreign-association-id')) {
              $(element).html(data); //Replace the content of the chat-window with the new data from the backend.
            }
          });
        },
        error: function (jqXHR, textStatus, errorThrown) {}
      });
    });
    $('body').on('click', '.js_openChat', function () {
      $this.loadChatLogWithPlayer(this);
    }); //maximize Chat set

    if (typeof $.cookie('maximizeId') == "string" || typeof $.cookie('maximizeId') == "number") {
      $('#chatMsgList .msg[data-playerid="' + $.cookie('maximizeId') + '"]').trigger('click');
      $.cookie('maximizeId', null);
    }
  },

  /**
   * gets the total new chat counter.
   *
   * @returns {Number}
   */
  getTotalNewChatCounter: function () {
    return ogame.messagecounter.sumNewChatMessages;
  },

  /**
   * calc total new chat counter and updates it.
   *
   * @returns {Number} total new chat counter
   */
  updateTotalNewChatCounter: function () {
    var sumNewChatMessages = 0;

    if ($(".msg .new_msg_count").length > 0) {
      $(".msg .new_msg_count").each(function () {
        sumNewChatMessages += Number($(this).data('new-messages'));
      });
    } else if ($("#chatBarPlayerList .new_msg_count").length > 0) {
      $("#chatBarPlayerList .new_msg_count").each(function () {
        sumNewChatMessages += Number($(this).data('new-messages'));
      });
    }

    ogame.messagecounter.initialize(ogame.messagecounter.type_chat, ogame.chat.playerId);

    if (ogame.messagecounter.sumNewChatMessages !== sumNewChatMessages) {
      ogame.messagecounter.initChatCounter(sumNewChatMessages);
      ogame.messagecounter.sumNewChatMessages = sumNewChatMessages;
      ogame.messagecounter.update();
    }

    return sumNewChatMessages;
  },

  /**
   * retry to initialize Connection
   */
  retryConnection: function () {
    var $this = ogame.chat;
    setTimeout(function () {
      $this.initConnection();
    }, 5000);
  },

  /**
   * sending the message
   *
   * @param {number} playerId >> id of the chat partner
   * @param {number} associationId >> id of the association (ally or coalition)
   * @param {string} messageText >> text to send
   *
   */
  sendMessage: function (playerId, associationId, messageText, refData) {
    var $this = ogame.chat;

    if ($.trim(messageText).length == 0) {
      showError("TEXT_EMPTY");
      return;
    }

    var ajaxData;

    if (playerId > 0) {
      ajaxData = {
        playerId: playerId,
        text: messageText,
        mode: 1,
        ajax: 1,
        _token: window.ajaxChatToken
      };
    } else {
      ajaxData = {
        associationId: associationId,
        text: messageText,
        mode: 3,
        ajax: 1,
        _token: window.ajaxChatToken
      };
    }

    if (typeof refData !== "undefined" && typeof refData.id !== "undefined") {
      ajaxData.msg2reply = refData.id;
    }

    function sendMessageViaAjax() {
      // send ajax Request
      $.ajax({
        url: chatUrl,
        type: 'POST',
        dataType: 'json',
        data: ajaxData,
        success: function (data) {
          addChatMessage(data);
          window.ajaxChatToken = data.newToken;
        },
        error: function (jqXHR, textStatus, errorThrown) {}
      });
    }

    function messageSent(data) {
      if (typeof data.refAuthor !== "undefined" && typeof data.refContent !== "undefined") {
        $refData = {
          'author': data.refAuthor,
          'text': data.refContent
        };
      } else {
        $refData = 0;
      }

      if (data.targetId !== undefined) {
        $this.addChatItem(data.targetId, 0, data.text, data.id, false, $refData, data.date);
      } else {
        $this.addChatItem(playerId, data.targetAssociationId, data.text, data.id, false, $refData, data.date);
      }
    }

    function showError(errorText) {
      if (chatLoca[errorText] !== undefined) {
        errorBoxNotify(LocalizationStrings.error, chatLoca[errorText], LocalizationStrings.ok);
      } else {
        errorBoxNotify(LocalizationStrings.error, errorText, LocalizationStrings.ok);
      }
    }

    function addChatMessage(result) {
      switch (result.status) {
        case 'NOT_AUTHORIZED':
          // do not show this error, try to send with ajax instead
          sendMessageViaAjax();
          break;

        case 'OK':
          messageSent(result);
          ogame.chat.cleanupUrl();
          break;

        default:
          showError(result.status);
      }
    }

    sendMessageViaAjax();
  },

  /**
   * get new message in chat
   *
   * @param {object} data >> message data
   *
   */
  messageReceived: function (data) {
    var $this = ogame.chat;

    if (typeof data.refAuthor !== "undefined" && typeof data.refText !== "undefined") {
      $refData = {
        'author': data.refAuhtor,
        'text': data.refText
      };
    } else {
      $refData = 0;
    } // for the association chats we need to get the player names from the backend.


    if (data.senderName !== undefined && data.senderId !== undefined) {
      //Save names, you get from the backend for later use in addChatItem
      $this.playernames[data.senderId] = data.senderName;
    }

    if ($(".chat_bar_list").length) {
      //only if chat bar is active
      if (data.associationId !== undefined && data.associationId > 0) {
        if ($this.data.association[data.associationId] === undefined) {
          $this.loadChatLogWithAssociation(data.associationId, null, function () {
            $this.addChatItem(data.senderId, data.associationId, data.text, data.id, true, $refData, data.date);
          }, false);
        } else {
          $this.addChatItem(data.senderId, data.associationId, data.text, data.id, true, $refData, data.date);
        }
      } else {
        if ($this.data[data.senderId] === undefined) {
          $this.loadChatLogWithPlayer(data.senderId, null, function () {
            $this.addChatItem(data.senderId, 0, data.text, data.id, true, $refData, data.date);
          }, false);
        } else {
          $this.addChatItem(data.senderId, 0, data.text, data.id, true, $refData, data.date);
        }
      }
    }

    if (data.associationId !== undefined && data.associationId > 0) {
      // count new mesages only if chat closed
      if ($('.chat_bar_list_item.open[data-associationid="' + data.associationId + '"]').length <= 0) {
        var newCount = $('.new_msg_count[data-associationid="' + data.associationId + '"]').data('new-messages');

        if (isNaN(newCount)) {
          newCount = 0;
        }

        newCount++;
        $this.saveMessageCounterAssociation(newCount, data.associationId);
        $this.updateTotalNewChatCounter();
      } else {
        // Set received message as read
        var ajaxData = {
          associationId: data.associationId,
          mode: 4,
          ajax: 1,
          updateUnread: 1
        };
        $.ajax({
          url: chatUrl,
          type: 'POST',
          data: ajaxData,
          success: function (data) {},
          error: function (jqXHR, textStatus, errorThrown) {}
        });
      }
    } else if (data.senderId !== undefined && data.senderId > 0) {
      ogame.messagemarker.setPartnerId(data.senderId);

      if (!$this.isOpen(data.senderId)) {
        ogame.messagecounter.initialize(ogame.messagecounter.type_chat, data.senderId);
        var newCount = parseInt(ogame.messagecounter.newChats[data.senderId]);

        if (isNaN(newCount)) {
          newCount = 0;
        }

        newCount++;
        $this.saveMessageCounter(newCount, data.senderId);
        ogame.messagemarker.updateNewMarker();
      } else {
        $this.saveMessageCounter(0, $(this).data('playerid'));
        ogame.messagemarker.updateNewMarker();
      }
    }
  },
  cleanupUrl: function () {// @todo what is the purpose?
    // since twig components always contain a & in their path I need to comment it out

    /*
    var currentUrl = window.location.href;
    var indexOfMsgid = currentUrl.indexOf('&');
      	if(indexOfMsgid > 0) {
    var paramIndex = currentUrl.indexOf('?');
    var firstPartOfUrl = currentUrl.substring(0, paramIndex);
    var newUrl = firstPartOfUrl+'?page=chat';

    	window.history.pushState({}, "", newUrl);
    }
    */
  },
  saveMessageCounter: function (count, playerId) {
    if (isNaN(playerId) || playerId === 0) {
      return false;
    }

    $('.new_msg_count[data-playerid="' + playerId + '"]').data('new-messages', count);
    ogame.messagecounter.newChats[playerId] = count;
  },
  saveMessageCounterAssociation: function (count, associationId) {
    if (isNaN(associationId) || associationId === 0) {
      return false;
    }

    $('.new_msg_count[data-associationid="' + associationId + '"]').data('new-messages', count);
    $('.new_msg_count[data-associationid="' + associationId + '"]').text(count);
    ogame.messagemarker.updateNewMarker();
  },

  /**
   * proof if the chat of the player is open
   * @param {string} playerid
   * @returns {boolean}
   */
  isOpen: function (playerid) {
    var isChatOpen = false;
    var chatPartnerId = $(".chatContent").data('chatplayerid');

    if (chatPartnerId != 'undefined' && chatPartnerId == playerid) {
      isChatOpen = true;
    } else {
      $(".chat_box").each(function () {
        if ($(this).attr('data-playerid') == playerid) {
          if ($(this).css("display") == "block") {
            isChatOpen = true;
          }
        }
      });
    }

    return isChatOpen;
  },

  /**
   * Load chatlog of player and playerinfo
   *
   * @param {mixed} element >> playerid of the other player
   * @param function callback
   *
   */
  loadChatLogWithPlayer: function (element, msg2reply, callback, updateUnread) {
    var $this = ogame.chat;
    var foreignPlayerId;

    if (typeof updateUnread == 'undefined') {
      updateUnread = true;
    }

    if (typeof element == 'number') {
      foreignPlayerId = element;
    } else {
      foreignPlayerId = $(element).attr('data-playerId');
    }

    var ajaxData = {
      playerId: foreignPlayerId,
      mode: 2,
      ajax: 1,
      updateUnread: updateUnread ? 1 : 0
    };

    if (typeof msg2reply == 'number') {
      ajaxData.msg2reply = msg2reply;
    }

    $.ajax({
      url: chatUrl,
      type: 'POST',
      data: ajaxData,
      success: function (data) {
        data = JSON.parse(data);
        $this.data[data.playerId] = {
          playerstatus: data.playerstatus,
          playerName: data.playerName,
          playerId: data.playerId,
          chatItems: data.chatItems,
          chatItemsByDateAsc: data.chatItemsByDateAsc
        };

        if (typeof callback == 'function') {
          callback();
        } else if ($(element).parents('#chatBarPlayerList').length || $('body')[0].id != 'chat') {
          // use chat bar
          $this.showChat(data);
        } else {
          $this.showChatHistory(data);
        }

        var currentChat = $(".chat_bar_list").find("[data-playerid='" + data.playerId + "']");
        $this.updateCustomScrollbar(currentChat.find('.chat_box_ctn'));
      },
      error: function (jqXHR, textStatus, errorThrown) {}
    });
  },

  /**
   * Load chatlog of association chat
   *
   * @param {mixed} element >> associationid of the other player
   * @param function callback
   *
   */
  loadChatLogWithAssociation: function (element, msg2reply, callback, updateUnread) {
    var $this = ogame.chat;
    var associationId;

    if (typeof updateUnread == 'undefined') {
      updateUnread = true;
    }

    if (typeof element == 'number') {
      associationId = element;
    } else {
      associationId = $(element).attr('data-associationid');
    }

    var ajaxData = {
      associationId: associationId,
      mode: 4,
      ajax: 1,
      updateUnread: updateUnread ? 1 : 0
    };

    if (typeof msg2reply == 'number') {
      ajaxData.msg2reply = msg2reply;
    }

    $.ajax({
      url: chatUrl,
      type: 'POST',
      data: ajaxData,
      success: function (data) {
        data = JSON.parse(data);
        $this.data.association[data.associationId] = {
          playerstatus: data.playerstatus,
          associationName: data.associationName,
          associationId: data.associationId,
          chatItems: data.chatItems,
          chatItemsByDateAsc: data.chatItemsByDateAsc
        };

        if (typeof callback == 'function') {
          callback();
        } else if ($(element).parents('#chatBarPlayerList').length || $('body')[0].id != 'chat') {
          // use chat bar
          $this.showChat(data);
        } else {
          $this.showChatHistory(data);
        }

        var currentChat = $(".chat_bar_list").find("[data-associationid='" + data.associationId + "']");
        $this.updateCustomScrollbar(currentChat.find('.chat_box_ctn'));
      },
      error: function (jqXHR, textStatus, errorThrown) {}
    });
  },

  /**
   * This initializes the node.js chat
   * @returns {undefined}
   */
  initChat: function (playerId, isMobile) {
    ogame.chat.playerId = playerId;
    ogame.chat.isMobile = isMobile;
    ogame.chat.initPlayerlist();
    ogame.chat.initialize();
    ogame.chat.toggleVisibility();
    ogame.chat.setVisibilityState();
    ogame.chat.initMaximize();
    ogame.chat.getInMaxChat();
  },

  /**
   * get data of a specific message in dom
   *
   * @return {object} itemData
   */
  getLastChatItemData: function () {
    var $this = ogame.chat;
    var newestChatMessage = null;
    $(".chat_box_ctn .mCustomScrollBox .mCSB_container").each(function () {
      var lastMessage = $(this).children('ul.chat').children('li:last');

      if (newestChatMessage === null || lastMessage.attr('data-chat-id') > newestChatMessage.attr('data-chat-id')) {
        newestChatMessage = lastMessage;
      }
    }); // Ugly hack to enable chatting when chatbar is disabled

    if (newestChatMessage === null) {
      $("ul.largeChat").each(function () {
        var lastMessage = $(this).children('li:last');

        if (newestChatMessage === null || lastMessage.attr('data-chat-id') > newestChatMessage.attr('data-chat-id')) {
          newestChatMessage = lastMessage;
        }
      });
    }

    if (newestChatMessage === null) return null;
    var msgDate = newestChatMessage.children('.msg_head').find('.msg_date').html();
    var msgText = newestChatMessage.find('.msg_content').html();
    var itemData = {
      'date': msgDate,
      'text': msgText
    };
    return itemData;
  },

  /**
   * Adds a chat item to a chat in the chat bar and to the Detail Chat Page ( = chatHistory)
   * if we are on that page
   *
   * @param {String} foreignPlayerId
   * @param {String} associationId
   * @param {String} msg
   * @param {int} msgId
   * @param {bool} received
   * @param $refData
   * @param srvTime
   * @return {undefined}
   */
  addChatItem: function (foreignPlayerId, associationId, msg, msgId, received, $refData, srvTime) {
    var $this = ogame.chat;
    var currentChat;

    if (associationId > 0) {
      currentChat = $(".chat_bar_list").find("[data-associationid='" + associationId + "']");
    } else {
      currentChat = $(".chat_bar_list").find("[data-playerid='" + foreignPlayerId + "']");
    }

    var chatItemData = {};
    chatItemData.date = srvTime; //will be formated later in createchatitem

    chatItemData.newClass = 'new';

    if (received) {
      // the class odd should only be added in case a message was received
      if ($this.data[foreignPlayerId] !== undefined) {
        chatItemData.playerName = $this.data[foreignPlayerId].playerName;
      } else {
        chatItemData.playerName = $this.playernames[foreignPlayerId];
      }

      chatItemData.altClass = '';
    } else {
      chatItemData.playerName = playerName;
      /* global own playerName */

      chatItemData.altClass = 'odd';
    }

    chatItemData.chatID = msgId; // this is probably some unique number

    chatItemData.chatContent = msg;

    if (typeof $refData == 'object') {
      chatItemData.refData = $refData;
    }

    if (!currentChat.length) {
      // someone new wants to talk to us || we want to talk to someone new \\
      var chatBoxContainer = $this.createChatBarContainer(foreignPlayerId);
      $this.updateChatBar(chatBoxContainer);
      currentChat = $(".chat_bar_list").find("[data-playerid='" + foreignPlayerId + "']");
    }

    var chatItem = $this.createChatItem(chatItemData);
    var lastItem = $this.getLastChatItemData(); // if message already exists

    if (lastItem !== null && (chatItemData.date != lastItem.date || chatItemData.chatContent != lastItem.text)) {
      // chatbar
      currentChat.find('.chat').append(chatItem);
      $this.updateCustomScrollbar(currentChat.find('.chat_box_ctn'));
      var chatHistory = $('.js_chatHistory');

      if (chatHistory.length && (chatHistory.data('chatplayerid') == foreignPlayerId || chatHistory.data('associationid') == associationId)) {
        //chat page
        chatHistory.find('.chat.clearfix').append(chatItem.clone());
        $this.updateCustomScrollbar($(".largeChatContainer"));
      }
    }
  },

  /**
   * Add items to moreBox
   *
   * @param {Object} chatbarListItems - Array of chatbar list items
   * @return {undefined}
   */
  addToMoreBox: function (chatbarListItems) {
    var $this = ogame.chat;
    var listLength = chatbarListItems.length;

    if (listLength && $('.more_chat_bar_items').length < 1) {
      $('.chat_bar_list').append($this.createMoreBox('more_chat_bar_items'));
    }

    var moreItemsList = $('.more_chat_bar_items .more_items');
    var moreItemsBox = $('.more_chat_bar_items .chat_box');

    for (var i = 0; i <= listLength; i++) {
      moreItemsList.append(chatbarListItems.pop());
    }

    $this.updateCustomScrollbar(moreItemsBox);
  },

  /**
   * Creates a new chatbar container element.
   *
   * A chatbar container consists of the chatbar list element for the player with the given playerid
   * and the corresponing chatbox (the chatbox is initially open)
   *
   * @param {String} playerid
   * @returns {DOM Object}
   */
  createChatBarContainer: function (playerid) {
    var $this = ogame.chat;

    if (!playerid) {
      return;
    }

    var chatBarData = $this.data[playerid];
    $this.data.playerId = playerid;
    var chatBarItem = $('<li class="chat_bar_list_item open" data-playerid="' + playerid + '"></li>');
    chatBarItem.append('<span class="playerstatus ' + chatBarData.playerstatus + '"></span>');
    chatBarItem.append('<span class="cb_playername">' + chatBarData.playerName + '</span>');
    chatBarItem.append('<span class="icon icon_close fright"></span>'); // adding the chat to the box

    chatBarItem.prepend($this.createChatBox(playerid));
    return chatBarItem;
  },

  /**
   * Creates a new chatbar container element for group chats.
   *
   *
   * @param {String} associationId
   * @returns {DOM Object}
   */
  createChatBarContainerForAssociations: function (associationId) {
    var $this = ogame.chat;

    if (!associationId) {
      return;
    }

    var chatBarData = $this.data.association[associationId];
    $this.data.associationId = associationId;
    var chatBarItem = $('<li class="chat_bar_list_item open" data-associationId="' + associationId + '"></li>');
    chatBarItem.append('<span class="playerstatus ' + chatBarData.playerstatus + '"></span>');
    chatBarItem.append('<span class="cb_playername">' + chatBarData.associationName + '</span>');
    chatBarItem.append('<span class="icon icon_close fright"></span>'); // adding the chat to the box

    chatBarItem.prepend($this.createChatBoxForAssociations(associationId));
    return chatBarItem;
  },

  /**
   * Make it Invisible in the Chatbar
   */
  closeChatBox: function (playerid, associationid) {
    var chatbaritems = $(".chat_bar_list_item");
    $.each(chatbaritems, function (key, item) {
      if (playerid !== undefined && $(item).data('playerid') == playerid) {
        $(item).addClass('outOfChatbar');
        $(item).removeClass('open');
      } else if (associationid !== undefined && $(item).data('associationid') == associationid) {
        $(item).addClass('outOfChatbar');
        $(item).removeClass('open');
      }
    });
  },

  /**
   * Get ONLY the chats that should be shown
   *
   * @returns {Array} visibleChats
   */
  getVisibleChats: function () {
    if (typeof visibleChats == "undefined") visibleChats = {
      "chatbar": false,
      "players": [],
      "associations": []
    };
    return visibleChats;
  },

  /**
   * get playerids from visible chats
   *
   * @returns {Array} playerIDs
   */
  getVisibleChatPlayerIds: function () {
    var $this = ogame.chat;
    var visibles = $this.getVisibleChats();
    var playerIDs = {};
    var jsonIndex = 0;

    for (var i = 0; i < visibles.players.length; i++) {
      if ($.inArray(visibles.players[i]['partnerId'], playerIDs) == -1) {
        playerIDs[jsonIndex] = visibles.players[i]['partnerId'];
        jsonIndex++;
      }
    }

    return playerIDs;
  },

  /**
   * get associationIds from visible chats
   *
   * @returns {Array} playerIDs
   */
  getVisibleChatAssociationIds: function () {
    var $this = ogame.chat;
    var visibles = $this.getVisibleChats();
    var associationIDs = {};
    var jsonIndex = 0;

    for (var i = 0; i < visibles.associations.length; i++) {
      if ($.inArray(visibles.associations[i]['partnerId'], associationIDs) == -1) {
        associationIDs[jsonIndex] = visibles.associations[i];
        jsonIndex++;
      }
    }

    return associationIDs;
  },

  /**
   * Set visibility state of chats
   */
  setVisibilityState: function () {
    var $this = ogame.chat;
    var visiblesPlayers = $this.getVisibleChatPlayerIds();
    var visiblesAssociations = $this.getVisibleChatAssociationIds();
    var listitems = $('#chatBar .chat_bar_list .chat_bar_list_item');

    for (var i = 0; i < listitems.length; i++) {
      var item = listitems.get(i);
      var playerid = $(item).data('playerid');
      var associationid = $(item).data('associationid'); //if its not on the visiblelist - close it instant

      if (playerid !== undefined && !$this.isInJson(playerid, visiblesPlayers)) {
        $this.closeChatBox(playerid, 0);
      } else if (associationid !== undefined && !$this.isInJson(associationid, visiblesAssociations)) {
        $this.closeChatBox(0, associationid);
      } else {
        item.style.display = 'inline';

        if ($(item).hasClass('open')) {
          var box = $(item).find('div.chat_box')[0];
          box.style.display = 'inline';
          $this.updateCustomScrollbar($(item).find('.chat_box_ctn'), 1);
        }
      }
    }
  },

  /**
   * Search 4 value in json-object
   */
  isInJson: function (value, json) {
    var returningValue = null;

    if ($.isEmptyObject(json)) {
      returningValue = false;
    }

    if (returningValue !== false) {
      $.each(json, function (key, jsonValue) {
        if (jsonValue == value) {
          returningValue = true;
        }
      });

      if (returningValue !== true) {
        false;
      }
    }

    return returningValue;
  },
  toggleVisibility: function () {
    $(".chat_bar_list_item .icon_close").on("click", function (clickObject) {
      var toPlayerId = $(this).parent().data("playerid");
      var closeThis = $(this).closest('.chat_box');

      if (!closeThis.length) {
        closeThis = $(this).parent()[0];
        closeThis.style.display = 'none';
      }

      if (toPlayerId > 0) {
        $.ajax({
          type: "POST",
          url: "/game/index.php?page=ajaxChatToggleVisibility",
          data: {
            from: playerId,
            to: toPlayerId,
            showState: 0
          },
          success: function (e) {},
          error: function (jqXHR, textStatus, errorThrown) {}
        });
      }
    });
    $(".cb_playerlist_box .playerlist_item").on("click", function () {
      var toPlayerId = $(this).data("playerid");

      if (toPlayerId) {
        $.ajax({
          type: "POST",
          url: "/game/index.php?page=ajaxChatToggleVisibility",
          data: {
            from: playerId,
            to: toPlayerId,
            showState: 1
          },
          success: function (e) {},
          error: function (jqXHR, textStatus, errorThrown) {}
        });
      }
    });
  },
  initMaximize: function () {
    $('.chat_bar_list').on('click.chatBar', '.chat_box .chat_box_title .icon_maximize', function () {
      var chatTitle = $(this).parent();
      var playerid = $(chatTitle).parent().data('playerid');
      $.cookie('maximizeId', playerid);
      $('.chat_bar_list_item.open .chat_box_title .icon_close').trigger('click');
      window.location = bigChatLink + '&playerId=' + playerid;
    });
  },
  getInMaxChat: function () {
    var currentLocation = location.href;
    if (typeof bigChatLink == "undefined") bigChatLink = "";

    if (bigChatLink == currentLocation) {
      if ($.cookie('maximizeId') !== null) {
        $('#chatMsgList .msg[data-playerId=' + $.cookie('maximizeId') + ']').trigger('click');
      }
    }

    $.cookie('maximizeId', null);
  },

  /**
   * Create a chatbox item to be shown in the chatbar.
   * A Chatbox contains chatitems
   *
   * @param {String} playerid
   * @returns {DOM Object} $chatBox
   */
  createChatBox: function (playerid) {
    var $this = ogame.chat;

    if (!playerid) {
      return;
    }

    var chatBarData = $this.data[playerid];
    var chatBoxHeader = $('<div class="chat_box_title"></div>');
    chatBoxHeader.append('<span class="icon icon_close fright"></span>');
    chatBoxHeader.append('<span class="icon icon_maximize fright"></span>');
    var chatBoxCtn = $('<div class="chat_box_ctn"><ul class="chat clearfix"></ul></div>');
    var chatItem = {};

    for (var i = 0; i < chatBarData.chatItemsByDateAsc.length; i++) {
      chatItem = chatBarData.chatItems[chatBarData.chatItemsByDateAsc[i]];
      chatBoxCtn.find('.chat').append($this.createChatItem(chatItem));
    }

    var chatBox = $('<div class="chat_box" data-playerid="' + playerid + '"></div>');
    chatBox.append(chatBoxHeader);
    chatBox.append(chatBoxCtn);
    chatBox.append('<textarea name="text" class="chat_box_textarea"></textarea>');
    return chatBox;
  },

  /**
   * Create a chatbox item to be shown in the chatbar.
   * A Chatbox contains chatitems
   *
   * @param {String} playerid
   * @returns {DOM Object} $chatBox
   */
  createChatBoxForAssociations: function (associationId) {
    var $this = ogame.chat;

    if (!associationId) {
      return;
    }

    var chatBarData = $this.data.association[associationId];
    var chatBoxHeader = $('<div class="chat_box_title"></div>');
    chatBoxHeader.append('<span class="icon icon_close fright"></span>');
    chatBoxHeader.append('<span class="icon icon_maximize fright"></span>');
    var chatBoxCtn = $('<div class="chat_box_ctn"><ul class="chat clearfix"></ul></div>');
    var chatItem = {};

    for (var i = 0; i < chatBarData.chatItemsByDateAsc.length; i++) {
      chatItem = chatBarData.chatItems[chatBarData.chatItemsByDateAsc[i]];
      chatBoxCtn.find('.chat').append($this.createChatItem(chatItem));
    }

    var chatBox = $('<div class="chat_box" data-associationId="' + associationId + '"></div>');
    chatBox.append(chatBoxHeader);
    chatBox.append(chatBoxCtn);
    chatBox.append('<textarea name="text" class="chat_box_textarea"></textarea>');
    return chatBox;
  },

  /**
   * Creates a chatitem
   *
   * A Chatitem can be added to a chatbox in the chatbar or to an existing chat in the chatcontent page.
   *
   * @param {Object} chatData - data needed for the chat item
   * @returns {DOM Object} $chatItem
   */
  createChatItem: function (chatData) {
    if (!chatData) {
      console.warn('no chatItem given');
      return;
    }

    var chatItemHeader = $('<div class="msg_head"></div>');
    chatItemHeader.append('<span class="msg_date fright">' + getFormatedDate(chatData.date, '[d].[m].[Y] <span>[H]:[i]:[s]</span>') + '</span>');
    chatItemHeader.append('<span class="msg_title blue_txt ' + chatData.newClass + '">' + chatData.playerName + '</span>');
    var chatItem = $('<li class="chat_msg ' + chatData.altClass + '" data-chat-id="' + chatData.chatID + '"></li>');
    chatItem.append(chatItemHeader);

    if (typeof chatData.refData !== "undefined") {
      var refMsgItem = $('<div class="referenceMsg"></div>');
      var refAuthorItem = '<div class="refAuthor">' + chatData.refData.author + '</div>';
      var refTextItem = '<div class="refText new">' + chatData.refData.text + '</div>';
      refMsgItem.append(refAuthorItem);
      refMsgItem.append(refTextItem);
      chatItem.append(refMsgItem);
    }

    chatItem.append('<span class="msg_content">' + chatData.chatContent + '</span>');
    chatItem.append('<div class="speechbubble_arrow"></div>');
    return chatItem;
  },

  /**
   * Create a a chatbar item of the type moreBox that will be a container for
   * all items that don't fit into the chatbar directly
   *
   * @param {String} itemClass
   * @returns {DOM Object} $moreBox
   */
  createMoreBox: function (itemClass) {
    var moreBox = $('<li class="chat_bar_list_item ' + itemClass + '">' + chatLoca['MORE_USERS'] + '<span class="icon icon_close fright"></span></li>');
    moreBox.prepend($('<div class="chat_box"><ul class="more_items clearfix"></ul></div>'));
    return moreBox;
  },

  /**
   * Filters the playerlist after the criteria that are selected in the
   * filter form
   *
   * @returns {undefined}
   */
  filterPlayerlist: function () {
    var filters = [];
    var isChecked;
    var filterCheckboxes = $('#playerlistFilters').find('input[type="checkbox"]'); // get filters to check

    filterCheckboxes.each(function () {
      filters.push($(this).attr('id'));
    });
    $('.playerlist_item').show(); // we don't need to filter anything if no filter is active

    isChecked = false;
    filterCheckboxes.each(function () {
      if ($(this).prop('checked')) isChecked = true;
    });

    if (!isChecked) {
      return;
    }

    var doFilter;
    var listElement;
    $('.playerlist_item').filter(function () {
      doFilter = false;
      listElement = $(this); // for every filter

      $.each(filters, function (i, filter) {
        // check if the element matches filter criteria
        // and should be filtered by that criteria
        if (listElement.data(filter) === 'off' && $('#' + filter).prop('checked')) {
          doFilter = true;
        }
      }); // hide the element if it should be filtered out

      doFilter === true ? listElement.hide() : listElement.show();
    });
  },

  /**
   * initializes the functions needed for the display of the chatbar
   *
   * @returns {undefined}
   */
  initChatBar: function (playerId) {
    var $this = ogame.chat;
    ogame.chat.playerId = playerId;
    $('html').off('.chatBar');
    $(window).resize(function () {
      $this.updateChatBar();
    }); // var playeridsInList = [];
    //
    // $('#chatBarPlayerList li.playerlist_item').each(function(index) {
    // 	if(!$(this).hasClass('nothingThere')) {
    // 		playeridsInList[index] = $(this).data('playerid');
    // 	}
    // });
    //
    // if(playeridsInList.length > 0) {
    // 	ogame.messagemarker.initMarker(playeridsInList);
    // }
    //        var chatsum = 0;
    //
    //        $('#chatBarPlayerList li.playerlist_item .newMsgMarker').each(function() {
    //        	chatsum = chatsum + 1;
    //        });
    //
    //        ogame.messagecounter.initChatCounter(chatsum);
    // $(".new_msg_count").each(function() {
    //     $this.saveMessageCounter($(this).data('new-messages'), $(this).data('playerid'));
    // });
    //
    // this.updateTotalNewChatCounter();

    $('.chat_bar_list').on('click.chatBar', '#chatBarPlayerList', function (e) {
      if ($(e.target).attr('id') !== 'chatBarPlayerList' && !$(e.target).hasClass('onlineCount')) {
        return;
      }

      $('.cb_playerlist_box').toggle();
      $this.updateCustomScrollbar($(".scrollContainer"), true);
      $.ajax({
        url: chatUrl,
        type: 'POST',
        dataType: 'json',
        data: {
          action: 'toggleChatBar'
        },
        success: function (data) {},
        error: function (jqXHR, textStatus, errorThrown) {}
      });
    }).on('click.chatBar', '.chat_bar_list_item', function (e) {
      e.stopPropagation();

      if (!isNaN($(this).data('playerid'))) {
        ogame.messagemarker.toggle(ogame.messagemarker.action_remove, ogame.messagemarker.type_chattab, $(this).data('playerid'));
        ogame.messagemarker.toggle(ogame.messagemarker.action_remove, ogame.messagemarker.type_chatbar, $(this).data('playerid'));
        $this.saveMessageCounter(0, $(this).data('playerid'));
        ogame.messagemarker.setPartnerId($(this).data('playerid'));
        ogame.messagemarker.updateNewMarker();
        ogame.chat.updateTotalNewChatCounter();
      } else if (!isNaN($(this).data('associationid') > 0)) {
        $this.saveMessageCounterAssociation(0, $(this).data('associationid'));
      }

      $.ajax({
        url: chatUrl,
        type: 'POST',
        dataType: 'json',
        data: {
          playerId: $(this).data('playerid'),
          action: 'chatBarListRead'
        },
        success: function (data) {},
        error: function (jqXHR, textStatus, errorThrown) {}
      });

      if ($(this).closest('.more_items').length) {
        $this.swapChatBarItem($(this));
      } else {
        $this.toggleChatBox($(e.target), $(this));
      }

      $this.updateVisibleState();
    }).on('click.chatBar', '.chat_bar_list_item > .icon_close', function (e) {
      e.stopPropagation();
      var chatbarItem = $(this).closest('.chat_bar_list_item');
      ogame.chat.closeChatBox(chatbarItem.attr('data-playerid'), chatbarItem.attr('data-associationid'));
      chatbarItem.remove('open');
      $this.updateChatBar();
    }).on('keyup.chatBar', '.chat_box_textarea', function (e) {
      if ((e.ctrlKey || e.keyCode == 10) && e.keyCode == 13) {
        e.preventDefault();
        var s = $(this).val();
        $(this).val(s + "\n");
      } else {
        if ($.trim($(this).val().length > 0)) {
          e.preventDefault();
          $this.submitChatBarMsg($(e.currentTarget), e.which, e.shiftKey, e.delegateTarget.scrollHeight);
        }
      }
    }).on('click.chatBar', '.chat_box_textarea', function (e) {
      ogame.messagemarker.toggle(ogame.messagemarker.action_remove, ogame.messagemarker.type_chattab, $(this).parent().parent().parent().data('playerid'));
      ogame.messagemarker.toggle(ogame.messagemarker.action_remove, ogame.messagemarker.type_chatbar, $(this).parent().parent().parent().data('playerid'));

      if ($(this).data('playerid') > 0) {
        $this.saveMessageCounter(0, $(this).data('playerid'));
      } else if ($(this).data('associationid') > 0) {
        $this.saveMessageCounterAssociation(0, $(this).data('associationid'));
      }
    }).on('keydown.chatBar', '.chat_box_textarea', function (e) {
      if (e.keyCode == 13) {
        if (e.shiftKey == false) {
          e.preventDefault();
        }
      }
    }); //        $this.updateCustomScrollbar($('.chat_box_ctn'));
    //        $this.updateCustomScrollbar($(".scrollContainer"), true);
  },

  /**
   * initializes the functions needed for the display of the playerlist
   *
   * @returns {undefined}
   */
  initPlayerlist: function () {
    var $this = ogame.chat;
    var $tools = ogame.tools; // for playerlist toggle

    $('.js_accordion').accordion({
      collapsible: true,
      heightStyle: 'content'
    }); // adding "zebra" to list items

    $(".playerlist_item:odd").addClass("odd");
    $tools.addHover('.playerlist_item, .msg, .playerlist_top_box .playerlist'); // playerlist events

    $('.js_playerlist').on('click.playerList', '.pl_filter_set', function () {
      $this.filterPlayerlist();
    });
    $this.filterPlayerlist(); // Do this once, to restore filter settings.
  },

  /**
   * Shows a chat in the chatbar
   *
   * @param data {Object} - the chat data to show
   * @returns {undefined}
   */
  showChat: function (data) {
    var found = false;
    var $this = ogame.chat;
    $('.chat_bar_list_item').each(function () {
      var $item = $(this); // trigger opening if we found the desired chat

      if (data['playerId'] !== undefined && $item.data('playerid') === data['playerId'] || data['associationId'] !== undefined && $item.data('associationid') === data['associationId']) {
        found = true;

        if ($item.hasClass('outOfChatbar')) {
          $item.removeClass('outOfChatbar');
        }

        if (!$item.hasClass('open')) {
          $item.click(); // trigger opening

          $item[0].style.display = 'inline';
        } else {
          $item.fadeTo('400', 0.3).fadeTo('400', 1.0);
        }

        $item.find('textarea').focus();
      }
    }); // add the chat if is not yet in chatbar or more list

    if (!found) {
      var chatBarContainer;

      if (data['playerId'] !== undefined) {
        chatBarContainer = $this.createChatBarContainer(data['playerId']);
      } else {
        chatBarContainer = $this.createChatBarContainerForAssociations(data['associationId']);
      }

      $this.updateChatBar(chatBarContainer);
    }
  },

  /**
   * Shows the (complete) chat history in the detail chat page
   *
   * @param data {Object} - the chat data to show
   * @returns {undefined}
   */
  showChatHistory: function (data) {
    var history = $('.js_chatHistory');
    var documentContent = data['data'];

    if (history.length) {
      history.remove();
    }

    $('#chatList').remove();
    $(documentContent).insertAfter('#planet');
    $("li.playerlist_item").removeClass('active');
    $("li.playerlist_item[data-playerid='" + data.playerId + "']").addClass('active');
    initBBCodeEditor(locaKeys, itemNames, false, '.new_msg_textarea', 2000, true);
  },

  /**
   * Handles the display of a sent message in a chat on the chat bar
   * @TODO: Actually send the message as well.
   * @param clickedElement {Object} -
   * @param pressedKey {Object} -
   * @param shiftKey {Object} - if shiftkey was pressed simultaneously
   * @param msgScrollHeight {Object} -
   * @returns {undefined}
   */
  submitChatBarMsg: function (clickedElement, pressedKey, shiftKey, msgScrollHeight) {
    var $this = ogame.chat;
    var msgMaxHeight = parseInt($('.chat_box_textarea').css('max-height'));
    var msgPadding = parseInt($('.chat_box_textarea').css('padding-top')) + parseInt($('.chat_box_textarea').css('padding-bottom')); // enter pressed while shift already was pressed
    // == new line without sending the message

    if (pressedKey === 13 && shiftKey) {
      if (msgScrollHeight <= msgMaxHeight + msgPadding) {
        clickedElement.css('height', msgScrollHeight - msgPadding);
      }

      return;
    }

    if (pressedKey === 13) {
      if (clickedElement.parent('.chat_box').data('playerid') !== undefined) {
        $this.sendMessage(clickedElement.parent('.chat_box').data('playerid'), 0, clickedElement.val());
      } else if (clickedElement.parent('.chat_box').data('associationid') !== undefined) {
        $this.sendMessage(0, clickedElement.parent('.chat_box').data('associationid'), clickedElement.val());
      } // @TODO: adding the element can only actually happen when the message was sent successfully!


      clickedElement.val('');
    }
  },

  /**
   * Removes an item from the list of more items and inserts it as the last item in the chat bar list
   *
   * @param $itemToSwap {DOM Object} - the item that will be swapped
   * @returns {undefined}
   */
  swapChatBarItem: function (itemToSwapIn) {
    var $this = ogame.chat; // remove item to swap out from the chatbar

    var itemToSwapOut = $('.more_chat_bar_items').prev();
    itemToSwapOut.removeClass('open').find('.icon_close').hide().end().find('.chat_box').hide();
    itemToSwapOut.remove(); // swap item back to chatbar

    itemToSwapIn.addClass('open').find('.icon_close').show().end().find('.chat_box').show().end().insertBefore('.more_chat_bar_items');
    $this.addToMoreBox([itemToSwapOut]); // if after the insertion we would not have enough space we need to correct that

    $this.updateChatBar();
    $this.updateCustomScrollbar(itemToSwapIn.find('.chat_box_ctn'));
  },

  /**
   * show the minimal chat for the clicked player on correct position
   * expand/shrink width accordingly
   *
   * @param clickedTarget {DOM Object} - clicked element
   * @param originalTarget {DOM Object} - element that was originally targeted
   * @returns {undefined}
   */
  toggleChatBox: function (clickedTarget, originalTarget) {
    var $this = ogame.chat; // some elements should not trigger toggle:

    if (clickedTarget.parents('.chat_box').length && !clickedTarget.hasClass('icon_close')) {
      return;
    }

    var chatBox = originalTarget.children('.chat_box'); // toggling the display of chat contents

    if (chatBox.is(':visible')) {
      chatBox.hide();
      originalTarget.removeClass('open');
    } else {
      if (!originalTarget.hasClass('more_chat_bar_items')) {
        originalTarget.addClass('open');
        $this.updateChatBar();
      }

      chatBox.show();
      var chatboxClass = chatBox.find('.chat_box_ctn');

      if (originalTarget.hasClass('more_chat_bar_items')) {
        chatboxClass = chatBox;
      }

      $this.updateCustomScrollbar(chatboxClass);
      chatBox.find('textarea').focus();
    }

    ogame.messagecounter.resetCounterByType(ogame.messagecounter.type_chat);
  },

  /**
   * move item to the morelist
   *
   * @see important for ogame.chat.updateChatBar
   * @param chatOpenLength, chatClosedLength, widthOpen, widthClosed, widthMoreItems, widthWindow @see ogame.chat.updateChatBar
   */
  handleTooMuchWindows: function (chatOpenLength, chatClosedLength, widthOpen, widthClosed, widthMoreItems, widthWindow) {
    var $this = ogame.chat;
    var isTooWide = true;
    var chatbarListItems = [];
    $($('.chat_bar_list > .chat_bar_list_item').get().reverse()).each(function () {
      var listItem = $(this);

      if (isTooWide) {
        // these element should never be removed:
        if (listItem.hasClass('more_chat_bar_items') || listItem.attr('id') === 'chatBarPlayerList') {
          return;
        } // decide what kind of element shall be removed (swapped out)


        if (listItem.hasClass('open')) {
          chatOpenLength--;
        } else {
          chatClosedLength--;
        } // prepare the item and add it to the more list


        listItem.removeClass('open').find('.icon_close').hide().end().find('.chat_box').hide();
        chatbarListItems.push(listItem);
        listItem.remove(); // check if more elements need to be removed

        widthTotal = widthClosed * chatClosedLength + widthOpen * chatOpenLength + widthMoreItems;
        isTooWide = widthTotal >= widthWindow ? true : false;
      }
    }); // update morebox with contents of chatbarListItems

    $this.addToMoreBox(chatbarListItems);
  },

  /**
   * move item back to the chatbar
   *
   * @see important for ogame.chat.updateChatBar
   */
  getItemFromMorelist2Chatbar: function () {
    // get item from more list then remove it from more list.
    var swappedChatBarItem = $('.more_items .chat_bar_list_item').first().remove();
    var $this = ogame.chat; // add swapped item back to chat bar

    swappedChatBarItem.addClass('open').find('.icon_close').show().end().find('.chat_box').show().end().insertBefore('.more_chat_bar_items'); // if more list is now empty remove it as well

    if ($('.more_items .chat_bar_list_item').length <= 0) {
      $('.more_chat_bar_items').remove();
    }

    $this.updateCustomScrollbar($('.more_chat_bar_items>.chat_box'));
    $this.updateCustomScrollbar(swappedChatBarItem.find('.chat_box_ctn'));
  },

  /**
   * Calculates available horizontal space and updates how many items are shown in the chatbar
   * and moves items to/from more list accordingly
   *
   * @param {DOM Object} chatBarItem - new item to add to chatbar
   */
  updateChatBar: function (chatBarItem) {
    var $this = ogame.chat;
    var chatOpenLength = $('.chat_bar_list > .chat_bar_list_item.open').length;
    var moreItemsLength = $('.more_chat_bar_items').length;
    var chatClosedLength = $('.chat_bar_list').children().length - chatOpenLength - moreItemsLength;
    var widthClosed = 190;
    var widthOpen = 270;
    var widthMoreItems = 190; // 180 + 10 px space

    var widthWindow = $('body').innerWidth(); // new items will be directly open

    if (chatBarItem) {
      chatOpenLength++;
    }

    var widthTotal = widthClosed * chatClosedLength + widthOpen * chatOpenLength + widthMoreItems * moreItemsLength; // if there are more elements than fit in the window

    if (widthTotal >= widthWindow) {
      $this.handleTooMuchWindows(chatOpenLength, chatClosedLength, widthOpen, widthClosed, widthMoreItems, widthWindow);
    } else if (widthTotal + widthOpen <= widthWindow && $('.more_chat_bar_items').length > 0) {
      // if widthTotal is small enough that another open element will fit an we have one in the more list
      $this.getItemFromMorelist2Chatbar();
    }

    if (chatBarItem) {
      chatBarItem.insertAfter('#chatBarPlayerList');
      $this.updateCustomScrollbar(chatBarItem.find('.chat_box_ctn'));
    }
  },

  /**
   * update the custom scrollbar or add it if the element has none
   *
   * @param element {DOM Object} - the element that gets the scrollbar
   * @param skipScrolling bool Skip scrolling to the bottom
   */
  updateCustomScrollbar: function (element, skipScrolling) {
    if (!element || element.length == 0) {
      return;
    }

    if (element.hasClass('mCustomScrollbar')) {
      element.mCustomScrollbar('update');
    } else {
      element.mCustomScrollbar({
        theme: "ogame"
      });
    }

    if (skipScrolling !== true) {
      element.mCustomScrollbar("scrollTo", "bottom", {
        scrollInertia: 0
      });
    }

    element.each(function () {
      if ($(this).height() + "px" == $(this).css("max-height")) {
        $(this).addClass("scrollbarPresent");
      }
    });
  },
  updateVisibleState: function () {
    var visibleChats = {
      "chatbar": false,
      "players": [],
      "associations": []
    };
    $('.chat_bar_list>.chat_bar_list_item').each(function () {
      var $item = $(this);

      if ($item.attr('id') === 'chatBarPlayerList' && $item.children('.cb_playerlist_box').is(':visible')) {
        visibleChats.chatbar = true;
      } else if ($item.data('playerid') && $item.children('.chat_box').is(':visible')) {
        visibleChats.players.push($item.data('playerid'));
      } else if ($item.data('associationid') && $item.children('.chat_box').is(':visible')) {
        visibleChats.associations.push($item.data('associationid'));
      }
    });
    $.cookie('visibleChats', JSON.stringify(visibleChats), {
      expires: 7
    });
  },
  showPlayerList: function (selector) {
      // TODO: re-enable later
      return;
    var $this = ogame.chat;

    if (window.deactivateChatBecauseOfLogout) {
      return;
    }

    if ($.inArray(selector, $this.playerListSelector) === -1) {
      $this.playerListSelector.push(selector);
    }

    if ($this.isLoadingPlayerList === false && $this.playerList === null) {
      $this.isLoadingPlayerList = true;
      $.ajax({
        url: chatUrl,
        type: 'POST',
        dataType: 'json',
        data: {
          action: 'showPlayerList'
        },
        success: function (data) {
          $this.playerList = data.content;
          $this.isLoadingPlayerList = false;

          $this._showPlayerList();
        },
        error: function (jqXHR, textStatus, errorThrown) {
          $this.isLoadingPlayerList = false;
        }
      });
    } else {
      $this._showPlayerList();
    }
  },
  _showPlayerList: function () {
    var $this = ogame.chat;
    $.each($this.playerListSelector, function (index, value) {
      $(value).html($this.playerList);
    });
  }
};
let characterClassArr = ['neutral', 'miner', 'warrior', 'explorer'];
let allianceClassArr = ['neutral', 'warrior', 'trader', 'explorer'];
let characterClassBonuses = {
  warrior: {
    109: 2,
    110: 2,
    111: 2
  }
};
let allianceClassBonuses = {
  warrior: {
    109: 1,
    110: 1,
    111: 1
  }
};

function isJsonString(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }

  return true;
}

function isReportString(str) {
  let [reportType, lang, serverId, apiKey] = str.split('-');

  if (str.length !== 50 || reportType !== 'sr' || lang !== js_serverlang || serverId !== js_serverid || str.match('/sr-' + js_serverlang + '-' + js_serverid + '[A-Z]{40}/g') === false || apiKey.length !== 40) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_INVALID_DATA + ' ' + combatSimLoca.LOCA_COMBATSIM_INVALID_API, 'warning');
    return false;
  }

  return true;
}

function loadPlanetAction(planetId, currentTarget, isBaseDefender, attackType) {
  let body = {
    _token: token
  };

  if (planetId) {
    body["planetId"] = planetId;
  }

  $.ajax({
    url: simBackendUrl + '&action=loadPlanet',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      if (typeof json.planetData == 'object') {
        token = json.newAjaxToken;
        fillData($(currentTarget.closest("fleet-content")[0]), json.planetData, isBaseDefender, attackType);
        showNotification(combatSimLoca.LOCA_COMBATSIM_PLANET_LOADED, 'success');
      } else {
        token = json.newAjaxToken;

        if (json.errors && json.errors.length) {
          showNotification(json.errors[0].message, 'error');
        }
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function loadSpyReport(hashId, currentTarget, isBaseDefender, attackType) {
  if (!currentTarget || !currentTarget.length) {
    return;
  }

  let body = {
    _token: token
  };

  if (hashId) {
    body["reportHash"] = hashId;
  }

  $.ajax({
    url: simBackendUrl + '&action=loadReport',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      if (typeof json.planetData == 'object') {
        token = json.newAjaxToken;
        adjustResearchClassBonuses(json.planetData);
        fillData($(currentTarget.closest("fleet-content")[0]), json.planetData, isBaseDefender, attackType);
        $("fleet-content[data-participant-id=0][data-attack-type=2] input[name='apikey']").val(hashId);
        showNotification(json.message, 'success');
        simChanged(currentTarget);
      } else {
        token = json.newAjaxToken;

        if (json.errors && json.errors.length) {
          showNotification(json.errors[0].message, 'error');
        }
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function adjustResearchClassBonuses(planetData) {
  let className = findClassName(characterClassArr, planetData.characterClassId ?? 0);

  if (characterClassBonuses[className]) {
    Object.keys(characterClassBonuses[className]).forEach(researchId => {
      if (planetData.researches[researchId] > 0) {
        planetData.researches[researchId] = Math.max(0, planetData.researches[researchId] - characterClassBonuses[className][researchId]);
      }
    });
  }

  className = findClassName(allianceClassArr, planetData.allianceClassId ?? 0);

  if (allianceClassBonuses[className]) {
    Object.keys(allianceClassBonuses[className]).forEach(researchId => {
      if (planetData.researches[researchId] > 0) {
        planetData.researches[researchId] = Math.max(0, planetData.researches[researchId] - allianceClassBonuses[className][researchId]);
      }
    });
  }
}

function simChanged(obj) {
  if ($(obj).attr('max')) {
    $(obj).val(Math.min(parseInt($(obj).attr('max')), parseInt($(obj).val())) || 0);
  }

  if ($(obj).attr('min')) {
    $(obj).val(Math.max(parseInt($(obj).attr('min')), parseInt($(obj).val())) || $(obj).attr('min'));
  } else {
    $(obj).val(Math.max(0, $(obj).val()));
  }

  if ($("gradient-button button#saveCombatPlanning div.emoji").length === 0) {
    $('<div class="emoji warningsign tooltipLeft" title="' + combatSimLoca.LOCA_COMBATSIM_DATA_CHANGED + '"></div>').insertBefore($("gradient-button button#saveCombatPlanning span"));
  }

  combatSimChanged = true;
  $('#showCombatResultShortInfo').prop('disabled', true).data('target', '');
  $("#saveCombatPlanning").removeAttr('disabled');
  $("#simulateCombatPlanning").prop('disabled', true);
}

function switchSpaceObject(obj) {
  let currentTarget = $(obj);

  if (currentTarget.hasClass("selected")) {
    return false;
  }

  let basicData = $(currentTarget.closest("basic-data")[0]);
  basicData.find('.togglePanel ul').hide().removeClass('active');
  basicData.find('.planetSelection div').removeClass('selected');
  currentTarget.addClass('selected');
  let className = 'planet';

  if (currentTarget.hasClass("moon")) {
    className = 'moon';
  }

  basicData.find('.togglePanel ul.' + className).show().addClass('active');
  let spaceObject = basicData.find('.togglePanel').find('ul.' + className + ' li:first');
  basicData.find('.toggleLink').attr('data-selected-planetid', spaceObject.data('planetid')).data('selectedPlanetid', spaceObject.data('planetid'));
  basicData.find('.togglePanel').hide();
  basicData.find('.togglePanel li').removeClass('selected');
  basicData.find('.togglePanel ul #' + spaceObject.data('planetid')).addClass('selected');
  basicData.find('.toggleLink').html(spaceObject.html());
}

function changeClass(target, selectedClass, type) {
  let classArr = characterClassArr;
  let classBonusArr = characterClassBonuses;

  if (type === 'allianceclass') {
    classArr = allianceClassArr;
    classBonusArr = allianceClassBonuses;
  }

  const classId = findClassId(classArr, selectedClass);
  const classSelection = $(target).closest("class-selection");
  const inputField = classSelection.find("input").first();
  const fleetSection = target.closest('fleet-content');
  const currentClass = findClassName(classArr, inputField.data('classId') === '' ? 0 : parseInt(inputField.data('classId')));
  inputField.data("classId", classId);
  inputField.attr("data-class-id", classId);
  inputField.prop('checked', false);
  const icons = classSelection.find(type + '-icon');
  icons.each((idx, icon) => {
    classArr.forEach(className => {
      $(icon).removeAttr(className);
    });
    targetId = idx + 1;

    if (targetId === classId) {
      targetId = 0;
    }

    $(icon).attr(classArr[targetId], true);
  });

  if (classBonusArr[currentClass]) {
    Object.keys(classBonusArr[currentClass]).forEach(techId => {
      const researchInput = $(fleetSection).find(".technology-row input[name='amount[" + techId + "]']").first();
      const currentValue = researchInput.val().length === 0 ? 0 : parseInt(researchInput.val());
      const currentMin = (researchInput.attr('min') ?? '').length === 0 ? 0 : parseInt(researchInput.attr('min'));
      researchInput.val(Math.max(0, currentValue - classBonusArr[currentClass][techId]));
      researchInput.attr('min', Math.max(0, currentMin - classBonusArr[currentClass][techId]));
    });
  }

  if (classBonusArr[selectedClass]) {
    Object.keys(classBonusArr[selectedClass]).forEach(techId => {
      const researchInput = $(fleetSection).find(".technology-row input[name='amount[" + techId + "]']").first();
      const currentValue = researchInput.val().length === 0 ? 0 : parseInt(researchInput.val());
      const currentMin = (researchInput.attr('min') ?? '').length === 0 ? 0 : parseInt(researchInput.attr('min'));
      researchInput.val(currentValue + classBonusArr[selectedClass][techId]);
      researchInput.attr('min', currentMin + classBonusArr[selectedClass][techId]);
    });
  }

  simChanged(classSelection);
}

function fillData(fleetSection, jsonObj, isBaseDefender, attackType) {
  changeClass(fleetSection.find('characterclass-icon'), characterClassArr[0], 'characterclass');
  changeClass(fleetSection.find('allianceclass-icon'), allianceClassArr[0], 'allianceclass');
  let inputField;
  $.each(jsonObj.researches, function (index, value) {
    inputField = $(fleetSection.find(".technology-row input[name='amount[" + index + "]']")[0]);
    inputField.val(value);
  });
  let selection = 0;

  if (characterClassArr[parseInt(jsonObj.characterClassId)]) {
    selection = parseInt(jsonObj.characterClassId);
  }

  changeClass(fleetSection.find('characterclass-icon'), characterClassArr[selection], 'characterclass');

  if (allianceClassArr[parseInt(jsonObj.allianceClassId)]) {
    selection = parseInt(jsonObj.allianceClassId);
  }

  changeClass(fleetSection.find('allianceclass-icon'), allianceClassArr[selection], 'allianceclass');
  $.each(jsonObj.ships, function (index, value) {
    inputField = $(fleetSection.find(".technology-row input[name='amount[" + index + "]']")[0]);
    inputField.val(value.amount);
    inputField = $(fleetSection.find(".technology-fullrow input[name='weapon[" + index + "]']")[0]);
    inputField.val((Math.floor(value.weapon * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='shield[" + index + "]']")[0]);
    inputField.val((Math.floor(value.shield * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='armor[" + index + "]']")[0]);
    inputField.val((Math.floor(value.armor * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='cargo[" + index + "]']")[0]);
    inputField.val((Math.floor(value.cargo * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='speed[" + index + "]']")[0]);
    inputField.val((Math.floor(value.speed * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='fuel[" + index + "]']")[0]);
    inputField.val((Math.floor(value.fuel * 10000) / 100).toFixed(2));
  });
  inputField = $(fleetSection.find(".technology-fullrow input[name='classBonus[1]']")[0]);
  inputField.val((Math.floor(jsonObj.bonuses.characterClassBooster[1] * 10000) / 100).toFixed(2));
  inputField = $(fleetSection.find(".technology-fullrow input[name='classBonus[2]']")[0]);
  inputField.val((Math.floor(jsonObj.bonuses.characterClassBooster[2] * 10000) / 100).toFixed(2));
  inputField = $(fleetSection.find(".technology-fullrow input[name='classBonus[3]']")[0]);
  inputField.val((Math.floor(jsonObj.bonuses.characterClassBooster[3] * 10000) / 100).toFixed(2));
  inputField = $(fleetSection.find("fleetspeed-section input[value='" + jsonObj.fleetspeed + "']")[0]);
  inputField.prop('checked', true);
  let coords = {};

  if (typeof jsonObj.coords == 'object') {
    coords[0] = jsonObj.coords.galaxy;
    coords[1] = jsonObj.coords.system;
    coords[2] = jsonObj.coords.position;
  } else {
    coords = jsonObj.coords.split(':');
  }

  $(fleetSection.find("coordinates-section input[name='galaxy']")[0]).val(coords[0]);
  $(fleetSection.find("coordinates-section input[name='system']")[0]).val(coords[1]);
  $(fleetSection.find("coordinates-section input[name='position']")[0]).val(coords[2]);

  if (isBaseDefender === true) {
    fleetSection = $("combatsim-section[base-defender] fleet-content");
    $.each(jsonObj.resources, function (index, value) {
      inputField = $(fleetSection.find(".resource-row input[name='resource[" + index + "]']")[0]);
      inputField.val(value);
    });
    $.each(jsonObj.ships, function (index, value) {
      inputField = $(fleetSection.find(".technology-row input[name='amount[" + index + "]']")[0]);
      inputField.val(value.amount);
    });
    $.each(jsonObj.defenses, function (index, value) {
      inputField = $(fleetSection.find(".technology-row input[name='amount[" + index + "]']")[0]);
      inputField.val(value.amount);
      inputField = $(fleetSection.find(".technology-fullrow input[name='weapon[" + index + "]']")[0]);
      inputField.val((Math.floor(value.weapon * 10000) / 100).toFixed(2));
      inputField = $(fleetSection.find(".technology-fullrow input[name='shield[" + index + "]']")[0]);
      inputField.val((Math.floor(value.shield * 10000) / 100).toFixed(2));
      inputField = $(fleetSection.find(".technology-fullrow input[name='armor[" + index + "]']")[0]);
      inputField.val((Math.floor(value.armor * 10000) / 100).toFixed(2));
    });
    inputField = $(fleetSection.find(".technology-fullrow input[name='special[11112]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.lifeformProtection * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='special[12112]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.spaceDockExtender * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='special[13112]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.recycleAttackerFleet * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='special[14112]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.moonChanceIncrease * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='denCapacity[22]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.denCapacity.metal * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='denCapacity[23]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.denCapacity.crystal * 10000) / 100).toFixed(2));
    inputField = $(fleetSection.find(".technology-fullrow input[name='denCapacity[24]']")[0]);
    inputField.val((Math.floor(jsonObj.bonuses.denCapacity.deuterium * 10000) / 100).toFixed(2));
    $.each(jsonObj.missiles, function (index, value) {
      inputField = $(fleetSection.find(".technology-row input[name='amount[" + index + "]']")[0]);
      inputField.val(value.amount);
    });
  }

  simChanged(fleetSection);
}

function clearPlayer(obj) {
  let participantId = $(obj).data('participantId');
  let attackType = $(obj).data('attackType');
  $("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "] fleetspeed-section input").prop('checked', false);
  $("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "] fleetspeed-section input[value='10']").prop('checked', true);
  let fleetSection = $("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "]");
  changeClass(fleetSection.find('characterclass-icon'), characterClassArr[0], 'characterclass');
  changeClass(fleetSection.find('allianceclass-icon'), allianceClassArr[0], 'allianceclass');
  fleetSection.find("research-section input").val('');
  fleetSection.find("ship-section input").val('');
  fleetSection.find("defense-section input").val('');
  fleetSection.find("coordinates-section input").val('');
  fleetSection.find("lifeform-data input").val('');
  simChanged(obj);
}

function clearTechnologies(obj) {
  let participantId = $(obj).data('participantId');
  let attackType = $(obj).data('attackType');
  $("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "] ship-section input").val('');
  $("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "] defense-section input").val('');
  simChanged(obj);
}

function expandLifeforms(obj) {
  let combatsimSection = $(obj).closest("combatsim-section");

  if (combatsimSection.attr("show-lifeform") === "1") {
    combatsimSection.attr("show-lifeform", "0");
  } else {
    combatsimSection.attr("show-lifeform", "1");
  }
}

function showSpaceObjectSelection(obj) {
  let basicData = $($(obj).closest("basic-data")[0]);
  let togglePanel = basicData.find('.js_togglePanel');
  togglePanel.toggle();
}

function selectSpaceObject(obj) {
  let currentTarget = $(obj);
  let basicData = currentTarget.closest("basic-data");
  basicData.find('.toggleLink').attr('data-selected-planetid', currentTarget.data('planetid')).data('selectedPlanetid', currentTarget.data('planetid'));
  basicData.find('.togglePanel').hide();
  basicData.find('.togglePanel li').removeClass('selected');
  basicData.find('.togglePanel ul #' + currentTarget.data('planetid')).addClass('selected');
  basicData.find('.toggleLink').html(currentTarget.html());
}

function loadPlanetInfo(obj) {
  let loadDataSection = $(obj).closest("div.selectWrapper");
  let inputField = loadDataSection.find(".toggleLink").first();
  let attackType = $(obj).data('attackType');
  let isBaseDefender = attackType === 2 && $(obj).data('participantId') === $('fleet-content[data-attack-type=2]').first().data('participantId');
  loadPlanetAction(inputField.data('selectedPlanetid'), $(obj), isBaseDefender, attackType);
  simChanged(obj);
}

function loadInfoParticipant(obj) {
  let loadDataSection = $(obj).closest("div.load_data");
  let inputField = loadDataSection.find("input").first();
  let attackType = inputField.data('attackType');
  let isBaseDefender = attackType === 2 && inputField.data('participantId') === $('fleet-content[data-attack-type=2]').first().data('participantId');

  if (isJsonString(inputField.val())) {
    fillData($(obj).closest("fleet-content"), JSON.parse(inputField.val()), isBaseDefender, attackType);
  } else if (isReportString(inputField.val())) {
    loadSpyReport(inputField.val(), $(obj), isBaseDefender, attackType);
  }
}

function selectCharacterClass(obj) {
  let selection = 'neutral';
  characterClassArr.forEach(characterClass => {
    if (obj.attributes[characterClass]) selection = characterClass;
  });
  changeClass(obj, selection, 'characterclass');
}

function selectAllianceClass(obj) {
  let selection = 'neutral';
  allianceClassArr.forEach(allianceClass => {
    if (obj.attributes[allianceClass]) selection = allianceClass;
  });
  changeClass(obj, selection, 'allianceclass');
}

function switchParticipant(obj) {
  if ($(obj).hasClass('active')) {
    return;
  }

  let attackType = $(obj).data('attackType');
  let participantId = $(obj).data('participantId');
  let combatsimSection = $(obj).closest("combatsim-section");
  $('participant-header[data-attack-type="' + attackType + '"]').removeClass('active');
  $('participant-header[data-attack-type="' + attackType + '"][data-participant-id="' + participantId + '"]').addClass('active');
  $('fleet-content[data-attack-type="' + attackType + '"]:not(fleet-content[base-defender])').hide();
  $('fleet-content[data-attack-type="' + attackType + '"][data-participant-id="' + participantId + '"]').show(); //adjust buttons

  $(combatsimSection.find("fleet-section-clear .clearPlayer")).attr('data-participant-id', participantId).data('participantId', participantId).attr('data-attack-type', attackType).data('attackType', attackType);
  $(combatsimSection.find("fleet-section-clear .clearTechnologies")).attr('data-participant-id', participantId).data('participantId', participantId).attr('data-attack-type', attackType).data('attackType', attackType);
}

function deleteRequest(obj) {
  let simId = $(obj).data('simulationId');

  if (simId === 0) {
    return;
  }

  let creation = $("single-simulation[data-simulation-id=" + simId + "] .creation").html();
  let target = $("single-simulation[data-simulation-id=" + simId + "] .target span").html();
  let question = combatSimLoca.LOCA_COMBATSIM_DELETE_REQUEST.replace('#date#', creation).replace('#target#', target);
  errorBoxDecision(combatSimLoca.LOCA_COMBATSIM_DELETE, question, jsloca.LOCA_ALL_YES, jsloca.LOCA_ALL_NO, function () {
    deleteSim(simId);
  });
}

function deleteSim(simId) {
  let body = {
    _token: token,
    simId: simId
  };
  $.ajax({
    url: simBackendUrl + '&action=deleteSim',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (json.status === 'failure') {
        showNotification(json.errors[0].message, 'error');
        return;
      }

      if (json.status === 'success') {
        $("combatsim-list single-simulation[data-simulation-id=" + json.simId + "]").remove();
        showNotification(json.message, 'success');

        if (combatSimId === json.simId) {
          combatSimId = 0;
          loadSimDetails();
          $('#deleteCombatPlanning').attr('disabled', true).attr('data-simulation-id', 0).data('simulationId', 0);
          newCombatPlanning();
        }

        if ($("combatsim-list owned-sims single-simulation").length === 0) {
          $("combatsim-list owned-sims").append('<div className="noentries">' + combatSimLoca.LOCA_COMBATSIM_NO_SIMS_FOUND + '</div>');
        }

        $("combatsim-list .entryCount .current").html($("combatsim-list single-simulation").length);
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function saveSimName(obj) {
  let simId = $(obj).data('simulationId');

  if (simId === 0 || simId !== combatSimId) {
    return;
  }

  let simName = $('combatsim-name input[name=simulationName]').val();
  let body = {
    _token: token,
    simId: simId,
    simName: simName
  };
  $.ajax({
    url: simBackendUrl + '&action=saveSimName',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (json.status === 'failure') {
        showNotification(json.errors[0].message, 'error');
        return;
      }

      if (json.status === 'success') {
        $("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "] .state span.simName").text(' - ' + json.simData.simName);
        $("combatsim-shortinfo .shortName span").text(json.simData.simName);
        showNotification(json.message, 'success');
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function filterPlayerNames(obj) {
  if ($(obj).val().length >= 3) {
    const filtered = Object.values(playerNames).filter(user => user.name.toLowerCase().includes($(obj).val().toLowerCase())).filter(function (user) {
      if (this.count < 5 && user.id > 0) {
        this.count++;
        return true;
      }

      return false;
    }, {
      count: 0
    });
    showUsers(filtered);
  }
}

function loadSimInfo(obj) {
  let simId = $(obj).data('simulationId');

  if (combatSimChanged === true) {
    let creation = $("single-simulation[data-simulation-id=" + simId + "] .creation").html();
    let target = $("single-simulation[data-simulation-id=" + simId + "] .target span").html();
    let question = combatSimLoca.LOCA_COMBATSIM_UNSAVED.replace('#date#', creation).replace('#target#', target);
    errorBoxDecision(jsloca.LOCA_NOTIFY_WARNING, question, jsloca.LOCA_ALL_YES, jsloca.LOCA_ALL_NO, function () {
      loadSim(simId);
    });
  } else {
    loadSim(simId);
  }
}

function saveRequest() {
  let simId = combatSimId;

  if (combatSimProgress === true) {
    let creation = $("single-simulation[data-simulation-id=" + simId + "] .creation").html();
    let target = $("single-simulation[data-simulation-id=" + simId + "] .target span").html();
    let question = combatSimLoca.LOCA_COMBATSIM_RESULTS_ERASE.replace('#date#', creation).replace('#target#', target);
    errorBoxDecision(jsloca.LOCA_NOTIFY_WARNING, question, jsloca.LOCA_ALL_YES, jsloca.LOCA_ALL_NO, function () {
      saveSim();
    });
  } else {
    saveSim();
  }
}

function saveSim() {
  let completeCombatsSim = $("div#combatsim");
  let fleetContent, participantId, attackType;
  let attackerObj = {},
      defenderObj = {};
  let currentObject;
  let totalShipCount = 0;
  let firstDefender = $(completeCombatsSim.find("combatsim-section[base-defender] fleet-content")[0]);
  let mainDefenderParticipantId = firstDefender.data('participantId');
  firstDefender = $('fleet-content[data-attack-type="2"][data-participant-id="' + mainDefenderParticipantId + '"]:not(fleet-content[base-defender])');

  if ($(firstDefender.find("coordinates-section input[name='galaxy']")[0]).val().length === 0 || $(firstDefender.find("coordinates-section input[name='system']")[0]).val().length === 0 || $(firstDefender.find("coordinates-section input[name='position']")[0]).val().length === 0) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_INVALID_TARGET, 'warning');
    return;
  }

  completeCombatsSim.find("fleet-content").each(function () {
    fleetContent = $(this);
    participantId = fleetContent.data('participantId');

    if (typeof participantId === 'undefined') {
      return;
    }

    attackType = fleetContent.data('attackType');

    if (attackType === 1) {
      currentObject = attackerObj;
    } else {
      currentObject = defenderObj;
    }

    if (!currentObject[participantId]) {
      currentObject[participantId] = {
        resources: {},
        researches: {},
        ships: {},
        defenses: {},
        missiles: {},
        bonuses: {},
        fleetspeed: 10,
        allianceClassId: $(fleetContent.find("basic-data class-selection input.allianceClass")[0]).data('classId'),
        characterClassId: $(fleetContent.find("basic-data class-selection input.characterClass")[0]).data('classId'),
        coords: {
          galaxy: $(fleetContent.find("coordinates-section input[name='galaxy']")[0]).val(),
          system: $(fleetContent.find("coordinates-section input[name='system']")[0]).val(),
          position: $(fleetContent.find("coordinates-section input[name='position']")[0]).val()
        }
      };
    }

    let fleetSpeedElement = $(fleetContent.find("fleetspeed-section")[0]);

    if (fleetSpeedElement.length) {
      currentObject[participantId].fleetspeed = fleetSpeedElement.find("input[name='speed[" + attackType + "][" + participantId + "]']:checked").val();
    }

    let technologyId, classId;
    $(fleetContent.find("research-section")[0]).find("input").each(function () {
      technologyId = $(this).data('technologyId');

      if (technologyId >= 100 && technologyId < 200) {
        currentObject[participantId].researches[technologyId] = parseInt($(this).val().length === 0 ? 0 : $(this).val());
        const characterClassName = findClassName(characterClassArr, currentObject[participantId]['characterClassId']);

        if (characterClassBonuses[characterClassName] && characterClassBonuses[characterClassName][technologyId]) {
          currentObject[participantId].researches[technologyId] = Math.max(0, currentObject[participantId].researches[technologyId] - characterClassBonuses[characterClassName][technologyId]);
        }

        const allianceClassName = findClassName(allianceClassArr, currentObject[participantId]['allianceClassId']);

        if (allianceClassBonuses[allianceClassName] && allianceClassBonuses[allianceClassName][technologyId]) {
          currentObject[participantId].researches[technologyId] = Math.max(0, currentObject[participantId].researches[technologyId] - allianceClassBonuses[allianceClassName][technologyId]);
        }
      }
    });
    let lfData = fleetContent.find("lifeform-data").first();
    $(fleetContent.find("ship-section")[0]).find("input").each(function () {
      technologyId = $(this).data('technologyId');

      if (technologyId >= 200 && technologyId < 300) {
        totalShipCount += parseInt($(this).val().length === 0 ? 0 : $(this).val());
        currentObject[participantId].ships[technologyId] = {
          amount: parseInt($(this).val().length === 0 ? 0 : $(this).val()),
          weapon: lfData.find("input[name='weapon[" + technologyId + "]']").val() / 100,
          shield: lfData.find("input[name='shield[" + technologyId + "]']").val() / 100,
          armor: lfData.find("input[name='armor[" + technologyId + "]']").val() / 100,
          cargo: lfData.find("input[name='cargo[" + technologyId + "]']").val() / 100,
          speed: lfData.find("input[name='speed[" + technologyId + "]']").val() / 100,
          fuel: lfData.find("input[name='fuel[" + technologyId + "]']").val() / 100
        };
      }
    });
    fleetContent.find(".resource-row input").each(function () {
      if ($(this).data('resource')) {
        currentObject[participantId].resources[$(this).data('resource')] = parseInt($(this).val().length === 0 ? 0 : $(this).val());
      }
    });
    lfData.find("characterclass-bonus input").each(function () {
      classId = $(this).data('classId');

      if (classId > 0) {
        currentObject[participantId].bonuses.characterClassBooster = {
          1: parseFloat(lfData.find("input[name='classBonus[1]']").val().length === 0 ? 0 : lfData.find("input[name='classBonus[1]']").val() / 100),
          2: parseFloat(lfData.find("input[name='classBonus[2]']").val().length === 0 ? 0 : lfData.find("input[name='classBonus[2]']").val() / 100),
          3: parseFloat(lfData.find("input[name='classBonus[3]']").val().length === 0 ? 0 : lfData.find("input[name='classBonus[3]']").val() / 100)
        };
      }
    });
    $(fleetContent.find("defense-section")[0]).find("input").each(function () {
      technologyId = $(this).data('technologyId');

      if (technologyId >= 200 && technologyId < 300) {
        totalShipCount += parseInt($(this).val().length === 0 ? 0 : $(this).val());
        currentObject[participantId].ships[technologyId] = {
          amount: parseInt($(this).val().length === 0 ? 0 : $(this).val()),
          weapon: firstDefender.find("lifeform-data input[name='weapon[" + technologyId + "]']").val() / 100,
          shield: firstDefender.find("lifeform-data input[name='shield[" + technologyId + "]']").val() / 100,
          armor: firstDefender.find("lifeform-data input[name='armor[" + technologyId + "]']").val() / 100,
          cargo: firstDefender.find("lifeform-data input[name='cargo[" + technologyId + "]']").val() / 100,
          speed: firstDefender.find("lifeform-data input[name='speed[" + technologyId + "]']").val() / 100,
          fuel: firstDefender.find("lifeform-data input[name='fuel[" + technologyId + "]']").val() / 100
        };
      }

      if (technologyId >= 400 && technologyId < 500) {
        totalShipCount += parseInt($(this).val().length === 0 ? 0 : $(this).val());
        currentObject[participantId].defenses[technologyId] = {
          amount: parseInt($(this).val().length === 0 ? 0 : $(this).val()),
          weapon: lfData.find("input[name='weapon[" + technologyId + "]']").val() / 100,
          shield: lfData.find("input[name='shield[" + technologyId + "]']").val() / 100,
          armor: lfData.find("input[name='armor[" + technologyId + "]']").val() / 100
        };
      }

      if (technologyId >= 500 && technologyId < 600) {
        currentObject[participantId].missiles[technologyId] = {
          amount: parseInt($(this).val().length === 0 ? 0 : $(this).val())
        };
      }

      currentObject[participantId].bonuses.denCapacity = {
        metal: parseFloat(lfData.find("input[name='denCapacity[22]']").val().length === 0 ? 0 : lfData.find("input[name='denCapacity[22]']").val() / 100),
        crystal: parseFloat(lfData.find("input[name='denCapacity[23]']").val().length === 0 ? 0 : lfData.find("input[name='denCapacity[23]']").val() / 100),
        deuterium: parseFloat(lfData.find("input[name='denCapacity[24]']").val().length === 0 ? 0 : lfData.find("input[name='denCapacity[24]']").val() / 100)
      };
      currentObject[participantId].bonuses.lifeformProtection = parseFloat(lfData.find("input[name='special[11112]']").val().length === 0 ? 0 : lfData.find("input[name='special[11112]']").val() / 100);
      currentObject[participantId].bonuses.moonChanceIncrease = parseFloat(lfData.find("input[name='special[12112]']").val().length === 0 ? 0 : lfData.find("input[name='special[12112]']").val() / 100);
      currentObject[participantId].bonuses.recycleAttackerFleet = parseFloat(lfData.find("input[name='special[13112]']").val().length === 0 ? 0 : lfData.find("input[name='special[13112]']").val() / 100);
      currentObject[participantId].bonuses.spaceDockExtender = parseFloat(lfData.find("input[name='special[14112]']").val().length === 0 ? 0 : lfData.find("input[name='special[14112]']").val() / 100);
    });
    let miscSection = $(fleetContent.find("misc-section")[0]);

    if (miscSection.length) {
      currentObject[participantId].engineerActive = $("#square-checkboxEngineer").is(':checked');
      currentObject[participantId].lootFood = $("#square-checkboxFoodLoot").is(':checked');
      currentObject[participantId].lootModifier = $('misc-section input[name=lootModifier]:checked').val();
    }

    if (attackType === 1) {
      attackerObj = currentObject;
    } else {
      defenderObj = currentObject;
    }
  });

  if (Object.keys(attackerObj).length + Object.keys(defenderObj).length > combatSimMaxParticipants) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_TOO_MUCH_PARTICIPANTS.replace("#number#", combatSimMaxParticipants), 'error');
    return;
  }

  if (totalShipCount > combatSimMaxShips) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_TOO_MUCH_SHIPS.replace("#number#", combatSimMaxShips.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".")), 'error');
    return;
  }

  let body = {
    _token: token,
    simId: combatSimId,
    participants: JSON.stringify({
      attacker: attackerObj,
      defender: defenderObj
    })
  };
  $.ajax({
    url: simBackendUrl + '&action=saveSim',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (typeof json.simData == 'object') {
        combatSimChanged = false;
        let combatSimIdBeforeSave = combatSimId;
        $("gradient-button button#saveCombatPlanning div.emoji").remove();
        $("#saveCombatPlanning").prop('disabled', true);
        showNotification(json.message, 'success'); // update short info

        $('combatsim-shortinfo .shortSimId span').html(json.simData.simId);
        $('combatsim-shortinfo .shortTarget span').html(json.simData.simName + ' ' + json.simData.target);
        $('combatsim-shortinfo .shortAttackerCount span').html(json.simData.attackerCount);
        $('combatsim-shortinfo .shortDefenderCount span').html(json.simData.defenderCount);
        $('combatsim-shortinfo .shortShipCount span').html(json.simData.shipCount);
        combatSimId = json.simData.simId;
        $('#deleteCombatPlanning').attr('data-simulation-id', combatSimId).data('simulationId', combatSimId);

        if (json.simData.isOwner === 0) {
          $('#deleteCombatPlanning').removeAttr('disabled');
          $("#simulateCombatPlanning").removeAttr('disabled');

          if ($("combatsim-list owned-sims .noentries").length === 1) {
            $("combatsim-list owned-sims .noentries").remove();
          }
        } else {
          $("#deleteCombatPlanning").prop('disabled', true);
          $("#simulateCombatPlanning").prop('disabled', true);
        } // update overview


        if ($("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "]").length === 0) {
          if (json.simData.isOwner === 0) {
            $("combatsim-list owned-sims").append(json.simData.singleSimTemplate);
          }
        } else {
          $("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "] .target span").html(json.simData.target);
          $("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "] .attackerCount span").html(json.simData.attackerCount);
          $("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "] .defenderCount span").html(json.simData.defenderCount);
          $("combatsim-list single-simulation[data-simulation-id=" + json.simData.simId + "] .shipCount span").html(json.simData.shipCount);
        }

        $("combatsim-list .entryCount .current").html($("combatsim-list owned-sims single-simulation").length);

        if (combatSimIdBeforeSave !== combatSimId) {
          loadSimDetails();
        }
      }

      if (json.status === 'failure') {
        showNotification(json.errors[0].message, 'error');

        if (json.errors[0].error === 280001) {
          newCombatPlanning();
          $("combatsim-list single-simulation[data-simulation-id=" + body.simId + "]").remove();
        }
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function removeCombatSim(simId) {
  if (combatSimId === simId) {
    combatSimId = 0;
    newCombatPlanning();
  }

  $(`combatsim-list single-simulation[data-simulation-id="${simId}"]`).remove();
}

function changeCombatSimState(simId, state) {
  let element = $(`combatsim-section[overview] single-simulation[data-simulation-id='${simId}'] .state .status`);
  let action = $(`combatsim-section[overview] single-simulation[data-simulation-id='${simId}'] sim-actions button.overlay`);
  let shortAction = $('#showCombatResultShortInfo');
  action.hide();

  switch (state) {
    case 1:
      element.text(jsloca.COMBATSIM_PENDING).removeClass('planning done').addClass('pending');
      break;

    case 2:
      element.text(jsloca.COMBATSIM_DONE).removeClass('planning pending').addClass('done');
      action.show();
      shortAction.removeAttr('disabled').attr('data-target', action.data('target'));
      break;

    default:
      element.text(jsloca.COMBATSIM_PLANNING).removeClass('pending done').addClass('planning');
  }
}

function loadSim(simId) {
  let body = {
    _token: token,
    simId: simId
  };
  $.ajax({
    url: simBackendUrl + '&action=loadSim',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (json.status === 'success') {
        newCombatPlanning(); // update short info

        $('combatsim-shortinfo .shortSimId span').html(json.simData.simId);
        $('combatsim-shortinfo .shortName span').html(json.simData.simName);
        $('combatsim-shortinfo .shortTarget span').html('[' + json.simData.galaxy + ':' + json.simData.system + ':' + json.simData.position + ']');
        $('combatsim-shortinfo .shortAttackerCount span').html(json.simData.attackerCount);
        $('combatsim-shortinfo .shortDefenderCount span').html(json.simData.defenderCount);
        $('combatsim-shortinfo .shortShipCount span').html(json.simData.shipCount);
        combatSimId = json.simData.simId;
        $('#deleteCombatPlanning').removeAttr('disabled').attr('data-simulation-id', combatSimId).data('simulationId', combatSimId);
        let combatSimSection;

        if (json.simData.attackerCount > 1) {
          combatSimSection = $("combatsim-section[data-attack-type=1]").first();
          Object.keys(json.simData.data.attacker).slice(1).forEach(participantId => {
            addParticipant(combatSimSection, participantId);
          });
        }

        if (json.simData.defenderCount > 1) {
          combatSimSection = $("combatsim-section[data-attack-type=2]").first();
          Object.keys(json.simData.data.defender).slice(1).forEach(participantId => {
            addParticipant(combatSimSection, participantId);
          });
        }

        let attackType = 1;
        let isBaseDefender = false;
        Object.keys(json.simData.data.attacker).forEach(index => {
          adjustResearchClassBonuses(json.simData.data.attacker[index]);
          fillData($("fleet-content[data-participant-id=" + index + "][data-attack-type=1]").first(), json.simData.data.attacker[index], isBaseDefender, attackType);
        });
        attackType = 2;
        isBaseDefender = true;
        Object.keys(json.simData.data.defender).forEach(index => {
          adjustResearchClassBonuses(json.simData.data.defender[index]);
          const element = json.simData.data.defender[index];

          if (isBaseDefender === true) {
            index = 0;

            if (element.engineerActive === true) {
              $("#square-checkboxEngineer").attr('checked', true);
            } else {
              $("#square-checkboxEngineer").removeAttr('checked');
            }

            if (element.lootFood === true) {
              $("#square-checkboxFoodLoot").attr('checked', true);
            } else {
              $("#square-checkboxFoodLoot").removeAttr('checked');
            }

            $("fleet-content[base-defender] misc-section input[name='lootModifier']").removeAttr('checked');
            $("#round-radioLootModifier" + Math.floor((element.lootModifier - 0.25) / 0.25)).attr('checked', true);
          }

          fillData($("fleet-content[data-participant-id=" + index + "][data-attack-type=2]").first(), element, isBaseDefender, attackType);
          isBaseDefender = false;
        });
        combatSimChanged = false;
        $("gradient-button button#saveCombatPlanning div.emoji").remove();

        if (parseInt(json.simData.type) === 0) {
          $("#deleteCombatPlanning").removeAttr('disabled');

          if (json.simStateProgress === true) {
            $("#simulateCombatPlanning").prop('disabled', true);
          } else {
            $("#simulateCombatPlanning").removeAttr('disabled');
          }
        } else {
          $("#deleteCombatPlanning").prop('disabled', true);
          $("#simulateCombatPlanning").prop('disabled', true);
        }

        $("#saveCombatPlanning").prop('disabled', true);
        loadSimDetails();
        showNotification(json.message, 'success');
      } else {
        showNotification(json.errors[0].message, 'error');

        if (json.errors[0].error === 280001) {
          newCombatPlanning();
          $("combatsim-list single-simulation[data-simulation-id=" + simId + "]").remove();
        }
      }
    },
    error: function () {
      showNotification(combatSimLoca.LOCA_ERROR_DEFAULT, 'error');
    }
  });
}

function addParticipant(combatsimSection, participantId = null) {
  let attackType = combatsimSection.data('attackType');
  combatsimSection.attr('show-lifeform', '0');
  combatsimSection.find("participants-headline").show();
  combatsimSection.find(".removeParticipantBtn").removeClass('disabled');

  if (participantId === null) {
    participantId = combatsimSection.find("participants-headline participant-header").last().data('participantId') + 1;
  }

  if ($("participant-header").length >= combatSimMaxParticipants) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_TOO_MUCH_PARTICIPANTS.replace("#number#", combatSimMaxParticipants), 'error');
    return;
  } // handle participants


  $(combatsimSection.find("participant-header")).removeClass('active');
  let newParticipant = [{
    attackType: attackType,
    participantId: participantId
  }].map(participantHeaderTemplate).join('');
  let cloneParticipant = combatsimSection.find("participants-headline participant-header").last().clone(true);
  cloneParticipant.attr('data-participant-id', $(newParticipant).data('participantId')).data('participantId', $(newParticipant).data('participantId')).attr('data-attack-type', $(newParticipant).data('attackType')).data('attackType', $(newParticipant).data('attackType')).addClass('active').html($(newParticipant).html()).insertAfter(combatsimSection.find("participants-headline participant-header").last()); // handle new fleet

  let newFleetSection = [{
    attackType: attackType,
    participantId: participantId
  }].map(fleetContentTemplate).join('');

  if (attackType === 2) {
    newFleetSection = newFleetSection.replace(/tabindex=\"(\d.*?)\"/g, function (i, match) {
      return "tabindex=\"" + (parseInt(match) + 200) + "\"";
    });
  }

  let cloneFleet = combatsimSection.find("fleet-content").last().clone(true);
  let newElement = $(newFleetSection);
  $(combatsimSection.find("fleet-content")).hide();
  newElement.find("lifeform-data technology-icon[solarsatellite]").closest('div.technology-fullrow').hide();
  newElement.find("lifeform-data technology-icon[resbuggy]").closest('div.technology-fullrow').hide();
  cloneFleet.attr('data-participant-id', newElement.data('participantId')).data('participantId', newElement.data('participantId')).attr('data-attack-type', newElement.data('attackType')).data('attackType', newElement.data('attackType')).html(newElement.html()).show().insertAfter(combatsimSection.find("fleet-content").last());
  combatsimSection.find("participants-headline participant-header p").each(function (index, element) {
    $(element).html(index + 1);
  }); //adjust buttons

  $(combatsimSection.find("fleet-section-clear .clearPlayer")).attr('data-participant-id', participantId).data('participantId', participantId).attr('data-attack-type', attackType).data('attackType', attackType);
  $(combatsimSection.find("fleet-section-clear .clearTechnologies")).attr('data-participant-id', participantId).data('participantId', participantId).attr('data-attack-type', attackType).data('attackType', attackType);
  simChanged(combatsimSection);
}

function newCombatPlanning() {
  let participantId = 0,
      attackType;
  let completeCombatsSim = $("div#combatsim");
  completeCombatsSim.find("combatsim-section:not(combatsim-section[base-defender]):not(combatsim-section[overview])").each((index, element) => {
    const combatsimSection = $(element);
    combatsimSection.attr('show-lifeform', '0');
    attackType = $(combatsimSection.find("thick-headline-background")[0]).data('attackType'); // remove header

    combatsimSection.find("participants-headline participant-header").remove();
    let newParticipant = [{
      attackType: attackType,
      participantId: participantId
    }].map(participantHeaderTemplate).join('');
    combatsimSection.find("participants-headline").hide().append(newParticipant);
    combatsimSection.find("participants-headline participant-header p").each(function (index, element) {
      $(element).html(index + 1);
    }); // remove fleet sections

    let newFleetSection = [{
      attackType: attackType,
      participantId: participantId
    }].map(fleetContentTemplate).join('');

    if (attackType === 2) {
      newFleetSection = newFleetSection.replace(/tabindex=\"(\d.*?)\"/g, function (i, match) {
        return "tabindex=\"" + (parseInt(match) + 200) + "\"";
      });
    }

    combatsimSection.find("fleet-content").remove();
    let newElement = $(newFleetSection);

    if (attackType !== 2) {
      newElement.find("lifeform-data technology-icon[solarsatellite]").closest('div.technology-fullrow').hide();
      newElement.find("lifeform-data technology-icon[resbuggy]").closest('div.technology-fullrow').hide();
    }

    newElement.insertBefore(combatsimSection.find("fleet-section-clear")); //adjust buttons

    $(combatsimSection.find("fleet-section-clear .clearPlayer")).attr('data-participant-id', 0).data('participantId', 0).attr('data-attack-type', attackType).data('attackType', attackType);
    $(combatsimSection.find("fleet-section-clear .clearTechnologies")).attr('data-participant-id', 0).data('participantId', 0).attr('data-attack-type', attackType).data('attackType', attackType);
  });
  completeCombatsSim.find("fleet-content[base-defender] misc-section input").removeAttr('checked');
  completeCombatsSim.find("fleet-content[base-defender] misc-section #round-radioLootModifier2").attr('checked', true);
  completeCombatsSim.find("combatsim-section[base-defender] basic-data .resource-row input").val('');
  completeCombatsSim.find("combatsim-section[base-defender] basic-data defense-section input").val('');
  completeCombatsSim.find("combatsim-section[base-defender] lifeform-data input").val('');
  completeCombatsSim.find("combatsim-section[base-defender] lifeform-data").hide();
  completeCombatsSim.find("combatsim-section[base-defender]").attr('show-lifeform', '0');
  combatSimChanged = false;
  $("gradient-button button#saveCombatPlanning div.emoji").remove();
  combatSimId = 0;
  loadSimDetails();
  $('#deleteCombatPlanning').attr('disabled', true).attr('data-simulation-id', 0).data('simulationId', 0);
  $("combatsim-shortinfo div > span").html('-');
  $('#showCombatResultShortInfo').prop('disabled', true).attr('data-target', '');
  $("#saveCombatPlanning").prop('disabled', true);
  $("#simulateCombatPlanning").prop('disabled', true);
  $(".removeParticipantBtn").addClass('disabled');
}

function resetAnim(obj) {
  let currentTarget = $(obj);
  currentTarget.find('.togglePanel').hide();
  currentTarget.find('class-selection input').prop('checked', false);
}

function invitePlayerToSim(obj) {
  let simId = $(obj).data('simulationId');
  let playerId = $(obj).data('playerId');

  if ($("shared-participant").length >= combatSimMaxParticipants) {
    showNotification(combatSimLoca.LOCA_COMBATSIM_TOO_MUCH_PARTICIPANTS.replace("#number#", combatSimMaxParticipants), 'error');
    return;
  }

  if (combatSimId !== 0 && simId === combatSimId) {
    let body = {
      _token: token,
      simId: simId,
      playerId: playerId
    };
    $.ajax({
      url: simBackendUrl + '&action=invitePlayer',
      data: body,
      type: "POST",
      dataType: "json",
      success: function (json) {
        token = json.newAjaxToken;

        if (json.status === 'failure') {
          showNotification(json.errors[0].message, 'error');
          return;
        }

        if (json.status === 'success') {
          showNotification(json.message, 'success');
          loadSimDetails();
        }
      }
    });
  }
}

function removeParticipant(obj) {
  let simId = $(obj).data('simulationId');
  let playerId = $(obj).data('playerId');

  if (combatSimId !== 0 && simId === combatSimId) {
    let body = {
      _token: token,
      simId: simId,
      playerId: playerId
    };
    $.ajax({
      url: simBackendUrl + '&action=removePlayer',
      data: body,
      type: "POST",
      dataType: "json",
      success: function (json) {
        token = json.newAjaxToken;

        if (json.status === 'failure') {
          showNotification(json.errors[0].message, 'error');
          return;
        }

        if (json.status === 'success') {
          showNotification(json.message, 'success');
          loadSimDetails();
        }
      }
    });
  }
}

function loadSimDetails() {
  if (combatSimId === 0) {
    $("fleet-content[siminfo]").html('<div class="noentries">' + combatSimLoca.LOCA_COMBATSIM_NO_SIMS_FOUND + '</div>');
  } else {
    let body = {
      _token: token,
      simId: combatSimId
    };
    $.ajax({
      url: simInfoUrl,
      data: body,
      type: "POST",
      dataType: "json",
      success: function (json) {
        token = json.newAjaxToken;
        $("fleet-content[siminfo]").html(json.content[json.target]);
        updateSimShortInfo($('combatsim-intro combatsim-shortinfo'));

        if (combatSimProgress) {
          let action = $(`combatsim-section[overview] single-simulation[data-simulation-id='${combatSimId}'] sim-actions button.overlay`);
          let shortAction = $('#showCombatResultShortInfo');
          shortAction.removeAttr('disabled').attr('data-target', action.data('target'));
        }
      }
    });
  }
}

function updateSimShortInfo(element) {
  if (!element || !element.length) {
    return;
  }

  $('combatsim-shortinfo .shortSimId span').text(element.find('.shortSimId span').first().text());
  $('combatsim-shortinfo .shortTarget span').text(element.find('.shortTarget span').first().text());
  $('combatsim-shortinfo .shortAttackerCount span').text(element.find('.shortAttackerCount span').first().text());
  $('combatsim-shortinfo .shortDefenderCount span').text(element.find('.shortDefenderCount span').first().text());
  $('combatsim-shortinfo .shortShipCount span').text(element.find('.shortShipCount span').first().text());
}

function joinCombatSim(simId, playerId) {
  let body = {
    _token: token,
    simId: simId,
    playerId: playerId
  };
  $.ajax({
    url: simBackendUrl + '&action=joinSim',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (json.status === 'failure') {
        showNotification(json.errors[0].message, 'error');
        return;
      }

      if (json.status === 'success') {
        showNotification(json.message, 'success');
        window.open(combatSimUrl);
      }
    },
    error: function () {}
  });
}

function startSimulation(obj) {
  let body = {
    _token: token,
    simId: combatSimId
  };
  $.ajax({
    url: simBackendUrl + '&action=startSim',
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      token = json.newAjaxToken;

      if (json.status === 'failure') {
        showNotification(json.errors[0].message, 'error');
        return;
      }

      if (json.status === 'success') {
        loadSimDetails();
        $("#simulateCombatPlanning").prop('disabled', true);
        showNotification(json.message, 'success');
      }
    },
    error: function () {}
  });
}

$(function () {
  $('thick-headline-background .minimizeBtn').on("click", function (event) {
    event.preventDefault();
    event.stopPropagation();

    if ($(event.currentTarget).hasClass('minimized')) {
      $(event.currentTarget).removeClass('minimized').html('&#128469;&#xFE0E;');
      $("combatsim-section[overview] combatsim-list").show();
      $("combatsim-section[overview] combatsim-shortinfo").show();
      $("combatsim-section[overview] combatsim-actions").removeAttr('style');
      $("combatsim-section[overview]").removeAttr('minimized');
    } else {
      $(event.currentTarget).addClass('minimized').html('&#128470;&#xFE0E;');
      $("combatsim-section[overview] combatsim-list").hide();
      $("combatsim-section[overview] combatsim-shortinfo").hide();
      $("combatsim-section[overview] combatsim-actions").css('flex-direction', 'row').css('width', '100%');
      $("combatsim-section[overview]").attr('minimized', true);
    }
  });
  $('thick-headline-background .addParticipantBtn').on("click", function (event) {
    event.preventDefault();
    event.stopPropagation();
    let combatsimSection = $($(event.currentTarget).closest("combatsim-section")[0]);
    addParticipant(combatsimSection);
  });
  $('thick-headline-background .removeParticipantBtn').on("click", function (event) {
    event.preventDefault();
    event.stopPropagation();
    let attackType = $(event.currentTarget).closest('thick-headline-background').data('attackType');
    let combatsimSection = $(event.currentTarget).closest("combatsim-section");

    if (combatsimSection.find("participant-header").length === 1) {
      return;
    }

    let currentActive = combatsimSection.find("participant-header.active").first();
    let participantId = currentActive.data('participantId');
    const sectionToRemove = combatsimSection.find("fleet-content[data-participant-id=" + participantId + "][data-attack-type=" + attackType + "]");
    const previousCoords = {
      galaxy: sectionToRemove.find("coordinates-section input[name='galaxy']").first().val(),
      system: sectionToRemove.find("coordinates-section input[name='system']").first().val(),
      position: sectionToRemove.find("coordinates-section input[name='position']").first().val()
    };
    sectionToRemove.remove();
    currentActive.remove();
    combatsimSection.find("participants-headline participant-header p").each(function (index, element) {
      $(element).html(index + 1);
    });
    let newActive = combatsimSection.find("fleet-content").first().data('participantId');
    combatsimSection.find("fleet-content[data-participant-id=" + newActive + "][data-attack-type=" + attackType + "]").show();
    combatsimSection.find("participants-headline participant-header[data-participant-id=" + newActive + "][data-attack-type=" + attackType + "]").addClass('active').show();

    if (combatsimSection.find("participant-header").length === 1) {
      combatsimSection.find("participants-headline").hide();
      combatsimSection.find(".removeParticipantBtn").addClass('disabled');
    } //adjust buttons


    $(combatsimSection.find("fleet-section-clear .clearPlayer")).attr('data-participant-id', newActive).data('participantId', newActive).attr('data-attack-type', attackType).data('attackType', attackType);
    $(combatsimSection.find("fleet-section-clear .clearTechnologies")).attr('data-participant-id', newActive).data('participantId', newActive).attr('data-attack-type', attackType).data('attackType', attackType); //adjust base defender

    let firstDefender = $("fleet-content[data-attack-type=2]:not(fleet-content[base-defender])").first();
    firstDefender.find("lifeform-data technology-icon[solarsatellite]").closest('div.technology-fullrow').show();
    firstDefender.find("lifeform-data technology-icon[resbuggy]").closest('div.technology-fullrow').show();
    let coordsGalaxy = firstDefender.find("coordinates-section input[name='galaxy']").first();
    let coordsSystem = firstDefender.find("coordinates-section input[name='system']").first();
    let coordsPosition = firstDefender.find("coordinates-section input[name='position']").first();

    if (coordsGalaxy.val() === '' || coordsSystem.val() === '' || coordsPosition.val() === '') {
      coordsGalaxy.val(previousCoords.galaxy);
      coordsSystem.val(previousCoords.system);
      coordsPosition.val(previousCoords.position);
    }

    $("fleet-content[base-defender]").attr('data-participant-id', firstDefender.data('participantId')).data('participantId', firstDefender.data('participantId'));
    simChanged(combatsimSection);
  });
  $('gradient-button #newCombatPlanning').on("click", function (event) {
    event.preventDefault();
    event.stopPropagation();
    newCombatPlanning();
  });
  $('gradient-button #saveCombatPlanning').on("click", function (event) {
    event.preventDefault();
    event.stopPropagation();
  });
});
$(document).ready(function () {
  let params = new URL(document.location).searchParams;
  let reportHash = params.get('reportHash');

  if (reportHash) {
    loadSpyReport(reportHash, $("fleet-content[data-participant-id=0][data-attack-type=2] .loadInfoParticipant"), true, 2);
  }
});

function closeCombatSimResultOverlay() {
  if (!$(".overlayDiv.combatSimResultOverlay").length) {
    return;
  }

  $(".overlayDiv.combatSimResultOverlay").remove();
}
/* Rounds start */


function getRoundData(round, participant, side = "attacker") {
  let remainingTechs = {};
  let lostTechs = {};
  let roundData = {};

  if (typeof combatData === 'undefined') {
    return roundData;
  }

  let {
    combatRounds
  } = combatData;

  if (!combatRounds[round]) {
    return roundData;
  }

  let currentRound = combatRounds[round];

  if (participant !== 'all') {
    if (currentRound[`${side}Ships`] && currentRound[`${side}Ships`][participant]) {
      remainingTechs = currentRound[`${side}Ships`][participant];
    }

    if (currentRound[`${side}Losses`] && currentRound[`${side}Losses`][participant]) {
      lostTechs = currentRound[`${side}Losses`][participant];
    }
  } else {
    if (currentRound[`${side}ShipsTotal`]) {
      remainingTechs = currentRound[`${side}ShipsTotal`];
    }

    if (currentRound[`${side}LossesInThisRoundTotal`]) {
      lostTechs = currentRound[`${side}LossesInThisRoundTotal`];
    }
  }

  Object.keys(remainingTechs).map(techId => {
    if (!roundData[techId]) {
      roundData[techId] = {
        "remaining": 0,
        "lost": 0
      };
    }

    roundData[techId].remaining = remainingTechs[techId];
  });
  Object.keys(lostTechs).map(techId => {
    if (!roundData[techId]) {
      roundData[techId] = {
        "remaining": 0,
        "lost": 0
      };
    }

    roundData[techId].lost = lostTechs[techId];
  });
  return roundData;
}

function selectRound(round) {
  let attacker = 'all';

  if ($('#combatSimReport .attacker .participant_select').length) {
    attacker = $('#combatSimReport .attacker .participant_select').val();
  }

  displayRoundData(round, attacker, 'attacker');
  let defender = 'all';

  if ($('#combatSimReport .defender .participant_select').length) {
    defender = $('#combatSimReport .defender .participant_select').val();
  }

  displayRoundData(round, defender, 'defender');
  displayRoundStatistics(round);
  $('.selectRoundBtn').removeAttr('disabled');
  $(`.selectRoundBtn[data-round-number=${round}]`).prop('disabled', true);
}

function displayRoundData(round, participant, side = "attacker") {
  let roundData = getRoundData(round, participant, side); // let shownTechIds = Object.keys(roundData)

  $(`#combatSimRounds .combat_participant.${side} .military_ships > li`).hide().removeClass('even odd');
  $(`#combatSimRounds .combat_participant.${side} .civil_ships > li`).hide().removeClass('even odd');
  $(`#combatSimRounds .combat_participant.${side} .defence_techs > li`).hide().removeClass('even odd');
  Object.keys(roundData).map(techId => {
    let {
      remaining,
      lost
    } = roundData[techId];

    if (remaining || lost) {
      $(`#${side}CombatSimTechRow_${techId}`).show();
      $(`#${side}CombatSimTechRow_${techId} .detail_shipsleft`).text(remaining);
      $(`#${side}CombatSimTechRow_${techId} .detail_shipslost`).text(-lost);
    }
  });
  let participantNumber = 0;

  if (participant !== 'all') {
    participantNumber = participant;
  }

  $(`.${side}CharacterClass characterclass-icon`).removeAttr(characterClassArr.join(' ')).attr(findClassName(characterClassArr, combatData[side][participantNumber].characterClassId), true);
  $(`.${side}AllianceClass allianceclass-icon`).removeAttr(allianceClassArr.join(' ')).attr(findClassName(allianceClassArr, combatData[side][participantNumber].allianceClassId), true);
  let visibleIterator = 0;
  $(`#combatSimRounds .combat_participant.${side} .military_ships li`).each(function (index, obj) {
    if ($(obj).is(':visible')) {
      if (visibleIterator % 2 === 0) {
        $(obj).addClass('odd');
      } else {
        $(obj).addClass('even');
      }

      visibleIterator++;
    }
  });
  $(`#combatSimRounds .combat_participant.${side} .combatShipsTitle`).show();

  if (!visibleIterator) {
    $(`#combatSimRounds .combat_participant.${side} .combatShipsTitle`).hide();
  }

  visibleIterator = 0;
  $(`#combatSimRounds .combat_participant.${side} .civil_ships li`).each(function (index, obj) {
    if ($(obj).is(':visible')) {
      if (visibleIterator % 2 === 0) {
        $(obj).addClass('odd');
      } else {
        $(obj).addClass('even');
      }

      visibleIterator++;
    }
  });
  $(`#combatSimRounds .combat_participant.${side} .civilShipsTitle`).show();

  if (!visibleIterator) {
    $(`#combatSimRounds .combat_participant.${side} .civilShipsTitle`).hide();
  }

  visibleIterator = 0;
  $(`#combatSimRounds .combat_participant.${side} .defence_techs li`).each(function (index, obj) {
    if ($(obj).is(':visible')) {
      if (visibleIterator % 2 === 0) {
        $(obj).addClass('odd');
      } else {
        $(obj).addClass('even');
      }

      visibleIterator++;
    }
  });
  $(`#combatSimRounds .combat_participant.${side} .defenceTechsTitle`).show();

  if (!visibleIterator) {
    $(`#combatSimRounds .combat_participant.${side} .defenceTechsTitle`).hide();
  }
}

function getRoundStatistic(round) {
  let statistic = {
    absorbedDamageAttacker: 0,
    absorbedDamageDefender: 0,
    fullStrengthAttacker: 0,
    fullStrengthDefender: 0,
    hitsAttacker: 0,
    hitsDefender: 0
  };

  if (typeof combatData === 'undefined') {
    return statistic;
  }

  let {
    combatRounds
  } = combatData;

  if (!combatRounds[round]) {
    return statistic;
  }

  let currentRound = combatRounds[round];

  if (currentRound.statistic) {
    statistic = currentRound.statistic;
  }

  return statistic;
}

function displayRoundStatistics(round) {
  let statistic = getRoundStatistic(round);
  Object.keys(statistic).map(statisticKey => {
    $(`#${statisticKey}`).text(statistic[statisticKey]);
  });
}

function getCombatResearchPercentages(side, participant = 'all') {
  let combatResearchPercentages = {
    weaponPercentage: 0,
    shieldPercentage: 0,
    armorPercentage: 0
  };

  if (typeof combatData === 'undefined') {
    return combatResearchPercentages;
  }

  if (!combatData[side]) {
    return combatResearchPercentages;
  }

  if (participant === 'all') {
    combatData[side].map(participantData => {
      if (participantData.weaponPercentage) {
        combatResearchPercentages.weaponPercentage += participantData.weaponPercentage;
      }

      if (participantData.shieldPercentage) {
        combatResearchPercentages.shieldPercentage += participantData.shieldPercentage;
      }

      if (participantData.armorPercentage) {
        combatResearchPercentages.armorPercentage += participantData.armorPercentage;
      }
    });
    combatResearchPercentages.weaponPercentage /= combatData[side].length;
    combatResearchPercentages.shieldPercentage /= combatData[side].length;
    combatResearchPercentages.armorPercentage /= combatData[side].length;
  } else {
    if (combatData[side] && combatData[side][participant]) {
      let participantData = combatData[side][participant];

      if (participantData.weaponPercentage) {
        combatResearchPercentages.weaponPercentage = participantData.weaponPercentage;
      }

      if (participantData.shieldPercentage) {
        combatResearchPercentages.shieldPercentage = participantData.shieldPercentage;
      }

      if (participantData.armorPercentage) {
        combatResearchPercentages.armorPercentage = participantData.armorPercentage;
      }
    }
  }

  return combatResearchPercentages;
}

function displayCombatResearchPercentages(side, participant) {
  let combatResarchPercentages = getCombatResearchPercentages(side, participant);
  $(`#combatSimRounds .combat_participant.${side} .${side}Weapon span`).text(`${combatResarchPercentages.weaponPercentage}%`);
  $(`#combatSimRounds .combat_participant.${side} .${side}Shield span`).text(`${combatResarchPercentages.shieldPercentage}%`);
  $(`#combatSimRounds .combat_participant.${side} .${side}Cover span`).text(`${combatResarchPercentages.armorPercentage}%`);
}

function findClassName(classArr, id) {
  return classArr[id] ?? classArr[0];
}

function findClassId(classArr, name) {
  return Math.max(0, classArr.indexOf(name));
}
/* rounds end */
/**
 * convert seconds to time interval for display. Usage in formatTime
 * @param timestamp Time interval in seconds
 * @param maxDigits count of shown digits
 * @param showUnits flag to use localized units
 * @param delimiter used delimiter
 * @param zerofill flag to use two digit zerofill
 * @param approx prefix for time string
 * @returns {string}
 */
function formatTimeWrapper(timestamp, maxDigits, showUnits, delimiter, zerofill, approx) {
  let timeUnits = {
    week: 604800,
    day: 86400,
    hour: 3600,
    minute: 60,
    second: 1
  };
  let timeString = "";

  for (let k in timeUnits) {
    let nv = Math.floor(timestamp / timeUnits[k]);

    if (maxDigits > 0 && (nv > 0 || zerofill && timeString !== "")) {
      timestamp = timestamp - nv * timeUnits[k];

      if (timeString !== "") {
        timeString += delimiter;

        if (nv < 10 && nv > 0 && zerofill) {
          nv = "0" + nv;
        }

        if (nv === 0) {
          nv = "00";
        }
      }

      timeString += nv + (showUnits ? LocalizationStrings.timeunits['short'][k] : '');
      maxDigits--;
    }
  }

  if (timestamp > 0) {
    timeString = approx + timeString;
  }

  return timeString;
}
/**
 * counter finished reload page
 * @param url
 */


function reload_page(url) {
  if (timerHandler && !timerHandler.pageReloadAlreadyTriggered) {
    timerHandler.pageReloadAlreadyTriggered = true;
    openParentLocation(url);
  }
}

class SimpleCountdownTimer {
  constructor(targetName, leftoverTime, reloadPage, countdownDoneFunction) {
    // default config
    this.timestamp = 0;
    this.maxDigits = 2;
    this.delimiter = " ";
    this.approx = "";
    this.showunits = true;
    this.zerofill = false;
    this.startTime = new Date().getTime();
    this.startLeftoverTime = parseInt(leftoverTime);
    this.targetName = targetName;
    this.reloadPage = reloadPage;
    this.countdownDoneFunction = countdownDoneFunction;
    this.timer = timerHandler.appendCallback(this.updateCountdown.bind(this));
    this.updateCountdown();
  }

  get getTimer() {
    return this.timer;
  }

  get getCurrentTimestring() {
    return formatTimeWrapper(this.getLeftoverTime(), this.maxDigits, this.showunits, this.delimiter, this.zerofill, this.approx);
  }

  getLeftoverTime() {
    let currTime = new Date();
    return Math.round(this.startLeftoverTime + (currTime.getTime() - this.startTime) * -1 / 1000);
  }

  updateCountdown() {
    let timeLeftInSeconds = this.getLeftoverTime();

    if (timeLeftInSeconds > 0) {
      $(this.targetName).text(this.getCurrentTimestring);
    } else {
      $(this.targetName).text(LocalizationStrings.status.ready);

      if (typeof this.countdownDoneFunction == 'function') {
        this.countdownDoneFunction();
      }

        if (this.reloadPage != null) {
          reload_page(this.reloadPage);
        }

        timerHandler.removeCallback(this.timer);
    }
  }

}

class CountdownTimer {
  constructor(targetName, leftoverTime, reloadPage, countdownDoneFunction, primaryReloadViaWS, maxDigits = 2, countValue = -1) {
    // default config
    this.countValue = parseInt(countValue);
    this.timestamp = 0;
    this.maxDigits = parseInt(maxDigits); // with 2 seconds won't be show when time is > 1h

    this.delimiter = " ";
    this.approx = "";
    this.showunits = true;
    this.zerofill = false;
    this.startTime = new Date().getTime();
    this.startLeftoverTime = parseInt(leftoverTime);
    this.targetName = targetName;
    this.reloadPage = reloadPage;
    this.countdownDoneFunction = countdownDoneFunction;
    this.primaryReloadViaWS = primaryReloadViaWS;
    this.timer = timerHandler.appendCallback(this.updateCountdown.bind(this));
    this.updateCountdown();
  } // Getter


  get getCurrentTimestring() {
    return formatTimeWrapper(this.getLeftoverTime(), this.maxDigits, this.showunits, this.delimiter, this.zerofill, this.approx);
  } // Method


  getLeftoverTime() {
    let currTime = new Date();
    return Math.round(this.startLeftoverTime + (currTime.getTime() - this.startTime) * this.countValue / 1000);
  }

  updateCountdown() {
    let timeLeftInSeconds = this.getLeftoverTime();

    if (timeLeftInSeconds > 0) {
      $(`time.${this.targetName}`).text(this.getCurrentTimestring);
    } else {
      $(`time.${this.targetName}`).text(LocalizationStrings.status.ready);

      if (typeof this.countdownDoneFunction == 'function') {
        this.countdownDoneFunction();
      }

        if (this.reloadPage != null && !isOverlayOpen() && (!this.primaryReloadViaWS || this.primaryReloadViaWS === true && ogame.frontendActions.connected !== true)) {
          reload_page(this.reloadPage);
        }

        timerHandler.removeCallback(this.timer);
    }
  }

}

class CountdownTimerUnit {
  constructor(targetName, leftoverTime, shipCount, targetTechnologyId, timePerUnit, reloadPage, maxDigits = 2) {
    // default config
    this.timestamp = 0;
    this.maxDigits = parseInt(maxDigits); // with 2 seconds won't be show when time is > 1h

    this.delimiter = " ";
    this.approx = "";
    this.showunits = true;
    this.zerofill = false;
    this.startTime = new Date().getTime();
    this.startLeftoverTime = parseInt(leftoverTime);
    this.shipCount = shipCount;
    this.timePerUnit = timePerUnit;
    this.targetTechnologyId = targetTechnologyId;
    this.targetName = targetName;
    this.reloadPage = reloadPage;
    this.timer = timerHandler.appendCallback(this.updateCountdown.bind(this));
    this.updateCountdown();
  } // Getter


  get getCurrentTimestring() {
    return formatTimeWrapper(this.getLeftoverTime(), this.maxDigits, this.showunits, this.delimiter, this.zerofill, this.approx);
  } // Method


  getLeftoverTime() {
    let currTime = new Date();
    return Math.round(this.startLeftoverTime + (currTime.getTime() - this.startTime) * -1 / 1000);
  }

  updateCountdown() {
    let timeLeftInSeconds = this.getLeftoverTime();
    let currentShipCount = parseInt($(`li.technology[data-technology=${this.targetTechnologyId}] span.amount`).attr('data-value'));
    let factor = Math.max(0, timeLeftInSeconds) / this.timePerUnit;
    $(`time.${this.targetName}`).text(this.getCurrentTimestring);

    if (factor > 0) {
      $(`li.technology[data-technology=${this.targetTechnologyId}][data-status="active"] .cooldownBackground`).css('height', factor * 100 + "%");
    } else {
      // let targetAmount = $(`li.technology[data-technology=${this.targetTechnologyId}] span.targetamount`).data('value')
      if (this.shipCount > 0) {
        this.shipCount--; // targetAmount--

        currentShipCount++;
      }

      if (this.shipCount >= 0) {
        // $(`li.technology[data-technology=${this.targetTechnologyId}] span.targetamount`).attr('data-value', targetAmount).text(targetAmount)
        $(`.shipSumCount.${this.targetName}`).text(this.shipCount);
      }

      $(`li.technology[data-technology=${this.targetTechnologyId}] span.amount`).attr('data-value', currentShipCount);
      $(`li.technology[data-technology=${this.targetTechnologyId}] span.amount .stockAmount`).text(gfNumberGetHumanReadable(currentShipCount));

      if (this.shipCount > 0) {
        this.startTime = new Date().getTime();
        this.startLeftoverTime = this.timePerUnit; // new CountdownTimerUnit(this.targetName, this.leftoverTime, this.shipCount, this.targetTechnologyId, this.timePerUnit, this.reloadPage)

        $(`time.${this.targetName}`).text(LocalizationStrings.status.ready);
      } else {
        if (timeLeftInSeconds <= -1 && timeLeftInSeconds > -6) {
          if (this.reloadPage != null && !isOverlayOpen()) {
            reload_page(this.reloadPage);
          }

          timerHandler.removeCallback(this.timer);
        }

        $(`time.${this.targetName}`).text(LocalizationStrings.status.ready);
      }
    }
  }

}
/*
 *	allgemeiner Countdown
 */


function oldcountdown(leftoverTime, maxDigits, countValue) {
  if (maxDigits == null || maxDigits == "") {
    maxDigits = 2;
  }

  var thisObj = this;
  thisObj.countValue = parseInt(countValue) || -1; // config

  thisObj.timestamp = 0;
  thisObj.maxDigits = parseInt(maxDigits); // bei 2 werden keine Sekunden gezeigt, wenn der Zeitraum > 1 h ist

  thisObj.delimiter = " "; // Trennzeichen

  thisObj.approx = ""; // wird vor Zeitstring angefuegt

  thisObj.showunits = true; // Einheiten zeigen

  thisObj.zerofill = false; // nullen auffuellen

  var localTime = new Date();
  thisObj.startTime = localTime.getTime(); // Script-Startzeit

  thisObj.startLeftoverTime = parseInt(leftoverTime); // Sekunden Restzeit

  this.getCurrentTimestring = function () {
    return formatTimeWrapper(thisObj.getLeftoverTime(), thisObj.maxDigits, thisObj.showunits, thisObj.delimiter, thisObj.zerofill, thisObj.approx);
  };

  this.getLeftoverTime = function () {
    var currTime = new Date();
    return Math.round(thisObj.startLeftoverTime + (currTime.getTime() - thisObj.startTime) * thisObj.countValue / 1000);
  };
}
/*
* Countdown fuer die Eventliste
*/


function eventboxCountdown(htmlObj, leftoverTime, parentElement, checkEventsUrl, checkEventIds) {
  if (typeof htmlObj !== 'object') {
    return;
  }

  var thisObj = this; // diese elemente werden veraendert

  thisObj.timeHtmlObj = htmlObj;

  this.updateCountdown = function () {
    thisObj.countdown.getCurrentTimestring();
    var timestamp = thisObj.countdown.getLeftoverTime();
    var timestring = thisObj.countdown.getCurrentTimestring();

    if (timestamp > 0) {
      $(thisObj.timeHtmlObj).html(timestring);
    } else {
      timerHandler.removeCallback(thisObj.timer);
      $(thisObj.timeHtmlObj).html(LocalizationStrings.status.ready); // checkEvents NICHT spammen:

      if (!timerHandler.checkEventsAlreadyQueued) {
        timerHandler.checkEventsAlreadyQueued = true;
        setTimeout(function () {
          $.post(checkEventsUrl, {
            ids: checkEventIds
          }, function (data) {
            var rowIDs = $.parseJSON(data);

            for (var index in rowIDs["rows"]) {
              $(parentElement).find("#eventRow-" + rowIDs["rows"][index]).remove();
              $(".union" + rowIDs["rows"][index]).remove();
            }

            $('.eventFleet').removeClass('odd');
            $('.partnerInfo').removeClass('part-even');
            $('.eventFleet:odd').addClass('odd');
            $('.partnerInfo:even').addClass('part-even');
            timerHandler.checkEventsAlreadyQueued = false;
          });
        }, 2500);
      } // else: wir sind noch innerhalb der 2,5 Sekunden vom letzten Aufruf (durch anderes Event)

    }
  };

  if (thisObj.timeHtmlObj) {
    // oldcountdown objekt
    thisObj.countdown = new oldcountdown(leftoverTime, 3);
    thisObj.timer = timerHandler.appendCallback(thisObj.updateCountdown);
    thisObj.updateCountdown();
  }
}
/*
* Einfacher Countdown mit Funktionsaufruf nach Ende des Countdowns
*/


function simpleCountdown(htmlObj, leftoverTime, countdownDoneFunction, countdownTickFunction) {
  if (typeof htmlObj !== 'object') {
    return;
  }

  var thisObj = this; // diese elemente werden veraendert

  thisObj.timeHtmlObj = $(htmlObj)[0];

  this.updateCountdown = function () {
    var timestamp = thisObj.countdownObject.getLeftoverTime();
    var timestring = thisObj.countdownObject.getCurrentTimestring();

    if (timestamp > 0) {
      $('#' + thisObj.timeHtmlObj.id).text(timestring);

      if (typeof countdownTickFunction == "string" && $.isFunction(window[countdownTickFunction])) {
        window[countdownTickFunction]();
      } else if ($.isFunction(countdownTickFunction)) {
        countdownTickFunction();
      }
    } else {
      timerHandler.removeCallback(thisObj.timer);
      $('#' + thisObj.timeHtmlObj.id).text(LocalizationStrings.status.ready);

      if (typeof countdownDoneFunction == "string" && $.isFunction(window[countdownDoneFunction])) {
        window[countdownDoneFunction]();
      } else if ($.isFunction(countdownDoneFunction)) {
        countdownDoneFunction();
      }
    }
  };

  if (typeof thisObj.timer != 'undefined') {
    timerHandler.removeCallback(thisObj.timer);
  }

  if (thisObj.timeHtmlObj) {
    // oldcountdown objekt
    thisObj.countdownObject = new oldcountdown(leftoverTime, 3);
    thisObj.timer = timerHandler.appendCallback(thisObj.updateCountdown);
    thisObj.updateCountdown();
  }
}

function countdownWithTickFunction(htmlObj, leftoverTime, totalTime, countdownDoneFunction, countdownTickFunction, maxDigits) {
  if (typeof htmlObj !== 'object') {
    return;
  }

  var thisObj = this; // diese elemente werden veraendert

  thisObj.timeHtmlObj = htmlObj;

  if (typeof $(htmlObj).attr("data-oldcountdown") != 'undefined') {
    timerHandler.removeCallback($(htmlObj).attr("data-oldcountdown"));
  }

  this.updateCountdown = function () {
    timestamp = thisObj.countdown.getLeftoverTime();
    timestring = thisObj.countdown.getCurrentTimestring();

    if (timestamp > 0) {
      thisObj.timeHtmlObj.innerHTML = timestring;

      if (typeof countdownTickFunction == "string" && $.isFunction(window[countdownTickFunction])) {
        window[countdownTickFunction](timestamp, totalTime);
      } else if ($.isFunction(countdownTickFunction)) {
        countdownTickFunction(timestamp, totalTime);
      }
    } else {
      timerHandler.removeCallback(thisObj.timer);
      thisObj.timeHtmlObj.innerHTML = LocalizationStrings.status.ready;

      if (typeof countdownDoneFunction == "string" && $.isFunction(window[countdownDoneFunction])) {
        window[countdownDoneFunction]();
      } else if ($.isFunction(countdownDoneFunction)) {
        countdownDoneFunction();
      }
    }
  };

  if (thisObj.timeHtmlObj) {
    // oldcountdown objekt
    thisObj.countdown = new oldcountdown(leftoverTime, maxDigits);
    thisObj.timer = timerHandler.appendCallback(thisObj.updateCountdown);
    thisObj.updateCountdown();
    $(htmlObj).attr("data-oldcountdown", thisObj.timer);
  }

  return thisObj;
}

function movementImageCountdown(htmlObj, leftoverTime, duration, isReturn, isRTL, routeLength) {
  if (typeof htmlObj !== 'object') {
    return;
  }

  var thisObj = this; // diese elemente werden veraendert

  thisObj.timeHtmlObj = htmlObj;

  this.updateCountdown = function () {
    thisObj.countdown.getCurrentTimestring();
    var timestamp = thisObj.countdown.getLeftoverTime();
    var timestring = thisObj.countdown.getCurrentTimestring();

    if (timestamp > 0) {
      percent = clampFloat(timestamp / duration, 0.0, 1.0);

      if (!isReturn) {
        pixel = Math.abs(routeLength - routeLength * percent);
      } else {
        pixel = Math.abs(routeLength * percent);
      }

      pixel = clampInt(Math.round(pixel), 0, routeLength);

      if (isRTL) {
        thisObj.timeHtmlObj.style['marginRight'] = pixel + 'px';
      } else {
        thisObj.timeHtmlObj.style['marginLeft'] = pixel + 'px';
      }
    }
  };

  if (thisObj.timeHtmlObj) {
    // oldcountdown objekt
    thisObj.countdown = new oldcountdown(leftoverTime, 3);
    timerHandler.appendCallback(thisObj.updateCountdown);
    thisObj.updateCountdown();
  }
}
function initItemActivation(currItemUuid) {
  inventoryObj.initalizeSlider(inventoryObj.items_inventory, "js_activeItemSlider", 395, 172, ' ', true, ' ', true, true);

  if (typeof currItemUuid == 'undefined' || currItemUuid.length == 0 || currItemUuid == 1) {
    // we can use this selector, because all Items in the set can be activated
    var $firstItem = $('.item_img_box .detail_button').filter(':first'); // there can only be no items if we're on a moon:

    if ($firstItem.length === 0) {
      $('#noItems').show();
      $('#itemDetailBox').hide();
      return;
    } else {
      $.bbq.pushState({
        'item': $firstItem.attr('ref')
      });
    }
  } else {
    $.bbq.pushState({
      'item': currItemUuid
    });
    $(window).trigger('hashchange');
  } // show cooldown for all active items:


  $('#activeBuffDetails .js_is_active').each(function () {
    $durationEl = $(this).parent().siblings('.js_duration');
    $pusherEl = $(this).parent().siblings('.pusher');
    startCooldown($durationEl, $pusherEl, 75);
  });
  $(document).undelegate('#activeBuffDetails .detail_button', 'click.updateItemDetails').delegate('#activeBuffDetails .detail_button', 'click.updateItemDetails', function () {
    if ($(this).hasClass('active')) {
      return;
    }

    $('#activeBuffDetails .detail_button').removeClass('active');
    $(this).addClass('active');
    $.bbq.pushState({
      'item': $(this).attr('ref')
    });
  }).undelegate('#activeBuffDetails .build-it', 'click.activateItem').delegate('#activeBuffDetails .build-it', 'click.activateItem', function () {
    activateItem($(this).attr('ref'));
  }).undelegate('#activeBuffDetails .buyAndActivate.dm.build-it_disabled', 'click.activateItem').delegate('#activeBuffDetails .buyAndActivate.dm.build-it_disabled', 'click.activateItem', function () {
    if (vacation) {
      return;
    }

    var uuid = $(this).attr('ref');

    if ($("#js_activeItemSlider>li a[ref='" + uuid + "']").length == 0) {
      return;
    }

    errorBoxDecision(LocalizationStrings.error, translation.buyDMDecision, LocalizationStrings.yes, LocalizationStrings.no, function () {
      window.location.href = $("#darkmatter_box a").attr("href");
    });
  }).undelegate('#activeBuffDetails .close_detail', 'click.changeHash').delegate('#activeBuffDetails .close_detail', 'click.changeHash', function () {
    $.bbq.pushState({
      'item': ''
    });
  });
}

function initBuffBar() {
  let slider = $('.sliderWrapper .active_items');
  slider.anythingSlider({
    buildNavigation: false,

    /* keine navigation zu einzelnen seiten */
    buildStartStop: false,

    /* keine start oder stop buttons */
    infiniteSlides: false,

    /* round robin abschalten */
    stopAtEnd: true
    /* zurueckspulen verhindern */

  });
  slider.removeClass('hidden');
  $(window).unbind("hashchange.openBuffBar").bind("hashchange.openBuffBar", function (hash) {
    var url = $.deparam.fragment(hash.fragment);

    if (typeof url['item'] != 'undefined') {
      var $activateItem = $('#buffBar .activate_item');
      $("#buffBar a").removeClass('active');
      var itemUuid = url['item'];

      if (itemUuid != '') {
        if ($("#activeBuffDetails:visible").length) {
          if (typeof inventoryObj.items_inventory[itemUuid] == 'undefined') {
            var $firstItem = $('#activeBuffDetails .detail_button').filter(':first');
            $.bbq.pushState({
              'item': $firstItem.attr('ref')
            });
            return;
          }

          $("#buffBar a[ref='" + url['item'] + "']").addClass('active');
          $activateItem.addClass('active');
          $('#noItems').hide();
          $('#itemDetailBox').show();
          updateItemDetails(itemUuid);
        } else {
          $("#buffBar a[ref='" + url['item'] + "']").addClass('active');
          $activateItem.addClass('active');
          gfSlider.slideIn(getElementByIdWithCache("detail"), itemUuid);
        }
      } else {
        if ($('#activeBuffDetails .detail_button').filter(':first').length === 0) {
          $('#noItems').show();
          $('#itemDetailBox').hide();
        }

        $("#activeBuffDetails .close_details").click();
        $activateItem.removeClass('active');
      }
    }
  });
  $(document).undelegate('#buffBar a', 'click.openDetails').delegate('#buffBar a', 'click.openDetails', function () {
    if ($(this).hasClass('active')) {
      $.bbq.pushState({
        'item': ''
      });
    } else {
      $.bbq.pushState({
        'item': $(this).attr('ref')
      });
    }
  });
  $('#buffBar').unbind('click.openDetails').bind('click.openDetails', function (event) {
    if (!$(event.target).is('#buffBar .activate_item') && !$(event.target).is('.arrow a')) {
      $('#buffBar .activate_item').click();
    }
  });
  $('#buffBar .active_items div:not(.activate_item)').each(function () {
    $durationEl = $(this).find('.js_duration');
    $pusherEl = $(this).find('.pusher');
    startCooldown($durationEl, $pusherEl, 32);
  });
  $(window).trigger('hashchange');
}

function getItem(uuid) {
  if (typeof inventoryObj.items_inventory[uuid] != 'undefined') {
    return inventoryObj.items_inventory[uuid];
  }

  return null;
}

function updateItemDetails(uuid) {
  var item = getItem(uuid);
  $('#activeBuffDetails .detail_button').removeClass('active');
  $('#activeBuffDetails .detail_button[ref="' + uuid + '"]').addClass('active');
  $('#activeBuffDetails .js_itemName').html(item.name);
  $('#activeBuffDetails .js_itemEffect').html(item.effect);
  $('#activeBuffDetails .js_itemAmount').html(item.amount);

  if (item.firstStatus) {
    $('#activeBuffDetails .js_itemDurationStatus').html(translation.durationType[item.firstStatus]);
  } else {
    $('#activeBuffDetails .js_itemDurationStatus').html(translation.durationType.effecting);
  }

  if (item.duration) {
    if (item.durationExtension) {
      $('#activeBuffDetails .js_itemDuration').html(formatTimeWrapper(item.duration, 2, true, " ", false, "") + item.durationExtension);
    } else {
      $('#activeBuffDetails .js_itemDuration').html(formatTimeWrapper(item.duration, 2, true, " ", false, ""));
    }
  } else if (item.duration === null) {
    if (item.moonOnlyItem) {
      $('#activeBuffDetails .js_itemDuration').html(translation.permanentMoon);
    } else {
      $('#activeBuffDetails .js_itemDuration').html(translation.permanent);
    }
  } else {
    $('#activeBuffDetails .js_itemDuration').html(translation.now);
  }

  if (item.timeLeft) {
    $('#activeBuffDetails .js_itemTimeLeftTxt').show();
    $('#activeBuffDetails .js_itemTimeLeft').html(formatTimeWrapper(item.timeLeft, 2, true, " ", false, ""));
  } else {
    $('#activeBuffDetails .js_itemTimeLeftTxt').hide();
  }

  var $activateBtn = $('#activationButton');
  $activateBtn.attr('ref', uuid);
  $activateBtn.removeClass('buyAndActivate activateItem build-it_disabled build-it dm bp').addClass(item.currency);

  if (item.amount > 0) {
    $activateBtn.addClass('activateItem').html('<span>' + (item.timeLeft > 0 && item.extendable ? translation.extend : translation.activate) + '</span>').addClass(item.canBeActivated ? 'build-it' : 'build-it_disabled');
  } else {
    var buyString = item.timeLeft > 0 && item.extendable ? translation.buyAndExtend : translation.buyAndActivate;
    buyString = buyString.replace(/%price%/, tsdpkt(item.costs));
    buyString = buyString.replace(/%currency%/, translation.currencies[item.currency]);
    $activateBtn.addClass('buyAndActivate').html('<span>' + buyString + '</span>').addClass(item.canBeBoughtAndActivated && item.hasEnoughCurrency ? 'build-it' : 'build-it_disabled');
  }
}

let startedActivation = false;

function noHandlerItemActivation() {
  startedActivation = false;
}

function activateItem(uuid) {
  if (startedActivation) {
    return;
  }

  startedActivation = true;
  var dataObject = {
    _token: token,
    itemUuid: uuid,
    referrerPage: $.deparam.querystring().page
  };
  var item = getItem(uuid);
  let action = 'buyAndActivate';

  if (item.amount > 0) {
    action = 'activate';
  }

  function updateItemAjax() {
    $.ajax({
      cache: false,
      url: inventoryObj.inventoryUrl + `&itemUuid=${uuid}&action=${action}`,
      data: dataObject,
      type: "GET",
      dataType: "json",
      success: function (data, textStatus, jqXHR) {
        token = data.newAjaxToken;

        if (data.status != 'success') {
          fadeBox(data.message, true);
          return;
        }

        if (data.reload) {
          location.href = getRedirectLink();
          return;
        }

        fadeBox(data.message, false);

        if (data.buff !== false) {
          // animate buff activation
          var item = getItem(data.buff);
          var isNew = true;
          var $activeItems = $('.active_items');
          var activeItemsSlider = $activeItems.data('AnythingSlider');
          var $buffElement;
          $activeItems.find('li a').removeClass('active');
          $activeItems.find('li a.activate_item').addClass('active'); // Prolong existing buff

          $activeItems.find('div[data-id=' + data.buffId + ']').each(function () {
            $(this).hide().show('pulsate').find('a').addClass('active');
            isNew = false;
            $buffElement = $(this);
          }); // Add a new buff

          if (isNew == true) {
            var $newItem = $('<div data-uuid="' + data.buff + '" data-id="' + data.buffId + '">' + '<div class="js_duration" style="display: none;"></div>' + '<a href="javascript:void(0);" ref="' + data.buff + '" class="detail_button slideIn active_item active r_' + data.item.rarity + ' border3px tooltipHTML" title=\'' + data.tooltip + '\'>' + '<div class="pusher" style="height: 0%; "></div>' + '<img src="/cdn/img/item-images/' + data.item.image + '-small.png" alt=""/>' + '</a>' + '</div>');
            var numberOfVisibleItemsInARow = 14; // gleicher Name in PHP
            // Store the number of the currently viewed page
            // In case the new item is appended to the page we already see, do not animate the slider
            // when switching to the new last page after repagination

            var currentSliderPage = activeItemsSlider.currentPage;
            var sliderAnimationTime = activeItemsSlider.options.animationTime; // If the new item leads to removal of existing buffs, handle that first

            if (data.upgraded) {
              $activeItems.find('div[data-id=' + data.upgraded + ']').remove();
            } // Add new item


            var numberOfBuffsInLastPage = $activeItems.children().last().children().length;

            if (numberOfBuffsInLastPage < numberOfVisibleItemsInARow) {
              // Item can be appended to existing last page
              $newItem.hide().appendTo($activeItems.children().last()).show('pulsate');

              if (currentSliderPage == activeItemsSlider.pages) {
                activeItemsSlider.options.animationTime = 0;
              }

              activeItemsSlider.gotoPage(activeItemsSlider.pages);

              if (currentSliderPage == activeItemsSlider.pages) {
                activeItemsSlider.options.animationTime = sliderAnimationTime;
              }
            } else {
              // Item does not fit into last page, so create new page
              $newItem = $newItem.hide().wrap('<li/>');
              $newItem.parent().appendTo($activeItems).children().last();
              activeItemsSlider.updateSlider();

              if (currentSliderPage == activeItemsSlider.pages) {
                activeItemsSlider.options.animationTime = 0;
              }

              activeItemsSlider.gotoPage(activeItemsSlider.pages);

              if (currentSliderPage == activeItemsSlider.pages) {
                activeItemsSlider.options.animationTime = sliderAnimationTime;
              }

              $newItem.show('pulsate');
            }

            $buffElement = $newItem;
          } else {
            var $oldItem = $('<div data-uuid="' + item.ref + '" data-id="' + data.buffId + '">' + '<div class="js_duration" style="display: none;"></div>' + '<a href="javascript:void(0);" ref="' + item.ref + '" class="detail_button slideIn active_item active r_' + data.item.rarity + ' border3px tooltipHTML" title="' + data.item.toolTip + '">' + '<div class="pusher" style="height: 0%; "></div>' + '<img src="/cdn/img/item-images/' + item.image + '-small.png" alt=""/>' + '</a>' + '</div>');
            var upgradedUuid = item.ref;
            $activeItems.find('div[data-uuid=' + upgradedUuid + ']').remove();
            $oldItem.hide().appendTo($activeItems.children().last()).show('pulsate');
            $buffElement = $oldItem;
          }

          var $pusherElement = $buffElement.find('.pusher');
          var $durationElement = $buffElement.find('.js_duration');
          $durationElement.attr('data-total-duration', data.duration).text(data.item.timeLeft);
          startCooldown($durationElement, $pusherElement, 32); // renew item buff box

          getAjaxResourcebox();
          $.ajax({
            type: "POST",
            url: detailUrl,
            data: {
              type: uuid
            },
            beforeSend: function () {
              $('#detailWrapper .detail_screen').html('<div id="techDetailLoading"></div>');
            },
            success: function (data) {
              $('#detailWrapper .detail_screen').html(data);
            }
          });
        }

        startedActivation = false;
      },
      error: function (data) {
        fadeBox("Error!", true);
        startedActivation = false;
      }
    });
  }

  if (item.isAnUpgrade) {
    errorBoxDecision(LocalizationStrings.activateItem.upgradeItemQuestionHeader, LocalizationStrings.activateItem.upgradeItemQuestion, LocalizationStrings.yes, LocalizationStrings.no, updateItemAjax, noHandlerItemActivation);
  } // character class items need extra confirmation box
  else if (item.isCharacterClassItem) {
    if (item.amount > 0) {
      errorBoxDecision(LocalizationStrings.notice, LocalizationStrings.characterClassItem.activateItemQuestion.replace('#characterClassName#', item.name), LocalizationStrings.yes, LocalizationStrings.no, updateItemAjax, noHandlerItemActivation);
    } else {
      errorBoxDecision(LocalizationStrings.notice, LocalizationStrings.characterClassItem.buyAndActivateItemQuestion.replace('#characterClassName#', item.name).replace('#darkmatter#', tsdpkt(item.costs)), LocalizationStrings.yes, LocalizationStrings.no, updateItemAjax, noHandlerItemActivation);
    }
  } // same as character class items
  else if (item.isAllianceClassItem) {
    if (item.amount > 0) {
      fetchDataAboutCurrentAllianceClass(item.name, updateItemAjax, 'activateItemQuestion', null);
    } else {
      fetchDataAboutCurrentAllianceClass(item.name, updateItemAjax, 'buyAndActivateItemQuestion', item.costs);
    }
  } else {
    updateItemAjax();
  }
}

function initEmpireEquipment() {
  $(".overview_equipment .item_img_box .hidden").each(function () {
    startCooldown($(this), $(this).parent().parent().find('.pusher'), 32);
  });
}

function startCooldown($durationEl, $pusherEl, maxHeight) {
  if ($.trim($durationEl.text()).match(/^\d+$/)) {
    var countdown = new countdownWithTickFunction($durationEl[0], parseInt($.trim($durationEl.text())), parseInt($durationEl.attr("data-total-duration")), function () {
      location.href = getRedirectLink(); // reload, damit das item verschwindet
    }, function (duration, totalDuration) {
      var faktor = 1 - duration / totalDuration;
      var realHeight = Math.floor(maxHeight * faktor);
      $pusherEl.css("height", realHeight + "px");
    });
  }
}

let activatingItem = false;

function fetchDataAboutCurrentAllianceClass(newClassName, upgradeItemAjax, questionType, price) {
  if (!activatingItem) {
    activatingItem = true;
    $.ajax({
      url: inventoryObj.ingameUrl,
      type: "GET",
      data: {
        component: 'allianceclassselection',
        action: 'fetchDataAboutCurrentAllianceClass',
        ajax: 1,
        asJson: 1
      },
      dataType: "json",
      error: function (error) {
        promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price);
      },
      success: function (data) {
        promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price, data);
      }
    });
  }
}

function promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price, response) {
  activatingItem = false;

  if (response.userDoesNotHaveAlliance) {
    return 0;
  }

  let localizationString = LocalizationStrings.allianceClassItem[questionType];
  localizationString = localizationString.replace('#allianceClassName#', newClassName);

  if (questionType === 'buyAndActivateItemQuestion') {
    localizationString = localizationString.replace('#darkmatter#', tsdpkt(price));
  }

  if (response && response.currentAllianceClass && response.dateOfLastAllianceClassChange) {
    localizationString += LocalizationStrings.allianceClassItem.appendCurrentClassQuestion;
    localizationString = localizationString.replace('#currentAllianceClassName#', response.currentAllianceClass);
    localizationString = localizationString.replace('#lastAllianceClassChange#', response.dateOfLastAllianceClassChange);
  }

  errorBoxDecision(LocalizationStrings.notice, localizationString, LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
}
function errorBoxAsArray(data) {
  if (data["type"] == "notify") {
    notifyBoxAsArray(data);
  } else if (data["type"] == "decision") {
    decisionBoxAsArray(data);
  } else if (data["type"] == "fadeBox") {
    fadeBox(data["text"], data["failed"]);
  }
}

function notifyBoxAsArray(data) {
  errorBoxNotify(data["title"], data["text"], data["buttonOk"], String(data["okFunction"]), data["removeOpen"], data["modal"]);
}

function fadeBox(message, failed, callback, duration) {
  if (failed) {
    $("#fadeBoxStyle").attr("class", "failed");
  } else {
    $("#fadeBoxStyle").attr("class", "success");
  }

  $("#fadeBoxContent").html(message);
  $("#fadeBox").stop(false, true).show().fadeOut(duration || 10000, callback);
}

let NotificationTimers = {};

function showNotification(message, type = 'info', headline = null) {
  let boxType = {
    error: {
      sign: '&#x2716;',
      cssClass: 'notification-error',
      headline: headline ?? jsloca.LOCA_NOTIFY_ERROR
    },
    info: {
      sign: '&#x2139;',
      cssClass: 'notification-info',
      headline: headline ?? jsloca.LOCA_NOTIFY_INFO
    },
    success: {
      sign: '&#x2714;',
      cssClass: 'notification-success',
      headline: headline ?? jsloca.LOCA_NOTIFY_SUCCESS
    },
    warning: {
      sign: '&#x2755;',
      cssClass: 'notification-warning',
      headline: headline ?? jsloca.LOCA_NOTIFY_WARNING
    }
  };
  let boxData = boxType[type] ?? boxType['info'];
  let notifyBoxId = Date.now();
  let notifyBox = `<notification id="${notifyBoxId}" class="${boxData.cssClass}">
            <notification-content>
                <notification-sign>${boxData.sign}</notification-sign>
                <notification-message>
                    <span class="headline">${boxData.headline}</span>
                    <span>${message}</span>
                </notification-message>
            </notification-content>
            <notification-close onclick="removeNotification(${notifyBoxId})">&#x2717;</notification-close>
            <notification-progress class=""></notification-progress>
        </notification>`;
  $("notification-container").append(notifyBox);
  let timer1 = setTimeout(() => {
    $("notification-container notification#" + notifyBoxId).addClass('active');
    $("notification-container notification#" + notifyBoxId + " notification-progress").addClass('active');
  }, 10);
  let timer2 = setTimeout(() => {
    $("notification-container notification#" + notifyBoxId).removeClass('active');
  }, 5010);
  let timer3 = setTimeout(() => {
    removeNotification(notifyBoxId);
  }, 5300);
  NotificationTimers[notifyBoxId] = {
    timer1: timer1,
    timer2: timer2,
    timer3: timer3
  };
}

function removeNotification(notifyBoxId) {
  $("notification-container notification#" + notifyBoxId).remove();
  clearTimeout(NotificationTimers[notifyBoxId].timer1);
  clearTimeout(NotificationTimers[notifyBoxId].timer2);
  clearTimeout(NotificationTimers[notifyBoxId].timer3);
  delete NotificationTimers[notifyBoxId];
}

function decisionBoxAsArray(data) {
  errorBoxDecision(data["title"], data["text"], data["buttonOk"], data["buttonNOk"], String(data["okFunction"]), String(data["nokFunction"]), data["removeOpen"]);
}

function errorBoxDecision(head, content, yes, no, yesHandler, noHandler, useHashCharacter) {
  var useHash = getIEVersion() <= 9 && (useHashCharacter || false);
  var errorBox = $("#errorBoxDecision");
  errorBox.find("#errorBoxDecisionHead").html(head);
  errorBox.find("#errorBoxDecisionContent").html(content);

  var yesFunction = function (e) {
    e.stopPropagation();

    if (typeof errorBox.data('uiDialog') != 'undefined') {
      errorBox.dialog('destroy');
    }

    if (typeof yesHandler == 'function') {
      yesHandler();
    }

    if (yesHandler == 'submit_planet_delete_form') {
      $('#planetMaintenanceDelete').submit();
    }
  };

  var noFunction = function (e) {
    e.stopPropagation();

    if (typeof errorBox.data('uiDialog') != 'undefined') {
      errorBox.dialog('destroy');
    }

    if (noHandler == 'reload') {
      location.reload();
    }

    if (typeof noHandler == 'function') {
      noHandler();
    }
  }; // workaround for firefox instantly firing yes on click event when the error box was opened via keyboard enter event:
  // setting a timeout with the event bindings


  errorBox.find(".yes, .no").unbind('click');
  errorBox.unbind('keydown.yesHandler');
  setTimeout(function () {
    var $yesButton = errorBox.find('.yes');
    var $noButton = errorBox.find('.no');
    $yesButton.unbind('click').bind('click', yesFunction).focus().find("#errorBoxDecisionYes").html(yes);
    $noButton.unbind('click').bind('click', noFunction).find("#errorBoxDecisionNo").html(no);

    if (useHash) {
      $yesButton.attr('href', '#');
      $noButton.attr('href', '#');
    } else {
      $yesButton.attr('href', 'javascript:void(0);');
      $noButton.attr('href', 'javascript:void(0);');
    }

    errorBox.bind('keydown.yesHandler', function (e) {
      if (e.which == KeyEvent.DOM_VK_RETURN) {
        errorBox.find('.yes').trigger('click');
      }
    });
  }, 100);
  Tipped.hideAll();
  errorBox.dialog({
    resizable: false,
    modal: true,
    title: head,
    close: noFunction,
    width: 400,
    dialogClass: 'errorBox'
  });
}

function errorBoxNotify(head, content, ok, okHandler, useHashCharacter) {
  var useHash = getIEVersion() <= 9 && (useHashCharacter || false);
  var errorBox = $("#errorBoxNotify");
  errorBox.find("#errorBoxNotifyHead").html(head);
  errorBox.find("#errorBoxNotifyContent").html(content);

  var okFunction = function (e) {
    e.stopPropagation();
    errorBox.dialog('destroy');

    if (typeof okHandler == 'function') {
      okHandler();
    } else if (typeof window[okHandler] == "function") {
      window[okHandler]();
    }
  };

  var $okButton = errorBox.find('.ok');
  $okButton.unbind('click').bind('click', okFunction).find("#errorBoxNotifyOk").html(ok);

  if (useHash) {
    $okButton.attr('href', '#');
  } else {
    $okButton.attr('href', 'javascript:void(0);');
  }

  Tipped.hideAll();
  errorBox.dialog({
    resizable: false,
    modal: true,
    title: head,
    close: okFunction,
    width: 400,
    dialogClass: 'errorBox'
  });
}
/*
    Document   : eventBirthday
    Created on : 31.08.2012, 12:16:13
    Author     : stefanie.knoth
    Description:
        This file contains the javascript that is neccessary for the Birthday
        Event
*/
function eventBDayInitGalaxy() {
  if (isMobile) {
    $('.js_bday_details').hide();
    $('.bdaySlotBox .name').click(function (e) {
      $('.row').children().each(function () {
        if ($(this).html().trim()) $(this).removeClass('active');
      });
      $('.bdaySlotBox .name').removeClass('active');
      $('.js_detailRow').hide();
      $(this).toggleClass('active');

      if ($(e.target).attr('class').indexOf('planet') !== -1) {
        $('.js_detailRowPlanet17').toggle();
      } else if ($(e.target).attr('class').indexOf('debris') !== -1) {
        $('.js_detailRowDebris17').toggle();
      }
    });
  }
}

function eventBDayInit() {
  var $event_box = $('.event_box');
  $('#eventBDayWrapper').click(function (e) {
    if ($(e.target).attr('id') === 'BDayContent' || $(e.target).attr('id') === 'BDayEventClose' || $(e.target).closest('#BDayHeader').length > 0) {
      $event_box.hide();
      $('.bday_box').removeClass('active');
    }

    e.stopPropagation();
  });
  $('.bday_box').click(function (e) {
    $('.bday_box').removeClass('active');
    var boxId = $(e.target).closest('.bday_box').attr('id').replace('box', '');
    $event_box.removeClass().addClass('event_box ' + eventBoxData[boxId].eventTypeClass);

    if (eventBoxData[boxId] !== undefined) {
      $event_box.attr('id', 'eventBox' + boxId).show();
      $('#box' + boxId).addClass('active');

      if (eventBoxData[boxId].eventTypeClass !== 'future') {
        $('#eventBox' + boxId + ' #BDayEventDate').html(eventBoxData[boxId].date + ': ');
      } else {
        $('#eventBox' + boxId + ' #BDayEventDate').html('');
      }

      $('#eventBox' + boxId + ' #BDayEventTitle').html(eventBoxData[boxId].title);
      $('#eventBox' + boxId + ' #BDayofficerImg').attr('src', eventBoxData[boxId].eventOfficerImgSrc);

      if (eventBoxData[boxId].eventTypeClass !== 'future' || eventBoxData[boxId].txtChronic !== undefined) {
        $('#eventBox' + boxId + ' #BDayEventTxtChronic').html(eventBoxData[boxId].txtChronic);
        $('#eventBox' + boxId + ' #BDayChronic').show();
      } else {
        $('#eventBox' + boxId + ' #BDayChronic').hide();
      }

      if (eventBoxData[boxId].eventImgSrc === undefined && eventBoxData[boxId].eventTypeClass === 'future') {
        $('#eventBox' + boxId + ' #BDayEventImg').attr('src', '/img/icons/d995359d038c9a0c21aed16b3cc162.png');
      } else {
        $('#eventBox' + boxId + ' #BDayEventImg').attr('src', eventBoxData[boxId].eventImgSrc);
      }

      if (eventBoxData[boxId].eventTxtDesc === undefined) {
        $('#eventBox' + boxId + ' #BDayEventTxtDesc').html('');
      } else {
        $('#eventBox' + boxId + ' #BDayEventTxtDesc').html(eventBoxData[boxId].eventTxtDesc);
      }

      $('#eventBox' + boxId + ' #BDayEventPastTxt').hide();

      if (eventBoxData[boxId].eventTypeClass === 'past') {
        $('#eventBox' + boxId + ' #BDayEventPastTxt').html(eventPastTxt).show();
      }

      $('#eventBox' + boxId + ' #BDayEventBtnCTA').hide();

      if (eventBoxData[boxId].eventTypeClass !== ('past' || 'future') && eventBoxData[boxId].btnCTA !== undefined) {
        $('#eventBox' + boxId + ' #BDayEventBtnCTA').html(eventBoxData[boxId].btnCTA).attr('href', eventBoxData[boxId].btnCTALink).show();
      }
    }
  });
}

function initBDayEventHints() {
  $(document).undelegate('.event_build_faster, .event_active_hint', 'click').delegate('.event_build_faster, .event_active_hint', 'click', function (e) {
    e.stopPropagation();

    if ($(this).parent().attr('id') === 'expeditionbutton') {
      doExpedition();
    } else {
      $(this).siblings('.detail_button').click();
    }
  });
}
function toggleEvents(doNotClose) {
  if ($("#eventboxContent").is(":hidden")) {
    $("#eventboxContent").slideDown('fast');
    $('#js_eventDetailsClosed').hide();
    $('#js_eventDetailsOpen').show();

    if (typeof toggleEvents.loaded == 'undefined' || !toggleEvents.loaded) {
      refreshFleetEvents();
    }
  } else {
    if (doNotClose) {
      return;
    }

    $("#eventboxContent").slideUp('fast');
    $('#js_eventDetailsClosed').show();
    $('#js_eventDetailsOpen').hide();
  }

  $("#contentWrapper select").ogameDropDown('hide');
}

function refreshFleetEvents(force) {
  if (typeof eventlistLink === 'undefined') {
    return;
  }

  if (!$("#eventboxContent").is(":hidden") || force === true) {
    $("#eventboxContent").html('<img height="16" width="16" src="//gf3.geo.gfsrv.net/cdne3/3f9884806436537bdec305aa26fc60.gif" />');
    $.ajax({
      url: eventlistLink,
      success: function (response) {
        $("#eventboxContent").html(response);
        toggleEvents.loaded = true;
      }
    });
  }
}

function toggleDetails() {
  var relTr = $(".partnerInfo." + $(this).attr("rel"));

  if ($(relTr).is(":hidden")) {
    $(relTr).show();
    $(this).parents("tr").addClass("detailsOpened").removeClass("detailsClosed");
  } else {
    $(relTr).hide();
    $(this).parents("tr").addClass("detailsClosed").removeClass("detailsOpened");
  }
}
function Exodus(cfg) {
  this.loca = cfg.loca;
  this.initServerSelect(cfg);
}

Exodus.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide(); //@todo handle error
};

Exodus.prototype.onAjaxError = function () {};

Exodus.prototype.updateToken = function (updatetoken) {
  this.token = updatetoken;
  token = updatetoken;
};

Exodus.prototype.initCommon = function (cfg) {
  this.serverWrapper = $('.exodus #serverNumbers');
  this.loadingIndicator = this.serverWrapper.ogameLoadingIndicator();
  this.serverLanguage = $('.exodus #serverLanguage');
  this.serverNumber = $('.exodus #serverNumber');
  this.serverNumbers = null;
  this.token = cfg.token;
  this.selectedLanguage = cfg.sourceLanguage;
  this.serverSelection = $('#serverSelection');
  this.table = this.serverLanguage.closest('.og-table');
  this.availableLanguages = cfg.availableLanguages;
  this.urlServerIds = cfg.urlServerIds || null;
  this.urlIsReady = cfg.urlIsReady || null;
  this.urlSubmitExodus = cfg.urlSubmitExodus || null;
  this.isReadyForExodus = cfg.isReadyForExodus || false;
  this.serverAmount = 0;
};

Exodus.prototype.initServerSelect = function (cfg) {
  this.initCommon(cfg);
  this.dropDownLanguageSelect = $('.exodus #serverLanguage');
  this.dropDownServerSelect = $('.exodus #serverNumber');
  this.exodusSubmitButton = $('.exodus #submitExodus');
  this.exodusSubmitButton.on('click', this.onClickExecute.bind(this));
  this.dropDownLanguageSelect.on('change', this.onChangeServerLanguage.bind(this));
  this.dropDownServerSelect.on('change', this.onChangeServerNumber.bind(this));
  this.refreshLanguage();
  this.fetchServerNumbers();
};

Exodus.prototype.onChangeServerLanguage = function (e) {
  this.selectedLanguage = this.dropDownLanguageSelect.val();
  this.refreshLanguage();
  this.fetchServerNumbers();
};

Exodus.prototype.onChangeServerNumber = function (e) {
  this.selectedServer = this.dropDownServerSelect.val();
  this.refreshServer();
};

Exodus.prototype.onClickExecute = function (e) {
  e.stopPropagation();
  e.preventDefault();
  let serverName = this.dropDownServerSelect.find('option[value="' + this.selectedServer + '"]').html();
  this.loadingIndicator.show();
  let that = this;
  errorBoxDecision(this.loca.LOCA_EXODUS_TRANSFER_QUESTION_TITLE, this.loca.LOCA_EXODUS_TRANSFER_QUESTION.replace('#uniname#', serverName), this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    let data = {
      serverNumber: parseInt(that.selectedServer),
      serverLanguage: that.selectedLanguage,
      _token: that.token
    };
    $.post(that.urlSubmitExodus, data, that.handleSubmitExodusResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Exodus.prototype.fetchServerNumbers = function () {
  this.loadingIndicator.show();
  let data = {
    language: this.selectedLanguage
  };
  $.getJSON(this.urlServerIds, data, this.onFetchServerNumbers.bind(this)).done(this.onAjaxDone.bind(this));
};

Exodus.prototype.checkIsReady = function () {
  let data = {};

  if (this.serverAmount > 0) {
    $.getJSON(this.urlIsReady, data, this.onCheckIsReady.bind(this)).done(this.onAjaxDone.bind(this));
  }
};

Exodus.prototype.setLanguage = function (language) {
  let languageOld = this.selectedLanguage;
  this.selectedLanguage = language;

  if (this.selectedLanguage !== languageOld) {
    this.resetLanguage();
    this.refreshLanguage();
    this.fetchServerNumbers();
    this.resetServer();
    this.checkIsReady();
  }
};

Exodus.prototype.setServer = function (number) {
  let serverOld = this.selectedServer;
  this.selectedServer = number;

  if (this.selectedServer !== serverOld) {
    this.resetServer();
    this.refreshServer();
    this.checkIsReady();
  }
};

Exodus.prototype.refreshLanguage = function () {
  this.dropDownLanguageSelect.find('option').removeAttr('selected');

  if (this.selectedLanguage) {
    this.dropDownLanguageSelect.find('option[value="' + this.selectedLanguage + '"]').attr('selected', 'selected');
    this.dropDownLanguageSelect.val(this.selectedLanguage);
  }
};

Exodus.prototype.refreshServer = function () {
  this.dropDownServerSelect.find('option').removeAttr('selected');

  if (this.selectedServer) {
    this.dropDownServerSelect.val(this.selectedServer);
    this.dropDownServerSelect.find('option[value="' + this.selectedServer + '"]').attr('selected', 'selected');
  }
};

Exodus.prototype.resetLanguage = function () {
  this.setLanguage(this.getFirstLanguage());
};

Exodus.prototype.resetServer = function () {
  this.setServer(this.selectedServer);
};

Exodus.prototype.getFirstLanguage = function () {
  return this.availableLanguages[0];
};

Exodus.prototype.onCheckIsReady = function (data) {
  this.isReadyForExodus = data.isReady;

  if (this.isReadyForExodus && this.selectedServer !== 0) {
    this.exodusSubmitButton.removeClass('disabled');
  } else {
    this.exodusSubmitButton.addClass('disabled');
  }
};

Exodus.prototype.handleSubmitExodusResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';

  if (status === 'success') {
    fadeBox(data.message, false);
    window.location = data.redirectUrl;
  } else {
    this.updateToken(data.newAjaxToken);
    this.displayErrors(data);
  }
};

Exodus.prototype.displayErrors = function (data) {
  // only display the first error
  let error = data.errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
    this.updateToken(data.newAjaxToken);
  }
};

Exodus.prototype.onFetchServerNumbers = function (data) {
  if (data.serverNumbers.length === 0 || this.isReadyForExodus === false) {
    if (this.isReadyForExodus === false) {
      this.serverSelection.html('<span id="noServer">' + this.loca.LOCA_EXODUS_RESTRICTION_NOT_FULFILLED + '</span>');
    }

    if (data.serverNumbers.length === 0) {
      this.serverSelection.html('<span id="noServer">' + this.loca.LOCA_EXODUS_NO_SERVER_AVAILABLE + '</span>');
    }

    this.exodusSubmitButton.addClass('disabled');
    this.serverAmount = 0;
    this.selectedServer = 0;
    return;
  } else {
    this.serverSelection.html('<select id="serverNumber" type="text" class="og-input" name="serverNumber"></select>');
    this.exodusSubmitButton.removeClass('disabled');
    this.dropDownServerSelect = $('.exodus #serverNumber');
    this.dropDownServerSelect.on('change', this.onChangeServerNumber.bind(this));
    this.serverAmount = data.serverNumbers.length;
  }

  this.selectedServer = data.serverNumbers[0].number;
  this.serverNumbers = data.serverNumbers;
  var select = this.dropDownServerSelect;

  if (select.prop) {
    var options = select.prop('options');
  } else {
    var options = select.attr('options');
  }

  $('option', select).remove();
  let htmlOptions = '';
  $.each(data.serverNumbers, function (key, server) {
    options[options.length] = new Option(server.name, server.number);
    htmlOptions += '<option value="' + server.number + '">' + server.name + '</option>';
  });
  this.dropDownServerSelect.ogameDropDown('destroy');
  this.dropDownServerSelect.html('');
  this.dropDownServerSelect.html(htmlOptions).ogameDropDown();
};
/**
 * Object.assign polyfill
 * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
 */
if (typeof Object.assign !== "function") {
  Object.assign = function (target) {
    if (target == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }

    target = Object(target);

    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      if (source != null) {
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }

    return target;
  };
}
/**
 * Number.isInteger polyfill
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill
 */


if (typeof Number.isInteger !== "function") {
  //noinspection JSPrimitiveTypeWrapperUsage
  Number.isInteger = function (number) {
    return typeof number === "number" && isFinite(number) && number > -9007199254740992 && number < 9007199254740992 && Math.floor(number) === number;
  };
}

var Formatter = {
  // #################################################################################################################
  // ##  DATE, TIME & PERIOD  ########################################################################################
  // #################################################################################################################

  /**
   * Human-readable time units
   */
  "timeUnits": {
    "second": 1,
    "minute": 60,
    "hour": 60 * 60,
    "day": 24 * 60 * 60,
    "week": 7 * 24 * 60 * 60
  },

  /**
   * Format seconds to human readable time (weeks, days, hours, minutes, seconds)
   *
   * @param {int} seconds
   * @param {Array} options
   * @returns {string}
   */
  "secondsToTime": function (seconds, options) {
    var defaults = {
      "segments": -1,
      "delimiter": " ",
      "units": {
        "weeks": "w",
        "days": "d",
        "hours": "h",
        "minutes": "m",
        "seconds": "s"
      },
      "now": "now"
    };
    options = Object.assign(defaults, options);

    if (!Number.isInteger(seconds)) {
      throw "Integer expected for parameter seconds";
    }

    if (seconds <= 0) {
      return options.now;
    }

    var time = {
      "weeks": Math.floor(seconds / Formatter.timeUnits.week),
      "days": Math.floor(seconds % Formatter.timeUnits.week / Formatter.timeUnits.day),
      "hours": Math.floor(seconds % Formatter.timeUnits.day / Formatter.timeUnits.hour),
      "minutes": Math.floor(seconds % Formatter.timeUnits.hour / Formatter.timeUnits.minute),
      "seconds": seconds % Formatter.timeUnits.minute
    };
    var formattedTime = [];

    for (var segment in time) {
      if (time[segment] > 0 && (options.segments == -1 || formattedTime.length < options.segments)) {
        formattedTime.push(time[segment] + options.units[segment]);
      }
    }

    return formattedTime.join(options.delimiter);
  },

  /**
   * Format seconds to period string (PDTHMS)
   *
   * @param {int} seconds
   * @returns {string}
   */
  "secondsToPeriod": function (seconds) {
    if (!Number.isInteger(seconds)) {
      throw "Integer expected for parameter seconds";
    }

    if (seconds <= 0) {
      return "PT0H0M0S";
    }

    var period = {
      "days": {
        "value": Math.floor(seconds / Formatter.timeUnits.day),
        "unit": "D"
      },
      "hours": {
        "value": Math.floor(seconds % Formatter.timeUnits.day / Formatter.timeUnits.hour),
        "unit": "H"
      },
      "minutes": {
        "value": Math.floor(seconds % Formatter.timeUnits.hour / Formatter.timeUnits.minute),
        "unit": "M"
      },
      "seconds": {
        "value": seconds % Formatter.timeUnits.minute,
        "unit": "S"
      }
    };
    var formattedPeriodDays = [],
        formattedPeriodTime = [];

    for (var segment in period) {
      if (period[segment].value > 0) {
        if (segment == "days") {
          formattedPeriodDays.push(period[segment].value + period[segment].unit);
        } else {
          formattedPeriodTime.push(period[segment].value + period[segment].unit);
        }
      }
    }

    return "P" + formattedPeriodDays.join("") + (formattedPeriodTime.length > 0 ? "T" + formattedPeriodTime.join("") : "");
  },
  // #################################################################################################################
  // ##  NUMBER ######################################################################################################
  // #################################################################################################################

  /**
   * Format number to string
   *
   * @param {number} number
   * @param {Array} options
   * @returns {string}
   */
  "numberToString": function (number, options) {
    var NUMBER_PRECISION_MINIMUM = 0;
    var NUMBER_PRECISION_MAXIMUM = 3;
    var NUMBER_TRANSFORM_ROUND = 1;
    var NUMBER_TRANSFORM_CEIL = 2;
    var NUMBER_TRANSFORM_FLOOR = 3;
    /**
     * Round fractions up or down with precision
     *
     * @param {number} number
     * @param {int} precision
     * @returns {number}
     */

    var round = function (number, precision) {
      if (typeof number !== "number") {
        throw "Numeric expected for parameter number";
      }

      if (!Number.isInteger(precision)) {
        throw "Integer expected for parameter precision";
      }

      if (precision <= 0) {
        return Math.round(number);
      }

      return Math.round(number * Math.pow(10, precision)) / Math.pow(10, precision);
    };
    /**
     * Round fractions up with precision
     *
     * @param {number} number
     * @param {int} precision
     * @returns {number}
     */


    var ceil = function (number, precision) {
      if (typeof number !== "number") {
        throw "Numeric expected for parameter number";
      }

      if (!Number.isInteger(precision)) {
        throw "Integer expected for parameter precision";
      }

      if (precision <= 0) {
        return Math.ceil(number);
      }

      return Math.ceil(number * Math.pow(10, precision)) / Math.pow(10, precision);
    };
    /**
     * Round fractions down with precision
     *
     * @param {number} number
     * @param {int} precision
     * @returns {number}
     */


    var floor = function (number, precision) {
      if (typeof number !== "number") {
        throw "Numeric expected for parameter number";
      }

      if (!Number.isInteger(precision)) {
        throw "Integer expected for parameter precision";
      }

      if (precision <= 0) {
        return Math.floor(number);
      }

      return Math.floor(number * Math.pow(10, precision)) / Math.pow(10, precision);
    };
    /**
     * Transform number using round, ceil or floor
     *
     * @param {number} number
     * @param {int} mode
     * @param {int} precision
     * @returns {number}
     */


    var transformNumber = function (number, mode, precision) {
      switch (mode) {
        case NUMBER_TRANSFORM_ROUND:
          number = round(number, precision);
          break;

        case NUMBER_TRANSFORM_CEIL:
          number = ceil(number, precision);
          break;

        case NUMBER_TRANSFORM_FLOOR:
          number = floor(number, precision);
          break;
      }

      return number;
    };

    var defaults = {
      "transform": NUMBER_TRANSFORM_ROUND,
      "precision": {
        "minimum": NUMBER_PRECISION_MINIMUM,
        "maximum": NUMBER_PRECISION_MAXIMUM
      },
      "separators": {
        "thousands": ",",
        "decimals": "."
      },
      "boundaries": {
        /*1000:           "K",*/
        1000000: "M",
        1000000000: "Bn"
      }
    };
    options = Object.assign(defaults, options);

    if (typeof number !== "number") {
      throw "Numeric expected for parameter number";
    }

    if (typeof options.precision === "undefined" || typeof options.precision.minimum === "undefined") {
      throw "Minimum precision not specified";
    }

    if (typeof options.precision === "undefined" || typeof options.precision.maximum === "undefined") {
      throw "Maximum precision not specified";
    }

    if (options.precision.minimum > options.precision.maximum) {
      throw "Minimum precision larger than maximum precision";
    }

    var boundaries = Object.keys(options.boundaries).sort(function (a, b) {
      return parseFloat(b) - parseFloat(a);
    });
    var unit = "";

    for (var i = 0; i < boundaries.length; i++) {
      var boundary = parseInt(boundaries[i]);

      if (boundary === 0) {
        continue;
      }

      if (Math.abs(number) >= boundary) {
        number /= boundary;
        unit = options.boundaries[boundaries[i]];
        break;
      }
    }

    var precision = options.precision.maximum;

    while ((number = transformNumber(number, options.transform, precision)) == transformNumber(number, options.transform, precision - 1) && precision > options.precision.minimum) {
      precision--;
    }

    number = number.toFixed(precision);
    var numberParts = number.toString().split(".");
    numberParts[0] = numberParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, options.separators.thousands);
    return numberParts.join(options.separators.decimals) + unit;
  }
};
ogame.frontendActions = {
  socket: null,
  connected: false,
  connecting: false,
  timeout: null,
  retryInterval: 5000,
  initConnection: function () {
    var that = ogame.frontendActions;

    if (that.connecting || that.connected || that.isMobile) {
      if (this.socket) {
        that.socket.disconnect();
      }
    }

    that.connecting = true;

    try {
      that.socket = io.connect(":" + nodePort + "/frontendactions", nodeParams);
      that.socket.on('connect', function () {
        clearTimeout(this.timeout); // send session for authorize... on success set it to connected else disconnect socket

        that.socket.emit("authorize", session, function (success) {
          that.connecting = false;

          if (success) {
            that.connected = true;
          } else {
            that.socket.disconnect();
          }
        });
      });
      that.socket.on("refreshFrontendData", function (data) {
        that.refreshFrontendData(data);
      });
      that.socket.on("refreshSimulationData", function (data) {
        that.refreshSimulationData(data);
      });
      that.socket.on('disconnect', function () {
        that.connected = false;
        that.connecting = false;
      });
    } catch (e) {
      that.connecting = false;
    }
  },
  initialize: function () {
    if (typeof nodeUrl === 'undefined') {
      return;
    }

    // TODO: re-enable later
    return;

    var that = ogame.frontendActions;
    loadScript(nodeUrl, that.initConnection);
  },
  retryConnection: function () {
    var that = ogame.frontendActions;
    setTimeout(function () {
      that.initConnection();
    }, 5000);
  },
  refreshFrontendData: function (wsData) {
    if (buildListActionCalled || speedingUpBuildListEntry) {
      return;
    }

    try {
      let currentUrl = window.location.href;
      let currentPageParams = new URLSearchParams(currentUrl.split('?')[1] ?? "");
      let currentComponent = currentPageParams.get("component");
      let currentIngamePage = currentPageParams.get("page");

      if (wsData.type && wsData.type === 'buildList') {
        if (currentComponent === 'empire') {
          window.location.reload();
          return;
        }

        if (wsData.spaceObjectId && wsData.spaceObjectId !== "any" && typeof currentSpaceObjectId !== "undefined" && wsData.spaceObjectId === currentSpaceObjectId || wsData.spaceObjectId === "any") {
          if (currentComponent === 'resourcesettings' && wsData.actionType && wsData.actionType === "built") {
            window.location.reload();
            return;
          }

          if (wsData.component) {
            if (wsData.component.indexOf(currentComponent) > -1 || wsData.component.indexOf(currentIngamePage) > -1) {
              window.location.reload();
              return;
            }
          }

          if (wsData.productionBox) {
            if ($(`#productionbox${wsData.productionBox}component`).length > 0) {
              reloadComponent(`productionbox${wsData.productionBox}`);
            }
          }

          if (typeof currentSpaceObjectId !== "undefined" && wsData.spaceObjectId === currentSpaceObjectId) {
            getAjaxResourcebox();
          }
        }

        reloadComponent('planetbar', currentIngamePage !== 'ingame');
      }
    } catch (e) {}
  },
  refreshSimulationData: function (wsData) {
    try {
      if (wsData.type && wsData.type === 'refreshSimInfo' && wsData.remove) {
        removeCombatSim(wsData.simId);
        loadSimDetails();
      }

      if (wsData.type && wsData.type === 'refreshSimInfo') {
        changeCombatSimState(wsData.simId, wsData.simState);
        loadSimDetails();
      }
    } catch (e) {}
  },
  initFrontendActions: function () {
    ogame.frontendActions.initialize();
  }
};

function reloadComponent(component, addFleft, callback) {
  $.ajax({
    type: "GET",
    url: `${ajaxReloadComponentURI}&component=${component}&currentComponent=${currentPage}`,
    success: function (response) {
      try {
        let parsedData = JSON.parse(response);
        $("#" + parsedData.id).replaceWith(parsedData.html);

        if (addFleft) {
          $("#" + parsedData.id).addClass('fleft');
        }

        token = parsedData.newAjaxToken;

        if (callback && typeof callback === "function") {
          callback();
        }

        $('select').ogameDropDown();
      } catch (e) {
        window.location.reload();
      }
    },
    error: function (err) {
      window.location.reload();
    }
  });
}

$(document).ready(() => {
  ogame.frontendActions.initFrontendActions();
});
function Graveyard(cfg) {
  this.loca = cfg.loca;
  this.initServerSelect(cfg);
}

Graveyard.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide(); //@todo handle error
};

Graveyard.prototype.onAjaxError = function () {};

Graveyard.prototype.updateToken = function (token) {
  this.token = token;
};

Graveyard.prototype.initCommon = function (cfg) {
  this.serverWrapper = $('.graveyard #serverNumbers');
  this.loadingIndicator = this.serverWrapper.ogameLoadingIndicator();
  this.serverLanguage = $('.graveyard #serverLanguage');
  this.serverNumber = $('.graveyard #serverNumber');
  this.serverNumbers = null;
  this.selectedLanguage = null;
  this.serverSelection = $('#serverSelection');
  this.token = cfg.token;
  this.table = this.serverLanguage.closest('.og-table');
  this.availableLanguages = cfg.availableLanguages;
  this.urlServerIds = cfg.urlServerIds || null;
  this.urlIsReady = cfg.urlIsReady || null;
  this.urlSubmitExodus = cfg.urlSubmitExodus || null;
  this.isReadyForExodus = cfg.isReadyForExodus || false;
  this.serverAmount = 0;
};

Graveyard.prototype.initServerSelect = function (cfg) {
  this.initCommon(cfg);
  this.dropDownLanguageSelect = $('.graveyard #serverLanguage');
  this.dropDownServerSelect = $('.graveyard #serverNumber');
  this.exodusSubmitButton = $('.graveyard #submitExodus');
  this.exodusSubmitButton.on('click', this.onClickExecute.bind(this));
  this.dropDownLanguageSelect.on('change', this.onChangeServerLanguage.bind(this));
  this.dropDownServerSelect.on('change', this.onChangeServerNumber.bind(this));
  this.resetLanguage();
  this.refreshLanguage();
};

Graveyard.prototype.onChangeServerLanguage = function (e) {
  this.selectedLanguage = this.dropDownLanguageSelect.val();
  this.refreshLanguage();
  this.fetchServerNumbers();
};

Graveyard.prototype.onChangeServerNumber = function (e) {
  this.selectedServer = this.dropDownServerSelect.val();
  this.refreshServer();
};

Graveyard.prototype.onClickExecute = function (e) {
  e.stopPropagation();
  e.preventDefault();
  let serverName = this.dropDownServerSelect.find('option[value="' + this.selectedServer + '"]').html();
  this.loadingIndicator.show();
  let that = this;
  errorBoxDecision(this.loca.LOCA_EXODUS_TRANSFER_QUESTION_TITLE, this.loca.LOCA_EXODUS_TRANSFER_QUESTION.replace('#uniname#', serverName), this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    let data = {
      serverNumber: parseInt(that.selectedServer),
      serverLanguage: that.selectedLanguage,
      _token: that.token
    };
    $.post(that.urlSubmitExodus, data, that.handleSubmitExodusResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Graveyard.prototype.fetchServerNumbers = function () {
  this.loadingIndicator.show();
  let data = {
    language: this.selectedLanguage
  };
  $.getJSON(this.urlServerIds, data, this.onFetchServerNumbers.bind(this)).done(this.onAjaxDone.bind(this));
};

Graveyard.prototype.checkIsReady = function () {
  let data = {};

  if (this.serverAmount > 0) {
    $.getJSON(this.urlIsReady, data, this.onCheckIsReady.bind(this)).done(this.onAjaxDone.bind(this));
  }
};

Graveyard.prototype.setLanguage = function (language) {
  let languageOld = this.selectedLanguage;
  this.selectedLanguage = language;

  if (this.selectedLanguage !== languageOld) {
    this.resetLanguage();
    this.refreshLanguage();
    this.fetchServerNumbers();
    this.resetServer();
    this.checkIsReady();
  }
};

Graveyard.prototype.setServer = function (number) {
  let serverOld = this.selectedServer;
  this.selectedServer = number;

  if (this.selectedServer !== serverOld) {
    this.resetServer();
    this.refreshServer();
    this.checkIsReady();
  }
};

Graveyard.prototype.refreshLanguage = function () {
  this.dropDownLanguageSelect.find('option').removeAttr('selected');

  if (this.selectedLanguage) {
    this.dropDownLanguageSelect.find('option[value="' + this.selectedLanguage + '"]').attr('selected', 'selected');
    this.dropDownLanguageSelect.val(this.selectedLanguage);
  }
};

Graveyard.prototype.refreshServer = function () {
  this.dropDownServerSelect.find('option').removeAttr('selected');

  if (this.selectedServer) {
    this.dropDownServerSelect.find('option[value="' + this.selectedServer + '"]').attr('selected', 'selected');
  }
};

Graveyard.prototype.resetLanguage = function () {
  this.setLanguage(this.getFirstLanguage());
};

Graveyard.prototype.resetServer = function () {
  this.setServer(this.selectedServer);
};

Graveyard.prototype.getFirstLanguage = function () {
  return this.availableLanguages[0];
};

Graveyard.prototype.onCheckIsReady = function (data) {
  this.isReadyForExodus = data.isReady;

  if (this.isReadyForExodus && this.selectedServer !== 0) {
    this.exodusSubmitButton.removeClass('disabled');
  } else {
    this.exodusSubmitButton.addClass('disabled');
  }
};

Graveyard.prototype.handleSubmitExodusResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';

  if (status === 'success') {
    fadeBox(data.message, false);
    window.location = data.redirectUrl;
  } else {
    this.displayErrors(data);
  }
};

Graveyard.prototype.displayErrors = function (data) {
  // only display the first error
  let error = data.errors[0] || undefined;

  if (error) {
    this.updateToken(data.newAjaxToken);
    fadeBox(error.message, true);
  }
};

Graveyard.prototype.onFetchServerNumbers = function (data) {
  if (data.serverNumbers.length === 0) {
    if (data.serverNumbers.length === 0) {
      this.serverSelection.html('<span id="noServer">' + this.loca.LOCA_EXODUS_NO_SERVER_AVAILABLE + '</span>');
    }

    if (this.isReadyForExodus === false) {
      this.serverSelection.html('<span id="noServer">' + this.loca.LOCA_EXODUS_RESTRICTION_NOT_FULFILLED + '</span>');
    }

    this.exodusSubmitButton.addClass('disabled');
    this.serverAmount = 0;
    this.selectedServer = 0;
    return;
  } else {
    this.serverSelection.html('<select id="serverNumber" type="text" class="og-input" name="serverNumber"></select>');
    this.exodusSubmitButton.removeClass('disabled');
    this.dropDownServerSelect = $('.graveyard #serverNumber');
    this.dropDownServerSelect.on('change', this.onChangeServerNumber.bind(this));
    this.serverAmount = data.serverNumbers.length;
  }

  this.selectedServer = data.serverNumbers[0].number;
  this.serverNumbers = data.serverNumbers;
  var select = this.dropDownServerSelect;

  if (select.prop) {
    var options = select.prop('options');
  } else {
    var options = select.attr('options');
  }

  $('option', select).remove();
  let htmlOptions = '';
  $.each(data.serverNumbers, function (key, server) {
    options[options.length] = new Option(server.name, server.number);
    htmlOptions += '<option value="' + server.number + '">' + server.name + '</option>';
  });
  this.dropDownServerSelect.ogameDropDown('destroy');
  this.dropDownServerSelect.html('');
  this.dropDownServerSelect.html(htmlOptions).ogameDropDown();
};
/**
 * getElementById-Funktion mit Cache
 */
var DOM_GET_ELEMENT_BY_ID_CACHE = [];

function getElementByIdWithCache(uid) {
  if (!DOM_GET_ELEMENT_BY_ID_CACHE[uid]) {
    DOM_GET_ELEMENT_BY_ID_CACHE[uid] = document.getElementById(uid);
  }

  return DOM_GET_ELEMENT_BY_ID_CACHE[uid];
}
/**
 *  returns a formated number like php number_format()
 *
 * @see http://de3.php.net/number_format
 */


function number_format(number, decimals, dec_point, thousands_sep) {
  dec_point = dec_point || LocalizationStrings['decimalPoint'];
  thousands_sep = thousands_sep || LocalizationStrings['thousandSeperator'];
  var exponent = "";
  var numberstr = number.toString();
  var eindex = numberstr.indexOf("e");

  if (eindex > -1) {
    exponent = numberstr.substring(eindex);
    number = parseFloat(numberstr.substring(0, eindex));
  }

  if (decimals != null) {
    var temp = Math.pow(10, decimals);
    number = Math.round(number * temp) / temp;
  }

  var sign = number < 0 ? "-" : "";
  var integer = (number > 0 ? Math.floor(number) : Math.abs(Math.ceil(number))).toString();
  var fractional = number.toString().substring(integer.length + sign.length);
  dec_point = dec_point != null ? dec_point : ".";
  fractional = decimals != null && decimals > 0 || fractional.length > 1 ? dec_point + fractional.substring(1) : "";

  if (decimals != null && decimals > 0) {
    for (i = fractional.length - 1, z = decimals; i < z; ++i) fractional += "0";
  }

  thousands_sep = thousands_sep != dec_point || fractional.length == 0 ? thousands_sep : null;

  if (thousands_sep != null && thousands_sep != "") {
    for (i = integer.length - 3; i > 0; i -= 3) integer = integer.substring(0, i) + thousands_sep + integer.substring(i);
  }

  return sign + integer + fractional + exponent;
}

function gfNumberGetHumanReadable(value, shortForm, precision) {
  value = Math.floor(value);
  shortForm = shortForm || false;
  var unit = '';
  var precision = precision || 3;

  if (shortForm) {
    if (value >= 1000000000) {
      unit = LocalizationStrings['unitMilliard'];
      value = value / 1000000000;
    } else if (value >= 1000000) {
      unit = LocalizationStrings['unitMega'];
      value = value / 1000000;
    }
  }

  floorWithPrecision = function (value, precision) {
    return Math.floor(value * Math.pow(10, precision)) / Math.pow(10, precision);
  };

  value = floorWithPrecision(value, precision);

  while (precision >= 0) {
    if (floorWithPrecision(value, precision - 1) != value) {
      break;
    }

    precision = precision - 1;
  }

  return number_format(value, precision, LocalizationStrings['decimalPoint'], LocalizationStrings['thousandSeperator']) + unit;
}

function getNumberFormatShort(value, precision) {
  if (typeof precision == 'undefined') {
    precision = 0;
  }

  value = Math.floor(value);
  var unit = '';

  if (value >= 1000000000) {
    unit = LocalizationStrings['unitMilliard'];
    value = value / 1000000000;
  }

  if (value >= 1000000) {
    unit = LocalizationStrings['unitMega'];
    value = value / 1000000;
  }

  if (value >= 1000) {
    unit = LocalizationStrings['unitKilo'];
    value = value / 1000;
  }

  return number_format(value, precision, LocalizationStrings['decimalPoint'], LocalizationStrings['thousandSeperator']) + unit;
}

function createExpireTime(timestamp) {
  var date = new Date();
  timestamp = timestamp * 1000;
  date.setTime(timestamp);
  return date;
}
function initHighscore() {
  $("a.navButton, a.subnavButton").click(function () {
    var type = $(this).attr('rel');
    var $parent = $(this).parent();
    var searchRelString = "";

    if ($parent.attr('id') == 'typeButtons') {
      $("#typeButtons > a.active").removeClass('active');
    } else if ($parent.attr('id') == 'categoryButtons') {
      $('#categoryButtons > a.active').removeClass('active');
      $("#typeButtons a.active").each(function () {
        type = $(this).attr('rel');
      });
    }

    if (searchRelId != null && $parent.attr('id') == 'typeButtons' || $parent.attr('id') == 'subnav_fleet') {
      searchRelString = "&searchRelId=" + searchRelId;
    }

    $(".subnavButton[rel!=" + type + "]").removeClass('active');
    $('#stat_list_content').html(LocalizationStrings['loading']);
    $(this).addClass('active');
    var category = $("#categoryButtons > a.active").attr('rel');
    var url = highscoreContentUrl + '?category=' + category + '&type=' + type + searchRelString;

    if (($parent.attr('id') == 'typeButtons' || $(this).hasClass('subnavButton')) && searchSite != site) {
      url = url + "&site=" + site;
    }

    removeTooltip(getTooltipSelector('#highscoreContent #ranks'));
    ajaxSubmit(url, '#send', '#stat_list_content', initHighscoreContent);

    if ($('.navButton.active').attr('rel') == 1) {
      $('#highscoreContent .header h2').text(highscoreLoca.playerHighscore);
    } else {
      $('#highscoreContent .header h2').text(highscoreLoca.allianceHighscore);
    }
  });
  $(".stat_filter").click(function () {
    var subnav = $(this).attr('id');
    $('.subnav').hide();
    $('#subnav_' + subnav).fadeIn('slow');
  }); // scroll to top buttons

  var threshold = $("#ranks").offset().top;
  var scrollToTopButton = $("#scrollToTop");
  $(window).unbind('scroll.highscoreTop').bind('scroll.highscoreTop', function (e) {
    var scrollTop = $(this).scrollTop();

    if (scrollTop > threshold) {
      scrollToTopButton.css('visibility', 'visible');
    } else {
      scrollToTopButton.css('visibility', 'hidden');
    }
  });
  $(document).undelegate('.scrollToTop', 'click').delegate('.scrollToTop', 'click', function () {
    $('html, body').animate({
      scrollTop: 0
    }, 50);
  });
}

function initHighscoreContent() {
  if (userWantsFocus) {
    if ($("#position" + searchPosition).length > 0) {
      $('html, body').animate({
        scrollTop: Math.max(0, $("#position" + searchPosition).offset().top - 200)
      }, 1000);
    }
  }

  $(".changeSite").change(function () {
    var value = $(this).val();
    $("#stat_list_content").html('<div class="ajaxLoad">' + LocalizationStrings.loading + '</div>');
    ajaxCall(highscoreContentUrl + '?category=' + currentCategory + '&type=' + currentType + '&page=' + value, '#stat_list_content', initHighscoreContent);
  }); // scroll to top buttons

  var scrollToTopButton = $("#scrollToTop");
  var positionCell = $("#ranks thead .score");

  function positionScrollButton() {
    if (positionCell.length) {
      scrollToTopButton.css('left', positionCell.offset().left);
    }
  }

  positionScrollButton();
  $(window).unbind('resize.highscoreTop').bind('resize.highscoreTop', positionScrollButton);
}
const IPI = {
  config: null,
  loadingIndicator: null,
  highlights: [],
  highlightSteps: [],
  highlightStepIndex: 0,
  ipiCall: (url, callback) => {
    IPI.loadingIndicator.show();
    $.get(url, {}, data => {
      IPI.loadingIndicator.hide();
      const result = JSON.parse(data);
      token = result.newAjaxToken ?? token;

      if (typeof result.success === "undefined" || result.success !== true) {
        if (typeof result.error !== "undefined") {
          fadeBox(result.error, true);
        }

        return;
      }

      callback(result);
    });
  },
  trackTask: taskId => {
    IPI.ipiCall(IPI.config.trackTaskUrl + "&token=" + (token ?? "0") + "&taskId=" + taskId, result => {
      const taskElements = document.querySelectorAll('.ipiTaskItem');
      taskElements.forEach(taskElement => {
        const taskTrackElement = taskElement.querySelector('.ipiTaskItemTrack');
        const currentState = taskElement.getAttribute('data-state') ?? 'none';

        if (parseInt(taskElement.getAttribute('data-taskid')) === taskId) {
          taskElement.setAttribute('data-state', currentState === 'none' ? 'tracked' : 'none');
          taskTrackElement.textContent = currentState === 'none' ? IPI.config.loca.LOCA_IPI_UNTRACK_TASK : IPI.config.loca.LOCA_IPI_TRACK_TASK;
          IPI.showTaskDescription(taskElement);
          return;
        }

        if (currentState === 'tracked') {
          taskElement.setAttribute('data-state', 'none');
          taskTrackElement.textContent = IPI.config.loca.LOCA_IPI_TRACK_TASK;
        }
      });

      if (typeof result.trackedAction !== 'undefined') {
        const actionTitle = result.trackedAction?.title ?? '';
        const actionHighlights = result.trackedAction?.highlights ?? [];
        IPI.updateCurrentAction(actionTitle, actionHighlights);
      }
    });
  },
  collectTask: taskId => {
    IPI.ipiCall(IPI.config.collectTaskUrl + "&token=" + (token ?? "0") + "&taskId=" + taskId, result => {
      IPI.markTaskAsCollected(document.querySelector('.ipiTaskItem[data-taskid="' + taskId + '"]'));

      if (typeof result.unclaimedRewards !== 'undefined') {
        const collectHint = document.querySelector('#ipiOverviewChapters .ipiChapterItem.active .ipiHintCollect');

        if (parseInt(result.unclaimedRewards) > 0) {
          collectHint.textContent = result.unclaimedRewards;
        } else {
          collectHint.remove();
        }
      }

      getAjaxResourcebox();
      fadeBox(result.claimedRewardsRendered ?? '', false);
    });
  },
  collectChapter: chapterId => {
    if (chapterId <= 0) {
      console.error("Invalid ChapterId: " + chapterId);
      return;
    }

    IPI.ipiCall(IPI.config.collectChapterUrl + "&token=" + (token ?? "0") + "&chapterId=" + chapterId, result => {
      const collectChapterElement = document.querySelector('#ipiOverviewChapterRewards .ipiOverviewCollectRewards');
      collectChapterElement.classList.add('disabled');
      collectChapterElement.textContent = IPI.config.loca.LOCA_IPI_CHAPTER_COLLECTED;
      document.querySelectorAll('.ipiTaskItem:not([data-state="collected"])').forEach(IPI.markTaskAsCollected);
      getAjaxResourcebox();
      fadeBox(result.claimedRewardsRendered ?? '', false);
    });
  },
  initIpiLayer: config => {
    IPI.config = config;
    IPI.loadingIndicator = $("#ipiOverviewContent").ogameLoadingIndicator();
    document.querySelectorAll('.ipiOverviewSelectChapter').forEach(linkElement => {
      linkElement.addEventListener('click', event => IPI.loadingIndicator.show());
    });
    const taskItems = document.querySelectorAll('.ipiTaskItem');
    taskItems.forEach(taskItem => {
      const taskId = parseInt(taskItem.getAttribute('data-taskid') ?? 0);
      taskItem.querySelector('.ipiTaskItemTitle')?.addEventListener('click', event => {
        if (taskItem.classList.contains('active')) {
          IPI.hideTaskDescription(taskItem);
          return;
        }

        IPI.showTaskDescription(taskItem);
      });

      if (taskItem.getAttribute('data-state') === 'tracked') {
        IPI.showTaskDescription(taskItem);
      }

      if (taskId === 5001 && taskItem.getAttribute('data-state') !== 'collected') {
        IPI.showTaskDescription(taskItem);
      }

      const trackElement = taskItem.querySelector('.ipiTaskItemTrack');
      trackElement.addEventListener('click', event => {
        if (IPI.config === null) {
          console.error("IPI Config missing");
          return;
        }

        const state = taskItem.getAttribute('data-state') ?? 'none';

        if (taskId <= 0) {
          console.error("Invalid TaskId: " + taskId);
          return;
        }

        switch (state) {
          case 'none':
          case 'tracked':
            IPI.trackTask(taskId);
            break;

          case 'completed':
            IPI.collectTask(taskId);
        }
      });
      const collectElement = taskItem.querySelector('.ipiOverviewCollectRewards');
      collectElement.addEventListener('click', event => {
        if (taskItem.getAttribute('data-state') !== 'completed') {
          return;
        }

        IPI.collectTask(taskId);
      });
      const progressElement = taskItem.querySelector('.ipiTaskItemProgress');
      const progress = parseInt(progressElement.getAttribute('data-progress') ?? 0);
      const total = parseInt(progressElement.getAttribute('data-total') ?? 0);

      if (progress > 0 && total > 0 && total >= progress) {
        const progressPercent = progress / total * 100;
        let progressColor = '#5a5716';
        let backgroundColor = 'transparent';

        if (progressPercent >= 100) {
          progressColor = '#4f4f4f';
        }

        progressElement.style.background = `linear-gradient(90deg, ${progressColor} ${progressPercent}%, ${backgroundColor} ${progressPercent}%)`;
      }

      const ipiMenuWrapper = document.querySelector('#ipiMenuWrapper');

      if (ipiMenuWrapper !== null) {
        changeTooltip(ipiMenuWrapper, '');
      }
    });
    const collectChapterElement = document.querySelector('#ipiOverviewChapterRewards .ipiOverviewCollectRewards');
    collectChapterElement.addEventListener('click', event => {
      if (IPI.config === null) {
        console.error("IPI Config missing");
        return;
      }

      if (collectChapterElement.classList.contains('disabled')) {
        return;
      }

      const target = parseInt(collectChapterElement.getAttribute('data-target') ?? 0);

      if (target <= 0) {
        console.error("Invalid ChapterId: " + target);
        return;
      }

      IPI.collectChapter(target);
    });
  },
  showTaskDescription: taskItem => {
    taskItem.classList.add('active');
    const contentElement = taskItem.querySelector('.ipiTaskItemContent');
    $(contentElement).slideDown();
  },
  hideTaskDescription: taskItem => {
    taskItem.classList.remove('active');
    const contentElement = taskItem.querySelector('.ipiTaskItemContent');
    $(contentElement).slideUp();
  },
  markTaskAsCollected: taskElement => {
    const taskTrackElement = taskElement.querySelector('.ipiTaskItemTrack');
    taskElement.setAttribute('data-state', 'collected');
    taskTrackElement.textContent = IPI.config.loca.LOCA_IPI_TASK_COLLECTED;
    const claimTaskRewardsButton = taskElement.querySelector('.ipiTaskItemContentCollect .claimTaskRewards');
    claimTaskRewardsButton.textContent = IPI.config.loca.LOCA_IPI_TASK_COLLECTED;
    claimTaskRewardsButton.classList.add('disabled');
  },
  addHighlight: highlightName => {
    if (typeof highlightName === 'object' && highlightName.length > 0) {
      IPI.highlightSteps = highlightName;
      IPI.highlightStepIndex = 0;
      return IPI.addHighlight(highlightName[IPI.highlightStepIndex]);
    }

    const targets = document.querySelectorAll('.ipiHintable[data-ipi-hint="' + highlightName + '"]');

    if (targets.length <= 0) {
      return false;
    }

    targets.forEach(target => {
      target.classList.add('ipiHintActive');
    });
    return true;
  },
  nextHighlightStep: event => {
    if (IPI.highlightSteps.length <= 0 || IPI.highlightStepIndex >= IPI.highlightSteps.length) {
      return;
    }

    const step = event.target.getAttribute('data-ipi-highlight-step');
    const previousHighlights = document.querySelectorAll('.ipiHintActive[data-ipi-hint="' + step + '"]');

    if (previousHighlights.length <= 0) {
      return;
    }

    previousHighlights.forEach(target => {
      target.classList.remove('ipiHintActive');
    });
    IPI.highlightStepIndex += 1;
    IPI.addHighlight(IPI.highlightSteps[IPI.highlightStepIndex]);
  },
  initIpiHighlights: highlights => {
    IPI.highlights = highlights;
    IPI.refreshHighlights();
    document.querySelectorAll('[data-ipi-highlight-step]').forEach(target => {
      if (target.nodeName.toLowerCase() === 'input') {
        target.addEventListener('change', IPI.nextHighlightStep);
        return;
      }

      target.addEventListener('click', IPI.nextHighlightStep);
    });
  },
  refreshHighlights: () => {
    document.querySelectorAll('.ipiHintable.ipiHintActive').forEach(target => {
      target.classList.remove('ipiHintActive');
    }); //this approach is more friendly to old browsers, since they do not support Array.toReversed yet

    const tmpHighlights = Array.from(IPI.highlights).reverse();

    for (highlight of tmpHighlights) {
      if (typeof highlight === 'object') {
        let highlightAdded = false;
        highlight.forEach(sub => highlightAdded = IPI.addHighlight(sub) || highlightAdded);

        if (highlightAdded === true) {
          break;
        }

        continue;
      }

      if (IPI.addHighlight(highlight) === true) {
        break;
      }
    }
  },
  updateCurrentAction: (title, highlights) => {
    const currentTaskComponent = document.querySelector('#ipimenucomponent .ipiMenuBody');
    const currentTaskFooter = document.querySelector('#ipimenucomponent .ipiMenuFooter');
    currentTaskComponent.textContent = title;

    if (title === '') {
      currentTaskComponent.classList.add('hidden');
      currentTaskFooter.classList.add('hidden');
    } else {
      currentTaskComponent.classList.remove('hidden');
      currentTaskFooter.classList.remove('hidden');
    }

    IPI.highlights = highlights;
    IPI.refreshHighlights();
  },
  initializeMenuContent: ipiMenuConfig => {
    $.ajax({
      url: ipiMenuConfig.ipiMenuContentUrl
    }).done(response => {
      IPI.populateMenuContent(response);
    }).fail(() => {
      fadeBox(result.error, true);
      return false;
    });
    $('.ipiMenuBody').mouseover();
    IPI.initIpiHighlights(ipiMenuConfig.highlights);
  },
  populateMenuContent: content => {
    $('#ipiMenuWrapper').html(content);
  },
  updateMenuContent: content => {
    if (typeof content.unclaimedRewards !== 'undefined') {
      const collectHint = $('#ipimenucomponent .ipiHintCollect');

      if (parseInt(content.unclaimedRewards) > 0) {
        collectHint.textContent = content.unclaimedRewards;
      } else {
        collectHint.remove();
      }
    }

    if (typeof content.trackedAction !== 'undefined') {
      const actionTitle = content.trackedAction?.title ?? '';
      const actionHighlights = content.trackedAction?.highlights ?? [];
      IPI.updateCurrentAction(actionTitle, actionHighlights);
    }
  }
};
/**
 * Save the current sort order to the cookie
 *
 * @param string destination
 */
function saveImperiumOrder(destination, isMoon) {
  var typeName = "impSortOrder";

  if (isMoon) {
    typeName = "impSortOrderMoon";
  }

  $.ajax({
    url: saveUrl,
    method: "post",
    dataType: "json",
    data: {
      ajax: 1,
      type: typeName,
      planets: $(destination).sortable('toArray')
    }
  });
}
/**
 * Reset the current sort order
 *
 */


function clearImperiumOrder() {
  $.ajax({
    url: saveUrl,
    method: "post",
    dataType: "json",
    data: {
      ajax: 1,
      type: 'reset'
    },
    success: function (data) {
      if (!data.error) {
        location.reload();
      }
    }
  });
}
/**
 * Generates the summary column for the imperium overview table
 *
 * @see createImperiumHtml()
 * @param array data
 * @return string
 */


function createSummaryHtml(data) {
  // Some variables we use
  var content = '';
  var planet = null;
  var value = 0;
  var i = 0;
  var key = '';
  content = content + '<div class="planetHead">' + '<div class="planetname">' + data.translations.summary + '</div>' + '<div class="planetImg"><img src="//gf3.geo.gfsrv.net/cdn8a/7efb2e73ca11d2344bbed43668da10.jpg"/></div>' + '<div class="planetData">' + '<ul>' + '<li class="coords textLeft"></li>' + '<li class="fields textRight"></li>' + '</ul>' + '</div>' + '<div class="clearfloat"></div>' + '</div>'; // Generate the content

  for (group in data.groups) {
    content = content + '<div class="row"></div>' + '<div class="values ' + group + ' group' + group + '">';

    for (i = 0; key = data.groups[group][i]; i++) {
      if (data.translations.planets[key] == null) {
        continue;
      }

      var production = {
        hourly: 0,
        daily: 0,
        weekly: 0
      };

      if (key == 'name') {
        value = data.translations.summary;
      } else {
        value = 0;

        if (group == "research") {
          if (!isNaN(data.planets[0][key])) {
            value = data.planets[0][key];
          }
        } else {
          $.each(data.planets, function () {
            planet = this;

            if (!isNaN(planet[key])) {
              value = value + parseInt(planet[key]);

              if (group == "supply" && !isNaN(planet['production']['hourly'][key - 1])) {
                production.hourly += planet['production']['hourly'][key - 1];
                production.daily += planet['production']['daily'][key - 1];
                production.weekly += planet['production']['weekly'][key - 1];
              }
            }
          });
        }
      }

      if (group == "supply" || group == "station") {
        value = "&#x00F8; " + tsdpkt(round(value / data.planets.length, 1));
      } else if (group == "items") {
        value = "&nbsp;";
      } else {
        value = tsdpkt(value);
      }

      if (group == "supply" && key != "name" && production.hourly > 0) {
        var tooltip = '<table>' + "<tr><td>" + data.translations.production.hourly + ':</td><td style=&quot;text-align: right;&quot;>' + tsdpkt(production.hourly) + "</td></tr>" + "<tr><td>" + data.translations.production.daily + ':</td><td style=&quot;text-align: right;&quot;>' + tsdpkt(production.daily) + "</td></tr>" + "<tr><td>" + data.translations.production.weekly + ':</td><td style=&quot;text-align: right;&quot;>' + tsdpkt(production.weekly) + "</td></tr></table>";
        tooltip = tooltip.replace(/</, "&lt;").replace(/>/, "&gt;");
        content = content + '<div class="tooltipRight ' + key + '" title="' + tooltip + '">' + value + '</div>';
      } else {
        content = content + '<div class="' + key + '">' + value + '</div>';
      }
    }

    content = content + '</div>';
  } // Add the outer div to the output


  content = '<div id="planet0" class="planet summary">' + content + '</div>';
  return content;
}
/**
 * Generates the first header column for the imperium table
 *
 * @see createImerpiumHtml()
 * @param array data
 * @return string
 */


function createHeaderHtml(data) {
  // Some variables we use
  var content = '';
  var i = 0;
  var key = '';
  content = content + '<div id="wrapTL">' + '<div id="tab-left">' + '<a id="planetsTab" href="javascript:void(0);" class="active" title="">' + '<span>' + data.translations['planetsTab'] + '</span>' + '</a>' + '<a id="moonsTab" href="javascript:void(0);" title="" class="">' + '<span>' + data.translations['moonsTab'] + '</span>' + '</a>' + '</div>' + '</div>'; // Generate the content

  for (group in data.groups) {
    content = content + '<div id="' + group + '" class="firstCat headers ' + group + ' headers' + group + '" group="' + group + '">' + '<h3 class="open">' + '<span>' + data.translations.groups[group] + '</span>' + '</h3>' + '<ul class="secondCat ' + group + ' group' + group + '">';

    for (i = 0; key = data.groups[group][i]; i++) {
      if (data.translations.planets[key] == null) {
        continue;
      }

      content += '<li class="' + key + '">';

      if (data.translations.planets[key + '_full'] != data.translations.planets[key]) {
        content += '<span class="tooltipLeft" title="' + data.translations.planets[key + '_full'] + '">' + data.translations.planets[key] + '</span>';
      } else {
        content += '<span>' + data.translations.planets[key] + '</span>';
      }

      content += '</li>';
    }

    content = content + '</ul>' + '</div>';
  } // Add the outer div to the output


  content = '<div id="empireTab">' + '<div class="wrapTab">' + '<div class="tab-part01"></div>' + '<h2>' + data.translations.header + '</h2>' + '<span class="reset"><img src="//gf2.geo.gfsrv.net/cdnab/f805c477d15ae3131b7c39c7d70e48.gif" width="16" height="16"><a href="javascript:void(0);" onClick="clearImperiumOrder(); return false;">' + data.translations.reset + '</a></span>' + '<div class="wrapCorner"></div>' + '<br class="clearfloat"/>' + '</div>' + '</div>' + '<div class="header">' + content + '</div>'; // Return the content

  return content;
}
/**
 * Generates all the planet columns for the imperium overview table
 *
 * @see createImperiumHtml()
 * @param array data
 * @return string
 */


function createPlanetsHtml(data) {
  // Some basic variables we use
  var planet = '';
  var shortname = '';
  var content = '';
  var headerKey = '';
  var newContent = '';
  var i = 0;
  var key = ''; // Iterate over the planets

  $.each(data.planets, function () {
    planet = this;
    content = '';
    headerKey = '';
    shortname = planet.name.length > 13 ? planet.name.substr(0, 11) + '...' : planet.name;
    content += '<div class="planetHead">';

    if (planet.name != shortname) {
      content += '<div class="planetname tooltip" title="' + planet.name + '">' + shortname + '</div>';
    } else {
      content += '<div class="planetname">' + shortname + '</div>';
    }

    if (isMobile) {
      content += '<div class="planetImg"><img class="' + planet.border + '" src="' + planet.image + '"/></div>' + '<div class="planetData">' + '<div class="planetDataTop odd">' + '<ul>' + '<li class="coords textLeft"><a class="dark_highlight_tablet" href="' + planet.coordinatesLink + '" >' + planet.coordinates + '</a></li>' + '<li class="coords">' + '<span class="dark_highlight_tablet energy tooltipRight" title="' + (planet.type == 3 ? planet.diameterTooltip : planet.energyTooltip) + '">' + (planet.type == 3 ? "\u2300: " + planet.diameter : planet.energyDescr + planet.energy) + '</span>' + '</li>' + '</ul>' + '</div>' + '<div class="planetDataTop">' + '<ul class="planet_data_2">' + '<li class="fields textLeft">' + planet.fieldUsed + '/' + planet.fieldMax + '</li>' + '<li class="fields textLeft">' + planet.temperature + '</li>' + '</ul>' + '</div>' + '</div>' + '<div class="clearfloat"></div>' + '</div>';
    } else {
      content += '<div class="planetImg"><img class="' + planet.border + '" src="' + planet.image + '"/></div>' + '<div class="planetData">' + '<div class="planetDataTop odd">' + '<ul>' + '<li class="coords textLeft"><a href="' + planet.coordinatesLink + '" >' + planet.coordinates + '</a></li>' + '<li class="fields textRight">' + planet.fieldUsed + '/' + planet.fieldMax + '</li>' + '</ul>' + '</div>' + '<div class="planetDataTop">' + '<ul>' + '<li class="coords textLeft">' + (planet.type == 3 ? planet.diameterDescr : planet.energyDescr) + '</li>' + '<li class="coords textRight">' + (planet.type == 3 ? planet.diameter : planet.energy) + '</li>' + '</ul>' + '</div>' + '<div class="planetDataBottom odd">' + '<ul>' + '<li class="fields textCenter">' + planet.temperature + '</li>' + '</ul>' + '</div>' + '</div>' + '<div class="clearfloat"></div>' + '</div>';
    } // Generate the content


    for (var group in data.groups) {
      content = content + '<div class="row"></div>' + '<div class="values ' + group + ' group' + group + '">';

      for (i = 0; key = data.groups[group][i]; i++) {
        key = String(key); // We have some special html for this!

        if (planet[key + '_html'] != null) {
          key = key + '_html';
        } // Define the header key


        headerKey = key;

        if (key.substring(key.length - 5) == '_html') {
          headerKey = key.substring(0, key.length - 5);
        }

        content = content + '<div class="' + headerKey + '">' + planet[key] + '</div>';
      }

      content = content + '</div>';
    } // And add the planet to the planetlist


    newContent = newContent + '<div id="planet' + this.id + '" class="planet">' + content + '</div>';
  });
  return newContent;
}
/**
 * Generates the imperium overview table
 *
 * @param string destination
 * @param string loading
 * @param array data
 */


function createImperiumHtml(destination, loading, data, isMoon) {
  // Set width to wrapper
  var planetCount = 0;

  if (typeof data.planets != "undefined") {
    planetCount = data["planets"].length;
  }

  var wrapperWidth = 345 + planetCount * 165;
  $("#mainWrapper").attr("style", "width: " + wrapperWidth + "px"); // Show the loading "screen"

  $(loading).show(); // Lets build up the new content

  var newContent = createHeaderHtml(data) + '<div class="planetWrapper">' + createPlanetsHtml(data) + createSummaryHtml(data) + '</div>' + '<br class="clearfloat"/>'; // Update the destination with the new content

  $(destination).append(newContent); // Finally we need the whole planetlist to be sortable

  $(destination + ' .planetWrapper').sortable({
    start: function () {
      removeTooltip(getTooltipSelector());
    },
    update: function () {
      saveImperiumOrder(destination + ' .planetWrapper', isMoon);
    }
  }).disableSelection(); // Make the groups clickable and load the toggle state

  for (group in data.groups) {
    $(destination + ' .headers' + group).click(function () {
      var selector = destination + ' .group' + $(this).attr('group');
      var selectorHeader = "#" + $(this).attr('group') + " h3";
      $(selector).toggle();
      $(selectorHeader).removeClass('openhover').removeClass('closehover').removeClass('close').removeClass('open');

      if ($(selector).attr('style').toLowerCase().substr(9, 4) == 'none') {
        $(selectorHeader).addClass("close");
        $.cookie('impToggleState' + $(this).attr('group'), '1', {
          expires: 365
        });
      } else {
        $(selectorHeader).addClass("open");
        $.cookie('impToggleState' + $(this).attr('group'), '0', {
          expires: 365
        });
      }
    });
    var cookie = $.cookie('impToggleState' + group);

    if (cookie != null && cookie == '1') {
      $("#" + group + " > h3").removeClass('open');
      $("#" + group + " > h3").addClass('close');
      $(destination + ' .group' + group).toggle();
    }
  } // Hide the loading "screen"


  $(loading).hide();
  var summaryIndex = $.inArray(0, empireOrder);

  if (summaryIndex > -1) {
    $('.planetWrapper .planet:eq(' + summaryIndex + '):not(:last-child)').before($("#planet0"));
  } // Load Tooltips


  initTooltips();
}

function displayMessage(response) {
  // bei Upgrades steht in der response nur 1 oder nichts... nichts was man anzeigen sollte. also nur reload
  location.reload(true); // true == NICHT aus dem Cache ^^
}

function doUpgrade(technologyId, planetId, mode, listId, showSlotWarning) {
  let warning;

  if (planetType === 1) {
    warning = LocalizationStrings.lastSlotWarningMoon;
  } else {
    warning = LocalizationStrings.lastSlotWarningPlanet;
  }

  if (showSlotWarning) {
    errorBoxDecision(LocalizationStrings.attention, warning, LocalizationStrings.yes, LocalizationStrings.no, function () {
      executeBuildAction(technologyId, planetId, mode, listId);
    });
  } else {
    executeBuildAction(technologyId, planetId, mode, listId);
  }
}

function executeBuildAction(technologyId, planetId, mode, listId) {
  if (mode === 1) {
    buildListActionBuild(technologyId, null, null, null, planetId);
  } else if (mode === 3) {
    buildListActionDemolish(technologyId, planetId);
  } else if (mode === 2 && listId) {
    buildListActionCancel(technologyId, listId, planetId);
  }
}

function initEmpire() {
  initConnectionErrorFunction();
  $(".secondCat").each(function () {
    $(this).find('li:last').addClass("catbox-end");
  });
  $('.values').each(function () {
    if (!$(this).hasClass('groupitems')) {
      $(this).find('div:even').addClass('even');
      $(this).find('div:odd').addClass('odd');
      $(this).find('div:last').addClass('box-end');
    }

    if ($(this).children().hasClass('equipment')) {
      $(this).children('.equipment').addClass('box-end');
    }
  });
  $("#settings li:last").addClass("set-end");
  $('.header h3').hover(function () {
    $(this).addClass($(this).attr('class') + 'hover');
  }, function () {
    $(this).removeClass('openhover').removeClass('closehover');
  });
  $('.header h3').click(function () {
    $(this).removeClass('openhover').removeClass('closehover');
    var actualClass = $(this).attr('class');

    if (actualClass == "open") {
      $(this).addClass("close");
    } else {
      $(this).addClass("open");
    }

    $(this).removeClass(actualClass);
  });
  $(".planet").hover(function () {
    $(this).addClass("move");
  }, function () {
    $(this).removeClass("move");
  });
  $('.values div img').hover(function () {
    $(this).addClass('imghover');
  }, function () {
    $(this).removeClass('imghover');
  });
  $("#planetsTab").click(function () {
    window.location.href = empireUrl + "&planetType=0";
  });

  if (moonCount > 0) {
    $("#moonsTab").click(function () {
      window.location.href = empireUrl + "&planetType=1";
    });
  } else {
    $("#moonsTab").addClass('nomoons');
  }

  if (planetType == 1) {
    $("#planetsTab").removeClass('active');
    $("#moonsTab").addClass('active');
  }

  initBuffBarEmpire();
}

function initBuffBarEmpire() {
  $('.empireItems').removeClass('hidden');
}

function changeSetting(key, value, success, error, showError) {
  $.ajax({
    type: 'POST',
    url: changeSettingsLink,
    dataType: 'json',
    data: {
      _token: changeSettingsToken,
      key: key,
      value: value
    },
    success: function (data) {
      changeSettingsToken = data.newToken;

      if (data.message.length > 0) {
        fadeBox(data.message, data.error);
      }

      if (!data.error && typeof success == 'function') {
        success();
      } else if (data.error && typeof error == 'function') {
        error();
      }
    },
    error: function (data) {
      if (typeof showError == 'undefined' || showError) {
        fadeBox(LocalizationStrings['error'], true);
      }

      if (data.error && typeof error == 'function') {
        error();
      }
    }
  });
}

function getOverlayText($thisObj) {
  if ($thisObj.hasClass('building') && $thisObj.children().hasClass('build-faster-img')) {
    return questionbuilding;
  } else if ($thisObj.hasClass('building') && $thisObj.children().hasClass('build-finish-img')) {
    return questionbuilding;
  } else if ($thisObj.hasClass('lfbuilding') && $thisObj.children().hasClass('build-faster-img')) {
    return questionlfbuilding;
  } else if ($thisObj.hasClass('lfbuilding') && $thisObj.children().hasClass('build-finish-img')) {
    return questionlfbuilding;
  } else if ($thisObj.hasClass('ship') && $thisObj.children().hasClass('build-faster-img')) {
    return questionship;
  } else if ($thisObj.hasClass('ship') && $thisObj.children().hasClass('build-finish-img')) {
    return questionship;
  } else if ($thisObj.hasClass('shipextended') && $thisObj.children().hasClass('build-faster-img')) {
    return questionshipextended;
  } else if ($thisObj.hasClass('shipextended') && $thisObj.children().hasClass('build-finish-img')) {
    return questionshipextended;
  } else if ($thisObj.hasClass('research') && $thisObj.children().hasClass('build-faster-img')) {
    return questionresearch;
  } else if ($thisObj.hasClass('research') && $thisObj.children().hasClass('build-finish-img')) {
    return questionresearch;
  } else if ($thisObj.hasClass('lfresearch') && $thisObj.children().hasClass('build-faster-img')) {
    return questionlfresearch;
  } else if ($thisObj.hasClass('lfresearch') && $thisObj.children().hasClass('build-finish-img')) {
    return questionlfresearch;
  }
}

function getFastBuildPrice($thisObj) {
  if ($thisObj.hasClass('building')) {
    return pricebuilding;
  } else if ($thisObj.hasClass('lfbuilding')) {
    return pricelfbuilding;
  } else if ($thisObj.hasClass('research')) {
    return priceresearch;
  } else if ($thisObj.hasClass('lfresearch')) {
    return pricelfresearch;
  } else if ($thisObj.hasClass('ship')) {
    return priceship;
  } else if ($thisObj.hasClass('shipextended')) {
    return priceshipextended;
  }
}

function getRedirectLink(params) {
  var finalParams = {};

  if (params != undefined) {
    for (var key in params) {
      finalParams[key] = params[key];
    }

    return $.param.fragment($.param.querystring(window.location.href, finalParams), {}); //Return witch anchor and added params
  } else {
    return window.location.href.split('#')[0]; //return url without anchor
  }
}

function sendShips(order, galaxy, system, planet, planettype, shipCount, additionalParams) {
  if (shipsendingDone == 1) {
    shipsendingDone = 0;
    params = {
      mission: order,
      galaxy: galaxy,
      system: system,
      position: planet,
      type: planettype,
      shipCount: shipCount,
      _token: token
    };

    if (additionalParams && typeof additionalParams === 'object') {
      Object.keys(additionalParams).map(key => {
        if (!params[key]) {
          params[key] = additionalParams[key];
        }
      });
    }

    $.ajax(miniFleetLink, {
      data: params,
      dataType: "json",
      type: "POST",
      success: function (data) {
        token = data.newAjaxToken;
        updateOverlayToken('phalanxSystemDialog', data.newAjaxToken);
        updateOverlayToken('phalanxDialog', data.newAjaxToken);
        getAjaxEventbox();
        displayMiniFleetMessage(data.response);
        refreshFleetEvents(true);
      }
    });
  }
}

function sendShipsWithPopup(order, galaxy, system, planet, planettype, shipCount) {
  params = {
    mission: order,
    galaxy: galaxy,
    system: system,
    position: planet,
    type: planettype,
    shipCount: shipCount,
    _token: token
  };
  $.ajax(miniFleetLink, {
    data: params,
    dataType: "json",
    type: "POST",
    success: function (data) {
      token = data.newAjaxToken;
      updateOverlayToken('phalanxSystemDialog', data.newAjaxToken);
      updateOverlayToken('phalanxDialog', data.newAjaxToken);

      if (data.response.success) {
        fadeBox(data.response.message + ' ' + data.response.coordinates.galaxy + ":" + data.response.coordinates.system + ":" + data.response.coordinates.position, !data.response.success);
      } else {
        fadeBox(data.response.message, true);
      }
    }
  });
}

function outlawWarning(order, galaxy, system, planet, planettype, shipCount, callbackFunction) {
  if (typeof callbackFunction != 'function') {
    if (order == constants.espionage) {
      callbackFunction = sendEspionageProbes;
    } else if (order == constants.missleattack) {
      callbackFunction = openMissleLaunchBox;
    }
  }

  if (showOutlawWarning) {
    errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.outlawWarning, LocalizationStrings.yes, LocalizationStrings.no, callbackFunction);
  } else {
    callbackFunction();
  }

  function sendEspionageProbes() {
    sendShips(order, galaxy, system, planet, planettype, shipCount);
  }

  function openMissleLaunchBox() {
    openOverlay(missleAttackLink + '&galaxy=' + galaxy + '&system=' + system + '&position=' + planet + '&planetType=' + planettype, {
      modal: true
    });
  }
}

function initThousandSeparator() {
  $('.checkThousandSeparator').each(function (e) {
    formatNumber(this, this.value);
  }).on('keydown', function (event) {
    var range = $(this).getSelection();

    if (range.length === 0) {
      var text = $(this).val();

      if (event.which === 8 && text.substr(range.start - 1, 1) === LocalizationStrings['thousandSeperator']) {
        range.start -= 1;
        range.end -= 1;
        $(this).setSelection(range);
      }

      if (event.which === 46 && text.substr(range.start, 1) === LocalizationStrings['thousandSeperator']) {
        range.start += 1;
        range.end += 1;
        $(this).setSelection(range);
      }
    }
  }).on('keyup', function (event) {
    formatNumber(this, this.value);
  });
}

var speedingUpBuildListEntry = false; // overall index page

function initIndex() {
  initConnectionErrorFunction();
  timerHandler.appendCallback(function () {
    localTime = new Date();
    serverTime = new Date(localTime.valueOf() + timeDiff);
    $('.OGameClock').html(getFormatedDate(serverTime.getTime(), '[d].[m].[Y] <span>[H]:[i]:[s]</span>'));
  });
  $('select').ogameDropDown();
  $('#planet .slot').hover(function () {
    $(this).addClass('slot-hover');
  }, function () {
    $(this).removeClass('slot-hover');
  });
  $('#eventboxFilled').hover(function () {
    $(this).addClass('eventboxHover');
  }, function () {
    $(this).removeClass('qeventboxHover');
  });
  $(document).undelegate('a.build-faster', 'click').delegate('a.build-faster', 'click', function () {
    var $thisObj = $(this);

    if (darkMatter < getFastBuildPrice($thisObj)) {
      errorBoxDecision(LocalizationStrings.error, LocalizationStrings.errorNotEnoughDM, LocalizationStrings.yes, LocalizationStrings.no, redirectPremium);
      return;
    }

    if (speedingUpBuildListEntry) {
      return;
    }

    speedingUpBuildListEntry = true;
    var referrerPage = $.deparam.querystring().page;
    errorBoxDecision(LocalizationStrings.notice, getOverlayText($thisObj), LocalizationStrings.yes, LocalizationStrings.no, function () {
      $.ajax({
        url: $thisObj.attr('rel'),
        data: {
          ajax: 1,
          _token: token,
          referrerPage: referrerPage
        },
        type: "POST",
        dataType: "json",
        error: function () {
          fadeBox(LocalizationStrings['error'], true);
          $thisObj.addClass('disabled');
          speedingUpBuildListEntry = false;
        },
        success: function (data) {
          token = data.newAjaxToken;

          if (data.error) {
            fadeBox(data.message, true);
            $thisObj.addClass('disabled');
            speedingUpBuildListEntry = false;
          } else {
            location.href = getRedirectLink();
          }
        }
      });
      return false;
    }, function () {
      speedingUpBuildListEntry = false;
    });
  }) // detail slides
  .undelegate('.slideIn', 'click').delegate('.slideIn', 'click', function () {
    $(".slideIn").removeClass("active");
    var id = $(this).attr("ref");
    $("a[ref='" + id + "']").addClass("active");
    Tipped.hideAll();
    $('html, body').animate({
      scrollTop: 0
    }, 500);
    gfSlider.slideIn(getElementByIdWithCache("detail"), id);
  }).undelegate('a.close_details', 'click').delegate('a.close_details', 'click', function () {
    if (window.gfSlider !== undefined) {
      gfSlider.hide(getElementByIdWithCache('detail'));
    }
  });
  $("#banner_skyscraper a.close_details").click(function () {
    changeSetting("hideBanner", $(this).attr("ref"), function () {
      $("#banner_skyscraper").remove();
    });
  });
  var wreckfield = $("#wreckFieldCountDown");

  if (wreckfield) {
    new simpleCountdown(wreckfield, wreckfield.data('duration'), null);
  }

  initHideElements();
  initOverlays();
  initThousandSeparator();
  initTooltips();
  initPlanetSorting(); // for Tablets only

  initRetinaImages(); //just during the birthday events

  initBDayEventHints();
}

function initPlanetSorting() {
  $("#planetList.sortable").sortable({
    start: function () {
      Tipped.hideAll();
    },
    stop: function () {
      Tipped.hideAll();
      changeSetting('customPlanetOrder', $(this).sortable('toArray'));
    }
  });

  if ($('.lockPlanets').hasClass('closed')) {
    $("#planetList.sortable").sortable('disable');
  }

  $('.lockPlanets').unbind('click').bind('click', function () {
    var $thisObj = $(this);
    changeSetting('planetOrderLocked', $thisObj.hasClass('open') ? 1 : 0, function () {
      var text;

      if ($thisObj.hasClass('open')) {
        $thisObj.removeClass('open').addClass('closed');
        $("#planetList.sortable").sortable('disable');
        text = LocalizationStrings.planetOrder.unlock;
      } else {
        $thisObj.removeClass('closed').addClass('open');
        $("#planetList.sortable").sortable('enable');
        text = LocalizationStrings.planetOrder.lock;
      }

      changeTooltip($thisObj, text);
    });
  });
}

function initHideElements() {
  $(document).undelegate('html', 'touchstart.hideElem click.hideElem').delegate('html', 'touchstart.hideElem click.hideElem', function (e) {
    e.stopPropagation();

    if ($(this).data('noclick')) {
      return;
    }

    if (isMobile) {
      var targetTagName = e.target.tagName.toUpperCase();

      if (!(targetTagName === 'TEXTAREA' || targetTagName === 'INPUT' || targetTagName === 'SELECT')) {
        document.activeElement.blur();
      }

      if (!$(e.target).parents('.markItUpHeader ul').length) {
        $('.markItUpHeader ul ul').hide();
      }
    } else {
      if ($(e.target).parents('.ui-dialog').length || $(e.target).parents('.tpd-tooltip').length) {
        // don't hide overlays when click was inside overlay itself or a tooltip
        // (tooltips might be part of the overlay even though they're technically located outside)
        return;
      }

      var $overlayDivs = $('.overlayDiv');

      if (typeof $overlayDivs.data('uiDialog') != "undefined") {
        // schliesse auch die Dropdowns sofern vorhanden
        var dropDowns = $overlayDivs.find('.markItUpDropMenu[id]');

        for (var i = 0; i < dropDowns.length; ++i) {
          var $innerUl = $('body>ul[rel=' + dropDowns[i].id + ']');
          $innerUl.hide();
        }

        $overlayDivs.dialog('close');

        if ($("#FederationLayer").length > 0) {
          $("#FederationLayer").remove();
        }
      }
    }
  });
}

function initJumpgate() {
  $('select').ogameDropDown();
  $(".list tr:even").addClass("alt");
  $(document).undelegate('#jumpgateForm .ship_input_row .textinput', 'keyup change input').delegate('#jumpgateForm .ship_input_row .textinput', 'keyup change input', function () {
    checkIntInput(this, 0, $(this).attr('rel'));
  }).undelegate('#jumpgateForm .ship_input_row .textinput', 'focus').delegate('#jumpgateForm .ship_input_row .textinput', 'focus', function () {
    if ($.isNumeric($(this).val()) === false) {
      $(this).val("");
    } else {
      $(this).select();
    }
  });
  $('#jumpgate .answerHeadline, .js_openStandardMoonMenu').click(function () {
    if (!player.hasCommander) {
      errorBoxNotify(LocalizationStrings.error, translation.changeSettingOnlyWithCommander, LocalizationStrings.ok, null, false);
    } else {
      $('#jumpgate').find('.answerHeadline').toggleClass('open');
      $('.thirdCol').toggleClass('hidden');
    }
  });
  $('.js_executeJumpButton').click(function () {
    var selectedMoon = $('#jumpgateForm').find('select[name="targetSpaceObjectId"]').val();
    window.jumpGateTargetId = selectedMoon;

    if (selectedMoon != 0) {
      var noShipsSelected = true;
      $('.ship_selection_table input').each(function () {
        if ($(this).val() > 0) {
          noShipsSelected = false;
        }
      });

      if (!noShipsSelected) {
        ajaxFormSubmit('jumpgateForm', $(this).attr('data-url'), jumpgateDone);
      } else {
        fadeBox(translation.noShipsWereSelected, true);
      }
    } else {
      fadeBox(translation.validTargetNeeded, true);
    }
  });
}

function jumpgateDone(data) {
  var data = $.parseJSON(data);

  if (data["status"]) {
    planet = data["targetMoon"];
    $('.overlayDiv').dialog('destroy');
  }

  errorBoxAsArray(data["errorbox"]);

  if (typeof data.newAjaxToken != 'undefined') {
    setNewTokenData(data.newAjaxToken);
  }
}

function jumpgateDefaultTargetSelectionCallback(data) {
  var data = $.parseJSON(data);

  if (data["status"]) {
    token = data.token;
    $('#jumpgateForm').find('input[name="token"]').val(data.token);
    var targetSelect = $('#jumpgateForm').find('select[name="targetSpaceObjectId"]');
    targetSelect.find('option').removeAttr('selected');
    var optionNode = targetSelect.find('option[value="' + data["targetMoon"] + '"]');

    if (optionNode.length) {
      optionNode.attr('selected', 'selected');
    } else {
      if (targetSelect.find('option[value="0"]').length == 0) {
        targetSelect.append($(document.createElement('option')).attr('value', 0).attr('selected', 'selected').text('--'));
      } else {
        targetSelect.find('option[value="0"]').attr('selected', 'selected');
      }
    }

    targetSelect.trigger('change'); // not sure if the following is enough to refresh that dropdown

    targetSelect.ogameDropDown('refresh');
  }

  errorBoxAsArray(data["errorbox"]);

  if (typeof data.newAjaxToken != 'undefined') {
    setNewTokenData(data.newAjaxToken);
  }
}

function setNewTokenData(newToken) {
  $('#jumpgateForm input[name="token"]').val(newToken);
  $('#jumpgateDefaultTargetSelectionForm input[name="token"]').val(newToken);
  token = newToken;
}

function openJumpgate() {
  //if($(".ui-dialog #content #jumpgate").length == 0) {
  openOverlay(jumpGateLink, {
    title: jumpGateLoca.LOCA_STATION_JUMPGATE_HEADLINE
  }); //}
}

function redirectLogout() {
  location.href = redirectLogoutLink;
}

function redirectBuyPremium() {
  location.href = redirectPremiumLink;
}

function redirectOverview() {
  location.href = redirectOverviewLink;
}

function redirectSpaceDock() {
  location.href = redirectSpaceDockLink;
}
if (typeof KeyEvent == "undefined") {
  var KeyEvent = {
    DOM_VK_CANCEL: 3,
    DOM_VK_HELP: 6,
    DOM_VK_BACK_SPACE: 8,
    DOM_VK_TAB: 9,
    DOM_VK_CLEAR: 12,
    DOM_VK_RETURN: 13,
    DOM_VK_ENTER: 14,
    DOM_VK_SHIFT: 16,
    DOM_VK_CONTROL: 17,
    DOM_VK_ALT: 18,
    DOM_VK_PAUSE: 19,
    DOM_VK_CAPS_LOCK: 20,
    DOM_VK_ESCAPE: 27,
    DOM_VK_SPACE: 32,
    DOM_VK_PAGE_UP: 33,
    DOM_VK_PAGE_DOWN: 34,
    DOM_VK_END: 35,
    DOM_VK_HOME: 36,
    DOM_VK_LEFT: 37,
    DOM_VK_UP: 38,
    DOM_VK_RIGHT: 39,
    DOM_VK_DOWN: 40,
    DOM_VK_PRINTSCREEN: 44,
    DOM_VK_INSERT: 45,
    DOM_VK_DELETE: 46,
    DOM_VK_0: 48,
    DOM_VK_1: 49,
    DOM_VK_2: 50,
    DOM_VK_3: 51,
    DOM_VK_4: 52,
    DOM_VK_5: 53,
    DOM_VK_6: 54,
    DOM_VK_7: 55,
    DOM_VK_8: 56,
    DOM_VK_9: 57,
    DOM_VK_SEMICOLON: 59,
    DOM_VK_EQUALS: 61,
    DOM_VK_A: 65,
    DOM_VK_B: 66,
    DOM_VK_C: 67,
    DOM_VK_D: 68,
    DOM_VK_E: 69,
    DOM_VK_F: 70,
    DOM_VK_G: 71,
    DOM_VK_H: 72,
    DOM_VK_I: 73,
    DOM_VK_J: 74,
    DOM_VK_K: 75,
    DOM_VK_L: 76,
    DOM_VK_M: 77,
    DOM_VK_N: 78,
    DOM_VK_O: 79,
    DOM_VK_P: 80,
    DOM_VK_Q: 81,
    DOM_VK_R: 82,
    DOM_VK_S: 83,
    DOM_VK_T: 84,
    DOM_VK_U: 85,
    DOM_VK_V: 86,
    DOM_VK_W: 87,
    DOM_VK_X: 88,
    DOM_VK_Y: 89,
    DOM_VK_Z: 90,
    DOM_VK_CONTEXT_MENU: 93,
    DOM_VK_NUMPAD0: 96,
    DOM_VK_NUMPAD1: 97,
    DOM_VK_NUMPAD2: 98,
    DOM_VK_NUMPAD3: 99,
    DOM_VK_NUMPAD4: 100,
    DOM_VK_NUMPAD5: 101,
    DOM_VK_NUMPAD6: 102,
    DOM_VK_NUMPAD7: 103,
    DOM_VK_NUMPAD8: 104,
    DOM_VK_NUMPAD9: 105,
    DOM_VK_MULTIPLY: 106,
    DOM_VK_ADD: 107,
    DOM_VK_SEPARATOR: 108,
    DOM_VK_SUBTRACT: 109,
    DOM_VK_DECIMAL: 110,
    DOM_VK_DIVIDE: 111,
    DOM_VK_F1: 112,
    DOM_VK_F2: 113,
    DOM_VK_F3: 114,
    DOM_VK_F4: 115,
    DOM_VK_F5: 116,
    DOM_VK_F6: 117,
    DOM_VK_F7: 118,
    DOM_VK_F8: 119,
    DOM_VK_F9: 120,
    DOM_VK_F10: 121,
    DOM_VK_F11: 122,
    DOM_VK_F12: 123,
    DOM_VK_F13: 124,
    DOM_VK_F14: 125,
    DOM_VK_F15: 126,
    DOM_VK_F16: 127,
    DOM_VK_F17: 128,
    DOM_VK_F18: 129,
    DOM_VK_F19: 130,
    DOM_VK_F20: 131,
    DOM_VK_F21: 132,
    DOM_VK_F22: 133,
    DOM_VK_F23: 134,
    DOM_VK_F24: 135,
    DOM_VK_NUM_LOCK: 144,
    DOM_VK_SCROLL_LOCK: 145,
    DOM_VK_COMMA: 188,
    DOM_VK_PERIOD: 190,
    DOM_VK_SLASH: 191,
    DOM_VK_BACK_QUOTE: 192,
    DOM_VK_OPEN_BRACKET: 219,
    DOM_VK_BACK_SLASH: 220,
    DOM_VK_CLOSE_BRACKET: 221,
    DOM_VK_QUOTE: 222,
    DOM_VK_META: 224
  };
}

(function ($) {
  $.fn.extend({
    ogameDropDown: function (functionName, preventScrollSelection) {
      if ($("body.showOldDropdowns").length) {
        return this;
      }

      function positionList($ul) {
        var ulHeight = $ul.outerHeight();
        var $dropdown = $('.dropdown.currentlySelected[rel="' + $ul.attr('id') + '"]');

        if ($dropdown.length) {
          var left = Math.min($(window).innerWidth() + $(window).scrollLeft() - $ul.width() - 3, $dropdown.offset().left);
          var top;
          var dropdownTop = Math.ceil($dropdown.offset().top);

          if (dropdownTop + $dropdown.height() + ulHeight + $('#siteFooter').outerHeight() >= $(window).innerHeight() + $(window).scrollTop()) {
            top = dropdownTop - ulHeight + 1;
          } else {
            top = dropdownTop + $dropdown.height() + 1;
          }

          $ul.css('left', left).css('top', top).css('min-width', $dropdown.width());
        }
      }

      var functions = {
        destroy: function () {
          $(this).filter('select.dropdownInitialized').each(function () {
            var $this = $(this);
            $('.dropdown[rel="' + $this.data('dropdownId') + '"]').remove();
            $('ul#' + $this.data('dropdownId')).remove();
            $this.removeClass('dropdownInitialized').data('dropdownId', '').show();
          });
        },
        hide: function () {
          $(this).filter('select.dropdownInitialized').each(function () {
            var $currentlySelected = $('.currentlySelected[rel="' + $(this).data('dropdownId') + '"]');
            $currentlySelected.find('a').removeClass('hover');
            $('.dropdownList#' + $currentlySelected.attr('rel')).hide();
          });
        },
        reposition: function () {
          $(this).filter('select.dropdownInitialized').each(function () {
            positionList($('#' + $(this).data('dropdownId')));
          });
        },
        refresh: function () {
          var selected = $(this).find("option[selected]"); // get selected <option>

          var href = getIEVersion() < 999 ? '#' : 'javascript:void(0);';
          var $currentItem = $('a[class="' + selected.attr('class') + '"][rel="' + $(this).data('dropdownId') + '"]').text(selected.text());
        },
        select: function (value) {
          $(this).find("option").prop("selected", false).removeAttr("selected");

          if (typeof value == 'string' && value.length > 0) {
            // select value and refresh
            let selected = $(this).find("option[value='" + value + "']");

            if (selected.length > 0) {
              selected.prop("selected", true).attr('selected', 'selected');
              functions.refresh.call(this);
              return;
            }
          } // select default value and refesh


          let defaultOption = $(this.find("option[value='-']"));

          if (defaultOption.length > 0) {
            defaultOption.prop("selected", true).attr('selected', 'selected');
            functions.refresh.call(this);
          }
        }
      };

      if (typeof functionName == 'string') {
        if (typeof functions[functionName] == 'function') {
          let args = Array.prototype.slice.call(arguments);
          args.shift();
          functions[functionName].apply(this, args);
        }

        return this;
      }

      $(this).filter('select:not(.dropdownInitialized)').each(function () {
        var $this = $(this);
        var randomId = 'dropdown' + Math.floor(Math.random() * 1000);
        var selected = $this.find("option[selected]"); // get selected <option>

        if (selected.length == 0) {
          selected = $this.find('option:first-child');
        }

        var href = getIEVersion() < 999 ? '#' : 'javascript:void(0);';
        var $currentItem = $('<a class="' + selected.attr('class') + '" data-value="' + selected.val() + '" rel="' + randomId + '" href="' + href + '">' + selected.text() + '</a>');
        var $dropdown = $('<span class="dropdown currentlySelected ' + $this.attr('class') + '" rel="' + randomId + '"></span>').append($currentItem).width($this.css('width').length ? $this.css('width') : $this.width()).data('selectElement', $this);

        if ($this.is('[readonly]') || $this.is(':disabled')) {
          $dropdown.addClass('disabled');
        }

        $this.after($dropdown).hide().addClass('dropdownInitialized').data('dropdownId', randomId); // iterate through all the <option> elements and create UL

        var $ul = $('<ul class="dropdown dropdownList" id="' + randomId + '"></ul>').delegate('a', 'click', function (e) {
          e.stopPropagation();

          if ($(this).attr('disabled') === 'disabled') {
            return;
          }

          $currentItem.html($(this).html()).attr('class', $(this).attr('class')).attr('data-value', $(this).attr('data-value'));
          $ul.hide().find('a').removeClass('focus');
          $(this).addClass('focus');
          var value = $(this).attr('data-value');
          $this.val($(this).attr('data-value')).trigger('change').find('option[value="' + value + '"], option:contains("' + value + '")').trigger('click');
        });

        function initialize() {
          if ($this.is($this.is('[readonly]') || ':disabled')) {
            return;
          }

          if (!$ul.hasClass('initialized')) {
            $ul.addClass('initialized');
            $this.find("option").each(function () {
              var html = $(this).html();
              var disabled = '';
              var title = '';

              if (typeof $(this).attr('data-html') != 'undefined') {
                html = $(this).attr('data-html');
              }

              if (typeof $(this).attr('data-html-prepend') != 'undefined') {
                html = $(this).attr('data-html-prepend') + html;
              }

              if (typeof $(this).attr('data-html-append') != 'undefined') {
                html += $(this).attr('data-html-append');
              }

              if (typeof $(this).attr('title') != 'undefined') {
                title = 'title="' + $(this).attr('title') + '" ';
              }

              if (typeof $(this).attr('disabled') != 'undefined') {
                disabled = 'disabled="' + $(this).attr('disabled') + '" ';
              }

              $li = $('<li><a ' + 'class="' + $(this).attr('class') + '" ' + disabled + title + 'data-value="' + $(this).val() + '">' + html + '</a></li>');
              $ul.append($li);

              if ($(this).is(':selected')) {
                $li.find('a').addClass('focus');
              }
            });
          }
        }

        $currentItem.bind('focus', function (e) {
          $(".dropdownList").not($ul).hide();
          $(".dropdown.currentlySelected").removeClass('focus');
          $(this).addClass('hover');
          $dropdown.addClass('focus');
          initialize();
        }).bind('mousewheel', function (e) {
          initialize();
          $(this).unbind('mousewheel');
        }).bind('click', function (e) {
          e.preventDefault();

          if ($this.is($this.is('[readonly]') || ':disabled')) {
            return;
          }

          $(".dropdownList").not($ul).hide();
          $(".dropdown.currentlySelected").removeClass('focus');
          $dropdown.addClass('focus');

          if ($ul.is(':hidden')) {
            $(this).addClass('hover');
            initialize();
            positionList($ul);
            $(window).unbind('resize.dropdown' + randomId).bind('resize.dropdown' + randomId, function () {
              positionList($ul);
            });
            $ul.show();

            if ($ul.hasScrollbar()) {
              $ul.find('a').css('padding-right', 22);
            }
          } else {
            $(this).removeClass('hover');
            $(window).unbind('resize.dropdown' + randomId);
            $ul.hide();
          }
        });
        $('body').append($ul);
      });
      var currentlyTyped = "";
      var currentlyTypedInterval;

      function updateCurrentlyTyped(text, e) {
        currentlyTyped = text;
        clearTimeout(currentlyTypedInterval);
        currentlyTypedInterval = setTimeout(function () {
          currentlyTyped = "";
        }, 1500);
        var $list = $('.dropdownList:visible');
        var instantSelect = false;

        if ($list.length == 0) {
          var $focusedElement = $('.dropdown.currentlySelected.focus');

          if ($focusedElement.length) {
            $list = $("#" + $focusedElement.attr('rel'));
            instantSelect = true;
          } else {
            return;
          }
        }

        var lowerText = currentlyTyped.toLowerCase();
        var $focusElement = $list.find('a').filter(function () {
          if ($(this).attr('data-value').toLowerCase().indexOf(lowerText) == 0) {
            return true;
          }

          return $(this).text().trim().toLowerCase().indexOf(lowerText) == 0;
        });

        if ($focusElement.length) {
          e.preventDefault();
          $list.find('a').removeClass('focus');
          $($focusElement.get(0)).addClass('focus').focus();

          if (instantSelect) {
            $focusElement.click();
          }
        } else {
          clearTimeout(currentlyTypedInterval);
          currentlyTyped = "";
        }
      }

      $(document) // hide the dropdown
      .undelegate('html', 'touchstart.dropdown click.dropdown').delegate('html', 'touchstart.dropdown click.dropdown', function (e) {
        if ($(e.target).closest(".dropdown").length == 0) {
          $(".dropdownList").hide(); //$(".currentlySelected a").removeClass('hover');
          //$(".currentlySelected").removeClass('focus');
        }
      }).undelegate('.dropdown', 'mousewheel.dropdown').delegate('.dropdown', 'mousewheel.dropdown', function (e, delta) {
        if (preventScrollSelection) {
          return;
        }

        e.preventDefault();
        var $target = $(e.target).closest('.dropdown');
        var $list;

        if ($target.hasClass('currentlySelected')) {
          $list = $("#" + $target.attr('rel'));
        } else {
          $list = $target;
        }

        var $currentItem = $('[rel="' + $list.attr('id') + '"] a');
        var $focussed = $list.find('a:focus');

        if ($focussed.length == 0) {
          $focussed = $list.find('a.focus');
        }

        if ($focussed.length == 0) {
          $focussed = $list.find('a[data-value="' + $currentItem.attr('data-value') + '"]');
        }

        var $focussedListElement = $focussed.parent();
        var $focusElement = null;
        var amount = Math.abs(delta);

        if (delta > 0) {
          for (var amountCounter = 0; amountCounter < amount; amountCounter++) {
            if ($focussedListElement.is(':first-child')) {
              $focusElement = $focussedListElement.find('a');
              break;
            } else {
              $focusElement = $focussedListElement.prev().find('a');
            }

            $focussedListElement = $focusElement.parent();
          }
        } else {
          for (var amountCounter = 0; amountCounter < amount; amountCounter++) {
            if ($focussedListElement.is(':last-child')) {
              $focusElement = $focussedListElement.find('a');
              break;
            } else {
              $focusElement = $focussedListElement.next().find('a');
            }

            $focussedListElement = $focusElement.parent();
          }
        }

        if ($focusElement != null) {
          $focussedListElement = $focusElement.parent();
          $list.find('a').removeClass('focus');
          $focusElement.addClass('focus').focus();

          if ($list.is(':hidden')) {
            $focusElement.click();
          } else {
            var currentPosition = $focussedListElement.position().top;

            if (currentPosition < 0) {
              $list.scrollTop($list.scrollTop() + currentPosition);
            } else if (currentPosition + $focussedListElement.outerHeight() > $list.innerHeight()) {
              $list.scrollTop($list.scrollTop() + currentPosition + $focussedListElement.outerHeight() - $list.innerHeight());
            }
          }
        }
      }).undelegate('*', 'focus.dropdown').delegate('*', 'focus.dropdown', function (e) {
        if ($(e.target).closest(".dropdown").length == 0) {
          $(".currentlySelected a").removeClass('hover');
          $(".currentlySelected").removeClass('focus');
        }
      }) // get keyboard arrow keys and backspace typing
      .unbind('keydown.dropdown').bind('keydown.dropdown ', function (e) {
        if ($(':focus').length > 0 && $(':focus').parents('.dropdown').length == 0) {
          return;
        }

        var instantSelect = false;
        var $list = $('.dropdownList:visible');

        if ($list.length == 0) {
          var $focusedElement = $('.dropdown.currentlySelected.focus');

          if ($focusedElement.length) {
            $list = $("#" + $focusedElement.attr('rel'));
            instantSelect = true;
          } else {
            return;
          }
        }

        var $currentItem = $('[rel="' + $list.attr('id') + '"] a');
        var $focussed = $list.find('a:focus');

        if ($focussed.length == 0) {
          $focussed = $list.find('a.focus');
        }

        if ($focussed.length == 0) {
          $focussed = $list.find('a[data-value="' + $currentItem.attr('data-value') + '"]');
        }

        var $focussedListElement = $focussed.parent();
        var $focusElement = null; // arrow keys

        if (e.keyCode == KeyEvent.DOM_VK_UP || e.keyCode == KeyEvent.DOM_VK_DOWN) {
          if (e.keyCode == KeyEvent.DOM_VK_UP) {
            if ($focussedListElement.is(':first-child')) {
              $focusElement = $focussedListElement.find('a');
            } else {
              $focusElement = $focussedListElement.prev().find('a');
            }

            $focussedListElement = $focusElement.parent();
          } else {
            if ($focussedListElement.is(':last-child')) {
              $focusElement = $focussedListElement.find('a');
            } else {
              $focusElement = $focussedListElement.next().find('a');
            }

            $focussedListElement = $focusElement.parent();
          }

          e.preventDefault();
        } else if (e.keyCode == KeyEvent.DOM_VK_BACK_SPACE) {
          // simulate keyboard typing
          updateCurrentlyTyped(currentlyTyped.substring(0, currentlyTyped.length - 1), e);
        } else if (e.keyCode == KeyEvent.DOM_VK_RETURN) {
          e.preventDefault();

          if (instantSelect) {
            $currentItem.parents('form').submit();
            return;
          } else {
            instantSelect = true;
            $focusElement = $focussed;
          }
        } else if (e.keyCode == KeyEvent.DOM_VK_ESCAPE) {
          $focusElement = $list.find('[data-value="' + $currentItem.attr('data-value') + '"]');
          instantSelect = true;
        }

        if ($focusElement != null) {
          $focussedListElement = $focusElement.parent();
          $list.find('a').removeClass('focus');
          $focusElement.addClass('focus').focus();

          if (instantSelect) {
            $focusElement.click();
          } else {
            var currentPosition = $focussedListElement.position().top;

            if (currentPosition < 0) {
              $list.scrollTop($list.scrollTop() + currentPosition);
            } else if (currentPosition + $focussedListElement.outerHeight() > $list.innerHeight()) {
              $list.scrollTop($list.scrollTop() + currentPosition + $focussedListElement.outerHeight() - $list.innerHeight());
            }
          }
        }
      }) // simulate keyboard typing
      .unbind('keypress.dropdown').bind('keypress.dropdown', function (e) {
        if ($(':focus').length > 0 && $(':focus').parents('.dropdown').length == 0 || e.charCode == 0) {
          return;
        }

        updateCurrentlyTyped(currentlyTyped + String.fromCharCode(e.charCode), e);
      });
      return $(this);
    },

    /**
    * @url http://stackoverflow.com/a/9217301/1386610
    */
    selectText: function () {
      var range,
          selection,
          obj = this[0],
          type = {
        func: 'function',
        obj: 'object'
      },
          // Convenience
      is = function (type, o) {
        return typeof o === type;
      };

      if (is(type.obj, obj.ownerDocument) && is(type.obj, obj.ownerDocument.defaultView) && is(type.func, obj.ownerDocument.defaultView.getSelection)) {
        selection = obj.ownerDocument.defaultView.getSelection();

        if (is(type.func, selection.setBaseAndExtent)) {
          // Chrome, Safari - nice and easy
          selection.setBaseAndExtent(obj, 0, obj, $(obj).contents().size());
        } else if (is(type.func, obj.ownerDocument.createRange)) {
          range = obj.ownerDocument.createRange();

          if (is(type.func, range.selectNodeContents) && is(type.func, selection.removeAllRanges) && is(type.func, selection.addRange)) {
            // Mozilla
            range.selectNodeContents(obj);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
      } else if (is(type.obj, document.body) && is(type.obj, document.body.createTextRange)) {
        range = document.body.createTextRange();

        if (is(type.obj, range.moveToElementText) && is(type.obj, range.select)) {
          // IE most likely
          range.moveToElementText(obj);
          range.select();
        }
      } // Chainable


      return this;
    },
    hasScrollbar: function () {
      return this.get(0).scrollHeight > this.innerHeight();
    }
  });
})(jQuery);
$(document).on('click', '[data-toggable]', function () {
  let curr = $(this);
  let targetElement = curr.attr('data-toggable');
  let targetElementParent = curr.parent();
  $(targetElementParent).find('[data-toggable-target="' + targetElement + '"]').slideToggle({
    'start': function () {
      if (curr.hasClass('active')) {
        curr.removeClass('active');
      } else {
        curr.addClass('active');
      }
    }
  });
});
function OGameLoadingIndicator(container) {
  this.container = container;
}

OGameLoadingIndicator.prototype.init = function () {
  let html = '<div class="og-loading"><div class="og-loading-overlay"><div class="og-loading-indicator"></div></div></div>';
  this.element = $(html);
  this.container.append(this.element);
};

OGameLoadingIndicator.prototype.show = function () {
  this.element.show();
};

OGameLoadingIndicator.prototype.hide = function () {
  this.element.hide();
};

(function ($) {
  $.fn.ogameLoadingIndicator = function (data) {
    if (this.length > 0) {
      let that = $(this[0]);
      let loadingIndicator = that.data('ogameLoadingIndicator');

      if (loadingIndicator == null) {
        loadingIndicator = new OGameLoadingIndicator(that, data);
        $(this).data('ogameLoadingIndicator', loadingIndicator);
        loadingIndicator.init();
      }

      return loadingIndicator;
    }

    return null;
  };
})(jQuery);
function MessageSlider(obj) {
  var thisObj = this;
  thisObj.htmlobject = obj;
  var maxHeight = document.documentElement.clientHeight - 160;
  this.open = function () {
    if (!this.inAction) {
      thisObj.startTime = new Date().getTime();
      thisObj.inAction = true;
      thisObj.slideInStep();
    }
  }, this.slideInStep = function () {
    time = new Date().getTime();
    height = parseInt(thisObj.currHeight * ((time - thisObj.startTime) / 500));

    if (height < thisObj.currHeight) {
      thisObj.htmlobject.style.height = height + 'px';
      window.setTimeout(thisObj.slideInStep, 10);
    } else {
      thisObj.htmlobject.style.height = thisObj.currHeight + 'px';
      thisObj.inAction = false;
    }
  }, this.close = function () {
    if (!thisObj.inAction) {
      thisObj.startTime = new Date().getTime();
      thisObj.inAction = true;
      thisObj.htmlobject.style.height = "0px";
      thisObj.inAction = false;
    }
  }, thisObj.inAction = false;

  if (document.getElementById('messages')) {
    thisObj.currHeight = Math.min(document.getElementById('messages').offsetHeight, maxHeight);
  } else {
    thisObj.currHeight = maxHeight;
  }
}
ogame.messagecounter = {
  countData: {
    'chat': 0,
    'messages': 0,
    'buddy': 0
  },
  newChats: Array(),
  type_chat: 10,
  type_message: 11,
  type_buddy: 12,
  currentLinkSelector: null,
  currentType: 0,
  currentPlayer: null,
  sumNewChatMessages: 0,
  initialize: function (type, player) {
    var $this = ogame.messagecounter;

    if (typeof player == 'undefined' && type !== $this.type_chat) {
      $this.currentPlayer = 0;
    }

    if (typeof player == 'undefined' && type == $this.type_chat) {
      return false;
    }

    if (typeof player !== 'undefined') {
      $this.currentPlayer = player;
    }

    $this.currentType = type;

    switch (type) {
      case $this.type_chat:
        $this.currentLinkSelector = $('a.comm_menu.chat');
        break;

      case $this.type_message:
        $this.currentLinkSelector = $('a.comm_menu.messages');
        break;

      case $this.type_buddy:
        $this.currentLinkSelector = $('a.comm_menu.buddies');
        break;

      default:
        return false;
    }

    $this.update();
  },
  initChatCounter: function (counter) {
    var $this = ogame.messagecounter;
    $this.currentLinkSelector = $('a.comm_menu.chat');
    $this.currentType = $this.type_chat;
    $this.setCount(counter); //        if(counter > 0) {

    $this.update(); //        }
  },

  /**
   * Update Count of new Chatmessages
   */
  update: function (locakey) {
    var $this = ogame.messagecounter; //        $this.updateCountData();

    /*
    if ($this.shouldAddCounter() && $this.getCount() > 0) {
        $this.setNewCounter($this.currentLinkSelector, $this.getCounterHtml($this.getCount()));
    } else {
        if ($this.getCount() == 0) {
            $this.resetCounterByType($this.currentType)
        } else {
            $this.setNewCounter($this.getCountSelectorByType($this.currentType), $this.getCount());
        }
    } */

    var loca;

    if (locakey === undefined) {
      loca = chatLoca.X_NEW_CHATS;
    } else {
      loca = locakey;
    }

    changeTooltip($this.currentLinkSelector, loca.replace('#+#', $this.getCount()));
  },
  resetCounterByType: function (type, locakey) {
    var $this = ogame.messagecounter;
    var selector = $this.getIconSelectorByType(type); //        $this.setNewCounter(selector, '');

    var loca;

    if (locakey === undefined) {
      loca = ''; //chatLoca.X_NEW_CHATS;
    } else {
      loca = locakey;
    }

    changeTooltip(selector, loca.replace('#+#', 0));
  },

  /**
   * Get the Selector of the right counterbox
   *
   * @param int type -> right codes see@top
   *
   * @return jquery-object unreadSelector
   */
  getCountSelectorByType: function (type) {
    var $this = ogame.messagecounter;
    var unreadSelector = '';

    switch (type) {
      case $this.type_chat:
        unreadSelector = $('a.comm_menu.chat .new_msg_count');
        break;

      case $this.type_message:
        unreadSelector = $('a.comm_menu.messages .new_msg_count');
        break;

      case $this.type_buddy:
        unreadSelector = $('a.comm_menu.buddies .new_msg_count');
    }

    return unreadSelector;
  },

  /**
   * Get the Selector of the right icon
   *
   * @param int type -> right codes see@top
   *
   * @return jquery-object unreadSelector
   */
  getIconSelectorByType: function (type) {
    var $this = ogame.messagecounter;
    var selector = '';

    switch (type) {
      case $this.type_chat:
        selector = $('a.comm_menu.chat');
        break;

      case $this.type_message:
        selector = $('a.comm_menu.messages');
        break;

      case $this.type_buddy:
        selector = $('a.comm_menu.buddies');
    }

    return selector;
  },

  /**
   * Get the Html-String to create a counter
   *
   * @param string count
   *
   * @return string counter
   */
  getCounterHtml: function (count) {
    var counter = '<span class="new_msg_count">' + count + '</span>';
    return counter;
  },

  /**
   * Get count from type
   *
   * @return int $this.countData.[type]
   */
  getCount: function () {
    var $this = ogame.messagecounter;

    switch ($this.currentType) {
      case $this.type_chat:
        return $this.countData.chat;

      case $this.type_message:
        return $this.countData.messages;

      case $this.type_buddy:
        return $this.countData.buddy;
    }
  },

  /**
   * Set count for type
   *
   * @param mixed value
   */
  setCount: function (value) {
    var $this = ogame.messagecounter;

    switch ($this.currentType) {
      case $this.type_chat:
        $this.countData.chat = value;
        break;

      case $this.type_message:
        $this.countData.messages = value;
        break;

      case $this.type_buddy:
        $this.countData.buddy = value;
        break;
    }
  },

  /**
   * Update Count for type
   */
  updateCountData: function () {
    var $this = ogame.messagecounter;

    if ($this.isOpen()) {
      $this.setCount(0);
    } else {
      if ($this.shouldAddCounter()) {
        var unreadMessages = 1;
      } else {
        var unreadMessagesSelector = $this.getCountSelectorByType($this.currentType);
        var unreadMessages = unreadMessagesSelector.html();
        unreadMessages = parseInt(unreadMessages) + 1;
      }

      $this.setCount(unreadMessages);
    }
  },

  /**
   * Returns if u should add the counter first
   *
   * @return boolean addCounter
   */
  shouldAddCounter: function () {
    var $this = ogame.messagecounter;
    var unreadMessagesSelector = $this.getCountSelectorByType($this.currentType);
    var unreadMessages = unreadMessagesSelector.html();
    var addCounter = false;

    if (typeof unreadMessages == 'undefined') {
      addCounter = true;
    }

    return addCounter;
  },

  /**
   * Set counter for new chatmessages
   *
   * @param jquery-object selector
   * @param string html    >> html for the counter on the chatsymbole
   */
  setNewCounter: function (selector, html) {
    selector.html(html);
  },

  /**
   * proof if the chat of the player is open
   */
  isOpen: function () {
    var $this = ogame.messagecounter;
    var returnValue = false;

    switch ($this.currentType) {
      case $this.type_chat:
        returnValue = ogame.chat.isOpen($this.currentPlayer); //                $('.chat_box').each(function () {
        //                    if ($(this).attr('data-playerid') == $this.currentPlayer) {
        //                        if ($(this).css('display') == 'block') {
        //                            returnValue = true;
        //                        }
        //                    }
        //                });

        break;

      case $this.type_message:
        returnValue = location.href.indexOf('page=messages') > -1;
        break;

      case $this.type_buddy:
        returnValue = location.href.indexOf('page=ingame&component=buddies') > -1;
        break;
    }

    return returnValue;
  }
};
ogame.messagemarker = {
  type_chatbar: 10,
  type_chattab: 11,
  action_remove: 20,
  action_add: 21,
  currentCount: '',
  currentSelector: '',
  currentPlayernameObject: '',
  currentListPlayernameObject: '',
  currentPartnerId: '',
  currentListItemSelector: '',
  totalNewMessages: 0,
  playerlist: new Array(),
  newsInitialized: false,
  effect: 'highlight',
  initialize: function () {
    $('.new_msg_count[data-playerid]').each(function () {
      var $this = ogame.messagemarker;
      var playerId = $(this).data('playerid');

      if (playerId && $.inArray(playerId, $this.playerlist) === -1) {
        $this.playerlist.push(playerId);
        $this.setPartnerId(playerId);
        $this.updateNewMarker();
      }
    }); //define effect to indicate new messages

    ogame.messagemarker.effect = 'highlight'; //        $('.new_msg_count.news').each(function() {
    //            var $this = ogame.messagemarker;
    //
    //            if (!$this.newsInitialized) {
    //                var $this = ogame.messagemarker;
    //                $this.newsInitialized = true;
    //                $this.setPartnerId('News');
    ////                $this.updateNewMarker();
    //            }
    //        });
  },
  initMarker: function (playerids) {
    var $this = ogame.messagemarker;
    var chatCount = 0;
    $.each(playerids, function (index, value) {
      $this.setPartnerId(value);
      var messageCount = $('.new_msg_count[data-playerid="' + value + '"]').data('new-messages');

      if (messageCount != null && messageCount > 0) {
        $this.setSelectorByType($this.type_chatbar);
        $this.mark($this.currentSelector, $this.currentPlayernameObject, messageCount);
        $this.mark($this.currentListItemSelector, $this.currentListPlayernameObject, messageCount);
        $this.setSelectorByType($this.type_chattab);
        $this.mark($this.currentSelector, $this.currentPlayernameObject, messageCount);
      }

      chatCount = chatCount + 1;
    });
    return chatCount;
  },
  setCounter: function (partnerId, counter) {
    this.setPartnerId(partnerId);
    $('.new_msg_count[data-playerid="' + this.currentPartnerId + '"]').data('new-messages', counter);
    this.updateNewMarker();
  },
  toggle: function (action, type, partnerId, currentState) {
    this.setPartnerId(partnerId);
    this.currentCount = parseInt($('.new_msg_count[data-playerid="' + this.currentPartnerId + '"]').data('new-messages')); //        this.setSelectorByType(type);

    if (action === this.action_add) {
      //            var newState = parseInt(currentState) + 1;
      //            this.currentCount = this.currentCount + 1;
      //            $.cookie('messageCount' + this.currentPartnerId, this.currentCount);
      this.updateNewMarker(); //            this.addNewMarker();
    }

    if (action === this.action_remove) {
      this.removeNewMarker();
    }
  },
  mark: function (selector, playerObject, count) {
    //        var htmlmarker = '<span class="newMsgMarker"><b><span>( <span class="newMsgCount">'+count+'</span> )</span></b></span>';
    //        $(selector).append(htmlmarker);
    //        playerObject.css('font-weight', 'bold');
    $('.playerlist_item[data-playerid="' + this.currentPartnerId + '"] .playername').css('font-weight', 'bold');
    $('.cb_playername[data-playerid="' + this.currentPartnerId + '"]').css('font-weight', 'bold');
  },
  addNewMarker: function () {
    var added = false;

    if (!$(this.currentSelector).find('.newMsgMarker').length) {
      this.mark(this.currentSelector, this.currentPlayernameObject, this.currentCount);
      added = true;
    }

    if (!$(this.currentListItemSelector).find('.newMsgMarker').length) {
      this.mark(this.currentListItemSelector, this.currentListPlayernameObject, this.currentCount);
      added = true;
    }

    if (!added) {
      this.updateNewMarker();
    }
  },
  removeNewMarker: function () {
    $('.playerlist_item[data-playerid="' + this.currentPartnerId + '"] .playername').css('font-weight', 'normal');
    $('.cb_playername[data-playerid="' + this.currentPartnerId + '"]').css('font-weight', 'normal'); //        $(this.currentSelector).find('.newMsgMarker').remove();
    //        $(this.currentListItemSelector).find('.newMsgMarker').remove();
  },
  updateNewMarker: function () {
    //        var newMarker = $(this.currentSelector).find('.newMsgCount');
    //        var newlistMarker = $(this.currentListItemSelector).find('.newMsgCount');
    //        var currentValue = parseInt(newMarker.html());
    //        newMarker.html(currentValue+1);
    //        newlistMarker.html(currentValue+1);
    //        $(this.currentSelector + ' .new_msg_count').text(currentValue+1).effect('highlight', {}, 500);
    //        $(this.currentListItemSelector + ' .new_msg_count').text(currentValue+1).effect('highlight', {}, 500);
    var newAmount = parseInt($('.new_msg_count[data-playerid="' + this.currentPartnerId + '"]').data('new-messages'));
    var sumNewMessagesChatBefore = $('.new_msg_count.totalChatMessages').text();
    var sumNewMessagesChat = ogame.chat.updateTotalNewChatCounter();

    if (newAmount === 0) {
      if (isNaN(this.currentPartnerId)) {
        $('.new_msg_count.totalMessages.news').text(newAmount).addClass('noMessage');
      } else {
        $('.new_msg_count[data-playerid="' + this.currentPartnerId + '"]').text(newAmount).addClass('noMessage');

        if (sumNewMessagesChat === 0) {
          $('.new_msg_count.totalChatMessages').text(sumNewMessagesChat).addClass('noMessage');
        } else {
          if (sumNewMessagesChatBefore != sumNewMessagesChat) {
            $('.new_msg_count.totalChatMessages').text(sumNewMessagesChat).removeClass('noMessage').effect(ogame.messagemarker.effect, {}, 500);
          }
        }
      }
    } else {
      if (isNaN(this.currentPartnerId)) {
        if (isNaN(newAmount)) {
          $('.new_msg_count.totalMessages.news').text(0).addClass('noMessage');
        } else {
          $('.new_msg_count.totalMessages.news').text(newAmount).removeClass('noMessage').effect(ogame.messagemarker.effect, {}, 500);
        }
      } else {
        $('.msg[data-playerid="' + this.currentPartnerId + '"]').addClass('msg_new');
        $('.new_msg_count[data-playerid="' + this.currentPartnerId + '"]').text(newAmount).removeClass('noMessage').effect(ogame.messagemarker.effect, {}, 500);

        if (sumNewMessagesChatBefore != sumNewMessagesChat) {
          $('.new_msg_count.totalChatMessages').text(sumNewMessagesChat).removeClass('noMessage').effect(ogame.messagemarker.effect, {}, 500);
        }
      }
    } //        $('.new_msg_count.totalChatMessages').text(this.totalNewMessages).effect('highlight', {}, 500);

  },
  setSelectorByType: function (type) {
    selector = '';

    if (type == this.type_chatbar) {
      selector = 'ul.chat_bar_list li.chat_bar_list_item[data-playerid="' + this.currentPartnerId + '"]'; //evtl muss hier noch um die id gnsefsschen
    }

    if (type == this.type_chattab) {
      selector = 'ul#chatMsgList li.msg[data-playerid="' + this.currentPartnerId + '"]'; //evtl muss hier noch um die id gnsefsschen
    }

    this.currentListItemSelector = '.js_playerlist ul.playerlist li.playerlist_item[data-playerid="' + this.currentPartnerId + '"]';
    this.currentSelector = selector;
    this.currentPlayernameObject = $(selector).find('.cb_playername');
    this.currentListPlayernameObject = $(this.currentListItemSelector).find('.playername');
  },
  setPartnerId: function (partnerId) {
    this.currentPartnerId = partnerId;
  }
};
ogame.messages = {
  data: {
    initActions: {
      'tabs-nfFleets': 'initTabFleets',
      'tabs-nfCommunication': 'initTabCommunication',
      'tabs-nfMarket': 'initTabMarket',
      'subtabs-nfCommunicationMessages': 'initSubTabMessages'
    }
  },

  /**
   * Adds a message to the given tab or subtab (whithout check of timestamp,
   * because this will in almost all cases be the newest message)
   *
   **/
  addMessage: function ($tabOrSubtab, msgData, insertAtBeginning) {
    if (insertAtBeginning !== false) {
      insertAtBeginning = true;
    }

    if ($tabOrSubtab.attr('aria-selected') !== 'true') {
      console.warn('addMessage: not correct Tab, aria-selected = ', $tabOrSubtab.attr('aria-selected'), $tabOrSubtab);
      return;
    }

    if (!msgData) {
      console.warn('addMessage: msgData is ', msgData);
      return;
    }

    var tabContentObject = $('#' + $tabOrSubtab.attr('aria-controls')).find('.tab_inner');
    var addBefore = false; //get id of active Tab, create the message and add it

    if (insertAtBeginning) {
      addBefore = true;
    }

    ogame.messages.createMessageItem(msgData, tabContentObject, addBefore);
  },

  /**
   *  Creates a message for tab messages
   *  That can then be inserted upon sending the message
   * @param before
   * @param messageData
   * @param tabObject
   */
  createMessageItem: function (messageData, tabObject, before) {
    var idArray = {};

    for (var msgData in messageData) {
      var data = messageData[msgData];
      idArray[msgData] = data.msgID;
    }

    var ids = JSON.stringify(idArray); // fetch message.tpl.php

    $.ajax({
      url: '?page=messages',
      type: 'POST',
      dataType: 'html',
      data: {
        messageId: ids,
        //details: messageData.detailURL, WTF?
        tabid: this.getCurrentMessageTab(),
        _token: token,
        action: 121,
        // \OGame\Messages\Message::ACTION_ADD
        ajax: 1
      },
      success: function (data) {
        token = data.newAjaxToken;

        if (before) {
          tabObject.prepend(data);
        } else {
          var favCount = tabObject.find('.favoriteCount');

          if (favCount.length > 0) {
            $(data).insertBefore(favCount);
          } else {
            tabObject.append(data);
          }
        }
      },
      error: function (jqXHR, textStatus, errorThrown) {}
    });
  },

  /**
   *  Creates a message (=Rundmail) for the subtab messages
   *  That can then be inserted upon sending the message
   *  @param {String} msgData - Data to fill the message with
  */
  createBroadcastMsgItem: function (msgData) {
    if (!msgData) {
      console.warn('createMessageItem: msgData is missing!');
      return undefined;
    }

    var $msgItemHeader = $('<div class="msg_head"></div>');
    $msgItemHeader.append('<span class="msg_title blue_txt">' + msgData.title + '</span>');
    $msgItemHeader.append('<span class="msg_date fright">' + msgData.date + '</span><br>');
    $msgItemHeader.append('<span class="msg_sender_label">' + loca.LOCA_WRITE_MSG_FROM + ': </span>');
    $msgItemHeader.append('<span class="msg_sender">' + msgData.senderName + '</span>');
    var $msgItemFooter = $('<div class="msg_actions clearfix"></div>');
    $msgItemFooter.append('<a class="fright txt_link overlay" href="' + msgData.detailURL + '" ' + 'data-overlay-title="' + loca.broadcasts + '">' + loca.details + '</a>');
    $msgItemFooter.append('<a class="fright txt_link comments_link overlay" href="' + msgData.commentsURL + '" ' + 'data-overlay-title="' + loca.broadcasts + '">' + msgData.commentsCount + ' <span class="comments"></span></a></a>');
    var $msgItem = $('<li class="msg ' + msgData.newClass + '" data-msg-id="' + msgData.msgID + '"></li>');
    $msgItem.append('<div class="msg_status"></div>');
    $msgItem.append($msgItemHeader);
    $msgItem.append('<span class="msg_content">' + msgData.msgContent + '</span>');
    $msgItem.append($msgItemFooter);
    return $msgItem;
  },

  /**
   * Creates the html elements for the recipients
   * @param {String} recipientId
   * @param {String} recipientCat
   * @param {String} name
   */
  createRecipient: function (recipientId, recipientCat, name) {
    var $inputReplacement, pattern;
    $('.input_replacement').each(function () {
      pattern = new RegExp($(this).data('recipient-cat'));

      if (pattern.test(recipientCat)) {
        $inputReplacement = $(this);
      }
    }); // stop if the corresponding inputbox cannot be found

    if ($inputReplacement === undefined) return;
    var found = $inputReplacement.children('.recipient_txt').filter(function () {
      return $(this).data('recipient-id') === recipientId;
    }); // the element only gets created if it was not there before

    if (found.length === 0) {
      if (!$inputReplacement.hasClass('focus')) {
        $inputReplacement.addClass('focus');
      }

      $inputReplacement.append('<div class="recipient_txt" data-recipient-id="' + recipientId + '" data-recipient-cat="' + recipientCat + '">' + name + '<a role="button" class="remove_recipient"></a></div>');
    }
  },

  /**
   * checks if the given action is valid and calls it
   * @param {String} action - determines which action shall be performed
   * @returns {unresolved}
   */
  doInitAction: function (action) {
    if (typeof ogame.messages[ogame.messages.data.initActions[action]] === 'function') {
      return ogame.messages[ogame.messages.data.initActions[action]]();
    }
  },
  initCombatReportDetails: function () {
    if ($('select').length > 0) {
      $('select').ogameDropDown();
    }
  },

  /**
   * Initializes detail messages
   * @param {Boolean} commentsAllowed - if true, initialize comments as well
   * @returns {undefined}
   */
  initDetailMessages: function (commentsAllowed) {
    $('.detail_list_el:nth-of-type(4n + 3), .detail_list_el:nth-of-type(4n + 4)').addClass("odd"); //max Height of the overlay is browsersize - (header of overlay + a little puffer)

    var newHeight = $(window).height() - 200;
    $('.detail_msg_ctn').css('height', newHeight);
    $('.detail_msg_ctn').mCustomScrollbar({
      theme: "ogame"
    });

    if (commentsAllowed) {
      // we need a a scroll to event, because anker won't work with customScrollbar
      $("#scrollToComments").on('click', function () {
        $('.detail_msg_ctn').mCustomScrollbar('scrollTo', 'bottom');
      });
      initBBCodeEditor(locaKeys, itemNames, false, '.comment_textarea', 2000);
    }

    $('#messages ul.pagination').on('click', 'li.p_li a', function () {
      var currentTab = $(this).data('tabid');
      var messageId = $(this).data('messageid');
      $.post('?page=messages', {
        tabid: currentTab,
        messageId: messageId,
        _token: token,
        ajax: 1
      }, function (data) {
        var ajaxTableContent = $(data).find('#messages .ui-dialog');
        $('.overlayDiv').html(data);
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);
      });
    });
  },
  initMessages: function (messageToken = null) {
    if (messageToken !== null) {
      ogame.messages.token = messageToken;
    }

    $('.js_tabs .tabs_btn_img').each(function () {
      if ($(this).attr('rel')) {
        $(this).attr('href', $(this).attr('rel'));
      }
    });
    ogame.messages.initTabs($('.js_tabs'));
    let currentTab = ogame.messages.getCurrentMessageTab();
    $('#contentWrapper #buttonz div.js_tabs.tabs_wrap.ui-tabs').on('click', 'ul li.list_item', function () {
      currentTab = ogame.messages.getCurrentMessageTab();
    });

    const messageActionAjax = (data, success = null, error = null) => {
      if (!data['_token']) data['_token'] = $("[name='_token']").val();
      if (!data['ajax']) data['ajax'] = 1;
      if (window.location.href.indexOf("page=standalone") > -1) data['standalonePage'] = 1;
      $.ajax({
        type: 'POST',
        url: '?page=messages',
        dataType: 'json',
        data: data,
        success: function (returnData) {
          if (returnData['newAjaxToken']) {
            token = returnData.newAjaxToken;
            $("[name='_token']").val(returnData.newAjaxToken);
          }

          if (success) {
            success(returnData);
          }
        },
        error: function () {
          if (error !== null) {
            error();
          }
        }
      });
    };

    $('body').on('click', '.msg_actions .icon_not_favorited', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id') || $(this).parents('div.detail_msg').data('msg-id'); // \OGame\Messages\Message::ACTION_ARCHIVE == 101

      messageActionAjax({
        tabid: currentTab,
        messageId: messageId,
        _token: token,
        action: 101
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId]['result'] == true) {
          let realTarget;

          if ($(event.target).is('img')) {
            $(event.target).attr('src', $(event.target).attr('src').replace('not_favorited', 'favorited'));
            $(event.target).parent().removeClass('icon_not_favorited').addClass('icon_favorited');
            realTarget = $(event.target).parent();
          } else {
            $(event.target).removeClass('icon_not_favorited').addClass('icon_favorited');
            $(event.target).find('img').attr('src', $(event.target).find('img').attr('src').replace('not_favorited', 'favorited'));
            realTarget = $(event.target);
          }

          changeTooltip($(realTarget), loca.LOCA_MSG_DELETE_FAV);
          var $counter = $('.favoriteTabFreeSlotCount');
          $counter.html(parseInt($counter.html()) - 1);
        } else if (data[messageId]['reason'] !== 'undefined') {
          fadeBox(data[messageId]['reason'], 1);
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.msg_actions .icon_favorited', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id') || $(this).parents('div.detail_msg').data('msg-id');
      ; // \OGame\Messages\Message::ACTION_ARCHIVE_REMOVE == 102

      messageActionAjax({
        tabid: currentTab,
        messageId: messageId,
        _token: token,
        action: 102
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId]['result'] == true) {
          let realTarget;

          if ($(event.target).is('img')) {
            $(event.target).attr('src', $(event.target).attr('src').replace('favorited', 'not_favorited'));
            $(event.target).parent().removeClass('icon_favorited').addClass('icon_not_favorited');
            realTarget = $(event.target).parent();
          } else {
            $(event.target).removeClass('icon_favorited').addClass('icon_not_favorited');
            $(event.target).find('img').attr('src', $(event.target).find('img').attr('src').replace('favorited', 'not_favorited'));
            realTarget = $(event.target);
          }

          changeTooltip($(realTarget), loca.LOCA_MSG_ADD_FAV);
          var $counter = $('.favoriteTabFreeSlotCount');
          $counter.html(parseInt($counter.html()) + 1);
        } else if (data[messageId]['reason'] !== 'undefined') {
          fadeBox(data[messageId]['reason'], 1);
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionKill', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id'); // \OGame\Messages\Message::ACTION_KILL == 103

      messageActionAjax({
        messageId: messageId,
        _token: token,
        action: 103
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId] == true) {
          $(event.target).parents('li.msg').remove();
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionKillAll', function (event) {
      // \OGame\Messages\Message::ACTION_KILL == 103
      messageActionAjax({
        tabid: ogame.messages.getCurrentMessageTab(),
        messageId: -1,
        _token: token,
        action: 103
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data["result"] == true) {
          location.reload();
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionKillDetail', function (event) {
      var messageId = $('.detail_msg').data('msg-id'); // \OGame\Messages\Message::ACTION_KILL == 103

      messageActionAjax({
        messageId: messageId,
        _token: token,
        action: 103
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId] == true) {
          location.reload();
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionRevive', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id');

      if (messageId === undefined) {
        messageId = $(this).parents('div.detail_msg').data('msg-id');
      } // \OGame\Messages\Message::ACTION_REVIVE == 104


      messageActionAjax({
        tabid: currentTab,
        messageId: messageId,
        _token: token,
        action: 104
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId] == true) {
          //in message list view
          $(event.target).parents('li.msg').remove(); //in message detail view

          $(event.target).parents('div.ui-dialog').remove();
          $('li.msg[data-msg-id=' + messageId + ']').remove();

          if (window.location.href.indexOf("page=standalone") > -1) {
            location.reload();
          }
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionReviveAll', function (event) {
      // \OGame\Messages\Message::ACTION_REVIVE == 104
      messageActionAjax({
        tabid: ogame.messages.getCurrentMessageTab(),
        messageId: -1,
        _token: token,
        action: 104
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data["result"] == true) {
          location.reload();
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionDelete', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id');

      if (!messageId) {
        messageId = $(this).parents('div.detail_msg').data('msg-id');
      } // \OGame\Messages\Message::ACTION_DELETE == 105


      messageActionAjax({
        tabid: currentTab,
        messageId: messageId,
        _token: token,
        action: 105
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data[messageId] == true) {
          $(event.target).parents('li.msg').remove();

          if (window.location.href.indexOf("page=standalone") > -1) {
            location.replace('index.php?page=ingame&component=overview');
          }
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.js_actionDeleteAll', function (event) {
      var messageId = $(this).parents('li.msg').data('msg-id'); // \OGame\Messages\Message::ACTION_DELETE == 105

      messageActionAjax({
        tabid: ogame.messages.getCurrentMessageTab(),
        messageId: -1,
        _token: token,
        action: 105
      }, data => {
        token = data.newAjaxToken;
        $("[name='_token']").val(data.newAjaxToken);

        if (data["result"] == true) {
          location.reload();
        } else {
          fadeBox(loca.LOCA_GALAXY_ERROR_OCCURED, 1);
        }
      });
    }).on('click', '.paginator', function (event) {
      var currentTab = $(this).data('tab');
      var page = $(this).data('page');
      var bla = $(this).closest('div[class^="ui-tabs-panel"]');
      let newToken = $("[name='_token']").val();
      $.ajax({
        type: 'POST',
        url: '?page=messages',
        dataType: 'html',
        data: {
          messageId: -1,
          tabid: currentTab,
          action: 107,
          pagination: page,
          ajax: 1,
          _token: newToken,
          standalonePage: window.location.href.indexOf("page=standalone") > -1 ? 1 : 0
        },
        success: function (data) {
          if (data['newAjaxToken']) {
            token = data.newAjaxToken;
            $("[name='_token']").val(data.newAjaxToken);
          }

          bla.html(data);
        },
        error: function () {}
      });
    }).on('click', '.jumpToAllianceApplications', function (event) {
      location.href = 'index.php?page=ingame&component=alliance&tab=applications';
    }).on('click', 'a.js_actionCollect', function (event) {
      event.preventDefault();
      let url = $(event.currentTarget).attr('href');
      $.ajax({
        type: 'POST',
        url: url,
        dataType: 'json',
        data: {
          new_token: ogame.messages.marketToken || ''
        },
        success: function (data) {
          let status = data.status || 'failure';
          let statusMessage = data.statusMessage || '';

          if (status === 'success') {
            ogame.messages.marketToken = data.newToken;
            $(event.currentTarget).hide();
            $(event.currentTarget).replaceWith(statusMessage);
            fadeBox(data.message || '', false);
            getAjaxResourcebox();
          }

          if (status === 'failure') {
            let error = data.errors[0] || undefined;

            if (error) {
              fadeBox(error.message, true);
            }
          }
        },
        error: function (data) {}
      });
    });
  },
  selectCurrentMessageTab: function () {
    var currentTab = $('.subtabs .ui-state-active:visible');

    if (!currentTab.length) {
      // none of the subTabs is visible
      currentTab = $('.js_tabs .ui-state-active:visible');
    }

    return currentTab;
  },
  getCurrentMessageTab: function () {
    var currentTab = $('.subtabs .ui-state-active:visible').attr('data-tabid');

    if (!currentTab) {
      // none of the subTabs is visible
      currentTab = $('.js_tabs .ui-state-active:visible').attr('data-tabid');
    }

    return currentTab;
  },
  getCurrentEarliestMessage: function () {
    //console.log($('.ui-tabs-panel .tab_inner .msg:visible'));
    return $('.ui-tabs-panel .tab_inner .msg:visible').last().attr('data-msg-id');
  },
  initCommentForm: function () {
    ogame.messages.initWriteNewMsgBox($('#newCommentForm'));
    $('#newCommentForm').on('click', '.js_send_comment', function (e) {
      let newToken = $("[name='_token']").val();
      e.preventDefault();
      var $myForm = $(this).closest('form');
      var $messageId = $myForm.find('input[name=messageId]').val();
      $.ajax({
        type: 'POST',
        url: $myForm.attr('action'),
        dataType: 'json',
        data: {
          messageId: $messageId,
          ajax: 1,
          action: 108,
          // \OGame\Messages\Message::ACTION_COMMENT
          text: $myForm.find('textarea[name=text]').val(),
          _token: newToken,
          standalonePage: window.location.href.indexOf("page=standalone") > -1 ? 1 : 0
        },
        success: function (data) {
          if (data['newAjaxToken']) {
            token = data.newAjaxToken;
            $("[name='_token']").val(data.newAjaxToken);
          }

          fadeBox(data.message, data.error);
          $myForm.find('textarea[name=text]').val('');
          $myForm.parent().after('<li class="msg"><div class="msg_status"></div><div class="msg_head">' + data.commentheader + '</div><div class="msg_content">' + data.commentcontent + '</div></li>');
          $('#scrollToComments').text(data.commentcount);
        },
        error: function (data) {}
      });
    });
  },

  /**
   * initializes the overlay for sharing reports
   * @returns {undefined}
   */
  initShareReportOverlay: function () {
    ogame.messages.initWriteNewMsgBox($('#newSharedReportForm'));
    $('#newSharedReportForm').on('click', '.js_send_msg_share', function (e) {
      e.preventDefault();
      var $myForm = $(this).closest('form');
      var $messageId = $myForm.find('input[name=messageId]').val();
      let newToken = $("[name='_token']").val();
      var $empfaenger = $myForm.find('li.select2-selection__choice');
      var $myData = [];
      $empfaenger.each(function () {
        $myData.push($(this).attr('title'));
      });
      $.ajax({
        type: 'POST',
        url: $myForm.attr('action'),
        dataType: 'json',
        data: {
          messageId: $messageId,
          empfaenger: $myData,
          ajax: 1,
          action: 106,
          // \OGame\Messages\Message::ACTION_SHARE
          text: $myForm.find('textarea[name=text]').val(),
          _token: newToken,
          standalonePage: window.location.href.indexOf("page=standalone") > -1 ? 1 : 0
        },
        success: function (data) {
          if (data['newAjaxToken']) {
            token = data.newAjaxToken;
            $("[name='_token']").val(data.newAjaxToken);
          }

          fadeBox(data.message, data.error);
          $myForm.closest('div[class^="overlayDiv"]').remove();
        },
        error: function (data) {}
      });
    });
  },

  /**
   * initializes the subtab messages where user can write messages (=Rundmails)
   * to members of their allies and federates
   * @returns {undefined}
   */
  initSubTabMessages: function () {
    // accordion initialized here, because this is the only tab where it is needed
    $('.js_accordion').accordion({
      collapsible: true,
      heightStyle: 'content',
      active: false // @TODO: this needs to be updated when the accordion was open on tab/page change

    });
    ogame.messages.initWriteNewMsgBox($('#newMsgForm'));
    $('html').off('.subtabmessages');
    $('#newMsgForm').on('click.subtabmessages', '.js_send_msg', function (e) {
      e.preventDefault();
      var $myForm = $(this).parents('form');
      let newToken = $("[name='_token']").val();
      var recipientIDs = {};
      $('.input_replacement').children().each(function () {
        if (typeof recipientIDs[$(this).data('recipient-cat')] == 'undefined') {
          recipientIDs[$(this).data('recipient-cat')] = [];
        }

        recipientIDs[$(this).data('recipient-cat')].push($(this).data('recipient-id'));
      });
      $.ajax({
        type: 'POST',
        url: $myForm.attr('action'),
        dataType: 'json',
        data: {
          empfaenger: recipientIDs,
          _token: newToken,
          text: $myForm.find('.new_msg_textarea').val()
        },
        success: function (data) {
          if (data['newAjaxToken']) {
            token = data.newAjaxToken;
            $("[name='_token']").val(data.newAjaxToken);
          }

          fadeBox(data.message, data.error); // add message to this tab if successful todo real data for inserted message needed from php

          if (!data.error) {
            ogame.messages.sendSubtabMsg($('.new_msg_textarea').val(), recipientIDs);
          }
        },
        error: function () {}
      }); // @TODO: clear input from message box and recipient fields
    });
  },
  initTabCommunication: function () {
    ogame.messages.initTabs($('.js_subtabs_communication'));
  },
  initTabFleets: function () {
    // using a callback function here, because it is the same function for every subtab of fleets
    ogame.messages.initTabs($('.js_subtabs_fleets'), ogame.messages.initTrash);
  },
  initTabMarket: function () {
    ogame.messages.initTabs($('.js_subtabs_market'), ogame.messages.initTrash);
  },

  /**
   * Wrapper for the initialization of tabs
   * @param {JQuery Object} $el - Element to attach tabs to
   * @param {Function} callbackFunc - a Function to be called after the tabs are loaded
   * @returns {undefined}
   */
  initTabs: function ($el, callbackFunc) {
    $el.tabs({
      beforeLoad: function () {
        $('.ajax_load_shadow').show();
      },
      load: function (e, el) {
        //console.info("load",el.tab.attr('id'));
        // select functions to initzialize based on id of active tab
        ogame.messages.doInitAction(el.tab.attr('id'));
        $('.ajax_load_shadow').hide(); // call the additional callback if one was given

        if (typeof callbackFunc === 'function') {
          callbackFunc(el.tab);
        }
      },
      // create is only called once when the tabs are created
      create: function (e, el) {
        ogame.messages.doInitAction(el.tab.attr('id'));
      }
    });
  },

  /**
   *
   */
  initTrash: function ($activeTab) {
    if (!$activeTab) return;
    $('.js_active_tab').html($activeTab.data('subtabname'));

    if ($activeTab.attr('id') === 'subtabs-nfFleetTrash' || $activeTab.attr('id') === 'subtabs-nfMarketTrash') {
      $('.trash_box').addClass('trash_open');
      $('.in_trash').show();
      $('.not_in_trash').hide();
    } else {
      $('.trash_box').removeClass('trash_open');
      $('.in_trash').hide();
      $('.not_in_trash').show();
    }
  },

  /**
   * Initializes the functions and events that are necessary for writing a new message
   * (Used on newsfeed for broadcast messages and new shared reports)
   * @param {Jquery Object} $newMsgForm - Element to attach the new message events to
   * @returns {undefined}
  */
  initWriteNewMsgBox: function ($newMsgForm) {
    initBBCodeEditor(locaKeys, itemNames, false, '.new_msg_textarea', 2000);
    $('html').off('.writeNewMsgBox'); // SubTabMessages - close any open recipient select boxes when clicking outside the box:

    $('html').on('click.writeNewMsgBox', function (e) {
      if ($('.new_msg_label').hasClass('open') && $(e.target).parents('.recipient_select_box').length < 1) {
        $('.input_replacement').removeClass('focus');
        $('.new_msg_label').removeClass('open');
        $('.new_msg_label').siblings('.recipient_select_box').hide();
      }
    });
    $newMsgForm.on('click.writeNewMsgBox', '.input_replacement', function (e) {
      e.stopPropagation();
      ogame.messages.toggleRecipientSelectBox($(e.target).data('recipient-cat'));
    }).on('click.writeNewMsgBox', '.new_msg_label', function (e) {
      e.stopPropagation();
      ogame.messages.toggleRecipientSelectBox($(e.currentTarget).data('recipient-cat'));
    }).on('click.writeNewMsgBox', '.recipient_select_box .ally_rank', function () {
      ogame.messages.toggleRecipientSelection($(this));
    })
    /*           .on('click.writeNewMsgBox', '.js_all_recipients', function() {
                   ogame.messages.toggleSelectAllRecipients($(this));
               })*/
    .on('click.writeNewMsgBox', '.remove_recipient', function () {
      ogame.messages.removeRecipient($(this).closest('.recipient_txt').data('recipient-id'));
    });
  },

  /**
   * Remove Recipient from input field and remove corresponding selection
   * @param {type} recipientId
   * @returns {undefined}
   */
  removeRecipient: function (recipientId) {
    $('.ally_rank').filter(function () {
      if ($(this).data('recipient-id') === recipientId) {
        $(this).removeClass('selected');
      }
    });
    $('.recipient_txt').filter(function () {
      if ($(this).data('recipient-id') === recipientId) {
        $(this).remove();
      }
    });
  },
  sendSubtabMsg: function (msg, recipientIDs) {
    if (!msg) {
      // @TODO: show warning
      console.warn('sendSubtabMsg: msg was empty');
      return;
    }

    if (!recipientIDs) {
      // @TODO: show warning
      console.warn('sendSubtabMsg: msg had no recipients');
      return;
    }

    var msgData = {};
    msgData.date = getFormatedDate(serverTime.getTime(), '[d].[m].[Y] <span>[H]:[i]:[s]</span>');
    msgData.newClass = 'msg_new';
    msgData.title = recipientIDs;
    msgData.senderName = '100011'; // needs to be id of current player, where do we get it from?

    msgData.msgID = '111'; // this is probably some unique number

    msgData.msgContent = msg;
    msgData.commentsURL = '';
    msgData.detailURL = '';
    msgData.commentsCount = 0;
    var data = array(msgData); // @TODO: Tell Backend that theres a new message that has to be sent and processed

    ogame.messages.addMessage($('#subtabs-nfCommunicationMessages'), data);
  },

  /**
   * toggle the box for recipient selection with the correct category
   * @param {String} recipientCat - category of recipients
   * @returns {undefined}
   */
  toggleRecipientSelectBox: function (recipientCat) {
    $('.input_replacement').filter(function () {
      if ($(this).data('recipient-cat') === recipientCat && !$(this).hasClass('focus')) {
        $(this).addClass('focus');
      }
    });
    $('.new_msg_label').filter(function () {
      var $currNewMsgLabel = $(this);

      if ($currNewMsgLabel.data('recipient-cat') === recipientCat) {
        if ($currNewMsgLabel.hasClass('open')) {
          //hide current
          $currNewMsgLabel.removeClass('open').siblings('.recipient_select_box').hide();
        } else {
          var $recipientSelectBox = $currNewMsgLabel.siblings('.recipient_select_box'),
              $scrollBox = $recipientSelectBox.find('.scroll_box'); // hide all

          $('.new_msg_label').removeClass('open').siblings('.recipient_select_box').hide(); // show current

          $currNewMsgLabel.addClass('open');
          $recipientSelectBox.show();
          $scrollBox.hasClass('mCustomScrollbar') ? $scrollBox.mCustomScrollbar('update') : $scrollBox.mCustomScrollbar();
        }
      }
    });
  },

  /**
   * add the clicked element to the corresponding list of recipients if it is
   * not yet in the list, remove it from the list otherwise.
   * @param $recipientLiEl
   */
  toggleRecipientSelection: function ($recipientLiEl) {
    var recipientCat = $recipientLiEl.data('recipient-cat'),
        recipientId = $recipientLiEl.data('recipient-id'); // some ranks (i.e. "founder of the ally") cannot be deselected

    if ($recipientLiEl.hasClass('always_selected')) return;

    if ($recipientLiEl.hasClass('complete_ally')) {
      ogame.messages.toggleSelectAllRecipients(recipientCat);
      return;
    }

    if (!$recipientLiEl.hasClass('selected')) {
      ogame.messages.createRecipient(recipientId, recipientCat, $recipientLiEl.html());
      $recipientLiEl.addClass('selected');
    } else {
      ogame.messages.removeRecipient(recipientId);
    }
  },

  /**
   * toggle the selection of all recipients from a given list
   */
  toggleSelectAllRecipients: function (currCat) {
    var cASelected = $('.complete_ally').hasClass('selected'),
        recipientId = cASelected ? '255' : '1',
        name = cASelected ? 'loca.founder' : 'loca.completeAlliance';
    $('.input_replacement').children().remove();
    ogame.messages.createRecipient(recipientId, currCat, name);
    $('.recipient_list').filter(function () {
      if ($(this).data('recipient-cat') === currCat) {
        $(this).find('.ally_rank').each(function () {
          if (!$(this).hasClass('always_selected')) {
            cASelected ? $(this).removeClass('selected') : $(this).addClass('selected');
          }
        });
      }
    });
  }
}; // Old Messages Code below this line:
// this seems to only get used in the showmessage.tpl.php which is only called on galaxy.inc.tpl.php and jumpgate.tpl.php
// @TODO is it depreceated???

function initShowMessage() {
  var $dialog = $('.overlayDiv[data-page="showmessage"]');
  $(".answerHeadline", $dialog).click(function () {
    $(this).toggleClass("open");

    if ($(this).hasClass("open")) {
      $(".answerForm", $dialog).show();
      $(".textWrapper", $dialog).addClass("textWrapperSmall");
      $(".textWrapper", $dialog).removeClass("textWrapper");
    } else {
      $(".answerForm", $dialog).hide();
      $(".textWrapperSmall", $dialog).addClass("textWrapper");
      $(".textWrapperSmall", $dialog).removeClass("textWrapperSmall");
    }
  });
  $(".note > div:first-child", $dialog).addClass("newMessage");
  $(".info:odd", $dialog).css("margin-left", "40px");
  $("div.note p:first").after("<span class=\"seperator\">");
  $('.answerHeadline', $dialog).hover(function () {
    $(this).addClass("pushable");
  }, function () {
    $(this).removeClass("pushable");
  });
  $(".melden", $dialog).click(function () {
    manageErrorbox($(this).attr("rel"), 1);
  });
}

function initNetworkAjax() {
  var $myRiders = $(".reiter");

  if (!$.isFunction(clickFunction)) {
    var clickFunction = function () {
      $myRiders.removeClass("active");
      $(this).addClass("active");
      ajaxLoad($(this).attr("id"), 1);
    };
  }

  $myRiders.off('click');
  $myRiders.click(clickFunction);
  $("#checkAll").off('click').click(function () {
    $(".checker").prop("checked", $(this).is(':checked'));
  });

  function hide(id) {
    $("#TR" + id).hide();
  }

  $(".overlay").click(function () {
    var msg_id = $(this).attr("id");
    markAsRead(msg_id);
  });
  $("#messageContent select").change(function () {
    if (typeof $("select option:selected").attr("id") == "undefined") {
      $(".buttonOK").hide();
      mod = "";
    } else {
      $(".buttonOK").show();
      mod = $("select option:selected").attr("id");
    }
  });
  $(".del").click(function () {
    mod = $(this).attr("id");
  });
  $(".underlined").click(function () {
    $(".buttonOK").hide();
  });
  reduceMsgCount(aktCat);
}
ogame.messages.combatreport = {
  data: [{
    'combatReportId': $('.detailReport').attr('data-combatreportid')
  }],
  loca: [{
    'weapon': '',
    'shield': '',
    'cover': ''
  }],
  // __________________________________________________________ATTRIBUTES__________________________________________________________

  /**
   * get the attributes by the active member(s)
   *
   * @see ogame.messages.combatreport.setCombatArray >> $this.data.combatArray, $this.data.activeMember must be set
   * @return object result 	>> 'armorPercentage': armorpower in percentage
   * 							>> 'weaponPercentage': weaponpower in percentage
   * 							>> 'shieldPercentage': shieldpower in percentage
   */
  getCombatValueByCombatMember: function () {
    var $this = ogame.messages.combatreport;
    var member = $this.data.activeMember;
    var result = {
      'armorPercentage': 0,
      'weaponPercentage': 0,
      'shieldPercentage': 0,
      'characterClassName': '-'
    };
    var countit = 0;
    $.each($this.data.combatArray, function (key, combatMember) {
      //if activeMember not selected and on default add all attributes of all combatMembers
      if ($this.check(true, member, {
        'values': {
          'is': {
            0: 'all'
          }
        }
      })) {
        result.armorPercentage += combatMember.armorPercentage;
        result.weaponPercentage += combatMember.weaponPercentage;
        result.shieldPercentage += combatMember.shieldPercentage;
        countit++;
      } else {
        if (combatMember.ownerName == member) {
          result.armorPercentage = combatMember.armorPercentage;
          result.weaponPercentage = combatMember.weaponPercentage;
          result.shieldPercentage = combatMember.shieldPercentage;
          result.characterClassName = combatMember.ownerCharacterClassName;
          countit = 1;
        }
      }
    });
    result.armorPercentage = Math.round(result.armorPercentage / countit);
    result.weaponPercentage = Math.round(result.weaponPercentage / countit);
    result.shieldPercentage = Math.round(result.shieldPercentage / countit);
    return result;
  },

  /**
   * Set the combatMember attributes
   *
   * @see ogame.messages.combatreport.getCombatValueByCombatMember >> resultArray with armor, weapon and shield must be set
   * @see ogame.messages.combatreport.setCombatArray >> combatside must be set
   */
  setCombatValue: function () {
    var $this = ogame.messages.combatreport; //set attributes by new combatmember

    var result = $this.getCombatValueByCombatMember();
    $('.' + $this.data.combatside + 'CharacterClass').text($this.loca.characterClass + ' ' + result.characterClassName);
    $('.' + $this.data.combatside + 'Weapon').text($this.loca.weapon + ' ' + result.weaponPercentage + '%');
    $('.' + $this.data.combatside + 'Shield').text($this.loca.shield + ' ' + result.shieldPercentage + '%');
    $('.' + $this.data.combatside + 'Cover').text($this.loca.cover + ' ' + result.armorPercentage + '%');
  },
  setCombatLoca: function (loca_weapon, loca_shield, loca_cover, loca_characterClass) {
    var $this = ogame.messages.combatreport;
    $this.loca.weapon = loca_weapon;
    $this.loca.shield = loca_shield;
    $this.loca.cover = loca_cover;
    $this.loca.characterClass = loca_characterClass;
  },
  // __________________________________________________________ACTIVESTATE__________________________________________________________

  /**
   * returns if a ship is active in the combat
   *
   * @param int id				>> shipid to proof
   * @param object membersArray	>> memberid: object	>> id
   *
   * @return string returningValue	>> 'on'||'off' -> for image-css-class
   */
  isActive: function (id, membersArray) {
    var $this = ogame.messages.combatreport; // if shipid is not in the membersArray the shipimage is not active (off)

    for (var key in membersArray) {
      if (key == 'length') {
        continue;
      }

      if ($this.check(true, membersArray[key][id])) {
        return 'on';
      }
    }

    ;

    if ($this.check(true, membersArray[id])) {
      return 'on';
    }

    return 'off';
  },

  /**
   * set the active class for all ships
   *
   * @param object allShipObjects	>> classes of all shipfields
   * @param object activeShips	>> all active ships
   */
  setActiveFlag4Fleet: function (allShipObjects, activeShips) {
    var $this = ogame.messages.combatreport;
    var allShipClasses = $this.getAllShipClasses(allShipObjects);
    $.each(allShipClasses, function (key, classname) {
      var currentShipId = $this.getShipIdByClass(classname);
      var isActiveClass = $this.isActive(currentShipId, activeShips);
      var selector = $this.getShipSelectors(currentShipId);
      $this.changeShipState(isActiveClass, selector['ship']); //clear count

      if (isActiveClass == 'off') {
        var shipSelector = selector['shipCount'];
        var lossSelector = selector['loss'];
        var counts = {
          'ships': {},
          'losses': {}
        };
        counts['ships'][shipSelector] = 0;
        counts['losses'][lossSelector] = "";
        $this.setShipCount(counts);
      }

      $this.toggleShipShowState(selector['ship']);
    });
  },

  /**
   * Search for the right class of the given shipID
   *
   * @param object possibleCategories >> shipcategories to get the right classname for id
   * @param int id >> shipid for searching
   *
   * @return string|bool classname|false	>> returns the classname if it exists else false
   */
  search4Class: function (possibleCategories, id) {
    for (var index in possibleCategories) {
      if ($('.' + possibleCategories[index] + id)[0]) {
        var classname = possibleCategories[index] + id;
        return classname;
      }
    }

    return false;
  },

  /**
   * Get an Object with ship- and lossselector
   *
   * @param mixed shipID	>> can be a string or a number, id of the ship
   *
   * @return object result	>> 'ship': selector
   * 								'shipCount': selector
   * 								'loss': selector
   */
  getShipSelectors: function (shipID) {
    var $this = ogame.messages.combatreport;
    var possibleShipClasses = ['military', 'civil', 'defense'];
    var classname = $this.search4Class(possibleShipClasses, shipID);
    var shipSelector = '.' + $this.data.combatside + ' .' + classname;
    var shipCountSelector = '.' + $this.data.combatside + ' .' + classname + ' .ecke';
    var lossCountSelector = '.' + $this.data.combatside + ' .' + classname + ' .lost_ships';
    var result = {
      'ship': shipSelector,
      'shipCount': shipCountSelector,
      'loss': lossCountSelector
    };
    return result;
  },

  /**
   * Get the shipid in the given class
   *
   * @param string classname	>> class of one shipobject
   *
   * @return string shipID
   */
  getShipIdByClass: function (classname) {
    var classlength = classname.length;
    var shipID = classname.substr(classlength - 3);
    return shipID;
  },

  /**
   * change the active state of shipfield
   *
   * @see ogame.messages.combatreport.setActiveFlag4Fleet
   * @param string newState >> the state to set
   * @param string selector >> the selector of the image
   */
  changeShipState: function (newState, selector) {
    if ($(selector).hasClass('off') && newState != 'off') {
      $(selector).removeClass('off');
    }

    if ($(selector).hasClass('on') && newState != 'on') {
      $(selector).removeClass('on');
    }

    if (!$(selector).hasClass(newState)) {
      $(selector).addClass(newState);
    }
  },

  /**
   * remove the ship if its marked as disabled and show all non disabled ships
   *
   * @param string selector >> the selector of the image
   */
  toggleShipShowState: function (selector) {
    if ($(selector).hasClass('off')) {
      $(selector).parent().hide();
    }

    if ($(selector).hasClass('on')) {
      $(selector).parent().show();
    }
  },
  // __________________________________________________________SHIPS__________________________________________________________

  /**
   * get only the ships of the active member(s)
   *
   * @param string member	>> selected combatMember
   *
   * @return object ships
   */
  getShipsByMembers: function (member) {
    var $this = ogame.messages.combatreport;
    var ships = [];

    if (!$this.check(true, $this.data.combatArray.shipDetails)) {
      $.each($this.data.combatArray, function (key, combatMember) {
        if (typeof combatMember == "object" && typeof combatMember.shipDetails != "undefined") {
          if (typeof ships[combatMember.ownerName] != "undefined") {
            $.extend(ships[combatMember.ownerName], combatMember.shipDetails);
          } else {
            ships[combatMember.ownerName] = combatMember.shipDetails;
          }
        } else {
          if (typeof ships[combatMember.ownerName] == "undefined") {
            ships[combatMember.ownerName] = {};
          }
        }
      });
    } else {
      if (typeof ships[$this.data.combatArray.ownerName] != "undefined") {
        $.extend(ships[$this.data.combatArray.ownerName], $this.data.combatArray.shipDetails);
      } else {
        ships[$this.data.combatArray.ownerName] = $this.data.combatArray.shipDetails;
      }
    }

    if (member == 'all') {
      return ships;
    } else {
      return ships[member];
    }
  },

  /**
   * get only the ships of the active member(s) and selected planet/moon
   *
   * @param member string	>> selected combatMember
   * @param coords string >> coordinates of Planet/Moon
   * @param type int >> 1 = planet, 3 = moon
   * @param combatSim boolean
   * @return object ships
   */
  getShipsByMembersAndCoords: function (member, coords, type) {
    var $this = ogame.messages.combatreport;
    var ships = [];

    if (!$this.check(true, $this.data.combatArray.shipDetails)) {
      $.each($this.data.combatArray, function (key, combatMember) {
        if (coords !== 0) {
          // a location was selected , so we need to filter based on owner name, coordinates and type
          if (typeof combatMember == "object" && typeof combatMember.shipDetails != "undefined") {
            if (combatMember.ownerCoordinates === coords && combatMember.ownerName == member && combatMember.ownerPlanetType == type) {
              if (typeof ships[combatMember.ownerName] != "undefined") {
                $.extend(ships[combatMember.ownerName], combatMember.shipDetails);
              } else {
                ships[combatMember.ownerName] = combatMember.shipDetails;
              }
            }
          }
        } else {
          // an owner name was selected incl. all, so we will group ships based on Owner names)
          if (typeof combatMember == "object" && typeof combatMember.shipDetails != "undefined") {
            if (typeof ships[combatMember.ownerName] != "undefined") {
              $.extend(ships[combatMember.ownerName], combatMember.shipDetails);
            } else {
              ships[combatMember.ownerName] = combatMember.shipDetails;
            }
          }
        }
      });
    } else {
      // This part of code was there, I have no clue why :D
      if (typeof ships[$this.data.combatArray.ownerName] != "undefined") {
        $.extend(ships[$this.data.combatArray.ownerName], $this.data.combatArray.shipDetails);
      } else {
        ships[$this.data.combatArray.ownerName] = $this.data.combatArray.shipDetails;
      }
    }

    if (member == 'all') {
      return ships;
    } else {
      return ships[member];
    }
  },

  /**
   * Get the Array with counts und selectors to set the count of the ships
   *
   * @param object ships	>> shipID: count
   * @param object losses	>> shipID: count
   *
   * @return object combatCountArray 	>> 'ships': object >> selector: count
   * 									>> 'losses': object >> selector: -count
   */
  getShipCountArray: function (ships, losses) {
    var $this = ogame.messages.combatreport;
    var noLosses = $this.check(true, losses, {
      'types': {
        0: 'isEmpty'
      }
    }) ? false : true; //var noLosses = losses == null || typeof losses == "undefined" || jQuery.isEmptyObject(losses) ? true : false;

    var combatShipsArray = {};
    var combatLossArray = {};

    for (var shipID in ships) {
      var selector = $this.getShipSelectors(shipID);
      var shipSelector = selector['shipCount'];
      combatShipsArray[shipSelector] = parseInt(ships[shipID]);

      if (!noLosses) {
        var lossSelector = selector['loss'];

        if ($this.check(true, losses[shipID])) {
          combatLossArray[lossSelector] = parseInt(losses[shipID]);
        }
      }
    }

    var combatCountArray = {
      'ships': combatShipsArray,
      'losses': combatLossArray
    };
    return combatCountArray;
  },

  /**
   * set the count of active ships by shipcountarray
   *
   * @param object shipArray	>> 'ships': object	>> memberID: object	>> shipID: count
   */
  setShipCount4All: function (shipArray) {
    var $this = ogame.messages.combatreport;
    var ships = shipArray['ships'];
    var losses = $this.check(true, shipArray['losses']) ? shipArray['losses'] : {};
    var combatResultArray = {};

    for (var index in ships) {
      var ship = ships[index];
      var loss = $this.check(true, losses, {
        'types': {
          0: 'isEmpty'
        }
      }) && $this.check(true, losses[index]) ? losses[index] : {};
      combatResultArray[index] = $this.getShipCountArray(ship, loss);
    }

    var shipResult = {};
    var lossResult = {};

    for (var memberIndex in combatResultArray) {
      var memberShipArray = combatResultArray[memberIndex]['ships'];
      var memberLossArray = combatResultArray[memberIndex]['losses'];

      for (var shipid in memberShipArray) {
        if ($this.check(true, shipResult[shipid])) {
          shipResult[shipid] = shipResult[shipid] + memberShipArray[shipid];
        } else {
          shipResult[shipid] = memberShipArray[shipid];
        }
      }

      for (var shipid in memberLossArray) {
        if ($this.check(true, lossResult[shipid])) {
          lossResult[shipid] = lossResult[shipid] + memberLossArray[shipid];
        } else {
          lossResult[shipid] = memberLossArray[shipid];
        }
      }
    }

    var resultCountArray = {
      'ships': shipResult,
      'losses': lossResult
    };
    $this.setShipCount(resultCountArray);
  },

  /**
   * set the Shipcount if a specific combatMember is selected
   *
   * @param resultCombatArray object 	>> 'ships': object	>> memberID: object	>> shipID: count
   * 								   	>> 'losses': object	.. (could be null or empty)
   * @param memberArray object		>> memberID: object >> 'ownerName': name
   * @param activeMember string		>> selected member in Dropdown
      * @param coords string             >> coordinates of planet/moon
      * @param planetType int                  >> 1= planet, 3= moon
   */
  setShipCountByActiveMember: function (resultCombatArray, memberArray, activeMember, coords, planetType) {
    coords = coords || 0;
    planetType = planetType || 1;
    var $this = ogame.messages.combatreport;
    var shipCounts = {};
    var lossCounts = {};

    for (var memberID in memberArray) {
      var ownerName = memberArray[memberID]['ownerName'];
      var ownerCoordinates = memberArray[memberID]['ownerCoordinates'];
      var ownerPlanetType = memberArray[memberID]['ownerPlanetType'];

      if (ownerName == activeMember) {
        for (var attr in resultCombatArray['ships'][memberID]) {
          if (coords !== 0) {
            if (coords == ownerCoordinates && planetType == ownerPlanetType) {
              if (!shipCounts.hasOwnProperty(attr)) {
                shipCounts[attr] = resultCombatArray['ships'][memberID][attr];
              } else {
                shipCounts[attr] = shipCounts[attr] + resultCombatArray['ships'][memberID][attr];
              }
            }
          } else {
            if (!shipCounts.hasOwnProperty(attr)) {
              shipCounts[attr] = resultCombatArray['ships'][memberID][attr];
            } else {
              shipCounts[attr] = shipCounts[attr] + resultCombatArray['ships'][memberID][attr];
            }
          }
        }

        if ($this.check(true, resultCombatArray['losses'])) {
          for (var attr in resultCombatArray['losses'][memberID]) {
            if (coords !== 0) {
              if (coords == ownerCoordinates && planetType == ownerPlanetType) {
                if (!lossCounts.hasOwnProperty(attr)) {
                  lossCounts[attr] = parseInt(resultCombatArray['losses'][memberID][attr]);
                } else {
                  lossCounts[attr] = lossCounts[attr] + parseInt(resultCombatArray['losses'][memberID][attr]);
                }
              }
            } else {
              if (!lossCounts.hasOwnProperty(attr)) {
                lossCounts[attr] = parseInt(resultCombatArray['losses'][memberID][attr]);
              } else {
                lossCounts[attr] = lossCounts[attr] + parseInt(resultCombatArray['losses'][memberID][attr]);
              }
            }
          }
        }
      }
    }

    if ($this.check(true, shipCounts, {
      'types': {
        0: 'isEmpty'
      }
    })) {
      var countsByMemberArray = $this.getShipCountArray(shipCounts, lossCounts);
      $this.setShipCount(countsByMemberArray);
    }
  },

  /**
   * Set Count by given result array
   *
   * @param object resultArray	>> 'ships': { selectorstring: count}
   * 								>> 'losses': ...
   */
  setShipCount: function (resultArray) {
    var combatside = ogame.messages.combatreport.data.combatside;
    var shipResult = resultArray['ships'];
    var lossResult = resultArray['losses'];

    if (!$.isEmptyObject(shipResult)) {
      for (var selector in shipResult) {
        $(selector).text(shipResult[selector].toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
      }
    } else {
      // when there are no Ships, then reset all ecke column to 0 in the current combatside (attacker or defender)
      $("." + combatside + " .ecke").text('0');
    }

    if (!$.isEmptyObject(lossResult)) {
      for (var selector in lossResult) {
        $(selector).text('-' + lossResult[selector].toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
      }
    } else {
      // when there are no losses, then reset all lost_ships column to - in the current combatside (attacker or defender)
      $("." + combatside + " .lost_ships").text('-');
    }
  },

  /**
   * Get classes of all ships by jqueryobjects of them
   *
   * @param object allShips	>> objects
   *
   * @return object allShipClasses	>> all classes in array
   */
  getAllShipClasses: function (allShips) {
    var id = allShips.map(function () {
      var id = $(this).attr('class');
      return id;
    }).get().join();
    var allShipClasses = [];
    $.each(id.split(','), function (key, value) {
      var classArray = value.split(' ');
      allShipClasses.push(classArray[1]);
    });
    return allShipClasses;
  },

  /**
   * Set the attributes to display ships
   *
   * @param activeMember object		>> selected member
   * @param combatside object			>> attacker||defender
   * @param resultCombatArray object	>> array of the last round
   * @param memberArray object		>> array of the specific member
      * @param coords string             >> coordinates of planet/moon
      * @param type int                  >> 1= planet, 3 = moon
   */
  displayShipData: function (activeMember, combatside, resultCombatArray, memberArray, coords, type) {
    coords = typeof coords !== 'undefined' ? coords : 0;
    var $this = ogame.messages.combatreport;

    if ($this.check(true, activeMember, {
      'values': {
        'isNot': {
          0: 'all'
        }
      }
    })) {
      //if(activeMember != 'all' && typeof activeMember != 'undefined') {
      $this.setShipCountByActiveMember(resultCombatArray, memberArray, activeMember, coords, type);
    } else {
      $this.setShipCount4All($this.data.combatRounds[combatside][$this.data.combatRounds[combatside].length - 1]);
    }
  },
  // __________________________________________________________ROUNDTEXT__________________________________________________________

  /**
   * show the last combatRound first
   */
  initCombatText: function (combatData) {
    var $this = ogame.messages.combatreport;
    var round = combatData['combatRounds'].length - 1;
    $('.combat_round_list .round_id').find('a').removeClass("active");
    $('.combat_round_list .round_id[data-round=' + round + ']').find('a').addClass("active");
    $this.loadDataBySelectedRound(combatData['attackerJSON'], combatData['defenderJSON'], round);
  },

  /**
   * set the text that descripe the combat by selected round
   *
   * @param object attackerArray	>> round: object >> 'statistic': object >> 'hits': int hitpoints
   * 																		>> 'absorbedDamage': int absorbedDamagePoints
   * 																		>> 'fullStrength': int strength without any absorbance
   * @param object defenderArray	>> defenderArray @see attackerArray
   * @param int round				>> selected round
   */
  setCombatText: function (attackerArray, defenderArray, round) {
    var $this = ogame.messages.combatreport;
    var attackerClass = '.statistic_attacker';
    var defenderClass = '.statistic_defender';
    var hitsClass = '.hits';
    var strengthClass = '.strength';
    var absorbedClass = '.absorbed';
    var sumHitsAttacker = 0;
    var sumAbsorbedDamageAttacker = 0;
    var sumFullStrengthAttacker = 0;
    var sumHitsDefender = 0;
    var sumAbsorbedDamageDefender = 0;
    var sumFullStrengthDefender = 0;

    if ($this.check(true, attackerArray, {
      'length': round
    })) {
      for (var roundindex in attackerArray) {
        sumHitsAttacker = sumHitsAttacker + parseInt(attackerArray[roundindex]['statistic']['hits']);
        sumAbsorbedDamageAttacker = sumAbsorbedDamageAttacker + parseInt(attackerArray[roundindex]['statistic']['absorbedDamage']);
        sumFullStrengthAttacker = sumFullStrengthAttacker + parseInt(attackerArray[roundindex]['statistic']['fullStrength']);
        sumHitsDefender = sumHitsDefender + parseInt(defenderArray[roundindex]['statistic']['hits']);
        sumAbsorbedDamageDefender = sumAbsorbedDamageDefender + parseInt(defenderArray[roundindex]['statistic']['absorbedDamage']);
        sumFullStrengthDefender = sumFullStrengthDefender + parseInt(defenderArray[roundindex]['statistic']['fullStrength']);
      }
    } else {
      sumHitsAttacker = parseInt(attackerArray[round]['statistic']['hits']);
      sumAbsorbedDamageAttacker = parseInt(attackerArray[round]['statistic']['absorbedDamage']);
      sumFullStrengthAttacker = parseInt(attackerArray[round]['statistic']['fullStrength']);
      sumHitsDefender = parseInt(defenderArray[round]['statistic']['hits']);
      sumAbsorbedDamageDefender = parseInt(defenderArray[round]['statistic']['absorbedDamage']);
      sumFullStrengthDefender = parseInt(defenderArray[round]['statistic']['fullStrength']);
    }

    $(attackerClass + hitsClass).text(sumHitsAttacker.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
    $(attackerClass + absorbedClass).text(sumAbsorbedDamageAttacker.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
    $(attackerClass + strengthClass).text(sumFullStrengthAttacker.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
    $(defenderClass + hitsClass).text(sumHitsDefender.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
    $(defenderClass + absorbedClass).text(sumAbsorbedDamageDefender.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
    $(defenderClass + strengthClass).text(sumFullStrengthDefender.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."));
  },
  // __________________________________________________________MAIN__________________________________________________________

  /**
   * Setup all important information for the combat
   *
   * @param object combatArray	>> all important information init
   * @param object combatside		>> for what side to set the information
   */
  setCombatArray: function (originalCombatArray, combatside) {
    // var combatArray = jQuery.extend({}, originalCombatArray); //shallow copy
    var combatArray = jQuery.extend(true, {}, originalCombatArray); //deep copy

    var $this = ogame.messages.combatreport;
    $this.data.combatside = combatside;
    $this.data.memberSelection = false;

    if ($('#' + $this.data.combatside + '_select_combatreport').find(':selected').length > 0) {
      $this.data.memberSelection = true;
    } // make sure that activeMember becomes a STRING, else all hell will break loose!


    if ($this.data.memberSelection) {
      $this.data.activeMember = '' + $('#' + $this.data.combatside + '_select_combatreport').find(':selected').val();
    } else {
      $this.data.activeMember = '' + $('#' + $this.data.combatside + '_select_combatreport').data('memberName');
    }

    $this.data.activeMember = $this.data.activeMember.split("|", 1)[0];
    $this.data.combatArray = combatArray.member;
    $this.data.combatRounds = [];
    $this.data.combatRounds[combatside] = combatArray.combatRounds;
  },

  /**
   * Setter for combatside
   *
   * @param object combatside		>> for what side to set the information
   */
  setCombatside: function (combatside) {
    var $this = ogame.messages.combatreport;
    $this.data.combatside = combatside;
  },

  /**
   * checks if the given object is correct
   *
   * @param bool easyCheck		>> the result should be only success or more information
   * @param object checks			>>
   *  mixed checkingObject	>> variable, array etc u wanna check - without any parameter check for undefined and null
   *  object values2check	>> values you wanna compare with the given object ({'values':{'is':{},'isNot'{}}})
   *  object types2check	>> types you wanna check with typeof (isEmpty, number, object, string)
   *
   * @return object result		>> success: bool			|| success
   * 								>> allErrors: int
   * 								>> valueErrors: int
   * 								>> typeErrors: int
   * 								>> type: string
   * 								>> length: int
   * 								>> lengthIsChecked: bool
   * 								>> lengthError: int (1||0)
   */
  check: function (easyCheck, checkingObject, checks) {
    var checks = checks != null && typeof checks != 'undefined' && typeof checks == 'object' ? checks : false;
    var success = false;
    var checkingValueErrorCount = 0;
    var checkingTypeErrorCount = 0;
    var checkingLengthErrorCount = 0;
    var length = 0;
    var lengthIsProofed = false; // only if any other checks are given

    if (checks != false) {
      var values2check = checks['values'] != null && typeof checks['values'] != 'undefined' && typeof checks['values'] == 'object' ? checks['values'] : {};
      var types2check = checks['types'] != null && typeof checks['types'] != 'undefined' && typeof checks['types'] == 'object' ? checks['types'] : {};
      var length2check = checks['length'] != null && typeof checks['length'] != 'undefined' ? checks['length'] : false;

      if (!jQuery.isEmptyObject(values2check)) {
        for (index in values2check) {
          var isValueChecklist = values2check[index]; //checking for isValue or isNotValue

          if (index == 'is' && !jQuery.isEmptyObject(isValueChecklist)) {
            for (var isValue in isValueChecklist) {
              if (checkingObject != isValueChecklist[isValue]) {
                checkingValueErrorCount = checkingValueErrorCount + 1;
              }
            }
          }

          if (index == 'isNot' && !jQuery.isEmptyObject(isValueChecklist)) {
            for (var isNotValue in isValueChecklist) {
              if (checkingObject == isValueChecklist[isNotValue]) {
                checkingValueErrorCount = checkingValueErrorCount + 1;
              }
            }
          }
        }
      }

      if (!jQuery.isEmptyObject(types2check)) {
        if (types2check['isEmpty']) {
          if (jQuery.isEmptyObject(checkingObject)) {
            checkingTypeErrorCount = checkingTypeErrorCount + 1;
          }
        }

        for (var index in types2check) {
          if (typeof checkingObject == types2check[index]) {
            checkingTypeErrorCount = checkingTypeErrorCount + 1;
          }
        }
      }

      if (typeof checkingObject == 'object') {
        for (var index in checkingObject) {
          if (typeof checkingObject[index] != 'undefined') {
            length = length + 1;
          }
        }
      } else {
        var checkingString = checkingObject + "";
        length = checkingString.length;
      }

      if (length2check !== false && typeof length2check == 'number' && typeof length == 'number') {
        if (length != length2check) {
          checkingLengthErrorCount = checkingLengthErrorCount + 1;
        }

        lengthIsProofed = true;
      }
    }

    if (typeof checkingObject == 'undefined' || checkingObject == null) {
      checkingTypeErrorCount = checkingTypeErrorCount + 1;
    }

    var errorCount = checkingValueErrorCount + checkingTypeErrorCount;

    if (lengthIsProofed != false) {
      errorCount = errorCount + checkingLengthErrorCount;
    }

    if (errorCount == 0) {
      success = true;
    }

    var result = {
      'success': success,
      'allErrors': errorCount,
      'valueErrors': checkingValueErrorCount,
      'typeErrors': checkingTypeErrorCount,
      'type': typeof checkingObject,
      'length': length,
      'lengthChecked': lengthIsProofed,
      'lengthError': checkingLengthErrorCount
    };

    if (easyCheck) {
      return success;
    } else {
      return result;
    }
  },

  /**
   * set the combatinformation for the report (main-function)
   *
   * @param object combatArray	>> all important information init
   * @param object combatside		>> for what side to set the information
   */
  loadData: function (combatArray, combatside) {
    var $this = ogame.messages.combatreport;
    $this.setCombatArray(combatArray, combatside);
    $this.loadDataBySelectedCombatMember(combatArray, combatside);
    $this.setCombatValue();
  },

  /**
   * set roundspecific information
   *
   * @see ogame.messages.combatreport.setCombatText for params
   */
  loadDataBySelectedRound: function (attackerCombatArray, defenderCombatArray, selectedRound) {
    var $this = ogame.messages.combatreport;
    var round2show = parseInt(selectedRound);
    var attacker = $('.attacker .participant_select option:selected').val(); // get the selected attacker

    var defender = $('.defender .participant_select option:selected').val(); // get the selected defender

    var attacker_coords = $('.attacker .participant_select option:selected').data('coords'); // get the coordinates of selected attacker planet (if planet selected)

    var defender_coords = $('.defender .participant_select option:selected').data('coords'); // get the coordinates of selected defender planet (if planet selected)

    var attacker_fleetID = [];
    var defender_fleetID = []; // check if planet was selected, if so we need to push its fleet Id in fleetIDs and sanitize the member name

    if (typeof attacker_coords != "undefined") {
      ids = attacker.split("|")[1].split(":");
      attacker_fleetID.push(ids);
      attacker = attacker.split("|")[0];
    } else if (attacker != 'all' && typeof attacker != "undefined") {
      // else if a member selected then we need to push the Ids of all its fleets in fleetIDs
      attacker_coords = 0;
      $('.attacker .participant_select option').each(function () {
        if (attacker == $(this).val().split("|")[0] && typeof $(this).val().split("|")[1] != "undefined") {
          attacker_fleetID.push($(this).val().split("|")[1].split(":"));
        }
      });
    } else {
      // no specifications if all was selected, attacker_fleetID must remain empty
      attacker_fleetID = [];
    }

    if (typeof defender_coords != "undefined") {
      ids = defender.split("|")[1].split(":");
      defender_fleetID.push(ids);
      defender = defender.split("|")[0];
    } else if (defender != 'all' && typeof defender != "undefined") {
      // else if a member selected then we need to push the Ids of all its fleets in fleetIDs
      defender_coords = 0;
      $('.defender .participant_select option').each(function () {
        if (defender == $(this).val().split("|")[0] && typeof $(this).val().split("|")[1] != "undefined") {
          defender_fleetID.push($(this).val().split("|")[1].split(":"));
        }
      });
    } else {
      // no specifications if all was selected, defender_fleetID must remain empty
      defender_fleetID = [];
    } // check if fleetID was not empty , then we need to get results of just this Fleets


    if (attacker_fleetID.length > 0) {
      for (var level1 in attackerCombatArray) {
        if (level1 == 'combatRounds') {
          for (var level2 in attackerCombatArray[level1][round2show]) {
            if (level2 == 'ships') {
              for (var shipIds in attackerCombatArray[level1][round2show][level2]) {
                var exist = $.inArray(shipIds, attacker_fleetID[0]); // check if we need the result of this fleet Id

                if (exist == -1) {
                  // if not , then remove its informations from the global result
                  delete attackerCombatArray[level1][round2show][level2][shipIds];
                }
              }
            }
          }
        }
      }
    }

    if (defender_fleetID.length > 0) {
      for (var level1 in defenderCombatArray) {
        if (level1 == 'combatRounds') {
          for (var level2 in defenderCombatArray[level1][round2show]) {
            if (level2 == 'ships') {
              for (var shipIds in defenderCombatArray[level1][round2show][level2]) {
                var exist = $.inArray(shipIds, defender_fleetID[0]); // check if we need the result of this fleet Id

                if (exist == -1) {
                  // if not , then remove its informations from the global result
                  delete defenderCombatArray[level1][round2show][level2][shipIds];
                }
              }
            }
          }
        }
      }
    }

    var attackerCombatRounds = attackerCombatArray['combatRounds'];
    var defenderCombatRounds = defenderCombatArray['combatRounds'];

    if ($this.check(true, attackerCombatRounds, {
      'length': selectedRound
    })) {
      round2show = round2show - 1;
    }

    round2show = round2show + "";
    $this.setCombatside('attacker');
    $this.setShipCount4All(attackerCombatRounds[round2show]);
    $this.setCombatside('defender');
    $this.setShipCount4All(defenderCombatRounds[round2show]);

    if ($this.data.memberSelection) {//$this.resetDropDowns();
    }

    $this.setCombatText(attackerCombatRounds, defenderCombatRounds, selectedRound);
  },

  /**
   * set the 2 dropdowns to no selected member
   */
  resetDropDowns: function () {
    $('#attacker_select_combatreport').val('all').ogameDropDown('refresh');
    $('#defender_select_combatreport').val('all').ogameDropDown('refresh');
  },

  /**
   * set all memberspecific information
   *
   * @param combatArray object	>> all important information init
   * @param combatside object		>> for what side to set the information
      * @param coords string         >> coordinates of planet
      * @param planetType int              >> 1 = planet, 3 = moon
   */
  loadDataBySelectedCombatMember: function (originalCombatArray, combatside, coords, planetType) {
    // var combatArray = jQuery.extend({}, originalCombatArray); //shallow copy
    var combatArray = jQuery.extend(true, {}, originalCombatArray); //deep copy
    // make sure that these params have a "proper" value

    coords = coords || 0;
    planetType = planetType || 1;
    var $this = ogame.messages.combatreport;
    $this.setCombatArray(combatArray, combatside); // set all ships of a combatside and get all active ships

    var ships = $('.' + $this.data.combatside + ' .buildingimg'); // Add defenses as well

    var defense = $('.' + $this.data.combatside + ' .defenseimg');
    ships = $.merge(ships, defense);
    var activeShips = $this.getShipsByMembersAndCoords($this.data.activeMember, coords, planetType); //set isActive-Flag to shippictures
    $this.setActiveFlag4Fleet(ships, activeShips);
    $this.displayShipData($this.data.activeMember, $this.data.combatside, combatArray['combatRounds'][combatArray['combatRounds'].length - 1], combatArray['member'], coords, planetType);
    $this.setCombatValue();
  }
};
function closeDetails(id, expireTime) {
  var elem = $("#fleet" + id);
  elem.children(".openDetails").children().children().attr("src", "//gf2.geo.gfsrv.net/cdn10/de1e5f629d9e47d283488eee0c0ede.gif");
  elem.children(".quantity").show();
  elem.removeClass("detailsOpened");
  elem.addClass("detailsClosed");
  currentMovementTabExtensionStates[id] = [0, expireTime]; // set to 0 == closed

  updateCookieStatus(currentMovementTabExtensionStates);
}

function openDetails(id, expireTime) {
  var elem = $("#fleet" + id);
  elem.children(".openDetails").children().children().attr("src", "//gf3.geo.gfsrv.net/cdnb6/577565fadab7780b0997a76d0dca9b.gif");
  elem.children(".quantity").hide();
  elem.removeClass("detailsClosed");
  elem.addClass("detailsOpened");
  currentMovementTabExtensionStates[id] = [1, expireTime]; // set to 0 == closed

  updateCookieStatus(currentMovementTabExtensionStates);
}

function updateCookieStatus(tabStates) {
  var stringifiedState = JSON.stringify(tabStates);
  var stringifiedOptions = JSON.stringify({
    expires: Math.round(new Date().getTime() / 1000) + 7 * 86400
  });
  $.cookie("tabBoxFleets", stringifiedState, stringifiedOptions);
}

function openCloseDetails(id, expireTime) {
  if ($("#fleet" + id).attr("class") == "fleetDetails detailsOpened") {
    closeDetails(id, expireTime);
  } else {
    openDetails(id, expireTime);
  }
}

function preCloseMovements() {
  $.each(currentMovementTabExtensionStates, function (id, data) {
    if (data[0] == 0) {
      var elem = $("#fleet" + id + " span.openDetails a");
      var expireTime = elem.attr('data-end-time');
      closeDetails(id, expireTime);
    }
  });
}

function initMovement() {
  initToggleHeader('movement');
  preCloseMovements();

  if (showInfos == undefined) {
    var showInfos = 0;
  }

  $("a.openCloseDetails").click(function () {
    openCloseDetails($(this).attr('data-mission-id'), $(this).attr('data-end-time'));
  });
  $(".closeAll").click(function () {
    if (showInfos == 0) {
      showInfos = 1;
      $(".closeAll").children().removeClass('all_open').addClass('all_closed');
    } else {
      showInfos = 0;
      $(".closeAll").children().removeClass('all_closed').addClass('all_open');
    }

    $("a.openCloseDetails").each(function () {
      if (showInfos === 1) {
        closeDetails($(this).attr('data-mission-id'), $(this).attr('data-end-time'));
      } else if (showInfos === 0) {
        openDetails($(this).attr('data-mission-id'), $(this).attr('data-end-time'));
      }
    });
  });
  timerHandler.appendCallback(function () {});
}

function addUserToUnion() {
  $("#participantselect").append($("#buddyselect").find("li.ui-selected"));
}

function removeUserFromUnion() {
  $("#buddyselect").append($("#participantselect").find("li.ui-selected"));
}

function addUserToUnionByForm() {
  var user = $('#unionUserSearch').find('[name="addtogroup"]');
  var userName = user.val();
  var participant = $('#participantselect');

  if (participant.find('li[ref="' + userName + '"]').length == 0) {
    participant.append($(document.createElement('li')).attr('ref', userName).text(userName));
  }

  user.val('');
}

function setUnionUsers() {
  var unionUsers = '';
  $("#participantselect").find("li").each(function () {
    unionUsers += $(this).attr('ref') + ';';
  });
  unionUsers = unionUsers.substring(0, unionUsers.length - 1);
  $('#unionUsers').val(unionUsers);
}

function unionUser(response) {
  var data = $.parseJSON(response);

  if (data["status"]) {
    addUserToUnionByForm();
  } else {
    errorBoxAsArray(data["errorbox"]);
  }
}

function initFederationLayer() {
  $("#switch").click(function () {
    var searchFed = $("#searchFed");
    searchFed.find("> .wrap").toggle();
    searchFed.find("> #honorWarning").toggle();
  });
  $("#buddyselect, #participantselect").selectable({
    filter: "li:not(.undermark)"
  });
  $(document).undelegate('ul#buddyselect li', 'dblclick').delegate('ul#buddyselect li', 'dblclick', function () {
    addUserToUnion();
  }).undelegate('ul#participantselect li', 'dblclick').delegate('ul#participantselect li', 'dblclick', function () {
    removeUserFromUnion();
  });
}

function submit_unionform() {
  setUnionUsers();
  ajaxFormSubmit('unionform', $('form#unionform').attr('action'), unionEdit);
}

function recallShipCountdown(fleetId, currentRecallTime) {
  var thisObj = this;
  var $element = $(".reversal_time[ref='" + fleetId + "']");

  if (isMobile && $element.length) {
    this.updateCountdown = function () {
      var timestamp = thisObj.countdown.getLeftoverTime();
      var formattedDate = getFormatedDate(new Date(timestamp * 1000 + timeDiff), '[d].[m].[Y] [H]:[i]:[s]');
      $element.html(formattedDate);
    }; // countdown objekt


    thisObj.countdown = new oldcountdown(currentRecallTime, 3, 2);
    thisObj.timer = timerHandler.appendCallback(thisObj.updateCountdown);
    thisObj.updateCountdown();
  }
}
function initNotesForm() {
  $('select').ogameDropDown();
  $("#createNote .text").trigger("keyup");

  if ($('#popupContent').length) {
    initNotes();
  }
}

function initNotes() {
  $('select').ogameDropDown();

  function formHasChanges(form) {
    var hasChanges = false;
    $(form).find(':input').each(function () {
      if (typeof $(this).data('value') != 'undefined') {
        if ($(this).data('value') != $(this).val()) {
          hasChanges = true;
        }
      }
    });
    return hasChanges;
  }

  var $overlayDiv = $('.overlayDiv.notices');
  $overlayDiv.find('.openOverlay').unbind('click').bind('click', function () {
    var overlayClass = $(this).attr('data-overlay-class');
    var options = {
      title: $(this).attr('data-title'),
      close: function () {
        var $thisObj = $('.' + overlayClass);

        if (formHasChanges($thisObj.find('form'))) {
          errorBoxDecision(LocalizationStrings.question, locaNotes.changesNotSaved + "<br/><br/>" + locaNotes.questionSaveChanges, LocalizationStrings.yes, LocalizationStrings.no, function () {
            $thisObj.find('form').trigger('submit');
            $thisObj.remove();
          }, function () {
            $thisObj.remove();
          }, true);
        } else {
          $thisObj.remove();
        }
      },
      'class': overlayClass
    };
    openOverlay($(this).attr('href'), options);

    if (overlayClass.indexOf('newNote-') === 0) {
      var number = parseInt(overlayClass.replace(/^newNote-/, '')) + 1;
      $(this).attr('data-overlay-class', 'newNote-' + number);
    }

    return false;
  });
  $(document).undelegate('#noteList form', 'submit').delegate('#noteList form', 'submit', function () {
    $.post($('#noteList').attr('rel'), $(this).serialize(), function (data) {
      $overlayDiv.html(data);
    });
  }).undelegate('#createNote form [type=submit]', 'click').delegate('#createNote form [type=submit]', 'click', function (e) {
    e.preventDefault();
    $(this).parents('form').submit();
  }).undelegate('#createNote form', 'submit').delegate('#createNote form', 'submit', function (e) {
    e.preventDefault();
    var $thisObj = $(this);
    $.ajax({
      url: $(this).attr('rel'),
      type: "post",
      data: $thisObj.serialize(),
      dataType: "json",
      error: function () {
        fadeBox(LocalizationStrings.error, true);
      },
      success: function (data) {
        if (data.error != null) {
          fadeBox(data.error, true);
        } else {
          if ($('#popupContent').length) {
            $(window).unbind("beforeunload.checkChanges");
            location.href = $thisObj.attr('rel') + "&popup=1";
          } else {
            if ($thisObj.parents('.overlayDiv').is(':visible')) {
              $thisObj.parents('.overlayDiv').dialog('option', 'close', function () {
                $(this).remove();
              }).dialog('close');
            }

            if (data.success != null) {
              fadeBox(data.success, false);
            }

            $overlayDiv.load($overlayDiv.find('#noteList').attr('rel'));
          }
        }
      }
    });
    return false;
  }).undelegate('#createNote .textBox', 'keyup touchstart change').delegate('#createNote .textBox', 'keyup touchstart change', function () {
    var sum = $(this).val().length;
    var max = $(this).attr('data-max-length');

    if (sum > max) {
      var range = $(this).getSelection();
      $(this).val($(this).val().substr(0, max));
      sum = max;
      $(this).setSelection(range);
    }

    $(this).parents("form").find(".cntChars").text(sum);
  });
  $(window).unbind("beforeunload.checkChanges").bind("beforeunload.checkChanges", function () {
    var hasChanges = false;
    $('#createNote form').each(function () {
      if (formHasChanges(this)) {
        hasChanges = true;
      }
    });

    if (hasChanges) {
      return locaNotes.changesNotSaved;
    }
  });
}
function getAjaxEventbox() {
  if (typeof ajaxEventboxURI === 'undefined') {
    return;
  }

  $.get(ajaxEventboxURI, reloadEventbox, "text");
}

let reloadEventBoxTimer = null;

function reloadEventbox(data) {
  var evalData;

  if (typeof data === 'string') {
    evalData = $.parseJSON(data);
  } else {
    evalData = data;
  }

  var type = typeof evalData["eventText"];
  var actionSum = parseInt(evalData["friendly"]) + parseInt(evalData["neutral"]) + parseInt(evalData["hostile"]);

  if (actionSum > 0) {
    var $eventList;
    var $eventDetails = $('<p class="event_list">');

    if ($('body').attr('id') === 'galaxy') {
      $eventDetails.append('<span class="next_event">' + eventboxLoca.nextEvent + ': <span class="countdown" id="tempcounter" name="countdown"></span></span>').append('<span class="next_event">' + eventboxLoca.nextEventText + ': <span class="' + evalData["eventType"] + '">' + evalData["eventText"] + '</span></span>');
      $eventList = $eventDetails;
    } else {
      var missions = actionSum === 1 ? eventboxLoca.mission : eventboxLoca.missions;
      $eventList = $('<p class="event_list">' + actionSum + ' ' + missions + ': </p>');

      if (evalData["friendly"]) {
        $eventList.append('<span class="undermark">' + evalData["friendly"] + ' ' + eventboxLoca.friendly + '</span>');
      }

      if (evalData["neutral"]) {
        if (evalData["friendly"]) {
          $eventList.append(', ');
        }

        $eventList.append('<span class="middlemark">' + evalData["neutral"] + ' ' + eventboxLoca.neutral + '</span>');
      }

      if (evalData["hostile"]) {
        if (evalData["friendly"] || evalData["neutral"]) {
          $eventList.append(', ');
        }

        $eventList.append('<span class="overmark">' + evalData["hostile"] + ' ' + eventboxLoca.hostile + '</span>');
      }

      $eventDetails.append('<span class="next_event">' + eventboxLoca.nextEvent + ': <span class="countdown" id="tempcounter" name="countdown"></span></span>').append('<span class="next_event">' + eventboxLoca.nextEventText + ': <span class="' + evalData["eventType"] + '">' + evalData["eventText"] + '</span></span>');
      $eventList.append($eventDetails);
    }

    $('#eventboxFilled p.event_list').remove();
    $('#eventboxFilled').prepend($eventList);
  }

  if (type === "string" || type === "undefined") {
    $("#eventboxLoading").hide();

    if (actionSum > 0) {
      $("#eventboxBlank").hide();
      $("#eventboxFilled").show(); // Dieser Countdown sorgt dafuer, dass nach dem Ablauf des aktuell angezeigten Events jeweils das naechste
      // geladen wird. Das 3 Sek. Delay sorgt dafuer, dass es nicht beliebig haeufig deswegen neu laedt...
      // Da es immer nur eine Eventbox gibt, muss der Kram im Gegensatz zu der Eventliste nicht weiter
      // abgesichert werden.

      if (reloadEventBoxTimer !== null) {
        timerHandler.removeCallback(reloadEventBoxTimer.timer);
      }

      reloadEventBoxTimer = new simpleCountdown(getElementByIdWithCache("tempcounter"), evalData["eventTime"], function () {
        setTimeout(getAjaxEventbox, 3000);
      });
    } else {
      $("#eventboxBlank").show();
      $("#eventboxFilled").hide();
    }
  }
}

(function ($) {
  $(document).undelegate('.eventToggle', 'click').delegate('.eventToggle', 'click', function () {
    toggleEvents();
    return false;
  });
  $(document).undelegate('#eventboxContent .toggleDetails', 'click').delegate('#eventboxContent .toggleDetails', 'click', function () {
    toggleDetails.call(this);
    return false;
  });
  $(function () {
    if ($("#eventboxContent").is(":visible")) {
      toggleEvents.loaded = true;
      $('#js_eventDetailsClosed').hide();
      $('#js_eventDetailsOpen').show();
    }

    if (window.isStandalonePage === undefined || window.isStandalonePage === false) {
      //This loads notification bar
      getAjaxEventbox(); // this loads even list (notification bar !== event list)

      refreshFleetEvents(true);
    }
  });
})(jQuery);
/**
 * Created by florianer on 04.07.16.
 */
if (ogame === undefined) {
  var ogame = {};
}

ogame.Notify = function (title, text, options) {
  this.canNotify = false;
  this.title = title || 'OGame';
  this.options = options || {};
  this.options.body = text || ''; // Let's check if the browser supports notifications

  if (!("Notification" in window)) {
    // alert("This browser does not support system notifications");
    return false;
  } // Let's check whether notification permissions have already been granted
  else if (Notification.permission === "granted") {
    // If it's okay let's create a notification
    this.canNotify = true;
  } // Otherwise, we need to ask the user for permission
  else if (Notification.permission !== 'denied') {
    Notification.requestPermission(function (permission) {
      // If the user accepts, let's create a notification
      if (permission === "granted") {
        this.canNotify = true;
      }
    });
  }
};

ogame.Notify.prototype.setImage = function (image) {
  this.options.icon = image;
};

ogame.Notify.prototype.setTag = function (tag) {
  this.options.tag = tag;
};

ogame.Notify.prototype.show = function () {
  if (this.canNotify) {
    this.notification = new Notification(this.title, this.options);
    setTimeout(this.notification.close.bind(this.notification), 5000);
  }
};
function scrollToTopOfDialog(dialog) {
  $('html, body').stop().animate({
    scrollTop: Math.max(0, dialog.offset().top - 300)
  }, 200);
}

function openOverlay(url, dialogParams) {
  if ($(".ui-dialog span.ui-dialog-title:contains('" + dialogParams.title + "')").length) {
    return;
  }

  if (typeof openOverlay.index == "undefined") {
    openOverlay.index = 0;
  } else {
    openOverlay.index++;
  }

  var currentIndex = openOverlay.index;
  dialogParams = dialogParams || {};

  if ((typeof dialogParams.type == 'undefined' || dialogParams.type != 'inline') && !url.match(new RegExp("^(" + ogameUrl + "|" + startpageUrl + ")"))) {
    window.open('redir.php?url=' + encodeURIComponent(url), '_newtab');
    return;
  }

  if (typeof dialogParams.height == 'undefined') {
    dialogParams.height = "auto";
  }

  if (typeof dialogParams.width == 'undefined') {
    dialogParams.width = "auto";
  }

  if (typeof dialogParams.position == 'undefined') {
    if (isMobile && !isMobileApp) {
      dialogParams.position = {
        my: "top",
        at: "top"
      };
    } else {
      dialogParams.position = {
        my: "center",
        at: "center"
      };
    }
  }

  dialogParams.closeText = "";

  if ($(".overlayDiv").length && !isMobile) {
    var lastOverlay = $(".overlayDiv:last");
    var offset = lastOverlay.offset();
    dialogParams.position = {
      my: "left top",
      at: "left+" + (offset.left + 10) + " top+" + (offset.top + 10)
    };
  }

  function positionDialog(dialog) {
    var $dialogParent = dialog.parent(".ui-dialog");

    if ($dialogParent.length) {
      $dialogParent.css('top', Math.max(0, parseInt($dialogParent.css('top').replace(/px$/, '')))).css('left', Math.max(0, parseInt($dialogParent.css('left').replace(/px$/, ''))));
    }
  }

  var type = dialogParams.type;
  delete dialogParams.type;

  if (type !== 'inline') {
    var loadImage = $(document.createElement('img')).attr('src', '/img/icons/4161a64a933a5345d00cb9fdaa25c7.gif').attr('alt', LocalizationStrings.loading);
    var centerDiv = $(document.createElement('div')).css('text-align', 'center').css('margin-top', '20px').append(loadImage);
    var dialog = $(document.createElement("div")).addClass('overlayDiv').css('display', 'none').append(centerDiv).appendTo("body");

    var defaultClose = function () {
      dialog.find('select').ogameDropDown('destroy');
      dialog.remove();
      Tipped.hideAll();
    };

    switch (typeof dialogParams.close) {
      case 'function':
        // Nothing to do
        break;

      case 'string':
        var closeCallbacks = dialogParams.close.split(' ');

        dialogParams.close = function () {
          $.each(closeCallbacks, function (i, e) {
            if (e == '__default') {
              defaultClose();
            } else {
              window[e]();
            }
          });
        };

        break;

      default:
        dialogParams.close = defaultClose;
        break;
    }
  } else if (!dialogParams.close && type === 'inline') {
    dialogParams.close = function () {
      if (closeTradeResourcesOverlay && typeof closeTradeResourcesOverlay === 'function' && typeof traderObj !== 'undefined') {
        closeTradeResourcesOverlay(true);
      }

      if ($($(".ui-dialog span.ui-dialog-title:contains('" + dialogParams.title + "')").parents('.ui-dialog')[0]).length > 0) {
        $($(".ui-dialog span.ui-dialog-title:contains('" + dialogParams.title + "')").parents('.ui-dialog')[0]).remove();
      }

      $(".overlayDiv").removeClass("overlayDiv");
    };
  }

  if (typeof url == 'string') {
    var queryObject = $.deparam($.param.querystring(url));

    if (typeof queryObject.page != 'undefined') {
      dialog.attr('data-page', queryObject.page);
    }

    if (!isMobile && $.inArray(queryObject.page, popupWindows) != -1) {
      var top = Math.max(0, Math.floor($(window).height() / 2 - dialogParams.popupHeight / 2));
      var left = Math.max(0, Math.floor($(window).width() / 2 - dialogParams.popupWidth / 2));
      var popup = window.open(url + '&popup=1', queryObject.page, "width=" + dialogParams.popupWidth + "," + "height=" + dialogParams.popupHeight + "," + "scrollbars=yes," + "resizable=yes," + "top=" + top + "," + "left=" + left);
      dialog.remove();
      popup.focus();
      return;
    }
  }

  if (typeof dialogParams['class'] != 'undefined') {
    var overlayClass = dialogParams['class'].split(' ').join('.');

    if ($(".overlayDiv." + overlayClass).length) {
      $.get(url, {}, function (data) {
        $(".overlayDiv." + dialogParams['class']).empty().append(data).dialog("moveToTop");
      });
      dialog.remove();
      dialog = $(".overlayDiv." + overlayClass);

      if (typeof queryObject.page != 'undefined') {
        dialog.attr('data-page', queryObject.page);
      }

      if (typeof dialogParams['title'] != 'undefined') {
        dialog.dialog('option', 'title', dialogParams['title']);
      }

      scrollToTopOfDialog(dialog);
      return true;
    } else {
      dialog.addClass(dialogParams['class']);
    }
  }

  if (type == 'inline') {
    dialog = $(url);
  }

  if (isNaN(dialogParams.dragStart) && isNaN(dialogParams.dragStop)) {
    var background;

    dialogParams.dragStart = function () {
      $('html').data('noclick', true);
      dialog.dialog('option', 'width', dialog.width()).dialog('option', 'height', dialog.height());
      background = {
        'bg': dialog.css('background'),
        'image': dialog.css('background-image'),
        'x': dialog.css('background-position-x'),
        'y': dialog.css('background-position-y'),
        'position': dialog.css('background-position')
      };
      dialog.find('select').ogameDropDown('hide');
      dialog.children().hide(); // da die dropdowns nun ausserhalb sind, muessen sie auch separat versteckt und wieder angezeigt werden

      var dropDowns = dialog.find('.markItUpDropMenu[id]');

      for (var i = 0; i < dropDowns.length; ++i) {
        var $myDropDown = $('body>ul[rel=' + dropDowns[i].id + ']'); // Anpassung beim 1. Mal:

        var adjustTop = typeof $myDropDown.attr('old_left') == 'undefined' ? -18 : 0;
        var adjustLeft = typeof $myDropDown.attr('old_left') == 'undefined' ? -6 : 0;
        $myDropDown.attr('old_top', dialog.offset()['top'] + adjustTop).attr('old_left', dialog.offset()['left'] + adjustLeft).hide(); // Werte merken fuer dragStop
      }

      dialog.css('background', '#000000');
    };

    dialogParams.dragStop = function () {
      setTimeout(function () {
        $('html').data('noclick', false);
      }, 100); // try to use the different css properties of different browsers

      if (typeof dialog.bg == 'undefined' || dialog.bg.length == 0) {
        dialog.css('background-image', background.image);

        if (typeof background.position == 'undefined' || background.position.length == 0) {
          dialog.css('background-position-x', background.x).css('background-position-y', background.y);
        } else {
          dialog.css('background-position', background.position);
        }
      } else {
        dialog.css('background', background.bg);
      }

      dialog.children().show(); // verschiebe die Dropdowns in der gleichen Weise wie den Dialog selbst

      var dropDowns = dialog.find('.markItUpDropMenu[id]');

      for (var i = 0; i < dropDowns.length; ++i) {
        var $innerUl = $('body>ul[rel=' + dropDowns[i].id + ']');
        $innerUl.css({
          'top': parseInt($innerUl.css('top')) - $innerUl.attr('old_top') + dialog.offset()['top'] + 'px',
          'left': parseInt($innerUl.css('left')) - $innerUl.attr('old_left') + dialog.offset()['left'] + 'px'
        });

        if ($(dropDowns[i]).attr('data-opened') == 1) {
          $innerUl.show();
        }
      }

      dialog.dialog('option', 'width', dialogParams.width).dialog('option', 'height', dialogParams.height);
      positionDialog(dialog);
    };
  }

  if (isNaN(dialogParams.resizable)) {
    dialogParams.resizable = false;
  }

  if (isMobile) {
    dialogParams.draggable = false; //        dialogParams.modal = true;
  }

  if (dialogParams.modal) {
    dialogParams.open = function () {
      $('.ui-widget-overlay').css('height', '').css('width', '');
    };
  }

  switch (type) {
    case 'iframe':
      var width = overlayWidth;
      var height = overlayHeight;

      if (typeof dialogParams.iframeWidth != 'undefined') {
        width = dialogParams.iframeWidth;
        delete dialogParams.iframeWidth;
      }

      if (typeof dialogParams.iframeHeight != 'undefined') {
        height = dialogParams.iframeHeight;
        delete dialogParams.iframeHeight;
      }

      dialog.html("<iframe allowTransparency='true'" + "frameborder='0' hspace='0' src='" + url + "' " + "id='TB_iframeContent' name='TB_iframeContent" + Math.round(Math.random() * 1000) + "' " + "style='width:" + (width + 25) + "px;height:" + (height + 1) + "px;' >" + "</iframe>").dialog(dialogParams).dialog("moveToTop");
      positionDialog(dialog);
      break;

    case 'inline':
      var inlineObject = $(url);
      var $dialogParent = inlineObject.parent();
      inlineObject.addClass('overlayDiv').dialog(dialogParams).dialog("moveToTop");
      positionDialog(inlineObject);
      break;

    default:
      dialog.dialog(dialogParams).dialog("moveToTop");
      $.get(url, {}).done(function (data) {
        dialog.empty().append(data).dialog('option', 'position', dialog.dialog('option', 'position'));
        setTimeout(function () {
          dialog.dialog('option', 'position', dialog.dialog('option', 'position'));
          positionDialog(dialog);
        }, 100);
        $(document).trigger('ajaxShowOverlay');
      }).fail(function () {});
  }

  Tipped.hideAll();
  $("select").ogameDropDown('hide');

  if (!isMobile) {
    $(window).bind('resize.overlay' + currentIndex, function () {
      if (dialog.is(':data(dialog)')) {
        dialog.dialog('option', 'position', dialog.dialog('option', 'position'));
        positionDialog(dialog);
      } else {
        $(window).unbind('resize.overlay' + currentIndex);
      }
    });
  }
} // checks if any overlay is there at all


function isOverlayOpen() {
  return $(".overlayDiv").length > 0;
}

function initOverlays() {
  $(document).undelegate('a[href*="overlay=1"], button[data-target*="overlay=1"], a.overlay, button.overlay', 'click').delegate('a[href*="overlay=1"], button[data-target*="overlay=1"], a.overlay, button.overlay', 'click', function (e) {
    e.preventDefault();
    var url = $(this).attr('href') || $(this).attr('data-target');

    if (typeof $(this).data('overlay-token') !== 'undefined') {
      url += "&token=" + $(this).data('overlay-token');
    }

    if ($(this).data('overlay-same')) {
      var $uiDialog = $(this).parents('.ui-dialog');
      var $overlayDiv = $uiDialog.find('.overlayDiv');

      if ($(this).data('overlay-same') && $overlayDiv.length > 0) {
        $.get(url, {}, function (data) {
          removeTooltip($overlayDiv.find(getTooltipSelector()));
          $overlayDiv.empty() // force repaint (ie 8 bug q.q)
          .append(data) // force repaint (ie 8 bug -.-)
          .dialog('moveToTop');
          $overlayDiv.dialog("option", "position", $overlayDiv.dialog("option", "position"));
          $uiDialog.hide(); // force repaint (ie 9/10 bug ~=[,,_,,]:3)

          $uiDialog.show(); // force repaint...  ie 9/10 bug (/  )/ ~ 
        });
        return false;
      }
    }

    var dialogParams = {
      zIndex: 4000
    };

    if ($(this).data('overlay-title')) {
      dialogParams.title = $(this).data('overlay-title');
    } else if (typeof $(this).attr('title') != 'undefined' && $(this).attr('title').length) {
      dialogParams.title = $(this).attr('title');
    } else if ($(this).data('tipped_restore_title')) {
      dialogParams.title = $(this).data('tipped_restore_title').replace(/^.+\|/, '');
    }

    if ($(this).data('overlay-class')) {
      dialogParams['class'] = $(this).data('overlay-class');
    }

    if ($(this).data('overlay-width')) {
      dialogParams.width = $(this).data('overlay-width');
    }

    if ($(this).data('overlay-height')) {
      dialogParams.height = $(this).data('overlay-height');
    }

    if ($(this).data('overlay-popup-width')) {
      dialogParams.popupWidth = $(this).data('overlay-popup-width');
    }

    if ($(this).data('overlay-popup-height')) {
      dialogParams.popupHeight = $(this).data('overlay-popup-height');
    }

    if ($(this).data('overlay-modal')) {
      dialogParams.modal = $(this).data('overlay-modal');
      dialogParams.resizable = false;
      dialogParams.draggable = false;
    }

    if ($(this).data('overlay-iframe')) {
      dialogParams.type = 'iframe';

      if ($(this).data('iframe-width')) {
        dialogParams.iframeWidth = $(this).data('iframe-width');
      }

      if ($(this).data('iframe-height')) {
        dialogParams.iframeHeight = $(this).data('iframe-height');
      }
    } else if ($(this).data('overlay-inline')) {
      dialogParams.type = 'inline';
      url = $(this).data('overlay-inline');
    }

    if ($(this).data('overlay-close')) {
      dialogParams.close = $(this).data('overlay-close');
    }

    openOverlay(url, dialogParams);
    return false;
  });
}

function updateOverlayToken(tokenId, updateToken) {
  $('[data-overlay-token-id=' + tokenId + ']').data('overlay-token', updateToken);
  token = updateToken;
}
function initOverview() {
  $(".cancelMove").click(function () {
    var thisObj = $(this);
    var locationObj = window.location;
    errorBoxDecision(planetMoveLoca["askTitle"], planetMoveLoca["askCancel"], planetMoveLoca["yes"], planetMoveLoca["no"], function () {
      $.ajax({
        method: "get",
        url: thisObj.attr("rel"),
        dataType: "json",
        cache: false,
        success: function (data) {
          if (data.error.length > 0) {
            fadeBox(data.error, true);
          } else {
            location.href = getRedirectLink();
          }
        },
        error: function () {
          fadeBox(planetMoveLoca["error"], true);
        }
      });
    });
  });
  $(document).undelegate('#planetMaintenanceDelete', 'submit').delegate('#planetMaintenanceDelete', 'submit', function (e) {
    e.preventDefault();
    ajaxFormSubmit('planetMaintenanceDelete', $(this).attr('action'), planetGivenup);
  }).undelegate('#abandonplanet #block', 'click').delegate('#abandonplanet #block', 'click', function (e) {
    e.preventDefault();

    if (!hasAPassword) {
      var question = $("#giveupHeadline").attr('rel') == 3 ? loca.moonGiveupQuestion : loca.planetGiveupQuestion;
      question = question.replace("%planetName%", $("#giveupName").text()).replace("%planetCoordinates%", $("#giveupCoordinates").text());
      errorBoxDecision($("#giveupHeadline").text(), question, LocalizationStrings.yes, LocalizationStrings.no, function () {
        $('#planetMaintenanceDelete').submit();
      });
    } else {
      show_hide_menus('#validate');
      show_hide_menus('#giveUpNotification');
    }
  }).undelegate('.openPlanetRenameGiveupBox', 'click').delegate('.openPlanetRenameGiveupBox', 'click', function (e) {
    e.stopPropagation();
    openPlanetRenameGiveupBox();
  });
}

function clearField() {
  currentValue = $("#planetName").val();

  if (defaultName == currentValue) {
    clearInput("#planetName");
  }
}

function fillField() {
  currentValue = $("#planetName").val();

  if (currentValue == "") {
    $("#planetName").val(defaultName);
  }
}

function openBuddyOverlay(url, title) {
  openOverlay(url, {
    'class': 'buddies',
    'title': title
  });
}

function planetGivenup(data) {
  errorBoxAsArray(data["errorbox"]);

  if (typeof data["newAjaxToken"] == 'string') {
    $("#planetMaintenanceDelete input[name='_token']").val(data["newAjaxToken"]);
  }

  if (typeof data["password_checked"] != "undefined" && data["password_checked"]) {
    $("#planetMaintenanceDelete").attr('action', data["intent"]);
  }
}
// https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function (predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

      var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.

      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


      var thisArg = arguments[1]; // 5. Let k be 0.

      var k = 0; // 6. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return kValue.
        var kValue = o[k];

        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        } // e. Increase k by 1.


        k++;
      } // 7. Return undefined.


      return undefined;
    },
    configurable: true,
    writable: true
  });
} // https://tc39.github.io/ecma262/#sec-array.prototype.findindex


if (!Array.prototype.findIndex) {
  Object.defineProperty(Array.prototype, 'findIndex', {
    value: function (predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

      var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.

      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


      var thisArg = arguments[1]; // 5. Let k be 0.

      var k = 0; // 6. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return k.
        var kValue = o[k];

        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        } // e. Increase k by 1.


        k++;
      } // 7. Return -1.


      return -1;
    },
    configurable: true,
    writable: true
  });
}
function initPreferences() {
  $('.category').click(function () {
    document.prefs.reset();
  });
  let copySubmitButton = $('.copy2PtrConainer a');
  copySubmitButton.on('click', this.onClickExecutePtrCopy.bind(this)); // solution to chrome auto-filling username and password, dynamically add password field
  // once user types in new password

  $('#db_character').on('input', function () {
    if ($('#db_character').val()) {
      if (!$('#db_character_password').length) {
        $('#confirmPasswordWrapper').show();
        $('#confirmPasswordContainer').append(`
                        <input class="textInput w200"
                               id="db_character_password"
                               type="password"
                               value=""
                               size="30"
                               name="db_character_password"
                               autocomplete="new-password"
                        />
                    `);
      }
    } else {
      $('#confirmPasswordWrapper').hide();
      $('#db_character_password').remove();
    }
  }); // Generell immer die erste Gruppe ffnen
  // WICHTIG ZUM DURCHKLICKEN DER TABS

  $('div.wrap > div.group').hide();
  $('div.wrap > div.group:first,' + 'div.wrap:eq(1) > div.group:eq(0),' + 'div.wrap:eq(2) > div.group:eq(0),' + 'div.wrap:eq(3) > div.group:eq(0)').show();
  $('div.wrap > div.bar').click(function () {
    $(this).next('div.group:hidden').slideDown('fast', function () {
      Tipped.show($(':input:visible'));
    }).siblings('div.group:visible').slideUp('fast', function () {
      Tipped.hide($(':input:not(:visible)'));
    });
    $('.formError').validationEngine('closePrompt');
  });
  $('.content .bar').hover(function () {
    $(this).addClass('bar-hover');
  }, function () {
    $(this).removeClass('bar-hover');
  });
  $('#newpass1').bind('keyup', function () {
    var value = $(this).val();
    var length = value.length;
    var hasSpecialChars = value.match(/[^A-Za-z\d]/);
    var hasNumbers = value.match(/\d/);
    var hasMixedCase = value.match(/[a-z]/) && value.match(/[A-Z]/);
    var score = 0;
    var maxScore = 4;
    var fulfilled = {
      'length': false,
      'mixed-case': false,
      'special-chars': false,
      'numbers': false
    };

    if (length >= passwordMinLength && length <= passwordMaxLength) {
      fulfilled['length'] = true;
      score++;
    }

    if (hasMixedCase) {
      fulfilled['mixed-case'] = true;
      score++;
    }

    if (hasNumbers) {
      fulfilled['numbers'] = true;
      score++;
    }

    if (hasSpecialChars) {
      fulfilled['special-chars'] = true;
      score++;
    }

    for (var name in fulfilled) {
      var isFulfilled = fulfilled[name];
      var element = $('#password-meter-status-' + name);
      element.find('img.status-checked').css('visibility', isFulfilled ? 'visible' : 'hidden');
    }

    var rating = Math.floor(score / maxScore * 2);
    var levels = new Array('low', 'medium', 'high');

    for (var i in levels) {
      if (i != rating) {
        $('#password-meter-rating-' + levels[i]).removeClass('arrow');
      } else {
        $('#password-meter-rating-' + levels[i]).addClass('arrow');
      }
    }
  });
  $(".contentzs").tabs({
    beforeActivate: function (event, ui) {
      $("input#selectedTab").val($(ui.tab).parent().prevAll().length);
    },
    activate: function () {
      Tipped.hide($('input:not(:visible)'));
      Tipped.show($('input:visible'));
    },
    active: selectedTab
  });
  $("#sortSetting").unbind('change').bind('change', function () {
    var name = "settings_order";

    if ($(this).val() == customSorting) {
      var $sortOrder = $("#sortOrder");
      $sortOrder.attr("disabled", "disabled").attr("name", "");
      $("#sortOrderHidden").attr("name", name).val($sortOrder.val());
      $("#sortOrder").next(".dropdown").addClass('disabled');
    } else {
      $("#sortOrder").next(".dropdown").removeClass('disabled');
      var $sortOrderHidden = $("#sortOrderHidden");
      $sortOrderHidden.attr("name", "");
      $("#sortOrder").removeClass('disabled').attr("name", name).removeAttr("disabled").val($sortOrderHidden.val());
    }
  }).trigger('change'); //initFormValidation();

  if (moveInProgress) {
    $("form#prefs").on('submit', function (e) {
      var $thisObj = $(this);

      if ($thisObj.find('input#urlaubs_modus.notOnVacation:checked').length) {
        errorBoxDecision(LocalizationStrings.attention, preferenceLoca.planetMoveQuestion, LocalizationStrings.yes, LocalizationStrings.no, function () {
          $thisObj.off('submit').submit();
        });
        e.preventDefault();
        return false;
      }
    });
  }

  if (hasAPassword) {
    $("#prefs").bind('submit', function () {
      var $thisObj = $(this);
      var nameChange = $("#db_character", $thisObj);

      if (!$thisObj.data('asking') && nameChange.val() != undefined && nameChange.val().length) {
        $thisObj.data('asking', true);
        errorBoxDecision(preferenceLoca.changeNameTitle, preferenceLoca.changeNameQuestion.replace("%newName%", $("#db_character", $thisObj).val()), LocalizationStrings.yes, LocalizationStrings.no, function () {
          $thisObj.submit();
          $thisObj.data('asking', false);
        }, function () {
          $thisObj.data('asking', false);
        });
        return false;
      }
    });
  } // Im aktiven Tab aber die richtige Auswahl ffnen


  if (tabsDisabled) {
    $(".contentzs").tabs("option", "disabled", [1, 2]);
    $("#tabGeneral, #tabRepresentation").attr("title", preferenceLoca.tabDisabled).attr("class", "tooltip");
  }

  $('div.wrap:visible > div.bar:eq(' + openGroup + ')').click();
}

function onClickExecutePtrCopy(e) {
  e.stopPropagation();
  e.preventDefault();
  errorBoxDecision(LocalizationStrings.question, preferenceLoca.copyToPtrQuestion, LocalizationStrings.yes, LocalizationStrings.no, function () {
    $.post($('.copy2PtrConainer a').attr('href'), {
      _token: token
    }, response => {
      let data = JSON.parse(response);
      token = data.newAjaxToken;

      if (data.status === 'success') {
        console.log(data.content);
        $('.copy2PtrConainer .fieldwrapper').replaceWith(data.content);
      }
    });
  });
}
function pqChangeTarget(obj) {
  window.location = $(obj).data('targetUrl');
}

function switchProductionTab(tab) {
  $("#productionqueuecomponent .spaceObjectTab").addClass('inactive');
  $(`#productionqueuecomponent .spaceObjectTab.${tab}`).removeClass('inactive');
  let targetQueues = tab === 'planet' ? 'moonProduction' : 'planetProduction';
  $(`#productionqueuecomponent .${targetQueues}`).hide();
  $(`#productionqueuecomponent .${tab}Production`).show();
}
function display_info(type) {
  if (document.getElementById("infoInput").innerHTML == "" || document.getElementById("infoInput").innerHTML != get_displayText(type)) {
    document.getElementById("infoInput").innerHTML = get_displayText(type);
  }
}

function display_error(type) {
  if (document.getElementById("errorInput").innerHTML == "" || document.getElementById("errorInput").innerHTML != get_errorText(type)) {
    document.getElementById("errorInput").innerHTML = get_errorText(type);
    document.getElementById("error").style.display = "block";
  }
}

function hide_error(type) {
  document.getElementById("errorInput").innerHTML = "";
  document.getElementById("error").style.display = "none";
}

function checkUsername() {
  var username = document.forms['new'].elements['username'].value;

  if (username.length < 3 || username.length >= 20) {
    display_error("username");
  } else {
    hide_error();
  }
}

function checkEmail() {
  var email = document.forms['new'].elements['email'].value;
  validate = email.match(/[a-zA-Z0-9]+@+[a-zA-Z0-9]+[.]+[a-zA-Z0-9]{2,4}/);

  if (email.length < 3 || email.length >= 64 || !validate) {
    display_error("email");
  } else {
    hide_error();
  }
}
/**
 * Created by christian.wiedemann on 15.03.2016.
 */
var TECHID_REPAIR_DOCK = 36;
var burnUpCountDownForStationScreen = {};
var repairTimeDownForStationScreen = {};

function displayBurnUpEnquiry() {
  var button = $("input.burnUpButton");
  errorBoxDecision(button.data("loca_box_text"), button.data("loca_decision_text"), button.data("loca_yes"), button.data("loca_no"), function () {
    $.ajax({
      url: button.data("url"),
      success: function (result) {
        var decoded = jQuery.parseJSON(result);

        if (decoded.success) {
          fadeBox(decoded.reason, false, function () {});
          redirectSpaceDock();
        } else {
          fadeBox(decoded.reason, true, function () {});
        }
      }
    });
  }, function () {});
}

function startWreckFieldRepairs() {
  var button = $("input.startRepairsButton");
  $.ajax({
    url: button.data("url"),
    success: function (result) {
      var decoded = jQuery.parseJSON(result);

      if (decoded.success) {
        fadeBox(decoded.reason, false, function () {});
        redirectSpaceDock();
      } else {
        fadeBox(decoded.reason, true, function () {});
      }
    }
  });
}

function reCommissionShips() {
  var button = $("input.reCommissionButton");
  $.ajax({
    url: button.data("url"),
    success: function (result) {
      var decoded = jQuery.parseJSON(result);

      if (decoded.success) {
        fadeBox(decoded.reason, false, function () {});
        redirectSpaceDock();
      } else {
        fadeBox(decoded.reason, true, function () {});
      }
    }
  });
}

function registerBurnUpCountDown(elementId) {
  var burnUpCountDownElement = $(elementId);
  var duration = $(elementId).data('duration');

  if (duration > 0) {
    if (!burnUpCountDownForStationScreen[elementId]) {
      burnUpCountDownForStationScreen[elementId] = new simpleCountdown(burnUpCountDownElement, duration, function () {
        location.reload();
      });
    }
  }
}

function registerRepairTimeCountDown(elementId) {
  var repairTimeCountDownElement = $(elementId);
  var duration = $(elementId).data('duration');

  if (duration > 0) {
    if (!repairTimeDownForStationScreen[elementId]) {
      repairTimeDownForStationScreen[elementId] = new simpleCountdown(repairTimeCountDownElement, duration, function () {
        location.reload();
      });
    }
  }
}

$(document).on("click", "div.burnUpButton", displayBurnUpEnquiry);
$(document).on("click", "div.startRepairsButton", startWreckFieldRepairs);
$(document).on("click", "div.reCommissionButton", reCommissionShips);
$(document).on("ajaxShowElement", function (event, tid) {
  if (tid == TECHID_REPAIR_DOCK) {
    registerBurnUpCountDown("#burnUpCountDownForStationScreen");
    registerRepairTimeCountDown("#repairTimeCountDownForStationScreen");
  }
});
$(document).on("ajaxShowOverlay", function (event) {
  registerBurnUpCountDown("#burnUpCountDownForRepairOverlay");
  registerRepairTimeCountDown("#repairTimeCountDownForRepairOverlay");
});
function initResourceTrader() {
  $(".big_tabs").tabs({
    activate: hideTipsOnTabChange
  });
  $('.resource_link').on('click', onSelectResource);
  $('.btn_calltrader').on('click', callTrader);
}

function onSelectResource(e) {
  var $resource = $(e.currentTarget); // if trader was not previously selected

  if (!$resource.hasClass('active')) {
    // mark new resource as active
    $('.resource_link').removeClass('active');
    $resource.addClass('active'); // blue
    // make the button sharp

    $('.btn_calltrader').attr('disabled', false).data('offerId', $resource.data('resourceId'));
    var $getNewTrader = $('.getNewTraderDiv'); // if the get-new-trader-button is hidden XOR we click on the resource of our last (still active) trader

    if ($getNewTrader.hasClass('hidden') && !$resource.hasClass('oldTraderActive') || !$getNewTrader.hasClass('hidden') && $resource.hasClass('oldTraderActive')) {
      // switch visibility of get-new-trader-button and open-last-trader-button
      $getNewTrader.parent().children().toggleClass('hidden');
    }
  }
}

function showTradeNowButton() {
  if ($("#callTrader").hasClass("traderActive")) {
    $("#callTrader").show();
  } else {
    $("#callTrader").hide();
  }
}
/* ******** Code from Old Trader = Resource Trader ******* */


function calcCosts(id, amount) {
  return Math.ceil(amount * factor[offer_id] / factor[id]);
}

function calcInputFromCosts(id, amount) {
  return Math.max(Math.floor(amount / factor[offer_id] * factor[id]), 0);
}

function setValue(id, value) {
  if (offer_id == id) {
    $("#" + id + "_value_label").html(number_format(value, 0, loca['decimalPoint'], loca['thousandsSeparator']));
  } else {
    formatNumber("#" + id + '_value', value);
  }
}

function checkValue(id) {
  setValue(id, Math.min(getValue($("#" + id + "_value").val()), Math.round(freeStorage[id])));
  free_id = 6 - id - offer_id;
  offer_costs = calcCosts(free_id, getValue($("#" + free_id + "_value").val()));
  costs = calcCosts(id, getValue($("#" + id + "_value").val()));
  freeOfferCosts = Math.round(offer_amount - offer_costs);

  if (costs > freeOfferCosts) {
    setValue(id, calcInputFromCosts(id, freeOfferCosts));
    costs = calcCosts(id, getValue($("#" + id + "_value").val()));
  }

  offer_costs = offer_costs + costs;
  setValue(offer_id, offer_costs);
  document.getElementById(id + '_storage').innerHTML = number_format(freeStorage[id] - getValue($("#" + id + "_value").val()), 0, loca['decimalPoint'], loca['thousandsSeparator']);
}

function setMaxValue(id) {
  setValue(id, freeStorage[id]);
  checkValue(id);
}

function callTrader(e) {
  if ($(e.currentTarget).attr('disabled') == 'disabled') {
    return;
  }

  var id = $(e.currentTarget).data('offerId'),
      askOverwrite = $(e.currentTarget).data('askOverwrite');

  if (typeof askOverwrite == 'undefined') {
    askOverwrite = true;
  }

  if (darkMatter < traderCosts) {
    errorBoxDecision(LocalizationStrings.error, loca.errorNotEnoughDM, LocalizationStrings.yes, LocalizationStrings.no, redirectBuyPremium);
    return;
  }

  function newTrader() {
    if (!$('.call_trader_box .getNewTraderDiv').hasClass('hidden')) {
      $('.call_trader_box').children().toggleClass('hidden');
    }

    $('.resource_list .resource_link').removeClass('oldTraderActive').filter(function (index) {
      return $(this).data('resourceId') == id;
    }).addClass('oldTraderActive'); // remove class from all resources, add to active trader

    $.post(traderCallLink, {
      offer_id: id,
      _token: token
    }, function (data) {
      data = $.parseJSON(data);
      token = data.newAjaxToken;

      if (data["status"] == "1") {
        $('#callTrader').show().addClass('traderActive');
        traderObj.reloadResources();
        $("#callTrader").addClass("traderActive").show();
        openOverlay(traderOverlayLink, {
          'class': "traderlayer"
        });
        var $activeTrader = $("#activeTrader");
        var resourceName = "metal";
        var headline = loca.traderResourceTitleMetal;

        switch (id) {
          case 2:
            resourceName = "crystal";
            headline = loca.traderResourceTitleCrystal;
            break;

          case 3:
            resourceName = "deut";
            headline = loca.traderResourceTitleDeuterium;
            break;
        }

        $activeTrader.find('.left_content #material').attr('class', resourceName);
        $activeTrader.find('p.stimulus').html(headline);
        $activeTrader.show();
        $("#boxHeader, #boxFooter").show();
      } else {
        errorBoxAsArray(data["errorbox"]);
      }
    });
  }

  if (askOverwrite && $("#callTrader").is(':visible')) {
    errorBoxDecision(loca.traderResourceNewQuestionHeadline, loca.traderResourceNewQuestion, LocalizationStrings.yes, LocalizationStrings.no, newTrader);
  } else {
    newTrader();
  }
}

function tradeDone(data) {
  data = $.parseJSON(data);
  token = data.token;

  if (data.status === true) {
    closeTradeResourcesOverlay();
  }

  errorBoxAsArray(data["errorbox"]);
}

function closeTradeResourcesOverlay(doNotDisableCallTrader) {
  $(".overlayDiv.traderlayer").remove();
  traderObj.reloadResources();

  if (!doNotDisableCallTrader) {
    $('.call_trader_box').children().toggleClass('hidden');
    $("#callTrader").removeClass('traderActive').hide();
    $('.btn_calltrader').attr('disabled', true);
    $('.resource_link').removeClass('oldTraderActive active');
    $("#activeTrader").hide();
  }
}
function closeSearch() {
  if (currentPage !== undefined) {
    if (currentPage == 'fleet1' || currentPage == 'fleet2') {
      $('a#continue').focus();
    } else if (currentPage == 'fleet3') {
      $('a#start').focus();
    }
  }
}
// moved to global scope due to CDN issues
inventoryObj = {
  currentPage: null,
  currentItems: null,
  currentItem: null,
  currentCategory: null,
  activatingItem: false,
  initalizeSlider: function (items, slider, width, height, doSlideIn, force, titleClass, small, buildNavigation) {
    if (inventoryObj.currentItems == items && typeof force == 'undefined' || force == false) {
      return;
    }

    inventoryObj.currentItems = items; // don't use slideIn on Overview

    doSlideIn = doSlideIn || 'slideIn';
    titleClass = titleClass || 'tooltipHTML js_hideTipOnMobile';

    if (typeof small == 'undefined') {
      small = true;
    }

    if (typeof buildNavigation == 'undefined') {
      buildNavigation = true;
    }

    $('#' + slider + 'Box').remove('.anythingSlider');
    var newItems = [];
    var counter = 0;

    for (var key in items) {
      var item = items[key];

      if (typeof item.hide != 'undefined' && item.hide) {
        continue;
      }

      if (inventoryObj.currentPage == 'shop' || inventoryObj.currentPage == 'inventory') {
        // switch sorting horizontal <=> vertical
        var modulo = counter % inventoryObj.itemsPerSlide;
        newItems[counter + 2 * (modulo % 3) - 2 * Math.floor(modulo / 3)] = item;
      } else {
        // buff bar
        newItems[counter] = item;
      }

      counter++;
    }

    var slideCounter = 0,
        i = 0,
        $newSlider = $('<ul id="' + slider + '" />');

    for (var length = newItems.length; i < length; i++) {
      if (typeof newItems[i] == 'undefined') {
        $lastSlide.append('<div class="item_img"><div class="empty border5px"></div></div>');
        continue;
      }

      var item = newItems[i];

      if (i % inventoryObj.itemsPerSlide == 0) {
        var $lastSlide = $('<li class="slide_' + slideCounter + '" />').appendTo($newSlider);
        slideCounter++;
      }

      var amount, amountClass, saleBadge;

      if (inventoryObj.currentPage == 'shop') {
        amount = getNumberFormatShort(item.costs, null) + ' ' + loca.currency[item.currency];
        amountClass = 'price';
      } else {
        amount = getNumberFormatShort(item.amount);
        amountClass = 'amount';
      }

      var imageName;

      if (small) {
        imageName = item.imageLarge + '-75x.png';
      } else {
        imageName = item.imageLarge + '-100x.png';
      }

      var activationClass;

      if (item.canBeActivated || item.canBeBoughtAndActivated) {
        activationClass = "enabled";
      } else {
        activationClass = "disabled";
      }

      if (item.isReduced) {
        saleBadge = '<div class="sale_badge ' + activationClass + '"></div>';
      } else {
        saleBadge = '';
      }

      var isActiveClass = item.timeLeft != null ? ' js_is_active ' : '';
      var remainingTime = '';
      var itemTitle = item.title;

      if (slider.indexOf('js_activeItemSlider') != -1) {
        itemTitle = ''; // only show remaining time on active item slider AND if the item is active:

        remainingTime = item.timeLeft != null ? '<span class="js_duration undermark" data-total-duration="' + item.totalTime + '">' + item.timeLeft + '</span>' : '';
      }

      var pusher = ''; // @TODO: add the logic for this condition:
      // only show pusher if we're on overview AND item is active:

      if (item.timeLeft != null && slider.indexOf('js_activeItemSlider') != -1) {
        pusher = '<div class="pusher"></div>';
      }

      var birthdayDiv = '';

      if ($.inArray(birthdayCategory, item.category) != -1) {
        birthdayDiv = '<div class="event_active_hint"></div>';
      }

      $lastSlide.append('<div class="item_img r_' + item.rarity + '" style="background-image: url(/cdn/img/item-images/' + imageName + ');">' + '<div class="item_img_box">' + birthdayDiv + '<div class="activation ' + activationClass + isActiveClass + '"></div>' + '<a href="javascript:void(0);" tabindex="1" title="' + itemTitle + '" class="detail_button ' + titleClass + ' ' + doSlideIn + '" ref="' + item.ref + '">' + saleBadge + '<span class="ecke"><span class="level ' + amountClass + '">' + amount + '</span></span></a></div>' + remainingTime + pusher + '</div>');
    }

    $('#' + slider + 'Box').prepend($newSlider); //Fill up empty Item Slots:

    if (i % inventoryObj.itemsPerSlide != 0) {
      for (var j = i % inventoryObj.itemsPerSlide; j < inventoryObj.itemsPerSlide; j++) {
        $('#' + slider + ' li:last').append('<div class="item_img"><div class="empty border5px"></div></div>');
      }
    } //Fill empty Items End


    return mySlider = $('#' + slider).anythingSlider({
      startStopped: true,
      // If autoPlay is on, this can force it to start stopped
      buildStartStop: false,
      expand: true,
      resizeContents: false,
      theme: 'default',
      infiniteSlides: false,
      autoPlay: false,
      easing: 'swing',
      resizeContents: true,
      stopAtEnd: true,
      playRtl: isRTLEnabled,
      hashTags: true,
      buildNavigation: buildNavigation,
      // Callback when the plugin finished initializing (for IPad Swipe Event)
      onInitialized: function (e, slider) {
        if (isMobile) {
          var time = 1000,
              // allow movement if < 1000 ms (1 sec)
          range = 50,
              // swipe movement of 50 pixels triggers the slider
          x = 0,
              t = 0,
              touch = ("ontouchend" in document),
              st = touch ? 'touchstart' : 'mousedown',
              mv = touch ? 'touchmove' : 'mousemove',
              en = touch ? 'touchend' : 'mouseup';
          slider.$window.bind(st, function (e) {
            // prevent image drag (Firefox)
            //e.preventDefault();
            t = new Date().getTime();
            x = e.originalEvent.touches ? e.originalEvent.touches[0].pageX : e.pageX;
          }).bind(en, function (e) {
            t = 0;
            x = 0;
          }).bind(mv, function (e) {
            //                            e.preventDefault();
            var newx = e.originalEvent.touches ? e.originalEvent.touches[0].pageX : e.pageX,
                r = x === 0 ? 0 : Math.abs(newx - x),
                // allow if movement < 1 sec
            ct = new Date().getTime();

            if (t !== 0 && ct - t < time && r > range) {
              if (newx < x) {
                slider.goForward();
              }

              if (newx > x) {
                slider.goBack();
              }

              t = 0;
              x = 0;
            }
          });
        }
      }
    });
  },
  // End initalizeSlider
  initShop: function () {
    var thisObj = this;
    $(window).unbind('.shop');
    $(document).undelegate('.slideIn', 'click.shop').delegate('.slideIn', 'click.shop', function () {
      if (thisObj.currentItem == $(this).attr('ref')) {
        thisObj.currentItem = null;
        $.bbq.pushState({
          'item': ''
        });
      } else {
        thisObj.currentItem = $(this).attr('ref');
        $.bbq.pushState({
          'item': $(this).attr('ref')
        });
      }
    }); //Buttons Start:

    $('button.to_shop').bind('click.shop', function () {
      $.bbq.pushState({
        'page': 'shop'
      });
    });
    $('button.to_inventory').bind('click.shop', function () {
      $.bbq.pushState({
        'page': 'inventory'
      });
    });
    $('button.buyResourcesLink').bind('click', function () {
      reload_page($(this).data('link'));
    });
    $('.to_shop, .to_inventory').hover(function () {
      $(this).addClass('hover');
    }, function () {
      $(this).removeClass('hover');
    }); // End Buttons
    // Rebuild the Slider if another Category is selected:

    $('.categoryFilter li a').bind('click.shop', function () {
      $.bbq.pushState({
        'category': $(this).attr('rel')
      });
    });
    $(window).unbind('hashchange.shop').bind('hashchange.shop', function (e) {
      thisObj.onHashChange($.deparam.fragment(e.fragment));
    });
    thisObj.onHashChange($.deparam.fragment());
    inventoryObj.refreshResources();
  },
  onHashChange: function (url) {
    if (typeof url['page'] == 'undefined') {
      var pushArray = {
        page: "shop",
        category: $(".categoryFilter a:first").attr('rel')
      };

      if (typeof url['item'] != 'undefined' && url['item'] != '') {
        var item = inventoryObj.items_shop[url['item']];

        if (item.category.length > 0) {
          pushArray.category = item.category[item.category.length - 1];
        }
      }

      $.bbq.pushState(pushArray);
      return;
    }

    var changePage = this.currentPage != url['page'];

    if (changePage) {
      if (url['page'] == 'inventory') {
        this.openInventory();
        $(".planetlink, .moonlink").fragment({
          "page": url["inventory"]
        });
      } else {
        this.openShop();
        $(".planetlink, .moonlink").fragment({
          "page": url["shop"]
        });
      }

      this.updateCategoryAmount();
    }

    if (typeof url["category"] == 'undefined') {
      $.bbq.pushState({
        "category": $(".categoryFilter a:first").attr('rel')
      });
      return;
    } else {
      if (url["category"] != this.currentCategory || changePage) {
        this.changeCategory(url["category"]);
      }
    }

    if (typeof url["item"] == 'undefined' || url['item'] == '' && this.currentItem != null) {
      $('#itemDetails a.close_details').click();
      $(".planetlink, .moonlink").fragment({
        "item": ""
      });
    } else if (this.currentItem != url['item']) {
      var $itemAnchor = $(".slideIn[ref='" + url["item"] + "']");

      if ($itemAnchor.length) {
        $itemAnchor.click();
      } else {
        // item could not be found in shop
        gfSlider.slideIn(getElementByIdWithCache("detail"), url["item"]);
      }

      $(".planetlink, .moonlink").fragment({
        "item": url["item"]
      });
    }
  },
  initShopDetails: function () {
    var thisObj = this;
    var referrerPage = $.deparam.querystring().page;
    $(document).undelegate('#itemDetails .close_details', 'click').delegate('#itemDetails .close_details', 'click', function () {
      gfSlider.hide(getElementByIdWithCache("itemDetails"));
    }).undelegate('#itemDetails a.item.build-it', 'click').delegate('#itemDetails a.item.build-it', 'click', function () {
      $.ajax({
        url: $(this).attr('rel'),
        data: {
          _token: token
        },
        type: "POST",
        dataType: "json",
        error: function () {
          fadeBox(translation['buyError'], true);
        },
        success: function (data) {
          token = data.newAjaxToken;

          if (data.error || data.status === "failure") {
            if (data.message) {
              fadeBox(data.message, true);
            } else {
              fadeBox(data.errors[0].message, true);
            }

            $('#itemDetails a.item').removeClass('build-it').addClass('build-it_disabled');
          } else {
            fadeBox(data.message, false);
            inventoryObj.refreshResources();
            inventoryObj.refreshItemData(data.item);
          }
        }
      });
      return false;
    }).undelegate('#itemDetails a.item.build-it_disabled.dm', 'click').delegate('#itemDetails a.item.build-it_disabled.dm', 'click', function () {
      errorBoxDecision(LocalizationStrings.error, loca.buyDMDecision, LocalizationStrings.yes, LocalizationStrings.no, function () {
        if ($("a.dm_button").length > 0) {
          $("a.dm_button").click();
        } else {
          window.location.href = $("#darkmatter_box a").attr("href");
        }
      });
    }).undelegate('#itemDetails a.activateItem.build-it', 'click').delegate('#itemDetails a.activateItem.build-it', 'click', function () {
      var $thisObj = $(this);

      function upgradeItemAjax() {
        $.ajax({
          url: $thisObj.attr('rel'),
          data: {
            _token: token,
            referrerPage: referrerPage
          },
          type: "POST",
          dataType: "json",
          error: function () {
            fadeBox(translation['buyError'], true);
            $('#itemDetails a.activateItem').removeClass('build-it').addClass('build-it_disabled');
          },
          success: function (data) {
            token = data.newAjaxToken;

            if (data.error || data.status === "failure") {
              if (data.message) {
                fadeBox(data.message, true);
              } else {
                fadeBox(data.errors[0].message, true);
              }

              $('#itemDetails a.activateItem').removeClass('build-it').addClass('build-it_disabled');
            } else {
              fadeBox(data.message, false);

              if (data.reload) {
                location.reload();
                return;
              }

              inventoryObj.refreshResources();
              inventoryObj.refreshItemData(data.item);
            }
          }
        });
      }

      if ($thisObj.hasClass('isUpgrade')) {
        errorBoxDecision(LocalizationStrings.activateItem.upgradeItemQuestionHeader, LocalizationStrings.activateItem.upgradeItemQuestion, LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
      } else if ($thisObj.hasClass('isCharacterClassItem')) {
        var name = $thisObj.data('itemName');
        errorBoxDecision(LocalizationStrings.notice, LocalizationStrings.characterClassItem.activateItemQuestion.replace('#characterClassName#', name), LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
      } else if ($thisObj.hasClass('isAllianceClassItem')) {
        thisObj.fetchDataAboutCurrentAllianceClass($thisObj.data('itemName'), upgradeItemAjax, 'activateItemQuestion', null);
      } else {
        upgradeItemAjax();
      }

      return false;
    }).undelegate('#itemDetails a.buyAndActivate.build-it', 'click').delegate('#itemDetails a.buyAndActivate.build-it', 'click', function () {
      var $thisObj = $(this);

      function upgradeItemAjax() {
        $.ajax({
          url: $thisObj.attr('rel'),
          data: {
            _token: token,
            referrerPage: referrerPage
          },
          type: "POST",
          dataType: "json",
          error: function () {
            fadeBox(translation['buyError'], true);
            $('#itemDetails a.activateItem').removeClass('build-it').addClass('build-it_disabled');
          },
          success: function (data) {
            token = data.newAjaxToken;

            if (data.error || data.status === "failure") {
              if (data.message) {
                fadeBox(data.message, true);
              } else {
                fadeBox(data.errors[0].message, true);
              }

              $('#itemDetails a.activateItem').removeClass('build-it').addClass('build-it_disabled');
            } else {
              if (data.reload) {
                location.reload();
                return;
              }

              fadeBox(data.message, false);
              inventoryObj.refreshResources();
              inventoryObj.refreshItemData(data.item);
            }
          }
        });
      }

      if ($thisObj.hasClass('isUpgrade')) {
        errorBoxDecision(LocalizationStrings.activateItem.upgradeItemQuestionHeader, LocalizationStrings.activateItem.upgradeItemQuestion, LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
      } else if ($thisObj.hasClass('isCharacterClassItem')) {
        var name = $thisObj.data('itemName');
        var price = $thisObj.data('itemPrice');
        errorBoxDecision(LocalizationStrings.notice, LocalizationStrings.characterClassItem.buyAndActivateItemQuestion.replace('#characterClassName#', name).replace('#darkmatter#', tsdpkt(price)), LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
      } else if ($thisObj.hasClass('isAllianceClassItem')) {
        thisObj.fetchDataAboutCurrentAllianceClass($thisObj.data('itemName'), upgradeItemAjax, 'buyAndActivateItemQuestion', $thisObj.data('itemPrice'));
      } else {
        upgradeItemAjax();
      }

      return false;
    }).undelegate('#itemDetails a.buyAndActivate.build-it_disabled.showGetMoreDmPopup', 'click').delegate('#itemDetails a.buyAndActivate.build-it_disabled.showGetMoreDmPopup', 'click', function () {
      errorBoxDecision(LocalizationStrings.error, loca.buyDMDecision, LocalizationStrings.yes, LocalizationStrings.no, function () {
        window.location.href = $("#darkmatter_box a").attr("href");
      });
    });
  },
  refreshResources: function () {
    getAjaxResourcebox(function (resources) {
      $(".to_dark_matter .level").text(gfNumberGetHumanReadable(resources.darkmatter.amount, isMobile));
    });
  },
  refreshItemData: function (itemData) {
    var uuid = itemData.ref;
    changeTooltip($(".detail_button[ref='" + uuid + "']"), itemData.title);
    $(".detail_button[ref='" + uuid + "'] span.amount, " + "#itemDetails[data-uuid='" + uuid + "'] span.amount").html(tsdpkt(itemData.amount));

    if (typeof inventoryObj.items_inventory != "undefined") {
      if (inventoryObj.items_inventory.length == 0) {
        inventoryObj.items_inventory = {};
      } else if (itemData.amount <= 0) {
        delete inventoryObj.items_inventory[uuid];
      } else {
        inventoryObj.items_inventory[uuid] = itemData;
      }
    }

    if (typeof inventoryObj.items_shop != "undefined") {
      if (inventoryObj.items_shop.length == 0) {
        inventoryObj.items_shop = {};
      }

      inventoryObj.items_shop[uuid] = itemData;
    }

    changeTooltip($('#itemDetails[data-uuid="' + uuid + '"] a.activateItem, #itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate'), itemData.activationTitle);

    if (itemData.hasEnoughCurrency) {
      $('#itemDetails[data-uuid="' + uuid + '"] a.item').addClass('build-it').removeClass('build-it_disabled');
    } else {
      $('#itemDetails[data-uuid="' + uuid + '"] a.item').removeClass('build-it').addClass('build-it_disabled');
    }

    if (itemData.amount > 0) {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').show();
      $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').hide();

      if (itemData.canBeActivated) {
        $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').removeClass('build-it_disabled').addClass('build-it');
      } else {
        $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').addClass('build-it_disabled').removeClass('build-it');
      }
    } else {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').hide();
      $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').show();

      if (itemData.canBeBoughtAndActivated && itemData.hasEnoughCurrency) {
        $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').removeClass('build-it_disabled').addClass('build-it');
      } else {
        $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').addClass('build-it_disabled').removeClass('build-it');
      }
    }

    if (isMobile) {
      var infoText = "";

      if ($('#itemDetails[data-uuid="' + uuid + '"] a.activateItem:visible,' + '#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate:visible').hasClass('build-it_disabled')) {
        infoText += itemData.activationTitle;
      }

      if (itemData.buyTitle.length && itemData.buyTitle != itemData.activationTitle) {
        infoText += itemData.buyTitle;
      }

      $('#itemDetails[data-uuid="' + uuid + '"] .info_txt').text(infoText);
    }

    if (itemData.timeLeft > 0 && itemData.extendable) {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem span').html(loca.extend);
      $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate span').html(loca.buyAndExtend);
    } else {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem span').html(loca.activate);
      $('#itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate span').html(loca.buyAndActivate);
    }

    if (itemData.isAnUpgrade) {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem, #itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').addClass('isUpgrade');
    } else {
      $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem, #itemDetails[data-uuid="' + uuid + '"] a.buyAndActivate').removeClass('isUpgrade');
    }

    if (this.inShop === true) {
      this.changeCategory($(".categoryFilter a.active").attr('rel'));
    }

    this.updateCategoryAmount();
  },
  boughtItemHint: function () {
    $('.to_inventory .bought_item_notice').show().fadeOut(1000);
  },
  openShop: function () {
    this.currentPage = 'shop';
    $('#js_inventorySliderBox').hide();
    $('#js_shopSliderBox').show();
    $('.to_inventory').removeClass('active');
    $('.to_shop').addClass('active');
    $('#buttonz h2').text(loca.LOCA_PREMIUM_SHOP);

    if (isMobile) {
      $('.js_shopCurrentPage').html(loca.shopText);
    }
  },
  openInventory: function () {
    this.currentPage = 'inventory';
    $('#js_shopSliderBox').hide();
    $('#js_inventorySliderBox').show();
    $('.to_shop').removeClass('active');
    $('.to_inventory').addClass('active');
    $('#buttonz h2').text(loca.LOCA_PREMIUM_INVENTORY);

    if (isMobile) {
      $('.js_shopCurrentPage').html(loca.inventoryText);
    }
  },
  changeCategory: function (category) {
    inventoryObj.currentCategory = category;
    $(".planetlink, .moonlink").fragment({
      "category": category
    });
    $('.categoryFilter li, .categoryFilter li a').removeClass('active');
    $('.categoryFilter li a[rel="' + category + '"]').addClass('active').parent().addClass('active'); // remove all items from active slider:

    $('.anythingSlider').remove();

    var changeItems = function (items, slider) {
      // select the items to rebuild the slider with:
      var newItems2 = [];
      var newItems = [];
      var highestIndex = 0;
      $.each(items, function (index) {
        if (this.category != null) {
          var joinedArray = '$' + this.category.join('$') + '$';

          if (joinedArray.toLowerCase().indexOf('$' + category + '$') != -1) {
            newItems2[inventoryObj.item_orders[category][this.ref]] = this;

            if (inventoryObj.item_orders[category][this.ref] > highestIndex) {
              highestIndex = inventoryObj.item_orders[category][this.ref];
            }
          }
        }
      });

      for (var i = 0; i <= highestIndex; ++i) {
        // in anderes Array umschaufeln fuer IE8 noetig.
        // dieser merkt sich zwar die Indizes, mit denen die Items eingefuegt wurden
        // wird aber mit for(x in y) darueber iteriert, sind diese in der Einfuege-Reihenfolge.
        if (newItems2[i]) {
          newItems[i] = newItems2[i];
        }
      }

      inventoryObj.initalizeSlider(newItems, slider, 340, 340, null, null, null, false);
    };

    if (inventoryObj.currentPage == 'shop') {
      changeItems(inventoryObj.items_shop, 'js_shopSlider');
    } else if (inventoryObj.currentPage == 'inventory') {
      changeItems(inventoryObj.items_inventory, 'js_inventorySlider');
    }
  },
  updateCategoryAmount: function () {
    var items;

    if (inventoryObj.currentPage == 'shop') {
      items = inventoryObj.items_shop;
    } else if (inventoryObj.currentPage == 'inventory') {
      items = inventoryObj.items_inventory;
    } else {
      return;
    }

    var filter = $('.categoryFilter');
    filter.find('.amount').text(0);
    $.each(items, function (index) {
      if (this.category != null) {
        for (var categoryIndex in this.category) {
          var uuid = this.category[categoryIndex];
          var amountSpan = filter.find('a[rel="' + uuid + '"] .amount');
          var amount;

          if (inventoryObj.currentPage == 'shop') {
            amount = 1;
          } else if (inventoryObj.currentPage == 'inventory') {
            amount = this.amount;
          }

          amountSpan.text(tsdpkt(getValue(amountSpan.text()) + amount));
        }
      }
    });
    $.each(filter.find('li'), function (index) {
      var pageFirstUpper = inventoryObj.currentPage.slice(0, 1).toUpperCase() + inventoryObj.currentPage.slice(1);

      if ($(this).hasClass('in' + pageFirstUpper)) {
        $(this).show();
      } else {
        $(this).hide();

        if (!filter.find('li:visible .active').length) {
          filter.find('li:visible:first a').click();
        }
      }
    });
  },
  fetchDataAboutCurrentAllianceClass: function (newClassName, upgradeItemAjax, questionType, price) {
    if (!this.activatingItem) {
      this.activatingItem = true;
      let that = this;
      $.ajax({
        url: inventoryObj.ingameUrl,
        type: "GET",
        data: {
          component: 'allianceclassselection',
          action: 'fetchDataAboutCurrentAllianceClass',
          ajax: 1,
          asJson: 1
        },
        dataType: "json",
        error: function (error) {
          that.promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price);
        },
        success: function (data) {
          that.promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price, data);
        }
      });
    }
  },
  promptUserForAllianceClassChange: function (newClassName, upgradeItemAjax, questionType, price, response) {
    this.activatingItem = false;

    if (response.userDoesNotHaveAlliance) {
      return 0;
    }

    let localizationString = LocalizationStrings.allianceClassItem[questionType];
    localizationString = localizationString.replace('#allianceClassName#', newClassName);

    if (questionType === 'buyAndActivateItemQuestion') {
      localizationString = localizationString.replace('#darkmatter#', tsdpkt(price));
    }

    if (response && response.currentAllianceClass && response.dateOfLastAllianceClassChange) {
      localizationString += LocalizationStrings.allianceClassItem.appendCurrentClassQuestion;
      localizationString = localizationString.replace('#currentAllianceClassName#', response.currentAllianceClass);
      localizationString = localizationString.replace('#lastAllianceClassChange#', response.dateOfLastAllianceClassChange);
    }

    errorBoxDecision(LocalizationStrings.notice, localizationString, LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
  }
}; // var shopObj = {} end
function GFSlider(obj) {
  var thisObj = this; // gekapseltes JavaScript-Objekt
  //thisObj.sliderObj = obj; // betroffenes HTML Obj
  //config (allgemein)

  thisObj.duration = 500; // in ms - gesamtdauer des slidevorgangs

  thisObj.zIndex = 10;
  thisObj.intervalTime = 30; // in ms - framerate des slidens
  // initialisierung

  thisObj.lastTid = 0; //thisObj.sliderObj.style.zIndex = thisObj.lastZIndex;

  thisObj.inAction = false;
  thisObj.isOpen = false;
  thisObj.lastObj = false;
  thisObj.currHeight = obj.offsetHeight;
  thisObj.opacity = 1; // extra funktionalitaet

  thisObj.header = document.getElementById('header_text');
  thisObj.ressButton = document.getElementById('resources_button');
  thisObj.areaMap = document.getElementById('transImg');

  this.slideIn = function (obj, thisTid, reload) {
    if (!thisObj.inAction) {
      thisObj.slideInObj = obj;

      if (thisObj.lastTid != thisTid || reload) {
        //thisObj.header.style.position='absolute';
        //thisObj.header.style.display='none';
        obj.opacity = 1;
        thisObj.lastTid = thisTid;
        $("#detail").html('<div id="techDetailLoading"></div>');

        if (!thisObj.isOpen) {
          if (thisObj.ressButton) thisObj.ressButton.style.display = 'none';
          obj.style.height = '1px';
          obj.style.display = 'block';
          obj.style.overflow = 'hidden';
          thisObj.inAction = true;
          thisObj.startTime = new Date().getTime();
          thisObj.slideInStep();
          thisObj.isOpen = true;
        } else {
          loadDetails(thisObj.lastTid);
        }
      } else {
        thisObj.header.style.display = 'block';
        thisObj.opacity = 0;
        thisObj.lastTid = 0;
        thisObj.inAction = true;
        thisObj.isOpen = false;
        thisObj.startTime = new Date().getTime();
        thisObj.slideOutObj = thisObj.slideInObj;
        thisObj.slideOutStep();
      }
    }
  };

  this.slideInStep = function () {
    obj = thisObj.slideInObj;
    var time = new Date().getTime();
    var height = parseInt(thisObj.currHeight * ((time - thisObj.startTime) / thisObj.duration));

    if (height < thisObj.currHeight) {
      obj.style.height = height + 'px';
      obj.style.marginTop = thisObj.currHeight - 1 - height + 'px';
      window.setTimeout(thisObj.slideInStep, thisObj.intervalTime);
      thisObj.opacity = Math.max(thisObj.opacity - 0.1, 0);
      thisObj.header.style.opacity = thisObj.opacity; //header.style.filter='alpha(opacity='+(this.opacity*100)+')';

      thisObj.header.style.filter = 'Alpha(opacity=' + 0.5 * 100 + ')';
    } else {
      // Ajax Call
      obj.style.height = thisObj.currHeight + 'px';
      obj.style.marginTop = '0px';
      thisObj.inAction = false;
      thisObj.header.style.display = 'none';
      loadDetails(thisObj.lastTid);

      if (thisObj.lastObj && obj != thisObj.lastObj) {
        thisObj.hideLast();
      }

      thisObj.lastObj = obj;
    }
  };

  this.slideOutStep = function () {
    obj = thisObj.slideInObj;
    var time = new Date().getTime();
    height = parseInt(thisObj.currHeight * ((time - thisObj.startTime) / thisObj.duration));

    if (height < thisObj.currHeight) {
      obj.style.height = thisObj.currHeight - 1 - height + 'px';
      obj.style.marginTop = height + 'px';
      window.setTimeout(thisObj.slideOutStep, thisObj.intervalTime);
      thisObj.opacity = Math.max(thisObj.opacity + 0.1, 0);
      thisObj.header.style.opacity = thisObj.opacity;
    } else {
      obj.style.height = thisObj.currHeight + 'px';
      obj.style.marginTop = '0px';
      thisObj.opacity = 1;
      thisObj.header.style.opacity = thisObj.opacity;

      if (thisObj.ressButton) {
        thisObj.ressButton.style.display = 'block';
      }

      obj.style.display = 'none';
      thisObj.inAction = false;
      thisObj.hideLast();
    }
  };

  this.hideLast = function () {
    if (thisObj.lastObj) {
      $(".slideIn").removeClass("active");
      thisObj.lastObj.style.display = 'none';
      thisObj.inAction = false;
    }

    $(document).trigger("ajaxHideElement", thisObj.lastTid);
  };

  this.hide = function (obj) {
    $(".slideIn").removeClass("active");
    thisObj.slideOutObj = obj;
    thisObj.opacity = 1;
    thisObj.header.style.opacity = thisObj.opacity;
    thisObj.header.style.display = 'block';

    if (thisObj.ressButton) {
      thisObj.ressButton.style.display = 'block';
    }

    if (thisObj.areaMap) {
      thisObj.areaMap.style.display = 'block';
    }

    thisObj.slideOutObj.style.display = 'none';
    thisObj.inAction = false;
    thisObj.lastTid = 0;
    thisObj.isOpen = false;
  };
}
function supplyFleet(data) {
  var data = $.parseJSON(data);

  if (data.status) {
    getAjaxResourcebox();
    /*$("#holdingTime-" + data.id).remove();
     var $holdingTime = $('<span class="countdown holdingTime" id="holdingTime-' + data.id + '"></span>')
        .show()
        .appendTo($('#holdingTimeCell'));
    */

    supplyTimes[data.id] = data.time;
    new simpleCountdown($("#holdingTime-" + data.id), data.time);
  }

  errorBoxAsArray(data["errorbox"]);
}

function updateSupplyDetails(ships, costs, index) {
  $("#shipCount").html(gfNumberGetHumanReadable(ships));
  $("#deutCosts").html(gfNumberGetHumanReadable(costs));
  $("span.countdown").hide();
  $("#holdingTime-" + index).show();
}

function initAllianceDepot() {
  $(".overlayDiv #allydepotlayer select").ogameDropDown();
  $(".holdingTime:first-child").show();

  for (var id in supplyTimes) {
    new simpleCountdown($("#holdingTime-" + id), supplyTimes[id]);
  }

  $("#supplyTimeInput").focus(function () {
    clearInput(this);
  }).keyup(function () {
    var deuterium = getValue($('#resources_deuterium').text());
    var costs = getValue($("#deutCosts").text());
    checkIntInput(this, 1, Math.floor(deuterium / costs));
  });
}
/*
 *
 *  Push Notifications codelab
 *  Copyright 2015 Google Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 *
 */

/* eslint-env browser, es6 */
'use strict';

var pushButton = null;
var applicationServerPublicKey = 'BA_ADqzYuy45TlLLbSQcBmOwbjYYaU1snQM8UtO6ZLgUon7HAOELOS_Wnwyv4kAIARi2jrLmXxtDTnx7htApqyc';
var isSubscribed = false;
var swRegistration = null;

function urlB64ToUint8Array(base64String) {
  var padding = '='.repeat((4 - base64String.length % 4) % 4);
  var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
  var rawData = window.atob(base64);
  var outputArray = new Uint8Array(rawData.length);

  for (var i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }

  return outputArray;
}

function initializeUI() {
  pushButton.addEventListener('click', function () {
    pushButton.disabled = true;

    if (isSubscribed) {
      unsubscribeUser();
    } else {
      subscribeUser();
    }
  }); // Set the initial subscription value

  swRegistration.pushManager.getSubscription().then(function (subscription) {
    isSubscribed = !(subscription === null);
    updateSubscriptionOnServer(subscription); // if (isSubscribed) {
    //     console.log('User IS subscribed.');
    // } else {
    //     console.log('User is NOT subscribed.');
    // }

    updateBtn();
  });
}

function updateBtn() {
  if (Notification.permission === 'denied') {
    pushButton.textContent = 'Push Messaging Blocked.';
    pushButton.disabled = true;
    updateSubscriptionOnServer(null);
    return;
  }

  if (isSubscribed) {
    pushButton.textContent = 'Disable Push Messaging';
    pushButton.checked = true;
  } else {
    pushButton.textContent = 'Enable Push Messaging';
    pushButton.checked = false;
  }

  pushButton.disabled = false;
}

function subscribeUser() {
  var applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);
  swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: applicationServerKey
  }).then(function (subscription) {
    // console.log('User is subscribed.');
    updateSubscriptionOnServer(subscription);
    isSubscribed = true;
    updateBtn();
  })['catch'](function (err) {
    // console.log('Failed to subscribe the user: ', err);
    updateBtn();
  });
}

function unsubscribeUser() {
  swRegistration.pushManager.getSubscription().then(function (subscription) {
    if (subscription) {
      return subscription.unsubscribe();
    }
  })['catch'](function (error) {// console.log('Error unsubscribing', error);
  }).then(function () {
    updateSubscriptionOnServer(null); // console.log('User is unsubscribed.');

    isSubscribed = false;
    updateBtn();
  });
}

function updateSubscriptionOnServer(subscription) {
  if (subscription) {
    $.post("?page=ajax&component=subscription&action=subscribe", {
      subscription: JSON.stringify(subscription)
    });
  }
}

function initSubscriptionSystem() {
  pushButton = document.querySelector('.onoffswitch-checkbox');
  console.log(pushButton);

  if ('serviceWorker' in navigator && 'PushManager' in window) {
    // console.log('Service Worker and Push is supported');
    pushButton.setAttribute('disabled', 'disabled');
    pushButton.classList.add('disabled');
    console.log(pushButton);
    navigator.serviceWorker.register('sw.js').then(function (swReg) {
      // console.log('Service Worker is registered', swReg);
      swRegistration = swReg;
      initializeUI();
    })['catch'](function (error) {// console.error('Service Worker Error', error);
    });
  } else {
    // console.warn('Push messaging is not supported');
    pushButton.textContent = 'Push Not Supported';
  }
}
/*
 * author: Stefanie Knoth
 * description: scripts that are only needed for tablet here
 * date: 04:07:2012
 */
function tabletInitOverviewAdvice() {
  if (!isMobile) {
    return false;
  }

  var $adviceWrapper = $('.adviceWrapper');
  var $exodus = $adviceWrapper.find('#exodus-indicator, #exodus-timer');
  var $exodusProcessed = $adviceWrapper.find('#exodus-indicator-processed');
  $adviceWrapper.prev().before($exodus);
  $adviceWrapper.prev().before($exodusProcessed);
  $('#planetdata').after($adviceWrapper);
}

function tabletInitGalaxyDetails() {
  if (!isMobile) {
    return false;
  }

  var clickEls = ['js_planet', 'js_moon', 'js_debris', 'js_playerName', 'js_allyTag']; //    $('.js_detailRow').hide();

  $('.js_detailRow').css('display', 'none'); // $('.planetname, .planetname1').each(function() {
  //     $newNode = $('<div class="' + $(this).attr('class') + '"/>');
  //     $(this).prev().append($newNode);
  //     $newNode.html($(this).html());
  //     $(this).remove();
  // });

  $('.js_detailRow').each(function (i) {
    i = $(this).attr('rel');

    for (var j = 0; j < clickEls.length; j++) {
      var currEl = $('.' + clickEls[j] + i);

      if (currEl === undefined || currEl.length == 0) {
        if (i == 16) continue;
        if (i == 17) continue;
        return;
      }

      if (currEl.attr('class').indexOf('js_no_action') >= 0) {
        continue;
      }

      currEl.unbind();
      currEl.bind('click.planet', function (e) {
        if ($(this).hasClass('active')) {
          $('.row *.active').removeClass('active'); //                    $('.js_detailRow').hide();

          $('.js_detailRow').css('display', 'none');
        } else {
          $('.row *.active').removeClass('active');
          if ($('.bdaySlotBox')) $('.bdaySlotBox .name').removeClass('active'); //                    $('.js_detailRow').hide();

          $('.js_detailRow').css('display', 'none'); //Show Detailbox for clicked Element

          if ($(this).html().trim()) {
            $(this).addClass('active');

            if ($(this).attr('class').indexOf('js_planet') >= 0) {
              //                            $('.js_detailRowPlanet'+ i).toggle().find('.active_row_details_content');
              elem = '.js_detailRowPlanet' + i;
            } else if ($(this).attr('class').indexOf('js_moon') >= 0) {
              //                            $('.js_detailRowMoon'+ i).toggle();
              elem = '.js_detailRowMoon' + i;
            } else if ($(this).attr('class').indexOf('js_debris') >= 0) {
              //                            $('.js_detailRowDebris'+ i).toggle();
              elem = '.js_detailRowDebris' + i;
            } else if ($(this).attr('class').indexOf('js_playerName') >= 0) {
              //                            $('.js_detailRowPlayer'+ i).toggle();
              elem = '.js_detailRowPlayer' + i;
            } else if ($(this).attr('class').indexOf('js_allyTag') >= 0) {
              //                            $('.js_detailRowAlliance'+ i).toggle();
              elem = '.js_detailRowAlliance' + i;
            }

            $(elem).css('display', 'table-row');
          }
        }
      });
    }
  });
  $("a.planetMoveIcons").bind('click', function (e) {
    e.stopPropagation();
  });
}

function tabletToggleTechtreeInfos(id) {
  if (!isMobile) {
    return false;
  }

  var $techtree = $("div.techtree[data-id='" + id + "']");
  var $techDiv = $techtree.find('.techImage a');
  $techDiv.each(function () {
    var $thisObj = $(this);
    var colorClass = $thisObj.parent().hasClass('built') ? "undermark" : "overmark";
    var techName = $thisObj.data('tech-name');
    var techType = $thisObj.data('tech-type');
    $thisObj.append('<div class="short_info" style="display: none"><span class="' + colorClass + '">' + techName + '</span><br/>' + techType + '</div>');
  });

  if ($techDiv.length) {
    $techtree.append($('<a id="toggleDetails" href="javascript:void(0)" class="btn_blue">' + LocalizationStrings.moreDetails + '</a>').click(function () {
      var $shortInfo = $techtree.find('.short_info');

      if ($shortInfo.is(':visible')) {
        $(this).text(LocalizationStrings.moreDetails);
      } else {
        $(this).text(LocalizationStrings.lessDetails);
      }

      $shortInfo.toggle();
    }));
  }
}

function tabletInitEmpire() {
  if (!isMobile) {
    return false;
  }

  var width = $('#mainWrapper').width();
  width = width < 1024 ? '1024' : width;
  $('#outerWrapper').width(width);
  $('.reset').hide();
}

function tabletInitPayment() {
  if (!isMobile) {
    return false;
  }

  $("#payment").parent('.overlayDiv').dialog('option', 'title', paymentLoca.title);
  document.addEventListener("deviceready", function () {
    $("#mobilePayment a.js_buyPacket").unbind('click').bind('click', function () {
      HostApp.StartPayment($(this).attr("ref"), userData.id, constants.name, constants.language);
    });

    HostApp.OnPaymentFinished = function () {
      getAjaxResourcebox(function (resources) {
        fadeBox(paymentLoca.success, false);
        $("#payment").parent().dialog('close');
        $("#planet #content .level span").attr('class', 'undermark').text(gfNumberGetHumanReadable(resources.darkmatter.amount, isMobile));
      });
    };

    HostApp.OnPaymentFailed = function () {
      fadeBox(paymentLoca.error, true);
    };
  }, false);
}

function tabletInitGalaxy() {
  if (!isMobile) {
    return false;
  }

  $("#galaxyContent").wipetouch({
    wipeLeft: function (e) {
      if (!$("#galaxyLoading:visible").length) {
        submitOnKey('ArrowLeft');
      }
    },
    wipeRight: function (e) {
      if (!$("#galaxyLoading:visible").length) {
        submitOnKey('ArrowRight');
      }
    },
    preventDefault: false,
    preventDefaultWhenTriggering: true,
    moveX: 180,
    moveY: 60
  });
}

function initRetinaImages() {
  // we only want to replace images if we're on a retina display:
  if ($('.js_replace2x').css('font-size') == "1px") {
    $('img.js_replace2x').each(function () {
      $(this).attr('src', $(this).attr('rel'));
    });
  }
}
function setupOverlay(pageLink, overlayTitle, techID) {
  $('.build-it_premium').addClass('overlay');
  $('.build-it_premium').attr('href', pageLink);
  $('.build-it_premium').data('overlay-title', overlayTitle);
  $('.build-it_premium').data('techid', techID);
}

function drawErrorbox(type, message, header, options, link, otherclass) {
  var otherclass = otherclass == undefined ? false : otherclass;
  var domobject = otherclass !== false ? $("." + otherclass) : $(".build-it_disabled");

  if (typeof link == "undefined" || link == "") {
    link = document.location.href;
  }

  domobject.click(function () {
    if (header !== undefined && options !== undefined && link !== undefined) {
      if (type == 'notify') {
        errorBoxNotify(header, message, options.allOk, function () {
          window.location.href = link;
        });
      }

      if (type == 'decision') {
        errorBoxDecision(header, message, options.allYes, options.allNo, function () {
          window.location.href = link;
        });
      }
    }

    if (type == 'fadeBox') {
      fadeBox(message, true);
    }
  });
}

function showErrors() {
  var options = {
    'allYes': loca.allYes,
    'allNo': loca.allNo,
    'allOk': loca.allOk
  };

  if (isBuildlistNeeded) {
    if (!hasCommander && !(isShip || isRocket)) {
      drawErrorbox('decision', loca.infoBuildlist, loca.allError, options, links.decisionCommander, 'build-it_premium');
      return 1;
    }

    if (isRocketAndStorageNotFree) {
      drawErrorbox('notify', loca.noRocketsiloCapacity, loca.allError, options, links.notify);
      return 1;
    }
  } else {
    if (error !== null && error !== 0) {
      if (premiumerror) {
        if (showErrorOnPremiumbutton) {
          drawErrorbox('decision', errorlist[error], loca.allError, options, links[error], buttonClass);
          return 1;
        } else {
          drawErrorbox('decision', errorlist[error], loca.allError, options, links[error]);
          return 1;
        }
      } else if (isRocketAndStorageNotFree) {
        drawErrorbox('notify', loca.noRocketsiloCapacity, loca.allError, options, links.notify);
        return 1;
      } else if (isBusy) {
        return 1;
      } else {
        drawErrorbox('notify', errorlist[error], loca.allError, options, '');
        return 1;
      }
    }
  }

  return 0;
}
function initGlobalTechtree(id) {
  var $techtree = $("div.graph[data-id='" + id + "']");
  $techtree.find(".headline").unbind('click').bind('click', function () {
    $(this).next().toggle(function () {
      var $dialog = $techtree.parents('.ui-dialog');
      $dialog.hide();
      $(this).toggleClass("open");
      $dialog.show();
    });
    /*$(this).next().slideToggle("slow", function() {
        $(this).toggleClass("open");
         $dialog.css('zoom', 1.1);
        setTimeout(function() {
            $dialog.css('zoom', 1);
        }, 1000);
    });*/
  });

  if (openTree == 'all') {
    $techtree.find('.techtree_content').show(0, function () {
      $(this).addClass('open');
    });
  } else if (openTree != null) {
    $techtree.find('.techtree_content_' + openTree).show(0, function () {
      $(this).addClass('open');
    });
  }
}

function initOverlayName() {
  let title = $('#technologytree').data('title');
  $("#technologytree").closest(".ui-dialog").find('.ui-dialog-title').html(title);
}

function drawArrows(id) {
  var $techtree = $("div.graph[data-id='" + id + "']");
  var rowHeight = $techtree.find('.techImage').outerHeight(true);
  var overallWidth = 20;
  $techtree.find('.techWrapper.depth1').each(function () {
    overallWidth += $(this).outerWidth();
  });
  $techtree.css('width', overallWidth);
  var newTree = jsPlumb.getInstance();
  newTree.Defaults.Container = $techtree; // for round edges set corner radius below

  newTree.Defaults.Connector = ["Flowchart", {
    cornerRadius: 20
  }];
  newTree.Defaults.Endpoint = ["Rectangle", {
    cssClass: "endpoint",
    width: 1,
    height: 1
  }]; // default anchors. in most cases a bad idea, only as backup.
  // Continuous Anchors may produce partially overlapping connections

  newTree.Defaults.Anchors = ["ContinuousTop", "ContinuousBottom"]; // coordinates: an array containing the coordinates of each endpoint in pixels as [left,top]

  var coordinates = {}; // endpoints-array is set in singleTree.tpl.php. the values are techIds.

  $.each(endpoints, function () {
    var $elem = $techtree.find(".tech" + this.toString());
    newTree.addEndpoint($elem);

    // TODO OGAMEX: without this additional if check, the techtree throws errors.
    var elemOffset = $elem.find('a').offset();
    if (elemOffset) {
      var elemLeft = Math.floor(elemOffset.left);
      var elemTop = Math.floor(elemOffset.top);
      coordinates[this] = [elemLeft, elemTop];
    }
    else {
      coordinates[this] = [0, 0];
    }
  });
  var changedSomething;

  do {
    // for every connection:
    // check if the source is below the target on the screen. if not, move the source downwards one row
    changedSomething = false;
    $.each(connections, function () {
      var $source = $techtree.find(".tech" + this.source + " a");
      var $target = $techtree.find(".tech" + this.target + " a");

      // TODO OGAMEX: without this additional if check, the techtree throws errors.
      var sourceOffset = $source.offset();
      var targetOffset = $target.offset();

      if (sourceOffset == undefined || targetOffset == undefined) {
        return;
      }

      if (sourceOffset.top >= targetOffset.top - 10 && sourceOffset.top <= targetOffset.top + 10) {
        $source.parent().css('margin-top', parseInt($source.parent().css('margin-top').replace(/px/, '')) + rowHeight); // we just moved a tech downwards... we have to adjust all corresponding coordinates
        // the surrounding div with class depth* is the second parent

        $source.parent().parent().find('a[data-tech-id]').each(function () {
          // TODO OGAMEX: without this additional if check, the techtree throws errors.
          if (coordinates[$(this).attr('data-tech-id')]) {
            coordinates[$(this).attr('data-tech-id')][1] += rowHeight; // 1 == top
            //console.log("RESET "+$(this).attr('data-tech-id') + " "+(coordinates[$(this).attr('data-tech-id')][1]));
          }
        });
        changedSomething = true;
      }
    });
  } while (changedSomething); // columns and rows: these 2 arrays will contain all different left- and top-values of the endpoint coordinates


  var columns = [];
  var rows = [];

  for (var elem in coordinates) {
    if (columns.indexOf(coordinates[elem][0]) == -1) {
      columns.push(coordinates[elem][0]);
    }

    if (rows.indexOf(coordinates[elem][1]) == -1) {
      rows.push(coordinates[elem][1]);
    }
  }

  columns.sort(function (a, b) {
    return a > b ? 1 : -1;
  });
  rows.sort(function (a, b) {
    return a > b ? 1 : -1;
  }); // now the 2 arrays contain a numeric sorted list
  // translated: an array containing the same keys as the coordinates-array, but the values aren't pixels anymore.
  // they are the numbers of the row/column containing that endpoint
  // with this information, it will be possible to test whether the path for a connection-line is free or not.

  var translated = {};

  for (var elem2 in coordinates) {
    translated[elem2] = {
      'left': columns.indexOf(coordinates[elem2][0]),
      'top': rows.indexOf(coordinates[elem2][1])
    };
  } //console.dir(translated);
  // unfortunately, it matters in which order you put the connections into the drawing algorithm.
  // (because every line that is drawn blocks 1 anchor place at its 2 endpoints)
  // lines that will be drawn straight upwards have to be protected and drawn first..
  // -> sort by the minimum column distance


  connections.sort(function (a, b) {
    return Math.abs(translated[a.source]['left'] - translated[a.target]['left']) < Math.abs(translated[b.source]['left'] - translated[b.target]['left']) ? -1 : 1;
  }); // connection styling, see http://jsplumbtoolkit.com/doc/paint-styles

  var connectStyles = {
    hasRequirements: {
      strokeStyle: "#015100",
      lineWidth: 3
    },
    hasNotRequirements: {
      strokeStyle: "#510009",
      lineWidth: 3
    }
  }; // our anchors, format: [x-coordinate 0-1, y-coordinate 0-1, dx {-1;+1}, dy {-1;+1}
  // the first two parameters mark the point where the line starts at the endpoint
  // (change if you need, or add more entries),
  // the last two parameters give the initial direction of the line (do not change).
  // the anchors at the beginning of the anchor-arrays will be used first (try to keep it symmetrical)

  var leftAnchors = [[0, 0.5, -1, 0], [0, 0.3, -1, 0], [0, 0.7, -1, 0], [0, 0.9, -1, 0]];
  var rightAnchors = [[1, 0.5, 1, 0], [1, 0.3, 1, 0], [1, 0.7, 1, 0], [1, 0.9, 1, 0]];
  var bottomAnchors = [[0.5, 1, 0, 1], [0.3, 1, 0, 1], [0.7, 1, 0, 1], [0.9, 1, 0, 1]];
  var topAnchors = [[0.5, 0, 0, -1], [0.3, 0, 0, -1], [0.7, 0, 0, -1], [0.9, 0, 0, -1]]; // 0.9 is used in tech TECH_NETZTECHNIK. i guess that's the only one
  // we do not want to use the same anchor twice. so we have to remember which of the anchors was already used

  var alreadyUsedAnchors = {};

  function chooseAnchor(elemId, orientation, anchors, alreadyUsedAnchors) {
    if (!alreadyUsedAnchors[elemId]) {
      alreadyUsedAnchors[elemId] = {};
    }

    if (alreadyUsedAnchors[elemId][orientation] == undefined) {
      alreadyUsedAnchors[elemId][orientation] = 0;
    } // a stupid algorithm perhaps, but we only track the number of already used anchors.
    // one after we other is used. could be modified in the future; should be enough for now.


    ++alreadyUsedAnchors[elemId][orientation];
    return anchors[alreadyUsedAnchors[elemId][orientation] - 1];
  } // draw each connection


  $.each(connections, function () {
    var $source = $techtree.find(".tech" + this.source + " a");
    var $target = $techtree.find(".tech" + this.target + " a");
    var connectOptions = {
      source: $source,
      target: $target,
      overlays: [["Arrow", {
        location: -5,
        paintStyle: connectStyles[this.paintStyle],
        width: 8,
        length: 8,
        foldback: 0.8
      }], ["Label", {
        label: this.label,
        cssClass: "label " + this.paintStyle,
        location: 0.85
      }]],
      paintStyle: connectStyles[this.paintStyle],
      hoverPaintStyle: {
        strokeStyle: "rgb(255, 255, 0)"
      }
    }; // if you want to change options
    // consult the documentation at http://jsplumbtoolkit.com for details
    //var sourcePosition = $source.offset();
    //var targetPosition = $target.offset();
    //console.info("source:" + $source.attr('data-tech-name') + ", target: " + $target.attr('data-tech-name') + ". pos " + sourcePosition.left + "|" + sourcePosition.top + " vs pos " + targetPosition.left + "|" + targetPosition.top);
    //#############################################
    // search for the path that we line should take
    // it may not go through other endpoints/techs
    // it should use the shortest path and should not change directions too often (1-2)

    if (translated[this.target].left < translated[this.source].left) {
      // target is left of the source
      // TODO OGAMEX: uncommented this because it throws errors while drawing the techtree.
      // Even with identical HTML to the original game, it still doesn't work for certain
      // complicated tech trees.
      /*if (!lineInCoordinatesBlocked(translated, translated[this.source].left, translated[this.source].top, translated[this.source].left, translated[this.target].top) && !positionInCoordinatesBlocked(translated, translated[this.source].left, translated[this.target].top) && !lineInCoordinatesBlocked(translated, translated[this.source].left, translated[this.target].top, translated[this.target].left, translated[this.target].top)) {
        // vertical, horizontal
        connectOptions.anchors = [chooseAnchor(this.source, 'top', topAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'right', rightAnchors, alreadyUsedAnchors)]; //console.log("chose top right");
      } else {
        // horizontal, vertical
        connectOptions.anchors = [chooseAnchor(this.source, 'left', leftAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'bottom', bottomAnchors, alreadyUsedAnchors)];
        connectOptions.overlays[1][1] = readableVersionOfLabel(connectOptions.overlays[1][1], alreadyUsedAnchors[this.target].bottom); //console.log("chose left bottom");
      }*/
    } else if (translated[this.target].left > translated[this.source].left) {
      // target is right of the source
      // TODO OGAMEX: uncommented this because it throws errors while drawing the techtree.
      // Even with identical HTML to the original game, it still doesn't work for certain
      // complicated tech trees.
      /*if (!lineInCoordinatesBlocked(translated, translated[this.source].left, translated[this.source].top, translated[this.source].left, translated[this.target].top) && !positionInCoordinatesBlocked(translated, translated[this.source].left, translated[this.target].top) && !lineInCoordinatesBlocked(translated, translated[this.source].left, translated[this.target].top, translated[this.target].left, translated[this.target].top)) {
        // vertical, horizontal
        connectOptions.anchors = [chooseAnchor(this.source, 'top', topAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'left', leftAnchors, alreadyUsedAnchors)]; //console.log("chose top left");
      } else {
        // horizontal, vertical
        connectOptions.anchors = [chooseAnchor(this.source, 'right', rightAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'bottom', bottomAnchors, alreadyUsedAnchors)];
        connectOptions.overlays[1][1] = readableVersionOfLabel(connectOptions.overlays[1][1], alreadyUsedAnchors[this.target].bottom); //console.log("chose right bottom");
      }*/
    } else {
      // target is above the source
      if (translated[this.target].top < translated[this.source].top - 1 && lineInCoordinatesBlocked(translated, translated[this.source].left, translated[this.source].top, translated[this.target].left, translated[this.target].top)) {
        // but it's far away and some tech/endpoint would block our path for a direct line
        connectOptions.anchors = [chooseAnchor(this.source, 'left', leftAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'left', leftAnchors, alreadyUsedAnchors)]; //console.log("chose left left");
        // NOTE: i didn't find a case where this occurred,
        // but it could be possible that 2 connections on the same column could overlap with this rule
        // in this case, "right,right" should be chosen
      } else {
        // the target is right above us. shoot it.
        connectOptions.anchors = [chooseAnchor(this.source, 'top', topAnchors, alreadyUsedAnchors), chooseAnchor(this.target, 'bottom', bottomAnchors, alreadyUsedAnchors)];
        connectOptions.overlays[1][1] = readableVersionOfLabel(connectOptions.overlays[1][1], alreadyUsedAnchors[this.target].bottom); //console.log("chose top bottom");
      }
    } // else: default.

    newTree.connect(connectOptions);
  });
}

function initTechtree(id) {
  (function ($) {
    drawArrows(id);
  })(jQuery);

  tabletToggleTechtreeInfos(id);
}
/**
 *
 * @param labelObject object
 * @param useCount int
 * @returns string
 */


function readableVersionOfLabel(labelObject, useCount) {
  labelObject.location = -0.05 * useCount + 0.85;
  var split = labelObject.label.indexOf('/');

  if (split) {//        label = label.substring(0,split) + '<br/>/<br/>' + label.substring(split + 1);
  }

  return labelObject;
}
/**
 * check single line of the matrix if a line could be drawn. does not check start or end of the line
 * @param coordinates array containing the positions of the endpoints
 * @param sourceLeft int x-coordinate of the source
 * @param sourceTop int y-coordinate of the source
 * @param targetLeft int x-coordinate of the target
 * @param targetTop int y-coordinate of the target
 * @return bool if the path is blocked by an element
 */


function lineInCoordinatesBlocked(coordinates, sourceLeft, sourceTop, targetLeft, targetTop) {
  if (sourceLeft == targetLeft) {
    // check column (target is above. every time!)
    for (var i in coordinates) {
      if (coordinates[i].left == sourceLeft && sourceTop > coordinates[i].top && targetTop < coordinates[i].top) {
        return true;
      }
    }
  } else if (sourceTop == targetTop && sourceLeft > targetLeft) {
    // check row to the left
    for (var j in coordinates) {
      if (coordinates[j].top == sourceTop && sourceLeft > coordinates[j].left && targetLeft < coordinates[j].left) {
        return true;
      }
    }
  } else if (sourceTop == targetTop && sourceLeft < targetLeft) {
    // check row to the right
    for (var k in coordinates) {
      if (coordinates[k].top == sourceTop && sourceLeft < coordinates[k].left && targetLeft > coordinates[k].left) {
        return true;
      }
    }
  }

  return false;
}
/**
 * check if a single spot in the coordinates array is blocked by an element. used for edges of the connection line
 * @param coordinates the coordinates matrix data
 * @param left x-coordinate to check
 * @param top y-coordinate to check
 * @returns {boolean}
 */


function positionInCoordinatesBlocked(coordinates, left, top) {
  for (var i in coordinates) {
    if (coordinates[i].left == left && coordinates[i].top == top) {
      return true;
    }
  }

  return false;
}
var javascriptAvailable = true;
var days = new Array('Mon', 'Tus', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');
var months = new Array("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");

function getFormatedDate(timestamp, format) {
  var currTime = new Date();
  currTime.setTime(timestamp);
  str = format;
  str = str.replace('[d]', dezInt(currTime.getDate(), 2));
  str = str.replace('[D]', days[currTime.getDay()]);
  str = str.replace('[m]', dezInt(currTime.getMonth() + 1, 2));
  str = str.replace('[M]', months[currTime.getMonth()]);
  str = str.replace('[j]', parseInt(currTime.getDate()));
  str = str.replace('[Y]', currTime.getFullYear());
  str = str.replace('[y]', currTime.getFullYear().toString().substr(2, 4));
  str = str.replace('[G]', currTime.getHours());
  str = str.replace('[H]', dezInt(currTime.getHours(), 2));
  str = str.replace('[i]', dezInt(currTime.getMinutes(), 2));
  str = str.replace('[s]', dezInt(currTime.getSeconds(), 2));
  return str;
}
/**
 * adds prefix digits to a number ('2'->'02')
 *
 * @param int   number
 * @param int   digits
 * @param str   prefix, default is '0'
 */


function dezInt(num, size, prefix) {
  prefix = prefix ? prefix : "0";
  var minus = num < 0 ? "-" : "",
      result = prefix == "0" ? minus : "";
  num = Math.abs(parseInt(num, 10));
  size -= ("" + num).length;

  for (var i = 1; i <= size; i++) {
    result += "" + prefix;
  }

  result += (prefix != "0" ? minus : "") + num;
  return result;
}

function getFormatedTime(time) {
  hours = Math.floor(time / 3600);
  timeleft = time % 3600;
  minutes = Math.floor(timeleft / 60);
  timeleft = timeleft % 60;
  seconds = timeleft;
  return dezInt(hours, 2) + ":" + dezInt(minutes, 2) + ":" + dezInt(seconds, 2);
}
function tsdpkt(f) {
  var vz = "";

  if (f < 0) {
    vz = "-";
  }

  f = Math.abs(f);
  var r = f % 1000;

  while (f >= 1000) {
    var k1 = "";

    if (f % 1000 < 100) {
      k1 = "0";
    }

    if (f % 1000 < 10) {
      k1 = "00";
    }

    if (f % 1000 == 0) {
      k1 = "00";
    }

    f = Math.abs((f - f % 1000) / 1000);
    r = f % 1000 + LocalizationStrings['thousandSeperator'] + k1 + r;
  }

  r = vz + r;
  return r;
}

function formatTime(seconds) {
  var hours = Math.floor(seconds / 3600);
  seconds -= hours * 3600;
  var minutes = Math.floor(seconds / 60);
  seconds -= minutes * 60;
  if (minutes < 10) minutes = "0" + minutes;
  if (seconds < 10) seconds = "0" + seconds;
  return hours + ":" + minutes + ":" + seconds;
}

function round(x, n) {
  if (n < 1 || n > 14) return false;
  var e = Math.pow(10, n);
  var k = (Math.round(x * e) / e).toString();
  if (k.indexOf('.') == -1) k += '.';
  k += e.toString().substring(1);
  return k.substring(0, k.indexOf('.') + n + 1);
}

function show_hide_menus(element) {
  if ($(element).is(':visible')) {
    $(element).hide();
  } else {
    $(element).show();
  }
}

function change_class(ele) {
  if (document.getElementById(ele).className == "closed") {
    document.getElementById(ele).className = "opened";
  } else {
    document.getElementById(ele).className = "closed";
  }
}

function show_hide_tbl(id) {
  var el = document.getElementById(id);

  try {
    if (el) el.style.display = el.style.display == "none" ? "table-row" : "none";
  } catch (e) {
    // Der IE bis V7 kann kein table-row, deshalb Fallback auf 'Block'
    el.style.display = "block";
  }
}

function cntchar(inputField, m) {
  var $inputField = $(inputField);

  if ($inputField.val().length > m) {
    $inputField.val($inputField.val().substr(0, m));
  }

  $inputField.parents("form").find(".cntChars").text($inputField.val().length);
}

function showGalaxy(galaxy, system, planet) {
  openParentLocation("index.php?page=ingame&component=galaxy&no_header=1&galaxy=" + galaxy + "&system=" + system + "&planet=" + planet);
}

function openParentLocation(url) {
  try {
      document.location.href = url;
  } catch (error) {
        try {
          window.parent.document.location.href = url;
        } catch (error) {
            window.opener.document.location.href = url;

        }
  }
}

function submitOnEnter(ev) {
  // Number 13 is the "Enter" key on the keyboard
  if (ev.key === 'Enter') {
    // Cancel the default action, if needed
    ev.preventDefault(); // Trigger the button element with a click

    trySubmit();
    return false;
  } else {
    return true;
  }
}

function setMaxIntInput(formElement, data) {
  for (var techID in data) {
    if (!$(formElement).find("#ship_" + techID).attr("disabled")) {
      $(formElement).find("#ship_" + techID).val(data[techID]);
      checkIntInput($(formElement).find("ship_" + techID), 0, data[techID]);
    }
  }
}

function clearInput(id) {
  $(id).val("");
}

function checkIntInput(id, minVal, maxVal) {
  var value = $(id).val();

  if (typeof value != "undefined" && value != "") {
    intVal = Math.abs(getValue(value));

    if (maxVal != null) {
      intVal = Math.min(intVal, maxVal);
    }

    $(id).val(intVal);
  }
}

function clampInt(val, minVal, maxVal, allowEmpty) {
  if (allowEmpty && (val === '' || val === 0)) {
    return '';
  }

  let intVal = parseInt(val);

  if (isNaN(intVal)) {
    return minVal;
  }

  intVal = Math.min(intVal, maxVal);
  intVal = Math.max(intVal, minVal);
  return intVal;
}

function clampFloat(val, minVal, maxVal) {
  let floatVal = parseFloat(val);

  if (isNaN(floatVal)) {
    return minVal;
  }

  floatVal = Math.max(floatVal, minVal);
  floatVal = Math.min(floatVal, maxVal);
  return floatVal;
}

function handlerToSubmitAjaxForm(form) {
  var submitFunction = "submit_" + String(form);

  if ($.isFunction(window[submitFunction])) {
    window[submitFunction]();
  }

  return false;
}

function ajaxCall(url, targetSelector, callback) {
  if (typeof targetSelector === 'string') {
    let $targetHTMLObj = $(targetSelector);
    $targetHTMLObj.find('select').ogameDropDown('destroy');
    $targetHTMLObj.html('<p class=\"ajaxLoad\"></p>');
  }

  $.post(url, function (data) {
    if (typeof targetSelector === 'string') {
      let $targetHTMLObj = $(targetSelector);
      $targetHTMLObj.html(data);
      $targetHTMLObj.find('select').ogameDropDown();
    }

    if (typeof callback === 'function') {
      callback();
    }
  });
}

function ajaxSubmit(url, formDataOrSelector, targetSelector, callback) {
  if (typeof targetSelector === 'string') {
    let $targetHTMLObj = $(targetSelector);
    $targetHTMLObj.find('select').ogameDropDown('destroy');
    $targetHTMLObj.html("<p class=\"ajaxLoad\"><?=LOCA_ALL_AJAXLOAD ?></p>");
  }

  let formData = typeof formDataOrSelector === 'string' ? $(formDataOrSelector).serialize() : formDataOrSelector;
  $.post(url, formData, function (data) {
    if (typeof targetSelector === 'string') {
      let $targetHTMLObj = $(targetSelector);
      $targetHTMLObj.html(data);
      $targetHTMLObj.find('select').ogameDropDown();
    }

    if (typeof callback === 'function') {
      callback();
    }
  });
}

Number.prototype.isBetween = function (min, max) {
  return this >= min && this <= max;
};

function getValue(value) {
  result = parseInt(value.toString().replace(/^k$/, "1000").replace(/k/, "000").replace(/^0+/, "").replace(/[^0-9]/g, ""));
  return isNaN(result) ? 0 : result;
}
/**
 * loads an external js script and calls a function when it is loaded
 * @param url url of the script to load
 * @param callback function to call when script is loaded
 * @url http://www.nczonline.net/blog/2009/07/28/the-best-way-to-load-external-javascript/
 */


function loadScript(url, callback) {
  if (typeof loadScript.loadedScripts == 'undefined') {
    loadScript.loadedScripts = {};
  }

  if (typeof loadScript.loadedScripts[url] == 'undefined') {
    loadScript.loadedScripts[url] = true;
    var script = document.createElement("script");
    script.type = "text/javascript";

    if (script.readyState) {
      //IE
      script.onreadystatechange = function () {
        if (script.readyState == "loaded" || script.readyState == "complete") {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else {
      //Others
      script.onload = function () {
        callback();
      };
    }

    script.src = url;
    var head = document.getElementsByTagName("head")[0];
    head.appendChild(script);
  } else {
    callback();
  }
}

function formatNumber(object, value) {
  var formattedValue = number_format(getValue(value), 0, LocalizationStrings['decimalPoint'], LocalizationStrings['thousandSeparator']);
  var $thisObj = $(object);
  var range = $thisObj.getSelection();

  if ($thisObj.val().length !== formattedValue.length) {
    range.start = Math.max(0, range.start + formattedValue.length - $thisObj.val().length);
    range.end = Math.max(0, range.end + formattedValue.length - $thisObj.val().length);
  }

  $thisObj.val(formattedValue);

  if ($thisObj.is(":focus")) {
    $thisObj.setSelection(range);
  }
}

function initToggleHeader(name) {
  $('a.toggleHeader[data-name=' + name + ']').click(function (e) {
    e.preventDefault();
    let toggleState = $(e.currentTarget).closest('.planet-header').hasClass('shortHeader');
    $(e.currentTarget).closest('.planet-header').toggleClass('shortHeader');
    $(".c-left").toggleClass('shortCorner');
    $(".c-right").toggleClass('shortCorner');
    changeSetting('headerImage', name + '|' + toggleState);
  });
}

function initFormValidation() {
  $("form.formValidation").validationEngine({
    validationEventTrigger: "keyup blur",
    promptPosition: "centerRight"
  });
}

Function.prototype.clone = function () {
  var fct = this;

  var clone = function () {
    return fct.apply(this, arguments);
  };

  clone.prototype = fct.prototype;

  for (var property in fct) {
    if (fct.hasOwnProperty(property) && property !== 'prototype') {
      clone[property] = fct[property];
    }
  }

  return clone;
};

function hideTipsOnTabChange() {
  $("select").ogameDropDown('hide');
  Tipped.hideAll();
}

jQuery.fn.slideFadeToggle = function (speed, easing, callback) {
  return this.animate({
    opacity: 'toggle',
    width: 'toggle'
  }, speed, easing, callback);
};

function focusOnTabChange(element, focusOnReady) {
  var focusFunction = function () {
    $(element).focus();
  };

  if (focusOnReady == true) {
    $(document).ready(focusFunction);
  }

  $(window).unbind('blur').bind('blur', focusFunction);
}
/**
 * @see http://obvcode.blogspot.de/2007/11/easiest-way-to-check-ie-version-with.html
 * @return {Number}
 */


function getIEVersion() {
  var version = 999;
  if (navigator.appVersion.indexOf("MSIE") != -1) version = parseFloat(navigator.appVersion.split("MSIE")[1]);
  return version;
}

ogame.tools = {
  /**
   * adds a hover effect to given selectors
   * @param {String} selector - selector with elements to apply the style to
   * @returns {undefined}
   */
  addHover: function (selector) {
    $(selector).on({
      mouseenter: function () {
        $(this).addClass("over");
      },
      mouseleave: function () {
        $(this).removeClass("over");
      }
    });
  },

  /**
   * shows a "to top" button on long pages
   *
   * @returns {undefined}
   */
  scrollToTop: function () {
    var $scrollToTop = $('.scroll_to_top');
    $(window).on('scroll.scrollToTop', function () {
      $('.scroll_to_top').css({
        visibility: $scrollToTop.offset().top > window.innerHeight ? 'visible' : 'hidden'
      }, 600);
    });
    $scrollToTop.on('click.scrollToTop', function () {
      $('body, html').animate({
        scrollTop: 0
      }, 600);
    });
  }
};
/**
 * Common UI Components, that are reused across the Game
 *
 **/

/**
 * Fill level bar display for storage rooms and cargo space
 *
 * @param barContainerClass
 * @param barClass
 * @param premiumBarClass - if additional premium bar is wanted
 *
 **/

function refreshBars(barContainerClass, barClass, premiumBarClass) {
  var $barContainer = $('.' + barContainerClass);
  $barContainer.each(function () {
    var $this = $(this),
        amountFull = $this.data('currentAmount'),
        capacity = $this.data('capacity'),
        wPercent = amountFull / capacity * 100,
        $bar = $this.find('.' + barClass);

    if (wPercent > 100) {
      wPercent = 100;
    } else if (wPercent == 0) {
      wPercent = 0;
    } else if (wPercent < 1.3) {
      wPercent = 1.3;
    }

    $bar.css('width', wPercent + '%');

    if (wPercent < 90) {
      $bar.attr('class', barClass + ' filllevel_undermark');
    } else if (wPercent > 90 && wPercent < 100) {
      $bar.attr('class', barClass + ' filllevel_middlemark');
    } else {
      $bar.attr('class', barClass + ' filllevel_overmark');
    }

    if (premiumBarClass) {
      var $premiumBar = $this.find('.' + premiumBarClass),
          wPercentPremium = $premiumBar.data('premiumPercent');

      if (wPercent + wPercentPremium > 100) {
        wPercentPremium = 100 - wPercent;
      }

      $premiumBar.css('width', wPercentPremium + '%');
    }
  });
}
function initTooltipSkins() {
  jQuery.extend(Tipped.Skins, {
    'cloud': {
      offset: {
        x: 0,
        y: -1,
        mouse: {
          x: -12,
          y: -12
        } // only defined in the base class

      },
      stem: {
        height: 6,
        width: 11,
        offset: {
          x: 5,
          y: 5
        },
        spacing: 0
      }
    },
    'premium': {
      offset: {
        x: 0,
        y: -1,
        mouse: {
          x: -12,
          y: -12
        } // only defined in the base class

      },
      stem: {
        height: 6,
        width: 11,
        offset: {
          x: 5,
          y: 5
        },
        spacing: 0
      }
    }
  });
}
function changeTooltip(object, title) {
  var targetElement = $(object);

  if (targetElement.length == 0) {
    return;
  }

  removeTooltip(targetElement);
  $(targetElement).attr('title', title);
  initTooltips(targetElement);
}

function removeTooltip(object) {
  var targetElement = $(object);
  targetElement.each(function () {
    if ($(this).data('tooltipLoaded')) {
      $(this).data('tooltipLoaded', false);
      Tipped.remove($(this));
    }
  });
}

function getTooltipOptions(element) {
  var $thisObj = $(element);
  var options = {
    skin: 'cloud',
    size: 'x-small',
    maxWidth: 400,
    closeButton: false,
    hideOn: {
      element: 'mouseleave',
      tooltip: 'mouseleave'
    },
    hideOnClickOutside: true
  }; // we need longer tooltips on galaxy

  if (window.location.href.indexOf('galaxy') !== -1) {
    options.maxWidth = 400;
  }

  if ($thisObj.hasClass('tooltipPremium')) {
    options.skin = 'premium';
  }

  if ($thisObj.hasClass('tooltipLeft')) {
    options.position = {
      target: 'leftmiddle',
      tooltip: 'righttop'
    };
  } else if ($thisObj.hasClass('tooltipRight')) {
    options.position = {
      target: 'rightmiddle',
      tooltip: 'lefttop'
    };
  } else if ($thisObj.hasClass('tooltipBottom')) {
    options.position = {
      target: 'bottommiddle',
      tooltip: 'topmiddle'
    };
  }

  if ($thisObj.data('tooltip-width')) {
    options.maxWidth = $thisObj.data('tooltip-width');
  }

  if ($thisObj.hasClass('hideTooltipOnMouseenter')) {
    options.hideOn.tooltip = 'mouseenter';
  }

  if (isMobile || $thisObj.hasClass('tooltipClose')) {
    options.hideOthers = true; // options.hideOn = false;
  }

  if ($thisObj.hasClass('hideOthers')) {
    options.hideOthers = true;
  }

  options.afterUpdate = function (content, element) {
    if (isMobile && $thisObj.data('tooltip-button')) {
      var $buttonDiv = $(document.createElement('div')).addClass('tooltipButton');
      $(document.createElement('a')).addClass('btn_blue').attr('href', 'javascript:void(0);').html($thisObj.data('tooltip-button')).bind('click', function (e) {
        if ($(element).not('a') && $(element).find('a').length) {
          element = $(element).find('a')[0];
        }

        var event = document.createEvent("MouseEvents");
        event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
        element.dispatchEvent(event);
      }).appendTo($buttonDiv);
      $(content).append($buttonDiv);
    }

    if (isMobile || $thisObj.hasClass('tooltipClose')) {
      var $closeBtn = $(document.createElement('div')).addClass('close-tooltip');
      $(content).prepend($closeBtn);
    }

    Tipped.refresh(element);
  };

  return options;
}

function getTooltipSelector(selector) {
  var standardSelector = ".tooltipPremium, .tooltip, .tooltipRight, .tooltipLeft, .tooltipBottom, .tooltipClose, .tooltipHTML, .tooltipRel, .tooltipAJAX, .tooltipCustom, .markItUpButton a";

  if (typeof selector == 'undefined') {
    selector = standardSelector;
  } else if (typeof selector == 'string' && !selector.match(/\.tooltip/)) {
    var standardSelectorArray = standardSelector.split(', ');
    var previousSelector = selector;

    for (i in standardSelectorArray) {
      selector += ", " + previousSelector + " " + standardSelectorArray[i];
    }
  }

  return selector;
}

function sanitizeTooltip(text) {
  return text.replace(/<\s*script/g, '&lt;script');
}

function initTooltips(selector) {
  initTooltipSkins();
  selector = getTooltipSelector(selector);

  function generateHTML(text) {
    var element = {};
    var splitted = text.split("|");
    var title = $(document.createElement('h1')).html(splitted[0]);
    var splitLine = $(document.createElement('div')).addClass('splitLine');

    if (typeof splitted[2] !== "undefined" && typeof splitted[3] !== "undefined") {
      var title2 = $(document.createElement('h1')).html(splitted[2]);
      var splitLine2 = $(document.createElement('div')).addClass('splitLine');
      element = $(document.createElement('div')).css('display', 'none').addClass('htmlTooltip').append(title).append(splitLine).append(splitted[1] + "</br>").append(title2).append(splitLine2).append(splitted[3]);
    } else {
      element = $(document.createElement('div')).css('display', 'none').addClass('htmlTooltip').append(title).append(splitLine).append(splitted[1]);
    }

    return element[0];
  }

  removeTooltip(selector);

  function addTooltip(object) {
    var $thisObj = $(object);

    if ($thisObj.data('tooltipLoaded')) {
      return;
    }

    $thisObj.data('tooltipLoaded', true);

    if (isMobile && $thisObj.hasClass('js_hideTipOnMobile')) {
      $thisObj.attr('title', '');
      return;
    }

    var options = getTooltipOptions($thisObj);

    if ($thisObj.hasClass('tooltipCustom')) {
      if (options.hideOn != false) {
        options.hideOn = {
          element: 'mouseleave',
          tooltip: 'mouseleave'
        };
      }

      options.afterUpdate = function (content) {
        $(content).find('.tooltipCustom').each(function (i, element) {
          var options = getTooltipOptions($thisObj);

          if ($(this).hasClass('tooltipHTML')) {
            options.inline = true;
            options.hideOthers = false;
            Tipped.create(this, generateHTML(sanitizeTooltip($(this).attr('title'))), options);
          } else {
            options.hideOthers = false;
            Tipped.create(this, sanitizeTooltip($(this).attr('title')), options);
          }
        });
      };
    }

    if ($thisObj.hasClass('tooltipHTML')) {
      if (typeof $thisObj.attr('title') == 'undefined' || $thisObj.attr('title').trim().length == 0) {
        return;
      }

      Tipped.create($thisObj[0], generateHTML(sanitizeTooltip($thisObj.attr('title'))), options);
      return;
    }

    if ($thisObj.hasClass('tooltipRel')) {
      options.inline = $thisObj.attr('rel');

      if ($thisObj.hasClass('tooltipPersistent')) {
        options.detach = false;
      }

      Tipped.create($thisObj[0], undefined, options);
      return;
    }

    if ($thisObj.hasClass('tooltipAJAX')) {
      $.get($thisObj.attr('rel'), {}, function (data) {
        Tipped.create($thisObj[0], data, options);
      });
      return;
    }

    if (typeof $thisObj.attr('title') == 'undefined' || $thisObj.attr('title').trim().length == 0) {
      return;
    }

    Tipped.create($thisObj[0], sanitizeTooltip($thisObj.attr('title')), options);
  }

  $(document).undelegate(selector, 'touchstart.tooltipClick').delegate(selector, 'touchstart.tooltipClick', function (e) {
    if (Tipped.visible(this)) {
      var event = document.createEvent("MouseEvents");
      event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
      this.dispatchEvent(event);
      e.preventDefault();
      e.stopPropagation();
    }
  }); // this fixes tooltips not being closed

  $(document).undelegate('.t_Tooltip.t_visible .close-tooltip', 'click').delegate('.t_Tooltip.t_visible .close-tooltip', 'click', function (e) {
    Tipped.hide($(e.currentTarget).closest('.t_Tooltip')[0]);
  });

  if (typeof selector == "string") {
    $(document).undelegate(selector, 'mouseenter.tooltipLoad touchstart.tooltipLoad').delegate(selector, 'mouseenter.tooltipLoad touchstart.tooltipLoad', function (e) {
      addTooltip(this);
      Tipped.show(this);
    });
  } else {
    $(selector).each(function () {
      addTooltip(this);
    });
  }
}

$(function () {
  initTooltips();
});
function initTrader() {
  var disableAnimationOnce = false;
  var url = $.deparam.fragment();

  if (typeof url["animation"] != 'undefined') {
    if (url["animation"] == 'false') {
      disableAnimationOnce = true;
    }
  } // toggle overview-panel


  var toggleDisplay = {
    $link: null,
    $panel: null,
    close: function () {
      this.$panel.hide();
    },
    setPanel: function () {
      this.$panel = $('#js_togglePanel' + traderObj.traderId.replace(/#div_trader/, ''));
    },
    init: function (traderId) {
      var $wrapper = $(traderId + ' .selectWrapper');
      traderId = traderId.replace(/#div_trader/, '');
      if (!$wrapper) return;
      this.$link = $('#js_toggleLink' + traderId);
      this.$panel = $('#js_togglePanel' + traderId);
      var $panel = this.$panel; // hide panel initially

      $panel.hide(); // bind toggle fn

      this.$link.unbind('click.selectLink').bind('click.selectLink', function (e) {
        traderId = traderObj.traderId.replace(/#div_trader/, '');

        if ($(this).hasClass('honor')) {
          return false;
        }

        if ($panel.find('ul.active').has('li').length) {
          $panel.toggle();
        }

        return false;
      }); //event for planet or moon select

      $('.selectWrapper .source').unbind('click.selectPlanetOrMoon').bind('click.selectPlanetOrMoon', function (e) {
        toggleDisplay.selectPlanetOrMoon(this);
      }); // event for list item, use live instead of bind, because list elements can be created dynamically

      $('#' + $panel.attr('id')).find('li').unbind('click.selectSource').bind('click.selectSource', function (e) {
        traderObj.selectSource(this);
        return false;
      }); // click outside of panel

      toggleDisplay.outerClick($wrapper, $panel); // delayed panel self-closing

      var timeoutID = null,
          delay = 8000;
      $wrapper.unbind('mouseout.closeSelect').bind('mouseout.closeSelect', function (e) {
        // custom mouseleave event
        e = e || window.event;
        var reltg = e.relatedTarget ? e.relatedTarget : e.toElement;

        if (reltg == $wrapper || toggleDisplay.isChildOf(reltg, $wrapper)) {
          return;
        } // hide after timeout


        timeoutID = setTimeout(function () {
          $panel.hide();
        }, delay);
      }).unbind('mouseover.clearTimeout').bind('mouseover.clearTimeout', function () {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      });
    },
    // helper function for custom mouseleave
    //TODO: is this still needed?
    isChildOf: function (child, parent) {
      parent = parent[0];

      while (child && child != parent) {
        child = child.parentNode;
      }

      return child == parent;
    },
    outerClick: function ($wrapper, $panel) {
      $('body').bind('click.outerClick', function (e) {
        if (!e) {
          e = window.event;
        }

        if (!($(e.target).closest('.selectWrapper') == $wrapper) && $panel.is(':visible') != false) {
          $panel.toggle();
        }
      });
    },
    selectPlanetOrMoon: function (elem) {
      var planet;

      if ($(elem).hasClass("selected")) {
        return false;
      }

      var selectedContent = '',
          selectedPlanetId = null;

      if ($(elem).hasClass('js_honor')) {
        $(traderObj.traderId + ' .selectWrapper .source').removeClass('selected');
        $(traderObj.traderId + ' .js_honor').addClass('selected');
        $(traderObj.traderId + ' .toggleLink').addClass('honor');
        var selectedContent = '<img height="18" src="//gf1.geo.gfsrv.net/cdnfc/f35675179214f8f6f0f8d75740d7db.png" alt="' + loca.honorPoints + '"/>' + '<span class="option_source">' + loca.honorPoints + '</span>';
        $(traderObj.traderId + ' .js_valSourcePlanet').html(selectedContent);
        $(traderObj.traderId + ' .normalResource').hide();
        $(traderObj.traderId + ' .honorResource').show();
        return false;
      }

      var $togglePanel = $(traderObj.traderId + ' .togglePanel');
      var className = 'planet';

      if ($(elem).hasClass('js_moon')) {
        var moonCounter = 0;
        className = 'moon';

        for (planet in traderObj.planets) {
          if (traderObj.planets[planet].isMoon) moonCounter++;
        }

        if (moonCounter == 0) return false;
      }

      var currentPlanet = traderObj.planets[traderObj.current.planet];
      $togglePanel.find('ul').hide().removeClass('active');
      $togglePanel.find('ul.' + className).show().addClass('active');
      $(traderObj.traderId + ' .toggleLink').removeClass('honor');
      $(traderObj.traderId + ' .selectWrapper .source').removeClass('selected');
      $(traderObj.traderId + ' .js_' + className).addClass('selected');

      if ($(elem).hasClass('js_moon') ? currentPlanet.isMoon : !currentPlanet.isMoon) {
        selectedPlanetId = traderObj.current.planet;
      } else if (currentPlanet.otherPlanetId != null && typeof traderObj.planets[currentPlanet.otherPlanetId] != "undefined") {
        selectedPlanetId = currentPlanet.otherPlanetId;
      } else {
        selectedPlanetId = $togglePanel.find('ul.' + className + ' li:first').attr('id');
      }

      $(traderObj.traderId + ' .normalResource').show();
      $(traderObj.traderId + ' .honorResource').hide();
      $togglePanel.find('ul li#' + selectedPlanetId).click();
      return false;
    },
    setToggleLink: function (link) {
      // we need to redefine the traderId here so we act on the right $link and $panel:
      var traderId = traderObj.traderId.replace(/#div_trader/, ''),
          $span = $(link).find('span'),
          planetName = traderObj.planets[$(link).attr('id')].name;

      if (planetName != $span.text()) {
        $span.attr('title', planetName.replace(/\|/g, '&#124;'));
      }

      this.$link = $('#js_toggleLink' + traderId);
      this.$link.html($(link).html());
    }
  };
  /*
   * Object for Auctioneer and ImportExport Slider
   */

  traderObj = {
    traderBGPos: {
      '#div_traderResources': '0px 0px',
      '#div_traderAuctioneer': '-546px 0px',
      '#div_traderScrap': '0px -220px',
      '#div_traderImportExport': '-546px -220px'
    },
    timer: 500,
    // Wenn direkt auf Unterseite -> timer = 0
    planets: {},
    honorOutput: 0,
    price: 0,
    deficit: 0,
    priceImportExport: 0,
    sumResources: 0,
    traderId: null,
    resources: ['Metal', 'Crystal', 'Deuterium'],
    current: {
      planet: currentPlanetId,
      resource: '',
      sliderValue: ''
    },
    barXPos: -180,
    // start Position
    barYPos: 0,
    percentPaid: 0,
    switchingTrader: false,
    checkOverbidden: function () {
      if (playerBid == false || playerBid >= getValue($('.detail_value.currentSum').html())) {
        $('.overbid_text').hide();
      } else {
        $('.overbid_text').show();
      }
    },

    /*
     * This function updates only the current slider.
     * It gets called whenever a slider was changed so we will
     * calculate the total sum here:
     */
    refresh: function () {
      var traderId = traderObj.traderId; // Check that we're in the right context:

      if ('#' + $(this).closest('.div_trader').attr('id') !== traderId) return; // Get the css-class that identifies the current slider:

      var myClass = $(this).attr('class');
      var re = new RegExp(/\b(js_slider\w*)\b/);
      myClass = re.test(myClass) ? RegExp.$1 : false;
      if (!myClass) return; // Update current values:

      traderObj.current.sliderValue = $(this).slider("value");
      traderObj.current.resource = myClass.replace('js_slider', '').toLowerCase();

      if (traderObj.current.resource == 'honor') {
        traderObj.honorOutput = traderObj.current.sliderValue;
      } else {
        traderObj.planets[traderObj.current.planet].output[traderObj.current.resource] = traderObj.current.sliderValue;
      }

      formatNumber($(traderId + ' .js_amount.js_' + traderObj.current.resource), traderObj.current.sliderValue);

      if (traderId == '#div_traderAuctioneer') {
        traderObj.price = getValue($(traderId + ' .js_price').html()); //traderObj.deficit = getValue($( traderId + ' .js_deficit' ).html());

        traderObj.sumAuctioneer();
        traderObj.checkOverbidden();
      } else if (traderId == '#div_traderImportExport') {
        traderObj.sumImportExport();
      }
    },
    // 	refresh: function() end

    /*
     * Whenever the view changes to another trader, all inputFields, Sliders, outputvalues
     * and selected planed have to be resetted:
     */
    resetValues: function (traderId, resetCurrentPlanet) {
      traderId = traderId || traderObj.traderId;
      resetCurrentPlanet = resetCurrentPlanet || false;
      /* for( planet in traderObj.planets ) funktioniert im IE7/8 nicht!! */
      // Reset output values:

      for (var planet in traderObj.planets) {
        for (var resource in traderObj.planets[planet].output) {
          traderObj.planets[planet].output[resource] = 0;
        }
      }

      traderObj.honorOutput = 0; // Reset input fields:

      $('.js_amount').val(0); // reset sums

      if (traderObj.traderId == '#div_traderAuctioneer') {
        traderObj.sumAuctioneer();
      } else if (traderObj.traderId == '#div_traderImportExport') {
        traderObj.sumImportExport();
      } // Reset display of selected planet to currentPlanetId


      if (resetCurrentPlanet) {
        traderId = traderId.replace(/#div_trader/, '');
        $('#js_togglePanel' + traderId).find("li#" + currentPlanetId).click();
      }

      toggleDisplay.close();
    },

    /*
     * Update the shown max-amount of planet resource
     */
    resetMaxAmount: function (planetResources, honor) {
      var traderId = traderObj.traderId;
      var resources = traderObj.resources;

      for (var planetId in traderObj.planets) {
        for (var i = 0; i < resources.length; i++) {
          var resToLower = resources[i].toLowerCase();
          traderObj.planets[planetId].input[resToLower] = planetResources[planetId][resToLower];
        }
      }

      for (var j = 0; j < resources.length; j++) {
        resToLower = resources[j].toLowerCase();
        var planetMax = traderObj.planets[traderObj.current.planet].input[resToLower];
        $(traderId + ' .max_planet_' + resToLower).html(number_format(planetMax, 0));
      }

      honorScore = honor;
      $(traderId + ' .max_planet_honor').html(number_format(Math.max(0, honor), 0));
      toggleDisplay.close();
    },

    /*
     * Update all fields with selected source:
     */
    selectSource: function (selectedSource) {
      // save selected source:
      traderObj.current.planet = $(selectedSource).attr('id'); //set first source to selected source

      toggleDisplay.close();
      toggleDisplay.setToggleLink($(selectedSource));
      var traderId = traderObj.traderId;
      var resources = traderObj.resources;
      $.ajax({
        url: urlRefreshPlanet,
        type: 'POST',
        data: {
          planetId: traderObj.current.planet,
          _token: token,
          ajax: 1
        },
        dataType: 'json',
        success: function (data) {
          if (data.status === 'success') {
            token = data.newAjaxToken; // update maximum and current values of all sliders and input fields:

            for (var i = 0; i < resources.length; i++) {
              var resToLower = resources[i].toLowerCase();
              var planetMax = data.refreshPlanet.input[resToLower];
              var currMax = planetMax;

              if (traderId == '#div_traderImportExport') {
                var outputMax = traderObj.priceImportExport / multiplier[resToLower] - traderObj.sumResources + data.refreshPlanet.output[resToLower];
                var currMax = Math.min(planetMax, outputMax);
              }

              $(traderId + ' .max_planet_' + resToLower).html(number_format(currMax, 0));
              $(traderId + ' .js_amount.js_' + resToLower).val(number_format(data.refreshPlanet.output[resToLower], 0));
            }
          } else {
            for (var i = 0; i < resources.length; i++) {
              var resToLower = resources[i].toLowerCase();
              $(traderId + ' .max_planet_' + resToLower).html(number_format(0, 0));
              $(traderId + ' .js_amount.js_' + resToLower).val(number_format(0, 0));
            }

            fadeBox(loca['error'] + ': ' + data.errors[0].message, true);
          }
        },
        error: function (data) {
          fadeBox(loca['error'] + ': ' + loca['ajaxError'], true);
        }
      });
    },

    /*
     * Overview Image Animation
     */
    selectTrader: function (myTrader, timer, tab) {
      timer = timer || traderObj.timer;
      $.bbq.pushState({
        'page': myTrader,
        'animation': 'false'
      });
      $(".planetlink, .moonlink").fragment({
        'page': myTrader,
        'animation': 'false'
      });
      traderObj.traderId = '#div_' + myTrader;
      var traderId = traderObj.traderId,
          $backToOverview = $('.back_to_overview');

      var showTrader = function () {
        if (traderId == '#div_traderAuctioneer' || traderId == '#div_traderImportExport') {
          traderObj.resetValues(null, true);
        }

        var changeTraderFunction = function () {
          $('#traderOverview').find('.c-left, .c-right').addClass('c-small');
          $backToOverview.show();

          if (traderId == '#div_traderAuctioneer' || traderId == '#div_traderImportExport') {
            $backToOverview.addClass('left');
            $backToOverview.removeClass('right');
          } else if (traderId == '#div_traderResources' || traderId == '#div_traderScrap') {
            $backToOverview.addClass('right');
            $backToOverview.removeClass('left');
          }

          $('#planet #header_text h2').html(loca[myTrader]).parent().show();
        };

        if (animation && !disableAnimationOnce) {
          $('#traderOverview').find('.c-left, .c-right').hide();
          $('#planet').animate({
            backgroundPosition: traderObj.traderBGPos[traderId],
            height: '250px'
          }, timer, function () {
            $('#planet').addClass('detail');
            $('#traderOverview').find('.c-left, .c-right').show();
            changeTraderFunction();

            if (traderId == '#div_traderResources') {
              showTradeNowButton();
            }
          });
        } else {
          disableAnimationOnce = false;
          $('#planet').css('background-position', traderObj.traderBGPos[traderId]).css('height', '250px');
          changeTraderFunction();

          if (traderId == '#div_traderResources') {
            showTradeNowButton();
          }
        }

        toggleDisplay.setPanel();
        $('#planet').addClass('detail');
        $('.js_trader').hide();
        $(traderId).show();

        if (traderId == '#div_traderResources' && typeof tab != 'undefined') {
          $(traderId + ' .ui-tabs').tabs('option', 'active', tab);
        }

        traderObj.switchingTrader = false;
      };

      if ($(traderObj.traderId).length == 0) {
        var traderString = myTrader.toLowerCase().replace(/^trader/, '');
        let traderUrl = traderUrls[traderString];
        $.ajax({
          url: traderUrl,
          type: 'POST',
          data: {
            show: traderString,
            ajax: 1
          },
          beforeSend: function () {
            $('#loadingOverlay').addClass(traderString).show();
          },
          success: function (data) {
            $("#inhalt").append(data);
            $('#loadingOverlay').hide().removeClass(traderString);
            showTrader();
          },
          error: function () {
            fadeBox(loca['error'], true);
            $('#loadingOverlay').hide().removeClass(traderString);
          }
        });
      } else {
        showTrader();
      }
    },
    submitAuction: function () {
      var traderId = traderObj.traderId;
      var sum = getValue($(traderId + ' .js_auctioneerSum').html());

      if (!$(traderId + ' .right_box .pay').hasClass('disabled') && traderObj.price > 0 && traderObj.deficit <= 0) {
        $(traderId + ' .right_box .pay').addClass('disabled');
        var bidArray = {
          planets: {},
          honor: traderObj.honorOutput
        };

        for (var planetId in traderObj.planets) {
          bidArray.planets[planetId] = traderObj.planets[planetId].output;
        }

        $.ajax({
          url: auctionUrl,
          type: 'POST',
          data: {
            bid: bidArray,
            _token: token,
            ajax: 1
          },
          dataType: "json",
          success: function (data) {
            token = data.newAjaxToken;
            fadeBox(data.message, data.error);

            if (!data.error) {
              traderObj.resetValues(traderId, false);
              traderObj.resetMaxAmount(data.planetResources, data.honor);
              traderObj.reloadResources();
            }
          },
          error: function () {
            fadeBox(loca['error'], true);
          }
        });
      }

      return false;
    },
    submitImportExport: function () {
      if (!$(traderObj.traderId + ' .right_box .pay').hasClass('disabled')) {
        $(traderObj.traderId + ' .right_box .pay').addClass('disabled');
        var bidArray = {
          planets: {},
          honor: traderObj.honorOutput
        };

        for (planetId in traderObj.planets) {
          bidArray.planets[planetId] = traderObj.planets[planetId].output;
        }

        $.ajax({
          url: importUrlTrade,
          type: 'POST',
          data: {
            action: "trade",
            bid: bidArray,
            _token: token,
            ajax: 1
          },
          dataType: "json",
          success: function (data) {
            token = data.newAjaxToken;
            fadeBox(data.message, data.error);

            if (!data.error) {
              for (planetId in traderObj.planets) {
                traderObj.planets[planetId].output = {
                  metal: 0,
                  crystal: 0,
                  deuterium: 0
                };
              }

              $(traderObj.traderId + ' .bargain_overlay').show();
              $(traderObj.traderId + ' .payment').hide();
              $(traderObj.traderId + ' .image_140px a').addClass("slideIn");
              traderObj.reloadResources();
              traderObj.updateImportItem(data.item);
              traderObj.refresh();
            }
          },
          error: function () {
            fadeBox(loca['error'], true);
          }
        });
      }

      return false;
    },
    reloadResources: function (callback) {
      getAjaxResourcebox(callback);
    },
    changeImportItem: function () {
      if ($(traderObj.traderId + ' .import_bargain.change').hasClass('disabled')) {
        if (darkMatter < importChangeCost) {
          errorBoxDecision(LocalizationStrings.error, loca.errorNotEnoughDM, LocalizationStrings.yes, LocalizationStrings.no, redirectBuyPremium);
        }
      } else {
        $(traderObj.traderId + ' .import_bargain.change').addClass('disabled');
        $.ajax({
          url: importUrlBargain,
          type: 'POST',
          data: {
            action: "bargain",
            _token: token,
            ajax: 1
          },
          dataType: "json",
          success: function (data) {
            token = data.newAjaxToken;
            fadeBox(data.message, data.error);

            if (!data.error) {
              traderObj.updateImportItem(data.item);
              traderObj.reloadResources(function () {
                if (data.item.offersLeft > 0 && darkMatter >= importChangeCost) {
                  $(traderObj.traderId + ' .import_bargain.change').removeClass('disabled');
                } else {
                  $(traderObj.traderId + ' .import_bargain.change').addClass('disabled');
                }
              });
              traderObj.refresh();
            }
          },
          error: function () {
            fadeBox(loca['error'], true);
          }
        });
      }

      return false;
    },
    updateImportItem: function (itemData) {
      $(traderObj.traderId + ' .got_item_text').html(itemData.itemText);
      $(traderObj.traderId + ' .bargain_text').html(itemData.bargainText);
      $(traderObj.traderId + ' .bargain_cost').html(itemData.bargainCostText);
      importChangeCost = itemData.bargainCost;
      $(traderObj.traderId + ' .image_140px img').attr("src", "/cdn/img/item-images/" + itemData.image + "-140x.png");
      removeTooltip($(traderObj.traderId + ' .image_140px a'));
      $(traderObj.traderId + ' .image_140px a').attr("ref", itemData.uuid).removeClass("tooltip").addClass("tooltipHTML").attr("title", itemData.tooltip);
      initTooltips($(traderObj.traderId + ' .image_140px a'));
      $(traderObj.traderId + ' .detail_button .amount').text(itemData.amount);
    },
    takeImportItem: function () {
      if (!$(traderObj.traderId + ' .import_bargain.take').hasClass('disabled')) {
        $(traderObj.traderId + ' .import_bargain.change').addClass('disabled');
        $(traderObj.traderId + ' .import_bargain.take').addClass('disabled');
        $(traderObj.traderId + ' .import_bargain.change').addClass('hidden');
        $(traderObj.traderId + ' .import_bargain.take').addClass('hidden');
        $(traderObj.traderId + ' .bargain_cost').addClass('hidden');
        $.ajax({
          url: importUrlTakeItem,
          type: 'POST',
          data: {
            action: "takeItem",
            _token: token,
            ajax: 1
          },
          dataType: "json",
          success: function (data) {
            token = data.newAjaxToken;
            fadeBox(data.message, data.error);

            if (!data.error) {
              var uuid = data.item.ref;
              changeTooltip($(".detail_button[ref='" + uuid + "']"), data.item.title);
              $(".detail_button[ref='" + uuid + "'] span.amount, " + "#itemDetails[data-uuid='" + uuid + "'] span.amount").html(tsdpkt(data.item.amount));

              if (data.item.canBeActivated) {
                $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').removeClass('build-it_disabled').addClass('build-it');
              } else {
                $('#itemDetails[data-uuid="' + uuid + '"] a.activateItem').addClass('build-it_disabled').removeClass('build-it');
              }

              if (data.item.newOffer == false) {
                $(traderObj.traderId + ' .bargain_text').html(data.item.noOfferMessage);
              } else {
                traderObj.resetImport(data.item.newOffer);
              }
            }
          },
          error: function () {
            fadeBox(loca['error'], true);
          }
        });
      }

      return false;
    },
    resetImport: function (importData) {
      importChangeCost = importData.bargainCost;

      if (darkMatter >= importChangeCost) {
        $(traderObj.traderId + ' .import_bargain.change').removeClass('disabled');
      } else {
        $(traderObj.traderId + ' .import_bargain.change').addClass('disabled');
      }

      $(traderObj.traderId + ' .import_bargain.take').removeClass('disabled');
      $(traderObj.traderId + ' .import_bargain.change').removeClass('hidden');
      $(traderObj.traderId + ' .import_bargain.take').removeClass('hidden');
      $(traderObj.traderId + ' .bargain_cost').removeClass('hidden');
      $(traderObj.traderId + ' .bargain_overlay').hide();
      $(traderObj.traderId + ' .payment').show();
      $(traderObj.traderId + ' .image_140px img').attr("src", "/cdn/img/trader/container_" + importData.rarity + ".jpg");
      $(traderObj.traderId + ' .image_140px a').removeClass("slideIn").attr("ref", "").removeClass("tooltipHTML").addClass("tooltip").removeClass('r_common_140px').removeClass('r_uncommon_140px').removeClass('r_rare_140px').removeClass('r_epic_140px').removeClass('r_buddy_140px').addClass('r_' + importData.rarity + '_140px');
      changeTooltip($(traderObj.traderId + ' .image_140px a'), importData.tooltip);
      $(traderObj.traderId + ' .js_import_price').removeClass('green_text').text(number_format(importData.price, 0));
      $(traderObj.traderId + ' .image_140px .amount').text("?");
      traderObj.priceImportExport = getValue($('.js_import_price').html());
      traderObj.resetValues(null, true);
      traderObj.init();
    },

    /*
     * add all values from all sources:
     * sum has to be initialized with 0 every time, because we add the total amount of resources every time, not just the change
     */
    sumAuctioneer: function () {
      var traderId = traderObj.traderId;
      var price = traderObj.price;

      if (price == 0) {
        $('#div_traderAuctioneer .js_amount').attr('disabled', 'disabled');
      } else {
        $('#div_traderAuctioneer .js_amount').removeAttr('disabled');
      }

      var sum = 0;

      for (var planetId in traderObj.planets) {
        var output = traderObj.planets[planetId].output;
        sum += parseInt(output.metal) * multiplier.metal + parseInt(output.crystal) * multiplier.crystal + parseInt(output.deuterium) * multiplier.deuterium;
      }

      sum += parseInt(traderObj.honorOutput) * multiplier.honor;
      sum = Math.floor(sum);
      traderObj.deficit = Number(auctioneer.calculateDeficit()) - Number(sum);

      if (traderObj.deficit > 0) {
        $(' .js_deficit').html(number_format(traderObj.deficit, 0));
      } else {
        $(' .js_deficit').html(number_format(0, 0));
      }

      if (sum > 0) {
        $('#div_traderAuctioneer .js_auctioneerSum').html('+ ' + number_format(sum, 0));
      } else {
        $('#div_traderAuctioneer .js_auctioneerSum').html('');
      }

      $('#div_traderAuctioneer .js_alreadyBidden').html(number_format(Math.floor(playerBid + sum), 0)); //bid ok?

      if (price > 0 && traderObj.deficit <= 0) {
        $('#div_traderAuctioneer .right_box .pay').removeClass('disabled');
      } else {
        $('#div_traderAuctioneer .right_box .pay').addClass('disabled');
      }
    },
    sumImportExport: function () {
      var traderId = traderObj.traderId;
      var sumMetal = 0;
      var sumCrystal = 0;
      var sumDeuterium = 0;
      traderObj.sumResources = 0;

      for (var planetId in traderObj.planets) {
        var output = traderObj.planets[planetId].output;
        sumMetal += parseInt(output.metal) * multiplier.metal;
        sumCrystal += parseInt(output.crystal) * multiplier.crystal;
        sumDeuterium += parseInt(output.deuterium) * multiplier.deuterium;
      }

      var sumHonor = traderObj.honorOutput * multiplier.honor;
      traderObj.sumResources += sumMetal + sumCrystal + sumDeuterium + sumHonor;

      if (traderObj.sumResources >= traderObj.priceImportExport) {
        traderObj.sumResources = traderObj.priceImportExport;
      }

      $(traderId + ' .js_sum_price').html(number_format(Math.floor(traderObj.sumResources), 0)); //price ok?

      if (traderObj.sumResources >= traderObj.priceImportExport) {
        $(traderId + ' .js_import_price').addClass('green_text');
        $(traderId + ' .right_box .pay').removeClass('disabled');
      } else {
        $(traderId + ' .js_import_price').removeClass('green_text');
        $(traderId + ' .right_box .pay').addClass('disabled');
      }
    },

    /*
     * Update all values of current slider depending on which button was clicked:
     */
    updateValues: function ($elem) {
      var traderId = traderObj.traderId;
      if (traderId !== '#' + $elem.closest('.div_trader').attr('id')) return;
      var myClass = $elem.attr('class');
      var re = new RegExp(/\b(js_slider\w*)\b/);
      myClass = re.test(myClass) ? RegExp.$1 : false;
      if (!myClass) return;
      var currPlanet = traderObj.current.planet;
      var action, value, sliderId;

      if (myClass.indexOf('More') != -1) {
        sliderId = myClass.replace('More', '');
        action = 'More';
      } else if (myClass.indexOf('Max') != -1) {
        sliderId = myClass.replace('Max', '');
        action = 'Max';
      }

      traderObj.current.resource = sliderId.replace('js_slider', '').toLowerCase() || null;
      var currResource = traderObj.current.resource;
      var currInputValue = 0;

      if (currResource == 'honor') {
        currInputValue = Math.max(0, honorScore);
      } else {
        currInputValue = traderObj.planets[currPlanet].input[currResource];
      }

      value = getValue($(traderId + ' .' + sliderId + 'Input').val());

      if (action == 'More') {
        if (traderId == '#div_traderImportExport') {
          if (traderObj.sumResources <= traderObj.priceImportExport - 1000 * multiplier[currResource]) {
            value += 1000;
          } else if (traderObj.sumResources < traderObj.priceImportExport) {
            value += Math.ceil((traderObj.priceImportExport - traderObj.sumResources) / multiplier[currResource]);
          }
        } else if (traderId == '#div_traderAuctioneer' && traderObj.price > 0) {
          value += 1000;
        }

        if (value >= currInputValue) {
          value = Math.max(0, currInputValue);
        }
      } else if (action == 'Max') {
        if (traderId == '#div_traderImportExport') {
          if (traderObj.sumResources == 0) {
            value = Math.min(currInputValue, Math.ceil(traderObj.priceImportExport / multiplier[currResource]));
          } else if (traderObj.sumResources.isBetween(0, traderObj.priceImportExport - 1)) {
            value = Math.min(currInputValue, value + Math.ceil((traderObj.priceImportExport - traderObj.sumResources) / multiplier[currResource]));
            value = Math.max(0, value);
          }
        } else if (traderId == '#div_traderAuctioneer' && traderObj.price > 0) {
          value = Math.min(currInputValue, Math.ceil(getValue($(traderId + ' .js_deficit').html()) / multiplier[currResource] + value));
        }

        if (currResource == 'honor' && value < 0) value = 0;
      } // update valueObject and slider with the new value:


      $(traderId + ' .js_amount.' + sliderId + 'Input').val(number_format(value, 0));

      if (currResource == 'honor') {
        traderObj.honorOutput = value;
      } else {
        traderObj.planets[currPlanet].output[currResource] = value;
      }

      if (traderId == '#div_traderImportExport') {
        traderObj.sumImportExport();
      } else if (traderId == '#div_traderAuctioneer' && traderObj.price > 0) {
        traderObj.sumAuctioneer();
        traderObj.checkOverbidden();
      }
    },
    updateValuesInputCanged: function ($elem) {
      var traderId = traderObj.traderId;
      if (traderId !== '#' + $elem.closest('.div_trader').attr('id')) return;
      var myClass = $elem.attr('class');
      var re = new RegExp(/\b(js_slider\w*)\b/);
      myClass = re.test(myClass) ? RegExp.$1 : false;
      if (!myClass) return;
      var sliderId = myClass.replace('Input', '');
      var currResource = sliderId.replace('js_slider', '').toLowerCase();
      var currPlanet = traderObj.current.planet;
      var currInputValue = 0;

      if (currResource == 'honor') {
        currInputValue = Math.max(0, honorScore);
      } else {
        currInputValue = parseInt(traderObj.planets[currPlanet].input[currResource]);
      } //update traderObj
      // value may be max either max ress on planet or the price devided by multiplier


      var value = 0;

      if (traderId == '#div_traderImportExport') {
        var sum = 0;

        for (var planetId in traderObj.planets) {
          var output = traderObj.planets[planetId].output;

          if (currResource != 'metal') {
            sum += Math.floor(parseInt(output.metal) * multiplier.metal);
          }

          if (currResource != 'crystal') {
            sum += Math.floor(parseInt(output.crystal) * multiplier.crystal);
          }

          if (currResource != 'deuterium') {
            sum += Math.floor(parseInt(output.deuterium) * multiplier.deuterium);
          } //if(currResource != 'honor') { sum += Math.floor(parseInt(output.honor) * multiplier.honor); }

        }

        value = Math.min(getValue($elem.val()), Math.ceil((traderObj.priceImportExport - sum) / multiplier[currResource]));
      } else if (traderId == '#div_traderAuctioneer') {
        value = getValue($elem.val());
      }

      value = Math.min(value, currInputValue);
      traderObj.planets[currPlanet].output[currResource] = value;

      if (currResource == 'honor') {
        traderObj.honorOutput = value;
      } else {
        traderObj.planets[currPlanet].output[currResource] = value;
      }

      if (traderId == '#div_traderImportExport') {
        traderObj.sumImportExport();
      } else if (traderId == '#div_traderAuctioneer') {
        traderObj.sumAuctioneer();
        traderObj.checkOverbidden();
      }

      formatNumber(traderId + ' .js_amount.' + sliderId + 'Input', value);
    },
    init: function () {
      $(".honorResource").hide();
      $("#menuTable a.trader").unbind("click.gotoTrader").bind("click.gotoTrader", function (e) {
        e.preventDefault();
        traderObj.switchTrader("traderResources");
      });
      $(window).unbind("hashchange.switchTrader").bind("hashchange.switchTrader", function (e) {
        var url = $.deparam.fragment(e.fragment);

        if (typeof url['page'] == 'undefined' || url['page'] == '' && traderObj.traderId != null) {
          traderObj.returnToOverview();
        } else {
          traderObj.switchTrader(url['page']);
        }
      });
      $('.small_back_to_overview').unbind('mouseenter').unbind('mouseout').bind('mouseenter', function () {
        $('#header_text').css('background-position', '0 -250px');
      }).bind('mouseout', function () {
        $('#header_text').css('background-position', '0 0');
      });
    },
    initSliderTrader: function (traderId) {
      // Unbind the events:
      $(traderId + ' .js_valButton').unbind('click.valControl');
      $(traderId + ' .js_amount').unbind('keyup.inputVal');
      toggleDisplay.init(traderId);
      $(traderId + ' .js_valButton').bind('click.valControl', function (e) {
        traderObj.updateValues($(this));
        e.stopPropagation();
      });
      $(traderId + ' .js_amount').bind('keyup.inputVal', function (e) {
        traderObj.updateValuesInputCanged($(this));
        e.stopPropagation();
      });
    },
    initImportExport: function () {
      traderObj.planets = planetResources;
      traderObj.priceImportExport = getValue($('.js_import_price').html());
      traderObj.initSliderTrader('#div_traderImportExport');
      $('#div_traderImportExport .right_box .pay').bind('click', function () {
        traderObj.submitImportExport();
      });
      $('#div_traderImportExport .import_bargain.change').bind('click', function () {
        traderObj.changeImportItem();
      });
      $('#div_traderImportExport .import_bargain.take').bind('click', function () {
        traderObj.takeImportItem();
      });
    },
    switchTrader: function (traderId) {
      if (traderObj.switchingTrader) {
        return;
      }

      traderObj.switchingTrader = true;
      Tipped.hideAll();
      $('#planet .close_details:visible').click();

      if ("#div_" + traderId == traderObj.traderId) {
        return;
      }

      if (traderObj.traderId != null || traderId == '' || traderId == null) {
        traderObj.returnToOverview();

        if (animation && !disableAnimationOnce) {
          setTimeout(function () {
            traderObj.selectTrader(traderId);
          }, 500);
        } else {
          traderObj.selectTrader(traderId);
        }
      } else {
        traderObj.selectTrader(traderId);
      }
    },
    returnToOverview: function () {
      // reset trader header
      $('#planet #header_text h2').empty().parent().hide();
      $('#traderOverview').find('.c-left, .c-right').hide();
      var traderId = traderObj.traderId;
      if (!traderId) return;
      $(traderId).hide();
      $("#callTrader").hide();

      if (animation && !disableAnimationOnce) {
        $('#planet h2').hide();
        $('#planet').animate({
          backgroundPosition: '-273px 0px',
          height: '470px'
        }, 500, function () {
          $('#planet h2').show();
          $('#planet').removeClass('detail');
          $('#traderOverview').find('.c-left, .c-right').show();
          $('.js_trader').show();
        });
      } else {
        $('#planet').removeClass('detail').css('background-position', '-273px 0px').css('height', '470px');
        $('.js_trader').show();
      }

      $('#planet a').show();
      $('#planet .back_to_overview').hide();
      removeTooltip($('#planet .back_to_overview'));
      $('#traderOverview').find('.c-left, .c-right').removeClass('c-small');
      traderObj.traderId = null;
      traderObj.switchingTrader = false;
    }
  };
  breakerObj = {
    costs: null,
    offer: null,
    ships: {},
    locked: false,
    lastTechId: null,
    initialize: function () {
      this.offer = parseInt($('.scrap_offer_amount').html());
      this.costs = breakerCosts;
      var thisObj = this;
      /* ****** Scrotthndler AnythingSlider ******* */

      $('#js_anythingSliderShips, #js_anythingSliderDefense').anythingSlider({
        startStopped: true,
        // If autoPlay is on, this can force it to start stopped
        buildStartStop: false,
        expand: true,
        resizeContents: false,
        theme: 'default',
        infiniteSlides: false,
        autoPlay: false,
        easing: 'swing',
        resizeContents: true,
        stopAtEnd: true,
        playRtl: isRTLEnabled,
        buildNavigation: false,
        // Callback when the plugin finished initializing (for IPad Swipe Event)
        onInitialized: function (e, slider) {
          if (isMobile) {
            var time = 1000,
                // allow movement if < 1000 ms (1 sec)
            range = 50,
                // swipe movement of 50 pixels triggers the slider
            x = 0,
                t = 0,
                touch = ("ontouchend" in document),
                st = touch ? 'touchstart' : 'mousedown',
                mv = touch ? 'touchmove' : 'mousemove',
                en = touch ? 'touchend' : 'mouseup';
            slider.$window.bind(st, function (e) {
              // prevent image drag (Firefox)
              //e.preventDefault();
              t = new Date().getTime();
              x = e.originalEvent.touches ? e.originalEvent.touches[0].pageX : e.pageX;
            }).bind(en, function (e) {
              t = 0;
              x = 0;
            }).bind(mv, function (e) {
              e.preventDefault();
              var newx = e.originalEvent.touches ? e.originalEvent.touches[0].pageX : e.pageX,
                  r = x === 0 ? 0 : Math.abs(newx - x),
                  // allow if movement < 1 sec
              ct = new Date().getTime();

              if (t !== 0 && ct - t < time && r > range) {
                if (newx < x) {
                  slider.goForward();
                }

                if (newx > x) {
                  slider.goBack();
                }

                t = 0;
                x = 0;
              }
            });
          }
        }
      }); // end slider 1 initialize

      $('#js_anythingSliderDefense').parent().parent().hide();
      $('.scrap_defense').bind('click.tabDefense', function () {
        $('.scrap_ships').removeClass('selected');
        $(this).addClass('selected');
        $('#js_anythingSliderShips').parent().parent().hide();
        $('#js_anythingSliderDefense').parent().parent().show();
      });
      $('.scrap_ships').bind('click.tabShips', function () {
        $('.scrap_defense').removeClass('selected');
        $(this).addClass('selected');
        $('#js_anythingSliderDefense').parent().parent().hide();
        $('#js_anythingSliderShips').parent().parent().show();
      });
      $('.image a').each(function () {
        var techId = $(this).attr('ref').substr(6, 3);
        var $level = $(this).find('.level');
        var $amount = $level.contents().filter(function () {
          return this.nodeType == 3;
        });
        thisObj.ships[techId] = $amount.text().replace(/^\s+|\s+$/g, '');
        $amount.remove();
        $level.append(tsdpkt(thisObj.ships[techId]));
      });
      $('#js_scrapBargain').unbind('click').bind('click', function () {
        if (!$(this).hasClass('disabled')) {
          thisObj.bargain(thisObj);
        } else {
          if (breakerMaximumPercent > thisObj.offer) {
            errorBoxDecision(LocalizationStrings.error, loca.errorNotEnoughDM, LocalizationStrings.yes, LocalizationStrings.no, redirectBuyPremium);
          }
        }

        return false;
      });
      $('#js_scrapScrapIT').unbind('click').bind('click', function () {
        if (!$(this).hasClass('disabled')) {
          thisObj.trade(thisObj);
        }

        return false;
      });
      $('input.ship_amount').unbind('focus').bind('focus', function () {
        thisObj.lastTechId = $(this).attr('name').substr(2, 3);
        $(this).val('');
      });
      $('input.ship_amount').unbind('keyup change').bind('keyup change', function (event) {
        thisObj.lastTechId = $(this).attr('name').substr(2, 3);
        formatNumber(this, $(this).val());
        var $this = $(this);
        clearTimeout($this.data('timer'));
        $this.data('timer', setTimeout(function () {
          $this.removeData('timer');
          thisObj.updateResources(thisObj);
        }, 300));
      });
      $('.buildingimg a').unbind('click').bind('click', function () {
        return false;
      });
      $('.js_maxShips').unbind('click').bind('click', function () {
        if (!isMobile) {
          $($(this).attr('ref')).focus();
        }

        var shipAmount = thisObj.ships[$(this).attr('ref').substr(6, 3)];
        $($(this).attr('ref')).val(tsdpkt(shipAmount)).trigger('change');
        thisObj.updateResources(thisObj);
        return false;
      });
      $('.sendAll').unbind('click').bind('click', function () {
        $('.anythingSlider ul:visible input').each(function () {
          thisObj.lastTechId = $(this).attr('name').substr(2, 3);
          var shipAmount = thisObj.ships[thisObj.lastTechId];

          if (shipAmount > 0) {
            $(this).val(tsdpkt(shipAmount));
          }
        });
        thisObj.updateResources(thisObj, function (data) {
          if (data.error) {
            $('.anythingSlider ul:visible input').val('');
            $('#div_traderScrap .resource_amount').text(0);
            thisObj.checkShips(thisObj);
          }
        });
      });
      $('.sendNone').unbind('click').bind('click', function () {
        $('.anythingSlider ul:visible input').each(function () {
          thisObj.lastTechId = $(this).attr('name').substr(2, 3);
          $(this).val('');
        });
        thisObj.updateResources(thisObj);
      });
      $('#js_bargainCost').text(tsdpkt(this.costs));
      this.checkMoney(this);
      this.checkShips(this);
      this.updateBargain(this);
    },
    bargain: function (thisObj) {
      $('#js_scrapBargain').addClass('disabled');
      $.ajax({
        url: breakerLinkBargain,
        type: "POST",
        dataType: "json",
        data: {
          bargain: 1,
          _token: token
        },
        beforeSend: function () {
          thisObj.lock(thisObj);
        },
        success: function (response) {
          let data = response.data;
          thisObj.unlock(thisObj);
          token = response.newAjaxToken;
          fadeBox(data.message, data.error);

          if (!data.error) {
            thisObj.costs = data.bargainPrice;
            thisObj.offer = data.percentage;
            darkMatter = data.resources.dm;
            thisObj.updateBargain(thisObj);
            thisObj.updateResources(thisObj);
            traderObj.reloadResources(function () {
              thisObj.checkMoney(thisObj);
              Tipped.show($('#js_scrapBargain')[0]);
            });
          }

          $(".scrap_trader_quote").text(data.quote);
        },
        error: function () {
          thisObj.unlock(thisObj);
        }
      });
    },
    trade: function (thisObj) {
      thisObj.lock(thisObj);
      var tradeArray = thisObj.getTradeArray();

      var getBreakerQuestion = function getBreakerQuestion() {
        var questionString = loca.breakerQuestion + '<br/><br/><div style="text-align: left; margin-left: 30px">';
        var counter = 0;
        $.each(tradeArray, function (techId) {
          questionString += this + "x " + breakerTechs[techId].name + ", ";
          counter++;

          if (counter % 2 == 0) {
            questionString += "<br/>";
          }
        });
        questionString = questionString.replace(/, (<br\/>)?$/, '');
        questionString += '</div>';
        return questionString;
      };

      errorBoxDecision(loca.breaker, getBreakerQuestion(), LocalizationStrings.yes, LocalizationStrings.no, function () {
        $.ajax({
          url: breakerLinkTrade,
          type: "POST",
          dataType: "json",
          data: {
            lastTechId: thisObj.lastTechId,
            finishTrade: 1,
            trade: tradeArray,
            _token: token
          },
          success: function (response) {
            let data = response.data;
            thisObj.unlock(thisObj);
            token = response.newAjaxToken;

            if (data.error) {
              fadeBox(data.message, true);
            } else {
              fadeBox(data.message, false);
              thisObj.offer = data.percentage;
              thisObj.costs = data.bargainPrice;
              thisObj.resetForm();
              thisObj.updateBargain(thisObj);
              $("#js_scrapAmountMetal").html(0);
              $("#js_scrapAmountCrystal").html(0);
              $("#js_scrapAmountDeuterium").html(0);
              traderObj.reloadResources(function () {
                thisObj.updateShips(thisObj);
              });
            }

            $(".scrap_trader_quote").text(data.quote);
          },
          error: function () {
            thisObj.unlock(thisObj);
            fadeBox(loca['error'], true);
          }
        });
      }, function () {
        thisObj.unlock(thisObj);
      });
    },
    updateResources: function (thisObj, callback) {
      if (thisObj.locked) {
        return;
      }

      $.ajax({
        url: breakerLinkTrade,
        type: "POST",
        dataType: "json",
        data: {
          lastTechId: thisObj.lastTechId,
          trade: thisObj.getTradeArray(),
          _token: token
        },
        beforeSend: function () {
          thisObj.lock(thisObj);
        },
        success: function (response) {
          let data = response.data;
          token = response.newAjaxToken;

          if (data.error) {
            fadeBox(data.message, true);
          }

          thisObj.locked = false;
          var reloadShips = false;

          for (var techId in data.techAmount) {
            $("#ship_" + techId).val(tsdpkt(data.techAmount[techId]));

            if (!reloadShips && $("#ship_" + techId).val() != thisObj.ships[techId]) {
              reloadShips = true;
            }
          }

          $("#js_scrapAmountMetal").html(tsdpkt(round(data.resources.metal, 2)));
          $("#js_scrapAmountCrystal").html(tsdpkt(round(data.resources.crystal, 2)));
          $("#js_scrapAmountDeuterium").html(tsdpkt(round(data.resources.deuterium, 2)));

          if (!thisObj.notFirstOffer) {
            $(".scrap_trader_quote").text(loca.breakerFirstOffer);
            thisObj.notFirstOffer = true;
          }

          if (reloadShips) {
            thisObj.updateShips(thisObj);
          } else {
            thisObj.unlock(thisObj);
          }

          if (typeof callback == 'function') {
            callback(data);
          }
        },
        error: function () {
          thisObj.unlock(thisObj);
        }
      });
    },
    updateShips: function (thisObj) {
      $.ajax({
        url: techUrl,
        type: "POST",
        dataType: "json",
        beforeSend: function () {
          thisObj.lock(thisObj);
        },
        success: function (data) {
          $('#div_traderScrap .item').each(function () {
            var techId = $(this).attr('id').substr(6, 3);

            if (typeof data[techId] != 'undefined') {
              // Sometimes, somehow we get null in the arrays. Workaround: shipcount shall be 0
              var shipCount = 0;

              if (data[techId] != null) {
                shipCount = getValue(data[techId]);
              }

              thisObj.ships[techId] = shipCount;
              var $level = $(this).find('.level');
              $level.contents().filter(function () {
                return this.nodeType == 3;
              }).remove();
              $level.append(tsdpkt(shipCount)); // if we've got that magical null, we don't want to touch the button colors
              // because we don't want to grey out any buttons that possibly were colored before

              if (data[techId] != null) {
                var $button = $("#button" + techId);
                $button.removeClass('on').removeClass('off');

                if (shipCount > 0) {
                  $button.addClass('on');
                } else {
                  $button.addClass('off');
                }
              }
            }
          });
          thisObj.unlock(thisObj);
        },
        error: function () {
          thisObj.unlock(thisObj);
        }
      });
    },
    getTradeArray: function () {
      var tradeArray = {};
      $('input.ship_amount').each(function () {
        var techId = $(this).attr('name').substr(2, 3);

        if (getValue($(this).val()) != 0) {
          tradeArray[techId] = getValue($(this).val());
        }
      });
      return tradeArray;
    },
    resetForm: function () {
      $('input.ship_amount').each(function () {
        $(this).val('0');
      });
      removeTooltip($('#js_scrapBargain'));
      $('#js_scrapBargain').removeClass('tooltip').removeAttr('title');
    },
    checkMoney: function (thisObj) {
      if (darkMatter < thisObj.costs) {
        $('#js_scrapBargain').addClass('disabled');
      } else if (breakerMaximumPercent <= thisObj.offer) {
        $('#js_scrapBargain').addClass('disabled').addClass('tooltip').attr('title', loca.infoMaxBargain);
        initTooltips($('#js_scrapBargain'));
      } else {
        $('#js_scrapBargain').removeClass('disabled');
      }
    },
    checkShips: function (thisObj) {
      var hasValue = false;
      $('input.ship_amount').each(function () {
        if ($(this).val().length > 0 && getValue($(this).val()) > 0) {
          hasValue = true;
        }
      });

      if (!hasValue) {
        $('#js_scrapScrapIT').addClass('disabled');
      } else {
        $('#js_scrapScrapIT').removeClass('disabled');
      }
    },
    updateBargain: function (thisObj) {
      $('.scrap_offer_amount').css('height', thisObj.offer / 100 * $('.scrap_offer_amount').parent().css('height').replace('px', ''));
      $('.scrap_offer_amount').html(thisObj.offer + "%");
      $('.js_bargainCost').text(tsdpkt(thisObj.costs));
    },
    lock: function (thisObj) {
      $('#js_scrapBargain').addClass('disabled');
      $('#js_scrapScrapIT').addClass('disabled');
      thisObj.locked = true;
    },
    unlock: function (thisObj) {
      thisObj.locked = false;
      thisObj.checkShips(thisObj);
      thisObj.checkMoney(thisObj);
    }
  };
  /*
       * Auctioneer socket functions
       */

  auctioneer = {
    socket: null,
    connected: false,
    timeout: null,
    retryInterval: 5000,
    historyShown: false,
    initConnection: function () {
      try {
        var thisObj = auctioneer;
        this.socket = new io.connect(":" + nodePort + "/auctioneer", nodeParams);
        this.socket.on('connect', function () {
          thisObj.connected = true;
          clearTimeout(this.timeout);
        });
        this.socket.on('disconnect', function () {
          thisObj.connected = false;
          thisObj.retryConnection();
        });
        this.socket.on("new auction", function (data) {
          auctionId = data.auctionId; // put last auction into history

          var playerName = $('#div_traderAuctioneer .detail_value.currentPlayer').html();

          if (data.oldAuction.player == null) {
            playerName = loca['auctionNotSold'];
          } else {
            playerName = "<a href=\"" + data.oldAuction.player.link + "\">" + data.oldAuction.player.name + "</a>";
          }

          removeTooltip($('#div_traderAuctioneer .image_140px .detail_button'));
          var title = $('#div_traderAuctioneer .image_140px .detail_button').attr('title');
          var className = $('.auction_history li:first').hasClass('even') ? 'odd' : 'even';
          var newAuctionElement = "\
                        <li class=\"" + className + "\" style=\"display: none\">\
                            <a href=\"javascript:void(0);\"\
                               class=\"slideIn\"\
                               ref=\"" + data.oldAuction.item.uuid + "\">\
                                <img height=\"30\" width=\"30\"\
                                     src=\"/cdn/img/item-images/" + data.oldAuction.item.imageSmall + "-small.png\"\
                                     alt=\"\" title=\"" + title + "\"\
                                     class=\"item_img tooltipHTML tooltipLeft r_" + data.oldAuction.item.rarity + "\"/>\
                            </a>\
                            <span class=\"detail sum\">" + number_format(data.oldAuction.sum, 0) + "</span>\
                            <span class=\"detail player\">" + playerName + "</span>\
                            <span class=\"detail date_time\">" + data.oldAuction.time + "</span>\
                        </li>";
          $('.auction_history .history_content ul').prepend(newAuctionElement);
          $('.auction_history .history_content li:first').slideDown("slow"); // remove tha last history entry

          var historyLength = $('#div_traderAuctioneer .auction_history li').length;

          if (historyLength > 3) {
            $('.auction_history .history_content li:last').slideUp("slow", function () {
              $('.auction_history .history_content li:eq(21)').remove();
              var $thirdAuction = $('.auction_history .history_content li:eq(3)');
              $thirdAuction.addClass('more_auctions_li');

              if (auctioneer.historyShown) {
                $thirdAuction.show();
              }
            });
            $('#div_traderAuctioneer .auction_history .more').show();
          } // set new auction


          $('#div_traderAuctioneer .image_140px .detail_button').attr('ref', data.item.uuid).attr('title', '').removeClass('r_common_140px').removeClass('r_uncommon_140px').removeClass('r_rare_140px').removeClass('r_epic_140px').addClass('r_' + data.item.rarity + '_140px');
          $('#div_traderAuctioneer .image_140px img').attr('src', "/cdn/img/item-images/" + data.item.image + "-140x.png");
          $('#div_traderAuctioneer .left_header h2').html(loca.auctionRunning);
          thisObj.setItemTooltip($('#div_traderAuctioneer .image_140px .detail_button'));
          thisObj.setData({
            price: 1000,
            sum: 0,
            player: null,
            bids: 0,
            info: data.info
          });
          $('#div_traderAuctioneer .js_alreadyBidden').html(number_format(0, 0));
          $('.noAuctionOverlay').hide();
          traderObj.resetValues('#div_traderAuctioneer', false);
          traderObj.checkOverbidden();
        });
        this.socket.on("new bid", function (data) {
          if (data.player.id == playerId) {
            playerBid = data.sum; // set auctionid for function "calculateDeficit", otherwise the actual minimum bid is shown

            AuctionIdOflastPlayerBid = data.auctionId;
            $('#div_traderAuctioneer .js_alreadyBidden').html(number_format(Math.floor(playerBid), 0));
          }

          thisObj.setData({
            price: data.price,
            sum: data.sum,
            player: data.player,
            bids: data.bids
          });
          traderObj.checkOverbidden();
        });
        this.socket.on("auction finished", function (data) {
          thisObj.setData({
            price: 0,
            player: data.player,
            bids: data.bids,
            info: data.info
          });
          traderObj.resetValues('#div_traderAuctioneer', false);
          $('#div_traderAuctioneer .js_alreadyBidden').html(number_format(0, 0));
          $('#div_traderAuctioneer .js_auctioneerSum').html('');
          $('#div_traderAuctioneer .left_header h2').html(loca.auctionFinished);

          if (data.player != null) {
            if (data.player.id == playerId) {
              thisObj.setItemTooltip($('#div_traderAuctioneer .image_140px .detail_button'));
            }
          }

          $('.noAuctionOverlay').show();
          traderObj.checkOverbidden();
        });
        this.socket.on("timeLeft", function (data) {
          thisObj.setData({
            info: data
          });
        });
      } catch (e) {}
    },
    setItemTooltip: function (object) {
      $.ajax({
        url: detailUrl,
        data: {
          getDetails: 1,
          type: $(object).attr('ref'),
          ajax: 1
        },
        dataType: "json",
        success: function (data) {
          changeTooltip(object, data.title);
          $("#itemDetails[data-uuid='" + $(object).attr('ref') + "'] .amount," + "a.detail_button[ref='" + $(object).attr('ref') + "'] .amount").html(tsdpkt(data.amount));
        },
        error: function () {
          fadeBox(loca['error'], true);
        }
      });
    },
    initialize: function () {
      if (typeof nodeUrl === 'undefined') {
        return;
      }

      traderObj.initSliderTrader('#div_traderAuctioneer');
      traderObj.planets = planetResources;
      traderObj.price = getValue($('.js_price').html());
      $('#div_traderAuctioneer .right_box .pay').bind('click', function () {
        traderObj.submitAuction();
      });
      $('#div_traderAuctioneer .auction_history .more').bind('click', function () {
        if (auctioneer.historyShown) {
          $(this).text("[" + loca['auctionShowMore'] + "]");
        } else {
          $(this).text("[" + loca['auctionShowLess'] + "]");
        }

        auctioneer.historyShown = !auctioneer.historyShown;
        $('#div_traderAuctioneer .auction_history .more_auctions_li').slideToggle('slow');
      });
      traderObj.sumAuctioneer();
      traderObj.checkOverbidden();
      this.initCountdown();
      loadScript(nodeUrl, this.initConnection);
    },
    retryConnection: function () {
      var thisObj = this;
      setTimeout(function () {
        thisObj.initConnection();
      }, 5000);
    },
    setData: function (data) {
      var somethingChanged = false;

      if (typeof data.player != 'undefined') {
        if (data.player == null) {
          $('#div_traderAuctioneer .detail_value.currentPlayer').text("");
          $('#div_traderAuctioneer .detail_value.currentPlayer').attr("href", "");
        } else {
          $('#div_traderAuctioneer .detail_value.currentPlayer').text(data.player.name);
          $('#div_traderAuctioneer .detail_value.currentPlayer').attr("href", data.player.link);
          $('#div_traderAuctioneer .detail_value.currentPlayer').attr("data-player-id", data.player.id);
          $('#div_traderAuctioneer .detail_value.currentPlayer').data("playerId", data.player.id);
        }

        somethingChanged = true;
      }

      if (typeof data.price !== 'undefined') {
        traderObj.price = data.price;
        $('#div_traderAuctioneer .js_price').html(number_format(Math.floor(data.price), 0));
        somethingChanged = true;
      }

      if (typeof data.sum !== 'undefined') {
        $('#div_traderAuctioneer .detail_value.currentSum').html(number_format(Math.floor(data.sum), 0));
        somethingChanged = true;
      }

      if (typeof data.bids !== 'undefined') {
        $('#div_traderAuctioneer .detail_value.numberOfBids').html(number_format(data.bids, 0));
        somethingChanged = true;
      }

      if (typeof data.info !== 'undefined' && $.trim($('#div_traderAuctioneer .auction_info').html()) != data.info) {
        $('#div_traderAuctioneer .auction_info').html(data.info);
        this.initCountdown();
        somethingChanged = true;
      }

      if (somethingChanged) {
        this.flash();
        traderObj.sumAuctioneer();
      }
    },
    initCountdown: function () {
      if (typeof this.nextAuctionTimer == 'object') {
        timerHandler.removeCallback(this.nextAuctionTimer.timer);
      }

      if ($('.nextAuction').length > 0) {
        this.nextAuctionTimer = new simpleCountdown($('.nextAuction').get(0), $('.nextAuction').text());
      }
    },
    flash: function () {
      if (traderObj.traderId == '#div_traderAuctioneer') {
        $('#div_traderAuctioneer .overlay').fadeIn('normal', function () {
          $(this).fadeOut('normal');
        });
      }
    },
    calculateDeficit: function () {
      var deficit = 0;

      if (Math.floor(traderObj.price) == 0) {
        deficit = 0;
      } else if (auctionId != AuctionIdOflastPlayerBid) {
        deficit = Math.floor(traderObj.price);
      } else {
        deficit = Math.floor(traderObj.price) - Math.floor(playerBid);
      }

      return Math.floor(deficit);
    }
  };
  /* TraderOverview Image Hover Styles */

  $('.js_trader').hover(function () {
    var clickedTrader = $(this).attr('id').replace('js_trader', '').toLowerCase();
    $(this).addClass(clickedTrader + '_link_hover');
  }, function () {
    var clickedTrader = $(this).attr('id').replace('js_trader', '').toLowerCase();
    $('.trader_link').each(function (index, element) {
      $(this).removeClass(clickedTrader + '_link_hover');
    });
  });
  /* **** Hover Stile ******* */

  $('.right_box .pay, .value-control, .ui-slider-handle, .bargain, .scrap_it, .source').hover(function () {
    $(this).addClass("hover");
  }, function () {
    $(this).removeClass("hover");
  });
  traderObj.init();
  /*
  * Click event: back to trader overview:
  */

  $(document).undelegate('.js_trader', 'click').delegate('.js_trader', 'click', function () {
    var id = $(this).attr('id').replace('js_', '');
    traderObj.switchTrader(id);
  }).undelegate('#planet .js_backToOverview', 'click').delegate('#planet .js_backToOverview', 'click', function () {
    $.bbq.pushState({
      'page': '',
      'animation': ''
    });
    $(".planetlink, .moonlink").fragment({
      'page': '',
      'animation': ''
    });
  });
  var url = $.deparam.fragment();

  if (typeof url["page"] != 'undefined' && url["page"] != '') {
    traderObj.selectTrader(url["page"], undefined, url["tab"]);
  }
}

function Alliance(cfg) {
  this.tab = cfg.tab || '';
  this.token = cfg.token;
  this.loca = cfg.loca;
  this.tabs = ['overview', 'management', 'broadcast', 'applications', 'classselection', 'createNewAlliance', 'handleApplication'];
  this.initMap = {
    'overview': this.initOverview.bind(this),
    'management': this.initManagement.bind(this),
    'applications': this.initApplication.bind(this),
    'broadcast': this.initBroadcast.bind(this),
    'classselection': this.initClasses.bind(this),
    'createNewAlliance': this.initCreateAlliance.bind(this),
    'handleApplication': this.initHandleApplication.bind(this)
  };

  if (this.initMap[this.tab]) {
    this.initMap[this.tab](cfg);
  }
} // general


Alliance.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

Alliance.prototype.initCommon = function (cfg) {
  this.taskWrapper = $('#alliancecomponent .alliance_wrapper');
  this.loadingIndicator = this.taskWrapper.ogameLoadingIndicator();
  this.allianceContent = $('#alliancecomponent .allianceContent');
  this.titlebar = $('#alliancecomponent #tab-ally');
  this.titlebar.on('click', '.overview', this.onClickTab.bind(this));
  this.titlebar.on('click', '.management', this.onClickTab.bind(this));
  this.titlebar.on('click', '.broadcast', this.onClickTab.bind(this));
  this.titlebar.on('click', '.applications', this.onClickTab.bind(this));
  this.titlebar.on('click', '.classselection', this.onClickTab.bind(this));
};

Alliance.prototype.initCommonWithout = function (cfg) {
  this.taskWrapper = $('#alliancecomponent .alliance_wrapper');
  this.loadingIndicator = this.taskWrapper.ogameLoadingIndicator();
  this.allianceContent = $('#alliancecomponent .allianceContent');
  this.titlebar = $('#alliancecomponent #tab-ally');
  this.titlebar.on('click', '#isNewApplication', this.onClickTab.bind(this));
};

Alliance.prototype.refreshContent = function (htmlItems) {
  this.allianceContent.html(htmlItems);
};

Alliance.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide();
  let that = this;

  switch (this.tab) {
    case 'createNewAlliance':
      $('#form_createAlly .createAlly').bind('click', that.onClickCreateAlliance.bind(that));
      this.urlCreateAlliance = urlCreateAlliance;
      break;

    case 'handleApplication':
      this.urlSendApplication = urlSendApplication;
      this.urlCancelApplication = urlCancelApplication;
      $('#writeapplication .sendNewApplication').bind('click', that.onClickSendApplication.bind(that));
      $('.bewerbung .cancelApplication').bind('click', that.onClickCancelApplication.bind(that));
      break;

    case 'overview':
      $('.kickMemberButton').each(function () {
        $(this).bind('click', that.onClickKickMember.bind(that));
      });
      $('#kickMemberForm .cancel').bind('click', that.onClickKickMemberCancel.bind(that));
      $('#kickMemberForm .submit').bind('click', that.onClickKickMemberSubmit.bind(that));
      $('#form_assignRank .assignRank').bind('click', that.onClickAssignRankSubmit.bind(that));
      $('#leaveAlly .leaveAlly').bind('click', that.onClickLeaveAlliance.bind(that));
      this.urlKickMember = urlKickMember;
      this.urlSubmitRanks = urlSubmitRanks;
      this.urlLeaveAlliance = urlLeaveAlliance;
      break;

    case 'management':
      $('#form_newRank .createRank').bind('click', that.onClickCreateRank.bind(that));
      $('#form_allyRankRights .editRank').bind('click', that.onClickUpdateRank.bind(that));
      $('.delete-rank .deleteRank').each(function () {
        $(this).bind('click', that.onClickDeleteRank.bind(that));
      });
      $('#form_internAllyText .submitText').bind('click', that.onClickUpdateAllianceText.bind(that));
      $('#form_externAllyText .submitText').bind('click', that.onClickUpdateAllianceText.bind(that));
      $('#form_candidacyText .submitText').bind('click', that.onClickUpdateAllianceText.bind(that));
      $('#allySettings .saveSetting').bind('click', that.onClickUpdateSettings.bind(that));
      $('#form_newTag .newTag').bind('click', that.onClickSubmitTag.bind(that));
      $('#form_newName .newName').bind('click', that.onClickSubmitName.bind(that));
      $('#dissolveally .dissolve').bind('click', that.onClickSubmitDisolve.bind(that));
      $('#assignally .transferLeadership').bind('click', that.onClickSubmitTransferLeadership.bind(that));
      $('#assignally .takeoverLeadership').bind('click', that.onClickSubmitTakeoverLeadership.bind(that));
      this.urlCreateRank = urlCreateRank;
      this.urlUpdateRank = urlUpdateRank;
      this.urlDeleteRank = urlDeleteRank;
      this.urlUpdateAllianceText = urlUpdateAllianceText;
      this.urlUpdateSettings = urlUpdateSettings;
      this.urlUpdateTag = urlUpdateTag;
      this.urlUpdateName = urlUpdateName;
      this.urlDissolve = urlDissolve;
      this.urlTransferLeadership = urlTransferLeadership;
      this.urlTakeoverLeadership = urlTakeoverLeadership;
      break;

    case 'applications':
      $('.action_icons .action').each(function () {
        switch ($(this).data('type')) {
          case 'deny':
            $(this).bind('click', that.onClickDenyApplication.bind(that));
            break;

          case 'accept':
            $(this).bind('click', that.onClickAcceptApplication.bind(that));
            break;
        }
      });
      $(".members form").each(function () {
        $(this).find('.accept').bind('click', that.onFormClickAcceptApplication.bind(that));
        $(this).find('.deny').bind('click', that.onFormClickDenyApplication.bind(that));
      });
      this.urlAccept = urlAccept;
      this.urlDeny = urlDeny;
      this.urlReport = urlReport;
      break;

    case 'broadcast':
      $("#submitMail").bind('click', that.onFormClickBroadcastButton.bind(that));
      this.urlSend = urlSend;
      break;
  }
};

Alliance.prototype.initCreateAlliance = function (cfg) {
  this.initCommonWithout(cfg);
  this.urlCreateAlliance = cfg.urlCreateAlliance;
  this.fetchNewAlliance();
};

Alliance.prototype.initHandleApplication = function (cfg) {
  this.initCommonWithout(cfg);
  this.appliedAllyId = cfg.appliedAllyId;
  this.urlSendApplication = cfg.urlSendApplication;
  this.urlCancelApplication = cfg.urlCancelApplication;
  this.fetchNewApplication();
};

Alliance.prototype.initOverview = function (cfg) {
  this.initCommon(cfg);
  this.urlKickMember = cfg.urlKickMember;
  this.urlSubmitRanks = cfg.urlSubmitRanks;
  this.urlLeaveAlliance = cfg.urlLeaveAlliance;
  this.fetch(this.tab);
};

Alliance.prototype.initManagement = function (cfg) {
  this.initCommon(cfg);
  this.urlCreateRank = cfg.urlCreateRank;
  this.urlUpdateRank = cfg.urlUpdateRank;
  this.urlDeleteRank = cfg.urlDeleteRank;
  this.urlUpdateAllianceText = cfg.urlUpdateAllianceText;
  this.urlUpdateSettings = cfg.urlUpdateSettings;
  this.urlUpdateTag = cfg.urlUpdateTag;
  this.urlUpdateName = cfg.urlUpdateName;
  this.urlDissolve = cfg.urlDissolve;
  this.urlTransferLeadership = cfg.urlTransferLeadership;
  this.urlTakeoverLeadership = cfg.urlTakeoverLeadership;
  this.fetch(this.tab);
};

Alliance.prototype.initApplication = function (cfg) {
  this.initCommon(cfg);
  this.urlAccept = cfg.urlAccept;
  this.urlDeny = cfg.urlDeny;
  this.urlReport = cfg.urlReport;
  this.fetch(this.tab);
};

Alliance.prototype.initBroadcast = function (cfg) {
  this.initCommon(cfg);
  this.urlSend = cfg.urlSend;
  this.fetch(this.tab);
};

Alliance.prototype.initClasses = function (cfg) {
  this.initCommon(cfg);
  this.fetch(this.tab);
};

Alliance.prototype.onClickCreateRank = function (e) {
  e.preventDefault();
  let rankName = $('#form_newRank #newRankName').val();
  let params = {
    rankName: rankName,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlCreateRank, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickUpdateRank = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token
  };
  $('#form_allyRankRights input[type="checkbox"]').each(function () {
    if ($(this).prop('checked')) {
      if (typeof params['rankId_' + $(this).data('rankid')] === 'undefined') {
        params['rankId_' + $(this).data('rankid')] = 0;
      }

      params['rankId_' + $(this).data('rankid')] = params['rankId_' + $(this).data('rankid')] + $(this).data('rankvalue');
    }
  });
  this.loadingIndicator.show();
  $.post(this.urlUpdateRank, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickDeleteRank = function (e) {
  e.preventDefault();
  let rankId = $(e.currentTarget).data('rankid');
  let params = {
    rankId: rankId,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlDeleteRank, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickUpdateAllianceText = function (e) {
  e.preventDefault();
  let allianceText = $(e.currentTarget).parent().find('.alliancetexts').val();
  let submitType = $(e.currentTarget).data('type');
  let params = {
    allianceText: allianceText,
    submitType: submitType,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlUpdateAllianceText, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickUpdateSettings = function (e) {
  e.preventDefault();
  let homepageUrl = $('#allySettings #homepageUrl').val();
  let logoUrl = $('#allySettings #logoUrl').val();
  let state = $('#allySettings #state').val();
  let foundername = $('#allySettings #foundername').val();
  let newcomerrankname = $('#allySettings #newcomerrankname').val();
  let language = $('#allySettings #languageSelectionDropdown').val();
  let params = {
    homepageUrl: homepageUrl,
    logoUrl: logoUrl,
    state: state,
    foundername: foundername,
    newcomerrankname: newcomerrankname,
    language: language,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlUpdateSettings, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickSubmitTag = function (e) {
  e.preventDefault();
  let newTag = $('#form_newTag #newTag').val();
  let params = {
    newTag: newTag,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlUpdateTag, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickSubmitName = function (e) {
  e.preventDefault();
  let newName = $('#form_newName #newName').val();
  let params = {
    newName: newName,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlUpdateName, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickSubmitDisolve = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_NETWORK_ALLY_GIVEUP, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlDissolve, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Alliance.prototype.onClickSubmitTransferLeadership = function (e) {
  e.preventDefault();
  let newLeaderId = $('#assignally #newLeaderId').val();
  let params = {
    newLeaderId: newLeaderId,
    _token: this.token
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_NETWORK_ALLY_TAKEOVER_ARE_YOU_SURE, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlTransferLeadership, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Alliance.prototype.onClickSubmitTakeoverLeadership = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_ALLY_TAKEOVER_QUESTION, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlTakeoverLeadership, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Alliance.prototype.onClickLeaveAlliance = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.locaAllyLeaveQuestion, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlLeaveAlliance, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Alliance.prototype.onClickKickMember = function (e) {
  e.preventDefault();
  $('#kickMemberReasonText').val("");
  let data = $(e.currentTarget).attr('id').split('-');
  let id = data[1];
  $('#kickMemberId').val(id);
};

Alliance.prototype.onClickKickMemberCancel = function (e) {
  e.preventDefault();
  $('#kickMemberReason').dialog('destroy');
};

Alliance.prototype.onClickKickMemberSubmit = function (e) {
  e.preventDefault();
  let playerId = $('#kickMemberId').val();
  let reasonText = $('#kickMemberReasonText').val();
  this.submitKickMember(playerId, reasonText);
  $('#kickMemberReason').dialog('destroy');
};

Alliance.prototype.onClickAssignRankSubmit = function (e) {
  e.preventDefault();
  let memberRanks = {};
  $('select[name^="memberRanks"]').each(function () {
    memberRanks[$(this).attr('id')] = $(this).val();
  });
  this.submitRanks(memberRanks);
};

Alliance.prototype.submitRanks = function (memberRanks) {
  let params = {
    _token: this.token,
    memberRanks: memberRanks
  };
  this.loadingIndicator.show();
  $.post(this.urlSubmitRanks, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickCreateAlliance = function () {
  let createTag = $('#allyTagField').val();
  let createName = $('#allyNameField').val();
  let params = {
    createTag: createTag,
    createName: createName,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlCreateAlliance, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickSendApplication = function (e) {
  e.preventDefault();
  let text = $('#writeapplication .alliancetexts').val();
  let params = {
    allianceId: this.appliedAllyId,
    applicationText: text,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlSendApplication, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickCancelApplication = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlCancelApplication, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.submitKickMember = function (playerId, reasonText) {
  let params = {
    playerId: playerId,
    reasonText: reasonText,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlKickMember, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickNewAlly = function (e) {
  e.preventDefault();

  if ($(e.currentTarget).parent().attr('disabled') !== 'disabled') {
    this.fetchNewAlliance();
  }
};

Alliance.prototype.onClickTab = function (e) {
  e.preventDefault();

  if ($(e.currentTarget).parent().attr('disabled') !== 'disabled') {
    this.tab = $(e.currentTarget).data('tab');
    this.fetch(this.tab);
  }
};

Alliance.prototype.fetchNewApplication = function () {
  this.tab = 'handleApplication';
  this.loadingIndicator.show();
  let data = {
    _token: this.token,
    appliedAllyId: this.appliedAllyId
  };
  let url = $('#alliancecomponent #isNewApplication').attr('rel');
  $.getJSON(url, data, this.onFetch.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.fetchNewAlliance = function () {
  this.tab = 'createNewAlliance';
  this.loadingIndicator.show();
  let data = {
    _token: this.token
  };
  let url = $('#alliancecomponent .createNewAlliance').attr('rel');
  $.getJSON(url, data, this.onFetch.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.fetch = function (targetTab) {
  let target = $('#alliancecomponent .' + targetTab);

  if (target.attr('rel') !== '') {
    this.loadingIndicator.show();
    let data = {
      _token: this.token
    };
    $.getJSON(target.attr('rel'), data, this.onFetch.bind(this)).done(this.onAjaxDone.bind(this));
    this.tabs.forEach(function (item) {
      let element = $('#alliancecomponent #tab-ally .' + item).parent();
      element.removeClass('aktiv');

      if (item === targetTab) {
        element.addClass('aktiv');
      }
    });
  }
};

Alliance.prototype.onFetch = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newAjaxToken);
  this.refreshContent(htmlItems);
};

Alliance.prototype.updateToken = function (newtoken) {
  this.token = newtoken;
  token = newtoken;
};

Alliance.prototype.refreshTabs = function (tabsObj) {
  if (tabsObj.applications.applicationCount >= 1) {
    $('.' + tabsObj.applications.tab + ' #applicationTab').removeClass('undermark').addClass('undermark');
    $('.' + tabsObj.applications.tab + ' #applicationTab span').removeClass('undermark').addClass('undermark').html("(" + tabsObj.applications.applicationCount + ")");
  } else {
    $('.' + tabsObj.applications.tab + ' #applicationTab').removeClass('undermark');
    $('.' + tabsObj.applications.tab + ' #applicationTab span').removeClass('undermark').html("");
  }
};

Alliance.prototype.onClickDenyApplication = function (e) {
  e.preventDefault();
  let playerId = $(e.currentTarget).data('playerid');
  this.submitDenyApplication(playerId);
};

Alliance.prototype.submitDenyApplication = function (playerId) {
  let params = {
    playerId: playerId,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlDeny, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onFormClickDenyApplication = function (e) {
  e.preventDefault();
  let playerId = $(e.currentTarget).data('playerid');
  let reasonText = $(e.currentTarget).closest("form").find('.alliancetexts').val();
  let params = {
    playerId: playerId,
    reasonText: reasonText,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlDeny, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onClickAcceptApplication = function (e) {
  e.preventDefault();
  let playerId = $(e.currentTarget).data('playerid');
  this.submitAcceptApplication(playerId);
};

Alliance.prototype.submitAcceptApplication = function (playerId) {
  let params = {
    playerId: playerId,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlAccept, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.onFormClickAcceptApplication = function (e) {
  e.preventDefault();
  let playerId = $(e.currentTarget).data('playerid');
  let reasonText = $(e.currentTarget).closest("form").find('.alliancetexts').val();
  let params = {
    playerId: playerId,
    reasonText: reasonText,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlAccept, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Alliance.prototype.handleResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newAjaxToken);

  if (status === 'success') {
    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    } else {
      if (data.tabs !== undefined) {
        this.refreshTabs(data.tabs);
      }

      fadeBox(data.message, false);
      getAjaxEventbox();
      getAjaxResourcebox();
      this.fetch(this.tab);
    }
  } else {
    if (data.tabs !== undefined) {
      this.refreshTabs(data.tabs);
    }

    this.displayErrors(data.errors);
  }
};

Alliance.prototype.onFormClickBroadcastButton = function (e) {
  e.preventDefault();
  let rankIds = $('#selectNew').val();
  let broadcastText = $("#allianceBroadCast").find('.alliancetexts').val();
  let params = {
    rankIds: rankIds,
    broadcastText: broadcastText,
    _token: this.token
  };
  this.loadingIndicator.show();
  $.post(this.urlSend, params, this.handleResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

$(function () {
  $(document).on('click', '[data-homepage-link]', function (e) {
    e.preventDefault();
    errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.redirectMessage, LocalizationStrings.yes, LocalizationStrings.no, function () {
      window.open('redir.php?url=' + encodeURIComponent(allyHome), '_newtab');
    }, false, false);
  });
});
function AllianceClassBoxes(params) {
  this.loca = params.loca;
  this.token = params.token;
  this.activatingItem = false;
  this.ingameUrl = params.ingameUrl;
  this.init();
}

AllianceClassBoxes.prototype.init = function () {
  $(document).on('click', '.allianceclass.boxes .buttons .freeselect', this.onClickFreeSelect.bind(this));
  $(document).on('click', '.allianceclass.boxes .buttons .darkmatter', this.onClickDarkMatter.bind(this));
  $(document).on('click', '.allianceclass.boxes .buttons .deactivate', this.onClickDeactivate.bind(this));
  $(document).on('click', '.allianceclass.boxes .buttons .nodarkmatter', this.onClickNoDarkMatter.bind(this));
  $(document).on('click', '.allianceclass.boxes .buttons .classchangeitem', this.onClickClassChangeItem.bind(this));
};

AllianceClassBoxes.prototype.hasActiveSelection = function () {
  return $('.allianceclass.box.selected').length > 0;
};

AllianceClassBoxes.prototype.executeActionWithRedirect = function (url) {
  let that = this;
  let params = {
    _token: token
  };
  $.post(url, params, this.handleResponse.bind(this));
};

AllianceClassBoxes.prototype.onClickFreeSelect = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let allianceClassBox = $(e.currentTarget).closest('.allianceclass.box');
  let name = allianceClassBox.data('allianceClassName');

  if ($(e.currentTarget).data('disabled') !== 1) {
    this.fetchDataAboutCurrentAllianceClass(name, function () {
      that.executeActionWithRedirect(url);
    }, '', 0);
  }
};

AllianceClassBoxes.prototype.onClickDarkMatter = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let allianceClassBox = $(e.currentTarget).closest('.allianceclass.box');
  let name = allianceClassBox.data('allianceClassName');
  let price = allianceClassBox.data('allianceClassPrice');

  if ($(e.currentTarget).data('disabled') !== 1) {
    this.fetchDataAboutCurrentAllianceClass(name, function () {
      that.executeActionWithRedirect(url);
    }, 'buyAndActivateItemQuestion', price);
  }
};

AllianceClassBoxes.prototype.onClickNoDarkMatter = function (e) {
  let that = this;
  let urlDarkMatter = $(e.currentTarget).attr('rel');

  if ($(e.currentTarget).data('disabled') !== 1) {
    errorBoxDecision(this.loca.LOCA_ALL_NOTICE, this.loca.LOCA_ALL_ERROR_LACKING_DM, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, redirectPremium);
  }
};

AllianceClassBoxes.prototype.onClickDeactivate = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let allianceClassBox = $(e.currentTarget).closest('.allianceclass.box');
  let name = allianceClassBox.data('allianceClassName');
  let label = this.loca.LOCA_ALLIANCE_CLASS_NOTE_DEACTIVATE.replace('#allianceClassName#', name);

  if ($(e.currentTarget).data('disabled') !== 1) {
    errorBoxDecision(this.loca.LOCA_ALL_NOTICE, label, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
      that.executeActionWithRedirect(url);
    });
  }
};

AllianceClassBoxes.prototype.onClickClassChangeItem = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let allianceClassBox = $(e.currentTarget).closest('.allianceclass.box');
  let name = allianceClassBox.data('allianceClassName');

  if ($(e.currentTarget).data('disabled') !== 1) {
    this.fetchDataAboutCurrentAllianceClass(name, function () {
      let params = {
        _token: token
      };
      $.post(url, params).done(function (data) {
        var json = $.parseJSON(data);
        token = json.newAjaxToken;

        if (json.status === 'success') {
          window.location.reload();
        } else {
          that.displayErrors(json);
        }
      });
    }, 'activateItemQuestion', null);
  }
};

AllianceClassBoxes.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

AllianceClassBoxes.prototype.handleResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  token = data.newAjaxToken;
  alliance.updateToken(data.newAjaxToken);

  if (status === 'success') {
    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    } else {
      if (data.tabs !== undefined) {
        alliance.refreshTabs(data.tabs);
      }

      fadeBox(data.message, false);
      getAjaxEventbox();
      getAjaxResourcebox();
      this.fetch(this.tab);
    }
  } else {
    if (data.tabs !== undefined) {
      alliance.refreshTabs(data.tabs);
    }

    this.displayErrors(data.errors);
  }
};

AllianceClassBoxes.prototype.fetchDataAboutCurrentAllianceClass = function (newClassName, upgradeItemAjax, questionType, price) {
  if (!this.activatingItem) {
    this.activatingItem = true;
    let that = this;
    $.ajax({
      url: this.ingameUrl,
      type: "GET",
      data: {
        component: 'allianceclassselection',
        action: 'fetchDataAboutCurrentAllianceClass',
        ajax: 1,
        asJson: 1
      },
      dataType: "json",
      error: function (error) {
        that.promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price);
      },
      success: function (data) {
        that.promptUserForAllianceClassChange(newClassName, upgradeItemAjax, questionType, price, data);
      }
    });
  }
};

AllianceClassBoxes.prototype.promptUserForAllianceClassChange = function (newClassName, upgradeItemAjax, questionType, price, response) {
  this.activatingItem = false;

  if (response.userDoesNotHaveAlliance) {
    return 0;
  }

  let localizationString = this.loca.LOCA_ALLIANCE_CLASS_NOTE_ACTIVATE_WITH_ITEM;

  if (questionType === 'buyAndActivateItemQuestion') {
    localizationString = this.loca.LOCA_ALLIANCE_CLASS_NOTE_ACTIVATE_WITH_DM;
  }

  localizationString = localizationString.replace('#allianceClassName#', newClassName);

  if (questionType === 'buyAndActivateItemQuestion') {
    localizationString = localizationString.replace('#darkmatter#', tsdpkt(price));
  }

  if (response && response.currentAllianceClass && response.dateOfLastAllianceClassChange) {
    localizationString += this.loca.LOCA_ALLIANCE_CLASS_NOTE_ACTIVATE_APPEND_CURRENT_CLASS;
    localizationString = localizationString.replace('#currentAllianceClassName#', response.currentAllianceClass);
    localizationString = localizationString.replace('#lastAllianceClassChange#', response.dateOfLastAllianceClassChange);
  }

  errorBoxDecision(LocalizationStrings.notice, localizationString, LocalizationStrings.yes, LocalizationStrings.no, upgradeItemAjax);
};
let buildListActionCalled = false;

function buildListActionBuild(technologyId, amount, mode, buyWithDmAmount, planetId) {
  if (typeof scheduleBuildListEntryUrl === 'undefined') {
    return;
  }

  if (buildListActionCalled) {
    return;
  }

  buildListActionCalled = true;
  let body = {
    technologyId: technologyId,
    amount: amount ? amount : 1,
    mode: mode ? mode : 1,
    _token: token
  };

  if ($(".shipyardSelection .radioShipyardSelection").length !== 0) {
    body["selectedShipyard"] = parseInt($(".shipyardSelection .radioShipyardSelection:checked").val());
  }

  if (buyWithDmAmount) {
    body["buyWithDmAmount"] = buyWithDmAmount;
  }

  if (planetId) {
    body["planetId"] = planetId;
  }

  $.ajax({
    url: scheduleBuildListEntryUrl,
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      if (json.status === "success") {
        if (json.message) {
          fadeBox(json.message);
        }

        window.location.reload();
      } else {
        token = json.newAjaxToken;

        if (json.errors && json.errors.length) {
          fadeBox(json.errors[0].message, true);
        }

        buildListActionCalled = false;
      }
    },
    error: function () {
      if (typeof LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN !== "undefined" && LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN) {
        fadeBox(LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN, true);
      }

      buildListActionCalled = false;
    }
  });
}

function buildListActionDemolish(technologyId, planetId) {
  if (typeof scheduleBuildListEntryUrl === 'undefined') {
    return;
  }

  if (buildListActionCalled) {
    return;
  }

  buildListActionCalled = true;
  let body = {
    technologyId: technologyId,
    mode: 3,
    _token: token
  };

  if (planetId) {
    body["planetId"] = planetId;
  }

  $.ajax({
    url: scheduleBuildListEntryUrl,
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      if (json.status === "success") {
        if (json.message) {
          fadeBox(json.message);
        }

        window.location.reload();
      } else {
        token = json.newAjaxToken;

        if (json.errors && json.errors.length) {
          fadeBox(json.errors[0].message, true);
        }

        buildListActionCalled = false;
      }
    },
    error: function () {
      if (typeof LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN !== "undefined" && LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN) {
        fadeBox(LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN, true);
      }

      buildListActionCalled = false;
    }
  });
}

function buildListActionCancel(technologyId, listId, planetId) {
  if (typeof cancelBuildListEntryUrl === 'undefined') {
    return;
  }

  if (buildListActionCalled) {
    return;
  }

  buildListActionCalled = true;
  let body = {
    technologyId: technologyId,
    listId: listId,
    _token: token
  };

  if (planetId) {
    body["planetId"] = planetId;
  }

  $.ajax({
    url: cancelBuildListEntryUrl,
    data: body,
    type: "POST",
    dataType: "json",
    success: function (json) {
      if (json.status === "success") {
        if (json.message) {
          fadeBox(json.message);
        }

        window.location.reload();
      } else {
        token = json.newAjaxToken;

        if (json.errors && json.errors.length) {
          fadeBox(json.errors[0].message, true);
        }

        buildListActionCalled = false;
      }
    },
    error: function () {
      if (typeof LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN !== "undefined" && LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN) {
        fadeBox(LOCA_ERROR_INQUIRY_NOT_WORKED_TRYAGAIN, true);
      }

      buildListActionCalled = false;
    }
  });
}
function CharacterClassBoxes(params) {
  this.loca = params.loca;
  this.init();
}

CharacterClassBoxes.prototype.init = function () {
  $(document).on('click', '.characterclass.boxes .buttons .freeselect', this.onClickFreeSelect.bind(this));
  $(document).on('click', '.characterclass.boxes .buttons .darkmatter', this.onClickDarkMatter.bind(this));
  $(document).on('click', '.characterclass.boxes .buttons .deactivate', this.onClickDeactivate.bind(this));
  $(document).on('click', '.characterclass.boxes .buttons .nodarkmatter', this.onClickNoDarkMatter.bind(this));
  $(document).on('click', '.characterclass.boxes .buttons .classchangeitem', this.onClickClassChangeItem.bind(this));
};

CharacterClassBoxes.prototype.hasActiveSelection = function () {
  return $('.characterclass.box.selected').length > 0;
};

CharacterClassBoxes.prototype.executeActionWithRedirect = function (url) {
  let that = this;
  $.post(url).done(function (data) {
    var json = $.parseJSON(data);

    if (json.status === 'success') {
      fadeBox(json.message, false, function () {
        window.location.replace(json.redirectUrl);
      }, 2000);
    } else {
      that.displayErrors(json);
    }
  });
};

CharacterClassBoxes.prototype.onClickFreeSelect = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  $.post(url).done(function (data) {
    var json = $.parseJSON(data);

    if (json.status === 'success') {
      fadeBox(json.message, false, function () {
        window.location.replace(json.redirectUrl);
      }, 2000);
    } else {
      that.displayErrors(json);
    }
  });
};

CharacterClassBoxes.prototype.onClickDarkMatter = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let characterClassBox = $(e.currentTarget).closest('.characterclass.box');
  let name = characterClassBox.data('characterClassName');
  let price = characterClassBox.data('characterClassPrice');
  let label = this.loca.LOCA_CHARACTER_CLASS_NOTE_ACTIVATE_WITH_DM.replace('#characterClassName#', name).replace('#darkmatter#', tsdpkt(price));
  errorBoxDecision(this.loca.LOCA_ALL_NOTICE, label, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    that.executeActionWithRedirect(url);
  });
};

CharacterClassBoxes.prototype.onClickNoDarkMatter = function (e) {
  let that = this;
  let urlDarkMatter = $(e.currentTarget).attr('rel');
  errorBoxDecision(this.loca.LOCA_ALL_NOTICE, this.loca.LOCA_ALL_ERROR_LACKING_DM, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, redirectPremium);
};

CharacterClassBoxes.prototype.onClickDeactivate = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let characterClassBox = $(e.currentTarget).closest('.characterclass.box');
  let name = characterClassBox.data('characterClassName');
  let label = this.loca.LOCA_CHARACTER_CLASS_NOTE_DEACTIVATE.replace('#characterClassName#', name);
  errorBoxDecision(this.loca.LOCA_ALL_NOTICE, label, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    that.executeActionWithRedirect(url);
  });
};

CharacterClassBoxes.prototype.onClickClassChangeItem = function (e) {
  let that = this;
  let url = $(e.currentTarget).attr('rel');
  let characterClassBox = $(e.currentTarget).closest('.characterclass.box');
  let name = characterClassBox.data('characterClassName');
  let label = this.loca.LOCA_CHARACTER_CLASS_NOTE_ACTIVATE_WITH_ITEM.replace('#characterClassName#', name);
  errorBoxDecision(this.loca.LOCA_ALL_NOTICE, label, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    let params = {
      _token: token
    };
    $.post(url, params).done(function (data) {
      var json = $.parseJSON(data);
      token = json.newAjaxToken;

      if (json.status === "success") {
        window.location.reload();
      } else {
        that.displayErrors(json);
      }
    });
  });
};

CharacterClassBoxes.prototype.displayErrors = function (data) {
  let errorCode = data.errorCode || 0;
  let errorMessage = data.errorMessage || data.message || '';
  fadeBox(errorMessage, true);
};

function initExpeditionFleetTemplate() {
  $(".list tr:even").addClass("alt");
  $("#expeditionFleetTemplateResetForm").on('click', function (event) {
    event.preventDefault();
    resetExpedtionFleetTemplateForm();
  });
}

function selectShipsPerFleet(templateId) {
  $('#expeditionFleetTemplateSelect').ogameDropDown('destroy');
  $('#expeditionFleetTemplateSelect').ogameDropDown();
  $('#expeditionFleetTemplateSelect').ogameDropDown('select', templateId);
  $('#expeditionFleetTemplateSelect').val(templateId).trigger('change');
  $('#expeditionFleetTemplates').parents('.ui-dialog').find('.ui-dialog-titlebar-close').click();
}

var editingTemplate = false;

function saveExpeditionFleetTemplate(event) {
  event.preventDefault();

  if (editingTemplate) {
    return;
  }

  editingTemplate = true;
  let expeditionFleetTemplateData = $('#expeditionFleetTemplateForm').serialize();
  expeditionFleetTemplateData += `&token=${token}`;
  expeditionFleetTemplateData += `&action=saveExpeditionTemplate`;
  $.ajax({
    url: fleetTemplateUrl,
    type: 'POST',
    data: expeditionFleetTemplateData,
    dataType: "json",
    success: function (response) {
      if (response.status === 'success') {
        showNotification(response.message, 'success');
        $('#expeditionFleetTemplateForm').parents('.ui-dialog').find('.ui-dialog-titlebar-close').click();
        $('div.ui-dialog[aria-describedby="expeditionFleetTemplatesEdit"]').remove();
        updateExpeditionFleetTemplates(response.expeditionFleetTemplates);
        reloadComponent('expeditionfleettemplate');
      } else {
        showNotification(response.errors[0].message, 'error');
      }

      token = response.newAjaxToken;
      editingTemplate = false;
    },
    error: function (e) {
      window.location.reload();
    }
  });
}

function deleteExpeditionFleetTemplate(id) {
  if (editingTemplate) {
    return;
  }

  editingTemplate = true;
  $.ajax({
    url: fleetTemplateUrl,
    type: 'POST',
    data: {
      "action": 'deleteExpeditionTemplate',
      "expeditionFleetTemplateId": id,
      "_token": token
    },
    dataType: "json",
    success: function (response) {
      if (response.status === 'success') {
        showNotification(response.message, 'success');

        if ($('div.ui-dialog[aria-describedby="expeditionFleetTemplatesEdit"]').length) {
          $('#expeditionFleetTemplateForm').parents('.ui-dialog').find('.ui-dialog-titlebar-close').click();
          $('div.ui-dialog[aria-describedby="expeditionFleetTemplatesEdit"]').remove();
        }

        updateExpeditionFleetTemplates(response.expeditionFleetTemplates);
        reloadComponent('expeditionfleettemplate');
      } else {
        showNotification(response.errors[0].message, 'error');
      }

      token = response.newAjaxToken;
      editingTemplate = false;
    },
    error: function (e) {
      window.location.reload();
    }
  });
}

function updateExpeditionFleetTemplates(newExpeditionFleetTemplates) {
  expeditionFleetTemplates = newExpeditionFleetTemplates;
  $('#expeditionFleetTemplateSelect').ogameDropDown('destroy');
  $('#expeditionFleetTemplateSelect option').each((idx, option) => {
    if (option.value !== '0') {
      $(option).remove();
    }
  });
  newExpeditionFleetTemplates.map(fleetTemplate => {
    $('#expeditionFleetTemplateSelect').append(`<option value="${fleetTemplate.id}">${fleetTemplate.name}</option>`);
  });
  $('#expeditionFleetTemplateSelect').ogameDropDown();
  $('#expeditionFleetTemplateSelect').val('0').trigger('change');
}

function resetExpedtionFleetTemplateForm() {
  $('#expeditionFleetTemplateForm')[0].reset();
  $('#expeditionFleetTemplateHoldingTimeSelect').val("1").ogameDropDown('select', "1");
  $('#expeditionFleetTemplateSpeedSelect').val("100").ogameDropDown('select', "100");
}

function setExpeditionFleetTemplateShips(ships, tempName, templateId, selectedExpeditionTime, selectedSpeed) {
  $('#expeditionFleetTemplateForm')[0].reset();
  $("#expeditionFleetTemplateId").val(templateId);
  $("#expeditionFleetTemplateName").val(tempName);

  for (let shipId in ships) {
    $("#expeditionFleetTemplateShip_" + shipId).val(ships[shipId]);
  }

  $('#expeditionFleetTemplateHoldingTimeSelect').val(selectedExpeditionTime.toString()).ogameDropDown('select', selectedExpeditionTime.toString());
  $('#expeditionFleetTemplateSpeedWarning').css({
    'display': 'none'
  });

  if (allowedSpeedsInExpeditionTemplate.indexOf(selectedSpeed) === -1) {
    $('#expeditionFleetTemplateSpeedWarning').css({
      'display': 'flex'
    });
  }

  let speedToSelect = allowedSpeedsInExpeditionTemplate.find(speed => speed >= selectedSpeed);
  $('#expeditionFleetTemplateSpeedSelect').val(speedToSelect.toString()).ogameDropDown('select', speedToSelect.toString());
}

function reinitializeExpeditionFleetTemplateOGameDropdown() {
  $('#expeditionFleetTemplateForm select').ogameDropDown('destroy');
  $('#expeditionFleetTemplateForm span.dropdown.currentlySelected').remove();
  $('#expeditionFleetTemplateForm select').ogameDropDown();
}
const FLEET_DISPATCH_PAGE1 = 'fleet1';
const FLEET_DISPATCH_PAGE2 = 'fleet2';

function getResourcesFromHeader(resourceId) {
  let value = $('#resources_' + resourceId).data('raw');
  return parseInt(value);
}

function getKeyCode(e) {
  if (window.event) {
    return window.event.keyCode;
  } else if (e) {
    return e.which;
  }

  return null;
}

function FleetDispatcher(cfg) {
  this.fleetHelper = new FleetHelper(cfg);
  this.loading = false;
  this.lifeformEnabled = cfg.lifeformEnabled;
  this.checkTargetUrl = cfg.checkTargetUrl;
  this.sendFleetUrl = cfg.sendFleetUrl;
  this.saveSettingsUrl = cfg.saveSettingsUrl;
  this.fleetBoxOrder = cfg.fleetBoxOrder || {};
  this.token = cfg.token || null;
  this.currentPlanet = cfg.currentPlanet;
  this.targetPlanet = cfg.targetPlanet || null;
  this.targetInhabited = cfg.targetInhabited || false;
  this.targetPlayerId = cfg.targetPlayerId || this.fleetHelper.PLAYER_ID_SPACE;
  this.targetPlayerName = cfg.targetPlayerName || '';
  this.targetPlayerColorClass = cfg.targetPlayerColorClass || '';
  this.targetPlayerRankIcon = cfg.targetPlayerRankIcon || '';
  this.cargoCapacity = cfg.cargoCapacity;
  this.fuelCapacity = cfg.fuelCapacity;
  this.currentPage = FLEET_DISPATCH_PAGE1;
  this.shipsOnPlanet = cfg.shipsOnPlanet || [];
  this.shipsToSend = cfg.shipsToSend || [];
  this.useHalfSteps = cfg.useHalfSteps || false;
  this.planets = cfg.planets || [];
  this.standardFleets = cfg.standardFleets || [];
  this.expeditionFleetTemplates = cfg.expeditionFleetTemplates || [];
  this.unions = cfg.unions || [];
  this.orders = [];
  this.orderNames = cfg.orderNames || [];
  this.orderDescriptions = cfg.orderDescriptions || [];
  this.mission = cfg.mission || this.fleetHelper.MISSION_NONE;
  this.union = 0;
  this.targetIsStrong = false;
  this.targetIsOutlaw = false;
  this.targetIsBuddyOrAllyMember = false;
  this.playerIsOutlaw = false;
  this.retreatAfterDefenderRetreat = false;
  this.lootFoodOnAttack = cfg.lootFoodOnAttack;
  this.holdingTime = cfg.holdingTime;
  this.expeditionTime = cfg.expeditionTime;
  this.speedPercent = 10;
  this.cargoMetal = 0;
  this.cargoCrystal = 0;
  this.cargoDeuterium = 0;
  this.cargoFood = 0;
  this.prioMetal = cfg.LOOT_PRIO_METAL;
  this.prioCrystal = cfg.LOOT_PRIO_CRYSTAL;
  this.prioDeuterium = cfg.LOOT_PRIO_DEUTERIUM;
  this.prioFood = cfg.LOOT_PRIO_FOOD;
  this.metalOnPlanet = cfg.metalOnPlanet;
  this.crystalOnPlanet = cfg.crystalOnPlanet;
  this.deuteriumOnPlanet = cfg.deuteriumOnPlanet;
  this.foodOnPlanet = 0;

  if (this.lifeformEnabled) {
    this.foodOnPlanet = cfg.foodOnPlanet;
  }

  this.fleetCount = cfg.fleetCount;
  this.maxFleetCount = cfg.maxFleetCount;
  this.expeditionCount = cfg.expeditionCount;
  this.maxExpeditionCount = cfg.maxExpeditionCount;
  this.warningsEnabled = cfg.warningsEnabled;
  this.playerId = cfg.playerId;
  this.hasAdmiral = cfg.hasAdmiral;
  this.hasCommander = cfg.hasCommander;
  this.isOnVacation = cfg.isOnVacation;
  this.moveInProgress = cfg.moveInProgress;
  this.planetCount = cfg.planetCount;
  this.explorationCount = cfg.explorationCount;
  this.apiDataJson = cfg.apiDataJson;
  this.apiCommonData = cfg.apiCommonData;
  this.apiTechData = cfg.apiTechData;
  this.apiDefenseData = cfg.apiDefenseData;
  this.apiShipBaseData = cfg.apiShipBaseData;
  this.loca = cfg.loca;
  this.locadyn = cfg.locadyn;
  this.errorCodeMap = cfg.errorCodeMap;
  this.urlFleetCheck = cfg.urlFleetCheck;
  this.additionalFlightSpeed = 0;
  this.timerTimes = null;
  this.fetchTargetPlayerDataTimeout = null;
  this.deferred = [];
  this.emptySystems = cfg.emptySystems;
  this.inactiveSystems = cfg.inactiveSystems;
}

FleetDispatcher.prototype.init = function () {
  this.initFleet1();
  this.initFleet2();
  let that = this;
  $(function () {
    $(".sortable").sortable({
      handle: ".move-box",
      tolerance: "pointer",
      revert: true,
      update: function (event, ui) {
        a = $("#fleet2 #buttonz > div");
        param = {};
        that.appendTokenParams(param);

        for (let i = 0; i < a.length; i++) {
          param[a[i].id] = i;
        }

        $.post(that.saveSettingsUrl, param, function (data) {
          data = JSON.parse(data);
          that.updateToken(data.newAjaxToken);
          token = data.newAjaxToken;
        });
      }
    });
    $(".sortable").disableSelection();
  });
  $('#fleetdispatchcomponent').on('keypress', async function (e) {
    if (getKeyCode(e) === 13) {
      e.preventDefault();
      e.stopPropagation();

      if ($('#fleet1').is(':visible')) {
        await new Promise((resolve, reject) => setTimeout(() => resolve(), 250));
        that.trySubmitFleet1();
      } else if ($('#fleet2').is(':visible')) {
        // we have to wait to the update of a token because it already started communication with backend
        // should not trigger really but just as a safety measure
        if (!that.fetchTargetPlayerDataTimeout) {
          await new Promise((resolve, reject) => setTimeout(() => resolve(), 250));
          that.trySubmitFleet2();
        }
      }

      return false;
    }
  });
};

FleetDispatcher.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

FleetDispatcher.prototype.refresh = function () {
  switch (this.currentPage) {
    case FLEET_DISPATCH_PAGE1:
      this.refreshFleet1();
      break;

    case FLEET_DISPATCH_PAGE2:
      this.refreshFleet2();
      break;
  }
};

FleetDispatcher.prototype.switchToPage = function (page) {
  let that = this;

  if (page === this.currentPage) {
    return;
  }

  if (page === FLEET_DISPATCH_PAGE1) {
    this.currentPage = page;
    $('#' + FLEET_DISPATCH_PAGE1).show();
    $('#' + FLEET_DISPATCH_PAGE2).hide();
    that.focusSubmitFleet1();
  }

  if (page === FLEET_DISPATCH_PAGE2) {
    this.currentPage = page;
    $('#' + FLEET_DISPATCH_PAGE1).hide();
    $('#' + FLEET_DISPATCH_PAGE2).show();
    this.setTargetType(this.targetPlanet.type);
    that.focusSendFleet();
  }

  if (this.currentPage === FLEET_DISPATCH_PAGE1 && this.timerTimes !== null) {
    clearInterval(this.timerTimes);
    this.timerTimes = null;
  } // create timer to refresh fleet arrival and return times


  if (this.currentPage === FLEET_DISPATCH_PAGE2) {
    if (this.timerTimes === null) {
      this.timerTimes = setInterval(function () {
        that.refreshFleetTimes();
      }, 1000);
    }
  }

  this.refresh();
};

FleetDispatcher.prototype.startLoading = function () {
  this.loading = true;
  $('#fleetdispatchcomponent .ajax_loading').show();
};

FleetDispatcher.prototype.stopLoading = function () {
  this.loading = false;
  $('#fleetdispatchcomponent .ajax_loading').hide();
};

FleetDispatcher.prototype.updateToken = function (tokenNew) {
  token = tokenNew;
};

FleetDispatcher.prototype.appendTokenParams = function (params) {
  params.token = token;
};

FleetDispatcher.prototype.updateEmptySystems = function (newData) {
  this.emptySystems = newData;
};

FleetDispatcher.prototype.updateInactiveSystems = function (newData) {
  this.inactiveSystems = newData;
};

FleetDispatcher.prototype.appendShipParams = function (params) {
  this.shipsToSend.forEach(function (ship) {
    params['am' + ship.id] = ship.number;
  });
};

FleetDispatcher.prototype.appendTargetParams = function (params) {
  params.galaxy = this.targetPlanet.galaxy;
  params.system = this.targetPlanet.system;
  params.position = this.targetPlanet.position;
  params.type = this.targetPlanet.type;
};

FleetDispatcher.prototype.appendCargoParams = function (params) {
  params.metal = this.cargoMetal;
  params.crystal = this.cargoCrystal;
  params.deuterium = this.cargoDeuterium;

  if (this.lifeformEnabled) {
    params.food = this.cargoFood;
  }
};

FleetDispatcher.prototype.appendPrioParams = function (params) {
  params.prioMetal = this.prioMetal;
  params.prioCrystal = this.prioCrystal;
  params.prioDeuterium = this.prioDeuterium;

  if (this.lifeformEnabled) {
    params.prioFood = this.prioFood;
  }
};
/**
 * FLEET 1
 */


FleetDispatcher.prototype.initFleet1 = function () {
  initToggleHeader('fleet1');
  let that = this;
  let elem = $('#fleet1');
  elem.find('select.combatunits').ogameDropDown();
  that.refresh();
  elem.on('click', '#continueToFleet2', async function (e) {
    e.preventDefault();
    await new Promise((resolve, reject) => setTimeout(() => resolve(), 250));
    that.trySubmitFleet1();
  });
  elem.on('keyup', '#technologies li input', function (e) {
    e.preventDefault();
    let shipId = parseInt($(e.currentTarget).closest('li').data('technology'));
    let number = getValue($(e.currentTarget).val());
    that.selectShip(shipId, number);
  });
  elem.on('focusout', '#technologies li input', function (e) {
    e.preventDefault();
    let shipId = parseInt($(e.currentTarget).closest('li').data('technology'));
    let number = getValue($(e.currentTarget).val());
    that.selectShip(shipId, number);
    that.refresh();
  });
  elem.on('click', '#technologies li .icon', function (e) {
    e.preventDefault();
    let shipId = parseInt($(e.currentTarget).closest('li').data('technology'));

    if (that.getNumberOfShipsSelected(shipId) < that.getNumberOfShipsOnPlanet(shipId)) {
      that.selectMaxShips(shipId);
    } else {
      that.selectShip(shipId, 0);
    }

    that.refresh();
    that.focusSubmitFleet1();
  });
  elem.on('click', '#sendall', function (e) {
    e.preventDefault();
    that.selectAllShips();
    that.refresh();
    that.focusSubmitFleet1();
  });
  elem.on('click', '#resetall', function (e) {
    e.preventDefault();
    that.resetShips();
    that.refresh();
    that.focusSubmitFleet1();
  });
  elem.on('click', '#combatunits', function (e) {
    e.preventDefault();
    initStandardFleet();
  });
  elem.on('change', '#standardfleet', function (e) {
    let standardFleetId = getValue($('select.combatunits').val());
    that.selectStandardFleet(standardFleetId);
    that.refresh();
  });
  elem.on('change', '#expeditionFleetTemplateSelect', function (e) {
    let expeditionFleetTemplateId = getValue($('#expeditionFleetTemplateSelect').val());
    that.selectExpeditionFleet(expeditionFleetTemplateId);
    that.refresh();
  });
};

FleetDispatcher.prototype.focusSubmitFleet1 = function () {
  $('#continueToFleet2').focus();
};

FleetDispatcher.prototype.hasShipsSelected = function () {
  return this.getTotalNumberOfShipsSelected() > 0;
};

FleetDispatcher.prototype.hasFreeSlots = function () {
  return this.maxFleetCount - this.fleetCount > 0;
};

FleetDispatcher.prototype.hasEnoughFuel = function () {
  return this.deuteriumOnPlanet >= this.getConsumption();
};

FleetDispatcher.prototype.validateFleet1 = function (onError, onSuccess) {
  if (!this.hasShipsSelected()) {
    this.displayErrors([{
      message: this.loca.LOCA_FLEET_NO_SELECTION
    }]);
    return false;
  }

  if (!this.hasFreeSlots()) {
    this.displayErrors([{
      message: this.loca.LOCA_FLEET_NO_FREE_SLOTS
    }]);
    return false;
  }

  return true;
};

FleetDispatcher.prototype.trySubmitFleet1 = function () {
  if (this.validateFleet1() === false) {
    return;
  }

  this.switchToPage(FLEET_DISPATCH_PAGE2);
};

FleetDispatcher.prototype.refreshFleet1 = function () {
  this.refreshNavigationFleet1();
  this.refreshShips();
  this.refreshAPIData();
  this.refreshStatusBarFleet();
};

FleetDispatcher.prototype.refreshNavigationFleet1 = function () {
  let invalidInfo = '';

  if (!this.hasShipsSelected()) {
    $('#continueToFleet2').attr('class', 'continue off');
    invalidInfo = this.loca.LOCA_FLEET_NO_SELECTION;
  } else if (!this.hasFreeSlots()) {
    $('#continueToFleet2').attr('class', 'continue off');
    invalidInfo = this.loca.LOCA_FLEET_NO_FREE_SLOTS;
  } else {
    $('#continueToFleet2').attr('class', 'continue on');
  }

  $('#allornone .info').html(invalidInfo);
};

FleetDispatcher.prototype.refreshShips = function () {
  let that = this;
  $('#fleet1 #technologies li').each(function (i, elem) {
    const shipId = $(elem).data('technology');
    const ship = that.findShip(shipId);
    const inputElem = $(elem).find('input');
    const oldValue = inputElem.val() === '' ? '' : parseInt(inputElem.val());
    const number = ship?.number ?? '';

    if (oldValue !== number) {
      inputElem.val(number);
      const event = new Event('change');
      inputElem.get(0).dispatchEvent(event);
    }
  });
};

FleetDispatcher.prototype.refreshAPIData = function () {
  let apiShipData = this.shipsToSend.map(function (ship) {
    return [ship.id, ship.number];
  });

  if (apiShipData.length < 1) {
    apiShipData = this.apiShipBaseData;
  }

  let apiDataOld = [].concat(this.apiCommonData).concat(this.apiTechData).concat(apiShipData).concat(this.apiDefenseData).map(function (item) {
    return item.join(';');
  }).join('|');
  let apiData = JSON.parse(JSON.stringify(this.apiDataJson));

  if (this.shipsToSend.length > 0) {
    Object.keys(apiData.ships).forEach(key => apiData.ships[key]['amount'] = 0);
    this.shipsToSend.forEach(ship => {
      apiData.ships[ship.id] = this.apiDataJson.ships[ship.id];
      apiData.ships[ship.id].amount = ship.number;
    });
  }

  let content = JSON.stringify(apiData);
  let tooltip = document.createElement('div');
  tooltip.textContent = this.loca.LOCA_API_FLEET_DATA;
  tooltip.append(document.createElement('br'));
  tooltip.append(document.createTextNode('API 1:'));
  let oldInput = document.createElement('input');
  oldInput.setAttribute('id', 'FLEETAPI');
  oldInput.setAttribute('readonly', '1');
  oldInput.setAttribute('onclick', 'select()');
  oldInput.setAttribute('value', apiDataOld ?? '');
  oldInput.value = apiDataOld ?? '';
  tooltip.appendChild(oldInput);
  tooltip.append(document.createElement('br'));
  tooltip.append(document.createTextNode('API 2:'));
  let jsonInput = document.createElement('input');
  jsonInput.setAttribute('id', 'FLEETAPI_JSON');
  jsonInput.setAttribute('readonly', '1');
  jsonInput.setAttribute('onclick', 'select()');
  jsonInput.setAttribute('value', content);
  jsonInput.value = content;
  tooltip.appendChild(jsonInput);
  changeTooltip($(".show_fleet_apikey"), tooltip.outerHTML);
};
/**
 * SHIP LOGIC
 */


FleetDispatcher.prototype.selectShip = function (shipId, number) {
  let shipsAvailable = this.getNumberOfShipsOnPlanet(shipId);
  number = Math.min(shipsAvailable, number);

  if (number <= 0) {
    this.removeShip(shipId);
  } else if (this.hasShip(shipId)) {
    this.updateShip(shipId, number);
  } else {
    this.addShip(shipId, number);
  }

  this.resetCargo();
};

FleetDispatcher.prototype.addShip = function (shipId, number) {
  this.shipsToSend.push({
    id: shipId,
    number: number
  });
};

FleetDispatcher.prototype.findShip = function (shipId) {
  return this.shipsToSend.find(function (ship) {
    return ship.id === shipId;
  });
};

FleetDispatcher.prototype.getNumberOfShipsSelected = function (shipId) {
  let ship = this.findShip(shipId);

  if (ship !== undefined) {
    return ship.number;
  }

  return 0;
};

FleetDispatcher.prototype.hasShip = function (shipId) {
  return this.findShip(shipId) !== undefined;
};

FleetDispatcher.prototype.hasColonizationShip = function () {
  return this.hasShip(this.SHIP_ID_COLONIZATION);
};

FleetDispatcher.prototype.hasRecycler = function () {
  return this.hasShip(this.SHIP_ID_RECYCLER);
};

FleetDispatcher.prototype.hasValidTarget = function () {
  return (this.targetPlanet.galaxy !== this.currentPlanet.galaxy || this.targetPlanet.system !== this.currentPlanet.system || this.targetPlanet.position !== this.currentPlanet.position || this.targetPlanet.type !== this.currentPlanet.type) && this.targetPlanet.galaxy > 0 && this.targetPlanet.system > 0 && this.targetPlanet.position > 0;
};

FleetDispatcher.prototype.removeShip = function (shipId) {
  let shipIndex = this.shipsToSend.findIndex(function (ship) {
    return ship.id === shipId;
  });

  if (shipIndex != -1) {
    this.shipsToSend.splice(shipIndex, 1);
  }
};

FleetDispatcher.prototype.updateShip = function (shipId, number) {
  let ship = this.findShip(shipId);

  if (ship) {
    ship.number = number;
  }
};

FleetDispatcher.prototype.getNumberOfShipsOnPlanet = function (shipId) {
  let ship = this.shipsOnPlanet.find(function (ship) {
    return ship.id === shipId;
  });

  if (ship) {
    return ship.number;
  }

  return 0;
};

FleetDispatcher.prototype.getTotalNumberOfShipsSelected = function () {
  let numberOfShipsSelected = 0;
  this.shipsToSend.forEach(function (ship) {
    numberOfShipsSelected += ship.number;
  });
  return numberOfShipsSelected;
};

FleetDispatcher.prototype.getShipIds = function () {
  return this.shipsToSend.map(function (ship) {
    return ship.id;
  });
};

FleetDispatcher.prototype.resetShips = function () {
  this.shipsToSend = [];
};

FleetDispatcher.prototype.selectAllShips = function () {
  let that = this;
  this.shipsOnPlanet.forEach(function (ship) {
    that.selectShip(ship.id, ship.number);
  });
};

FleetDispatcher.prototype.selectMaxShips = function (shipId) {
  let number = this.getNumberOfShipsOnPlanet(shipId);
  this.selectShip(shipId, number);
};

FleetDispatcher.prototype.selectShips = function (ships) {
  for (let shipId in ships) {
    let number = ships[shipId];
    this.selectShip(parseInt(shipId), number);
  }
};

FleetDispatcher.prototype.selectStandardFleet = function (standardFleetId) {
  let standardFleet = this.standardFleets.find(function (item) {
    return item.id === standardFleetId;
  });

  if (standardFleet === undefined || standardFleet.ships === undefined) {
    return;
  }

  this.selectShips(standardFleet.ships);
};

FleetDispatcher.prototype.selectExpeditionFleet = function (expeditionFleetTemplateId) {
  this.resetShips();
  let speedSelect = $('#speedPercentage');

  if (speedSelect && speedSelect.length) {
    speedSelect.data('percentageBarInstance').setValue(10);
  }

  $('#expeditiontime').val('1').ogameDropDown('select', '1');
  this.refresh();
  this.focusSubmitFleet1();
  let expeditionFleetTemplate = expeditionFleetTemplates.find(item => item.id === expeditionFleetTemplateId);

  if (!expeditionFleetTemplate || !expeditionFleetTemplate.ships) {
    return;
  }

  this.selectShips(expeditionFleetTemplate.ships);

  if (speedSelect && speedSelect.length) {
    let speedToSelect = allowedSpeedsInExpeditionTemplate.find(speed => speed >= expeditionFleetTemplate.fleetSpeed);
    speedSelect.data('percentageBarInstance').setValue(speedToSelect / 10);
  }

  $('#position').val(EXPEDITION_POSITION);
  $('#expeditiontime').val(expeditionFleetTemplate.expeditionTime.toString()).ogameDropDown('select', expeditionFleetTemplate.expeditionTime.toString());
  this.updateTarget();
};
/**
 * FLEET 2
 */


FleetDispatcher.prototype.initFleet2 = function () {
  // @todo jquery is loaded twice
  addPercentageBarPlugin();
  initToggleHeader('fleet2'); // reorder fleet-box snippets based on settings

  let reorderFleetBox = Object.fromEntries(Object.entries(this.fleetBoxOrder).sort(([, a], [, b]) => a - b));
  let parent = $("#fleet2 #buttonz");

  for (let fleetBox in reorderFleetBox) {
    let child = $("#fleet2 #buttonz #" + fleetBox);
    $(parent).append(child);
  }

  let that = this;
  let elem = $('#fleet2').off();
  $('#speedPercentage').percentageBar().on('change', function (e) {
    that.setFleetPercent(e.value);
    that.refresh();
  });
  elem.find('#slbox').ogameDropDown();
  elem.find('#aksbox').ogameDropDown();
  elem.on('click', '#backToFleet1', function (e) {
    e.preventDefault();
    that.switchToPage(FLEET_DISPATCH_PAGE1);
  }); // clear inputs on focus

  elem.on('focus', '#galaxy', function () {
    clearInput('#galaxy');
    that.targetPlanet.galaxy = '';
    that.refreshFleet2();
  });
  elem.on('focus', '#system', function () {
    clearInput('#system');
    that.targetPlanet.system = '';
    that.refreshFleet2();
  });
  elem.on('focus', '#position', function () {
    clearInput('#position');
    that.targetPlanet.position = '';
    that.refreshFleet2();
  });
  elem.on('keyup', '#galaxy, #system, #position', function (e) {
    let coordinatesCount = (1 * $("#galaxy").val() > 0 ? 1 : 0) + (1 * $("#system").val() > 0 ? 1 : 0) + (1 * $("#position").val() > 0 ? 1 : 0);
    that.updateTarget(coordinatesCount === 3);
    that.updateTargetDropDowns();
    that.refresh();

    if (coordinatesCount !== 3) {
      that.clearMissions();
      that.updateTargetDropDowns();
    }
  });
  elem.on('click', '#pbutton', function (e) {
    e.preventDefault();
    that.clearMissions();
    that.setTargetType(that.fleetHelper.PLANETTYPE_PLANET);
    that.updateTargetDropDowns();
    that.refresh();
  });
  elem.on('click', '#mbutton', function (e) {
    e.preventDefault();
    that.clearMissions();
    that.setTargetType(that.fleetHelper.PLANETTYPE_MOON);
    that.updateTargetDropDowns();
    that.refresh();
  });
  elem.on('click', '#dbutton', function (e) {
    e.preventDefault();
    that.clearMissions();
    that.setTargetType(that.fleetHelper.PLANETTYPE_DEBRIS);
    that.updateTargetDropDowns();
    that.refresh();
  });
  elem.on('change', '#slbox', function (e) {
    e.preventDefault();
    that.selectShortLink($(e.currentTarget));
    that.updateTarget();
    that.refresh();
  });
  elem.on('change', '#aksbox', function (e) {
    e.preventDefault();
    that.selectCombatUnion($(e.currentTarget));
    that.updateTarget();
    that.refresh();
  });
  elem.on('click', '#selectMaxMetal', function (e) {
    e.preventDefault();
    that.selectMaxMetal();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMinMetal', function (e) {
    e.preventDefault();
    that.selectMinMetal();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMaxCrystal', function (e) {
    e.preventDefault();
    that.selectMaxCrystal();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMinCrystal', function (e) {
    e.preventDefault();
    that.selectMinCrystal();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMaxDeuterium', function (e) {
    e.preventDefault();
    that.selectMaxDeuterium();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMinDeuterium', function (e) {
    e.preventDefault();
    that.selectMinDeuterium();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMaxFood', function (e) {
    e.preventDefault();
    that.selectMaxFood();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#selectMinFood', function (e) {
    e.preventDefault();
    that.selectMinFood();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('click', '#allresources', function (e) {
    e.preventDefault();
    that.selectMaxAll();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('keyup', '#metal', function (e) {
    that.updateMetal();
    that.refresh();
  });
  elem.on('change', '#metal', function (e) {
    that.updateMetal();
    that.refresh();
  });
  elem.on('keyup', '#crystal', function (e) {
    that.updateCrystal();
    that.refresh();
  });
  elem.on('change', '#crystal', function (e) {
    that.updateCrystal();
    that.refresh();
  });
  elem.on('keyup', '#deuterium', function (e) {
    that.updateDeuterium();
    that.refresh();
  });
  elem.on('change', '#deuterium', function (e) {
    that.updateDeuterium();
    that.refresh();
  });
  elem.on('keyup', '#food', function (e) {
    that.updateFood();
    that.refresh();
  });
  elem.on('change', '#food', function (e) {
    that.updateFood();
    that.refresh();
  });
  elem.on('click', '#sendFleet', async function (e) {
    e.preventDefault();
    await new Promise((resolve, reject) => setTimeout(() => resolve(), 250));
    that.trySubmitFleet2();
  });
  elem.on('click', '#missions > li > a', function (e) {
    e.preventDefault();
    let mission = parseInt($(e.currentTarget).data('mission') || this.fleetHelper.MISSION_NONE);
    that.selectMission(mission);
    that.focusSendFleet();
  });
  elem.on('click', '.prioButton', function (e) {
    e.preventDefault();
    let type = $(e.currentTarget).attr('data-resource-type');
    let priority = parseInt($(e.currentTarget).attr('data-resource-prio'));
    that.selectPriority(type, priority);
    that.refresh();
    that.focusSendFleet();
  });

  FleetDispatcher.prototype.focusSendFleet = function () {
    $('#sendFleet').focus();
  };

  elem.on('change', 'input[name=retreatAfterDefenderRetreat]', function (e) {
    that.selectRetreatAfterDefenderRetreat($(e.currentTarget).is(':checked'));
  });
  elem.on('change', 'input[name=lootFoodOnAttack]', function (e) {
    that.selectLootFoodOnAttack($(e.currentTarget).is(':checked'));
  });
  elem.on('change keyup', '#holdingtime', function () {
    that.updateHoldingTime();
    that.refresh();
    that.focusSendFleet();
  });
  elem.on('change keyup', '#expeditiontime', function (e) {
    that.updateExpeditionTime();
    that.refresh();
    that.focusSendFleet();
  });
  this.fetchTargetPlayerData();
};

FleetDispatcher.prototype.validateFleet2 = function () {
  if (!this.hasValidTarget() || !this.hasMission()) {
    return false;
  }

  return true;
};

FleetDispatcher.prototype.trySubmitFleet2 = function () {
  clearTimeout(this.fetchTargetPlayerDataTimeout);
  this.fetchTargetPlayerDataTimeout = null;
  let that = this; // call refreshNavigationFleet2 to show error messages if any

  this.refreshNavigationFleet2(true);

  if ($("#sendFleet.off").length === 1) {
    return;
  }

  if (this.validateFleet2() === false) {
    return;
  }

  if (this.moveInProgress) {
    errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_PLANETMOVE_BREAKUP_WARNING, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
      that.submitFleet2();
    });
  } else if (this.warningsEnabled && this.targetIsStrong && !this.targetIsOutlaw && !this.targetIsBuddyOrAllyMember && !this.playerIsOutlaw && this.fleetHelper.isAggressiveMission(this.mission)) {
    errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.locadyn.locaAllOutlawWarning, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
      that.submitFleet2();
    });
  } else if (this.mission === this.fleetHelper.MISSION_COLONIZE && this.fleetHelper.COLONIZATION_ENABLED === true && !this.hasFreePlanetSlots()) {
    errorBoxDecision(this.loca.LOCA_ALL_NOTICE, this.loca.LOCA_FLEETSENDING_MAX_PLANET_WARNING, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
      that.submitFleet2();
    });
  } else {
    this.submitFleet2();
  }
};

FleetDispatcher.prototype.refreshFleet2 = function () {
  this.refreshNavigationFleet2();
  this.refreshTarget();
  this.refreshBriefing();
  this.refreshCargo();
  this.refreshPriorities();
};

FleetDispatcher.prototype.refreshTarget = function () {
  if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_PLANET) {
    $('#pbutton').attr('class', 'planet_selected');
  } else {
    $('#pbutton').attr('class', 'planet');
  }

  if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS) {
    $('#dbutton').attr('class', 'debris_selected');
  } else {
    $('#dbutton').attr('class', 'debris');
  }

  if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_MOON) {
    $('#mbutton').attr('class', 'moon_selected');
  } else {
    $('#mbutton').attr('class', 'moon');
  }

  $('#galaxy').val(this.targetPlanet.galaxy);
  $('#system').val(this.targetPlanet.system);
  $('#position').val(this.targetPlanet.position);
  $('#type').val(this.targetPlanet.type);
  $('#distanceValue').html(tsdpkt(this.getDistance()));
  let planetName = this.getOwnPlanetName(this.targetPlanet, this.targetPlanet.type);

  if (planetName !== undefined && planetName !== '') {
    $('#targetPlanetName').html(planetName);
  } else if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_PLANET) {
    $('#targetPlanetName').html(this.loca.LOCA_ALL_PLANET);
  } else if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS) {
    $('#targetPlanetName').html(this.loca.LOCA_FLEET_DEBRIS);
  } else if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_MOON) {
    $('#targetPlanetName').html(this.loca.LOCA_ALL_MOON);
  } // After we've chosen another Planet update the Missions


  this.refreshMissions();
};

FleetDispatcher.prototype.refreshBriefing = function () {
  this.refreshDuration();
  this.refreshConsumption();
  this.refreshStorage();
  this.refreshFleetTimes();
  this.refreshMaxSpeed();
  this.refreshEmptySystems();
  this.refreshInactiveSystems();
};

FleetDispatcher.prototype.refreshTargetPlanet = function () {
  let targetName = '[' + this.targetPlanet.galaxy + ':' + this.targetPlanet.system + ':' + this.targetPlanet.position + '] ' + (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS ? this.loca.LOCA_FLEET_DEBRIS : this.targetPlanet.name);
  let elem = $('#fleet2 #targetPlanet');
  let tooltip = this.targetInhabited === true ? this.loca.LOCA_ALL_PLAYER + ': ' + this.targetPlayerName : '';
  elem.toggleClass('tooltip', this.targetInhabited).toggleClass('active', this.targetInhabited).attr('title', tooltip).html(targetName);
  changeTooltip(elem);
};

FleetDispatcher.prototype.refreshDuration = function () {
  let duration = this.getDuration();
  duration = !isNaN(duration) && isFinite(duration) ? duration : 0;
  $('#fleet2 #duration').html(formatTime(duration) + ' h');
};

FleetDispatcher.prototype.refreshConsumption = function () {
  let fuelCapacity = this.getFuelCapacity();
  let deuterium = getResourcesFromHeader('deuterium');
  let consumption = this.getConsumption();
  consumption = !isNaN(consumption) && isFinite(consumption) ? consumption : 0;
  let styleClass = consumption > fuelCapacity || consumption > deuterium ? 'overmark' : 'undermark';
  let fuelLevel = Math.ceil(100 * consumption / fuelCapacity);
  let htmlConsumption = '<span class="' + styleClass + '">' + tsdpkt(consumption) + ' (' + fuelLevel + '%)</span>';
  $('#fleet2 #consumption').html(htmlConsumption);
};

FleetDispatcher.prototype.refreshStorage = function () {
  let cargoSpace = this.getFreeCargoSpace();
  let styleClass = cargoSpace < 0 ? 'overmark' : 'undermark';
  let htmlStorage = '<span class="' + styleClass + '">' + tsdpkt(cargoSpace) + '</span>';
  $('#storage').html(htmlStorage);
};

FleetDispatcher.prototype.refreshFleetTimes = function () {
  let duration = this.getDuration();
  let holdingTime = 0;

  if (this.mission === this.fleetHelper.MISSION_EXPEDITION) {
    holdingTime = this.expeditionTime * 3600;
  }

  if (this.mission === this.fleetHelper.MISSION_HOLD) {
    holdingTime = this.holdingTime * 3600;
  }

  duration = !isNaN(duration) && isFinite(duration) ? duration : 0;
  holdingTime = !isNaN(holdingTime) && isFinite(holdingTime) ? holdingTime : 0;
  let arrivalTime = getFormatedDate(serverTime.getTime() + duration * 1000, '[d].[m].[y] [G]:[i]:[s]');
  let returnTime = getFormatedDate(serverTime.getTime() + (2 * duration + holdingTime) * 1000, '[d].[m].[y] [G]:[i]:[s]');
  $('#fleet2 #arrivalTime').html(arrivalTime);
  $('#fleet2 #returnTime').html(returnTime);

  if (this.mission === this.fleetHelper.MISSION_UNIONATTACK) {
    let union = this.getUnionData(this.union);

    if (union !== null) {
      let durationAKS = parseInt(union.time - serverTime.getTime() / 1000);
      let unionArrivalTime = formatTime(durationAKS);
      $('#durationAKS').html(unionArrivalTime);
    }
  }
};

FleetDispatcher.prototype.refreshMaxSpeed = function () {
  let maxSpeed = this.getMaxSpeed();
  $('#maxspeed').html(tsdpkt(maxSpeed));
};

FleetDispatcher.prototype.refreshEmptySystems = function () {
  $('#emptySystems').html(this.emptySystems);
};

FleetDispatcher.prototype.refreshInactiveSystems = function () {
  $('#inactiveSystems').html(this.inactiveSystems);
};

FleetDispatcher.prototype.getPlanetIcon = function (planetType, showTooltip) {
  showTooltip = showTooltip || true;
  let className = '';
  let name = '';

  switch (planetType) {
    case this.fleetHelper.PLANETTYPE_MOON:
      className = "moon";
      name = this.loca.LOCA_ALL_MOON;
      break;

    case this.fleetHelper.PLANETTYPE_DEBRIS:
      className = "tf";
      name = this.loca.LOCA_FLEET_DEBRIS;
      break;

    case this.fleetHelper.PLANETTYPE_PLANET:
    default:
      className = "planet";
      name = this.loca.LOCA_ALL_PLANET;
  }

  let title = '';

  if (showTooltip) {
    className += " tooltip js_hideTipOnMobile";
    title = ' title="' + name + '"';
  }

  return '<figure class="planetIcon ' + className + '"' + title + '></figure>';
};

FleetDispatcher.prototype.updateTarget = function (fetch = true) {
  let galaxy = clampInt(getValue($('#galaxy').val()), 1, this.fleetHelper.MAX_GALAXY, true);
  let system = clampInt(getValue($('#system').val()), 1, this.fleetHelper.MAX_SYSTEM, true);
  let position = clampInt(getValue($('#position').val()), 1, this.fleetHelper.MAX_POSITION, true);
  this.targetPlanet.galaxy = galaxy;
  this.targetPlanet.system = system;
  this.targetPlanet.position = position;

  if (this.targetPlanet.position === this.fleetHelper.EXPEDITION_POSITION) {
    this.targetPlanet.type = this.fleetHelper.PLANETTYPE_PLANET;
  }

  clearTimeout(this.fetchTargetPlayerDataTimeout);

  if (fetch && $('#fleet2').is(':visible')) {
    let that = this;
    this.fetchTargetPlayerDataTimeout = setTimeout(() => {
      that.deferred.push($.Deferred()); // check if this is the only target fetch in queue or there are other pending calls

      if (that.deferred.length === 1) {
        that.fetchTargetPlayerData();
      }

      that.deferred[that.deferred.length - 1].done(() => {
        if (that.deferred.length !== 0) {
          that.fetchTargetPlayerData();
        }
      });
    }, 500);
  }
};

FleetDispatcher.prototype.updateTargetDropDowns = function () {
  this.resetDropDown("#slbox");
  this.resetDropDown("#aksbox");
};

FleetDispatcher.prototype.resetDropDown = function (elementId) {
  let coords = [this.targetPlanet.galaxy, this.targetPlanet.system, this.targetPlanet.position, this.targetPlanet.type].join('#');
  let selection = $(elementId).find("option[value^=\"" + coords + "\"]");

  if (selection.length === 0) {
    $(elementId).ogameDropDown('select', '-');
  }
};

FleetDispatcher.prototype.selectShortLink = function (elem) {
  let value = elem.val();
  let parts = value.split('#');

  if (parts instanceof Array && parts.length >= 5) {
    $('#galaxy').val(parts[0]);
    $('#system').val(parts[1]);
    $('#position').val(parts[2]);
    this.setTargetType(parseInt(parts[3]), true);
  }
};

FleetDispatcher.prototype.setTargetType = function (type, doNotFetchDataAboutTarget) {
  this.targetPlanet.type = type;

  if (!doNotFetchDataAboutTarget && $('#fleet2').is(':visible')) {
    clearTimeout(this.fetchTargetPlayerDataTimeout);
    this.fetchTargetPlayerDataTimeout = null;
    this.fetchTargetPlayerData();
  }
};

FleetDispatcher.prototype.selectCombatUnion = function (elem) {
  let value = elem.val();
  let parts = value.split('#');

  if (parts instanceof Array && parts.length >= 5) {
    $('#galaxy').val(parts[0]);
    $('#system').val(parts[1]);
    $('#position').val(parts[2]);
    this.setTargetType(parseInt(parts[3]), true);
    this.union = parseInt(parts[5]);
  } else {
    this.mission = this.fleetHelper.MISSION_NONE;
    this.union = 0;
  }
};

FleetDispatcher.prototype.setFleetPercent = function (speedPercent) {
  this.speedPercent = speedPercent;
};

FleetDispatcher.prototype.findOwnPlanet = function (coords, type) {
  if (!coords) return undefined;
  if (!type) return undefined;
  let planet = this.planets.find(function (elem) {
    if (elem.galaxy != coords.galaxy) return false;
    if (elem.system != coords.system) return false;
    if (elem.position != coords.position) return false;
    if (elem.type != type) return false;
    return true;
  });
  return planet;
};

FleetDispatcher.prototype.getOwnPlanetName = function (coords, type) {
  if (!coords) return undefined;
  if (!type) return undefined;
  let planet = this.findOwnPlanet(coords, type);

  if (planet) {
    return planet.name;
  }

  return undefined;
};

FleetDispatcher.prototype.getDistance = function () {
  return this.fleetHelper.calcDistance(this.currentPlanet, this.targetPlanet, this.emptySystems, this.inactiveSystems);
};

FleetDispatcher.prototype.getConsumption = function () {
  return this.fleetHelper.calcConsumption(this.shipsToSend, this.getDistance(), this.speedPercent, this.getHoldingTime(), this.mission);
};

FleetDispatcher.prototype.getDuration = function () {
  let distance = this.getDistance();
  let maxSpeed = this.getMaxSpeed();
  return this.fleetHelper.calcDuration(distance, maxSpeed, this.speedPercent, this.mission);
};

FleetDispatcher.prototype.getHoldingTime = function () {
  switch (this.mission) {
    case this.fleetHelper.MISSION_EXPEDITION:
      return this.expeditionTime;

    case this.fleetHelper.MISSION_HOLD:
      return this.holdingTime;

    default:
      return 0;
  }
};

FleetDispatcher.prototype.getMaxSpeed = function () {
  let shipIds = this.getShipIds();
  return this.fleetHelper.getMaxSpeed(shipIds);
};

FleetDispatcher.prototype.getCargoCapacity = function () {
  let that = this;
  let cargoCapacity = 0;
  this.shipsToSend.forEach(function (ship) {
    cargoCapacity += that.fleetHelper.calcCargoCapacity(ship.id, ship.number);
  });
  return Math.floor(cargoCapacity);
};

FleetDispatcher.prototype.getFuelCapacity = function () {
  let that = this;
  let fuelCapacity = 0;
  this.shipsToSend.forEach(function (ship) {
    fuelCapacity += that.fleetHelper.calcFuelCapacity(ship.id, ship.number);
  });
  return Math.floor(fuelCapacity);
};

FleetDispatcher.prototype.getFreeCargoSpace = function () {
  return this.getCargoCapacity() - this.cargoMetal - this.cargoCrystal - this.cargoDeuterium - this.cargoFood;
};

FleetDispatcher.prototype.getUsedCargoSpace = function () {
  return this.cargoMetal + this.cargoCrystal + this.cargoDeuterium + this.cargoFood;
};

FleetDispatcher.prototype.setOrders = function (ordersNew) {
  this.orders = ordersNew;
};

FleetDispatcher.prototype.setTargetInhabited = function (inhabitedNew) {
  this.targetInhabited = inhabitedNew;
};

FleetDispatcher.prototype.setTargetPlayerId = function (targetPlayerIdNew) {
  this.targetPlayerId = targetPlayerIdNew;
};

FleetDispatcher.prototype.setTargetPlayerName = function (targetPlayerNameNew) {
  this.targetPlayerName = targetPlayerNameNew;
};

FleetDispatcher.prototype.setTargetIsStrong = function (targetIsStrongNew) {
  this.targetIsStrong = targetIsStrongNew;
};

FleetDispatcher.prototype.setTargetIsOutlaw = function (targetIsOutlawNew) {
  this.targetIsOutlaw = targetIsOutlawNew;
};

FleetDispatcher.prototype.setTargetIsBuddyOrAllyMember = function (targetIsBuddyOrAllyMemberNew) {
  this.targetIsBuddyOrAllyMember = targetIsBuddyOrAllyMemberNew;
};

FleetDispatcher.prototype.setPlayerIsOutlaw = function (playerIsOutlawNew) {
  this.playerIsOutlaw = playerIsOutlawNew;
};

FleetDispatcher.prototype.setTargetPlayerColorClass = function (targetPlayerColorClassNew) {
  this.targetPlayerColorClass = targetPlayerColorClassNew;
};

FleetDispatcher.prototype.setTargetPlayerRankIcon = function (targetPlayerRankIconNew) {
  this.targetPlayerRankIcon = targetPlayerRankIconNew;
};

FleetDispatcher.prototype.setTargetPlanet = function (targetPlanetNew) {
  this.targetPlanet = targetPlanetNew;
};

FleetDispatcher.prototype.fetchTargetPlayerData = function () {
  if (!this.fetchTargetPlayerDataTimeout) {
    this.fetchTargetPlayerDataTimeout = true;
  }

  let that = this; // Prevent spaming the Planets (Destination)

  this.startLoading();
  let params = {};
  this.appendShipParams(params);
  this.appendTargetParams(params);
  this.appendTokenParams(params);
  params.union = this.union;

  if (this.hasColonizationShip()) {
    params.cs = 1;
  }

  if (this.hasRecycler()) {
    params.recycler = 1;
  }

    // Ensure all our params are existent, otherwise no point posting the data.
    if (!params.galaxy || !params.system || !params.position || !params.type) {
        this.stopLoading();
        return;
    }

  $.post(this.checkTargetUrl, params, function (data) {
    let status = data.status || 'failure';
    $("#additionalFleetSpeedInfo").html(data.additionalFlightSpeedinfo);
    that.fleetHelper.shipsData = data.shipsData;

    if (status === 'success') {
      let {
        targetPlanet
      } = data;

      if (targetPlanet && parseInt($('#galaxy').val()) === targetPlanet.galaxy && parseInt($('#system').val()) === targetPlanet.system && parseInt($('#position').val()) === targetPlanet.position) {
        that.refreshDataAfterAjax(data);
        that.refreshStatusBarFleet();
      }
    } else {
      that.setTargetPlayerNameOnStatusBarFleet();
      that.setTargetPlayerPlanetNameOnStatusBarFleet();

      if (that.currentPage === "fleet2") {
        that.clearMissions();
        that.updateTargetDropDowns();
        that.displayErrors(data.errors);
      }
    }

    if (that.currentPage === "fleet2") {
      if (that.mission !== that.fleetHelper.MISSION_NONE && !that.isMissionAvailable(that.mission)) {
        that.mission = that.fleetHelper.MISSION_NONE;
      } //select ACS attack if no mission is selected and if union is selected


      if (that.union !== 0 && that.hasMission() === false && that.isMissionAvailable(that.fleetHelper.MISSION_UNIONATTACK)) {
        that.selectMission(that.fleetHelper.MISSION_UNIONATTACK);
      }

      that.validateMissions();
    }

    that.updateToken(data.newAjaxToken);
    that.updateEmptySystems(data.emptySystems);
    that.updateInactiveSystems(data.inactiveSystems);
    that.refreshTargetPlanet();
    that.refreshFleet2();
    that.fetchTargetPlayerDataTimeout = null;
    that.stopLoading();

    if (data.bashingSystemLimitReached) {
      $('#attackMissionsDisabledBashingLimit').show();
    } else {
      $('#attackMissionsDisabledBashingLimit').hide();
    }

    let deferred = that.deferred.shift();

    if (deferred) {
      deferred.resolve();
    }
  });
};

FleetDispatcher.prototype.setTargetPlayerNameOnStatusBarFleet = function (serverResponse) {
  let elemTargetPlayerName = $('#statusBarFleet .targetPlayerName');
  let targetPlayerName = '';

  if (!serverResponse) {
    targetPlayerName = this.loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE;
  } else {
    if (serverResponse.targetPlanet && serverResponse.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS) {
      targetPlayerName = this.loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE;
    } else {
      if (!serverResponse.targetPlayerName) {
        targetPlayerName = this.loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE;
      } else if (serverResponse.targetPlayerId === this.playerId) {
        targetPlayerName = serverResponse.targetPlayerName;
      } else {
        targetPlayerName = serverResponse.targetPlayerRankIcon + '<span class="status_abbr_{color}">{name}</span>';
        targetPlayerName = targetPlayerName.replace('{color}', serverResponse.targetPlayerColorClass);
        targetPlayerName = targetPlayerName.replace('{name}', serverResponse.targetPlayerName);
      }
    }
  }

  elemTargetPlayerName.closest('li').show();
  elemTargetPlayerName.html(targetPlayerName);
};

FleetDispatcher.prototype.setTargetPlayerPlanetNameOnStatusBarFleet = function (serverResponse) {
  let targetName;

  if (!serverResponse || serverResponse && !serverResponse.targetPlanet) {
    let planetIcon = this.getPlanetIcon(this.fleetHelper.PLANETTYPE_PLANET, false);
    targetName = `[${$('#galaxy').val()}:${$('#system').val()}:${$('#position').val()}] ${planetIcon} ?`;
  } else {
    let planetIcon = this.getPlanetIcon(serverResponse.targetPlanet.type, false);
    targetName = '[' + serverResponse.targetPlanet.galaxy + ':' + serverResponse.targetPlanet.system + ':' + serverResponse.targetPlanet.position + '] ' + planetIcon + serverResponse.targetPlanet.name;
  }

  $('#statusBarFleet .targetName').html(targetName);
};

FleetDispatcher.prototype.submitFleet2 = function (force) {
  force = force || false;
  let that = this;
  let params = {};
  this.appendTokenParams(params);
  this.appendShipParams(params);
  this.appendTargetParams(params);
  this.appendCargoParams(params);
  this.appendPrioParams(params);
  params.mission = this.mission;
  params.speed = this.speedPercent;
  params.retreatAfterDefenderRetreat = this.retreatAfterDefenderRetreat === true ? 1 : 0;
  params.lootFoodOnAttack = this.lootFoodOnAttack === true ? 1 : 0;
  params.union = this.union;
  if (force) params.force = force;
  params.holdingtime = this.getHoldingTime();
  this.startLoading();
  $.post(this.sendFleetUrl, params, function (data) {
    if (data.success === true) {
      fadeBox(data.message, false);
      $("#sendFleet").removeAttr("disabled");
      window.location = data.redirectUrl;
    } // request failed
    else {
      // @TODO display confirmation popup to infringe bashlimit rules
      if (data.responseArray && data.responseArray.limitReached && !data.responseArray.force) {
        that.updateToken(data.newAjaxToken || '');
        errorBoxDecision(that.loca.LOCA_ALL_NETWORK_ATTENTION, that.locadyn.localBashWarning, that.loca.LOCA_ALL_YES, that.loca.LOCA_ALL_NO, function () {
          that.submitFleet2(true);
        });
      } else {
        that.displayErrors(data.errors);
        that.updateToken(data.newAjaxToken || '');
        $("#sendFleet").removeAttr("disabled");
        that.stopLoading();
      }
    }
  });
};

FleetDispatcher.prototype.refreshNavigationFleet2 = function (displayErrors = false) {
  let invalidInfo = null;
  const sendFleetElement = document.getElementById('sendFleet');

  if (!this.hasShipsSelected()) {
    sendFleetElement.classList.add('off');
    sendFleetElement.classList.remove('on');
    invalidInfo = this.loca.LOCA_FLEET_NO_SELECTION;
  } else if (!this.hasMission()) {
    sendFleetElement.classList.add('off');
    sendFleetElement.classList.remove('on');
    invalidInfo = this.loca.LOCA_FLEETSENDING_NO_MISSION_SELECTED;
  } else if (!this.hasFreeSlots()) {
    sendFleetElement.classList.add('off');
    sendFleetElement.classList.remove('on');
    invalidInfo = this.loca.LOCA_FLEET_NO_FREE_SLOTS;
  } else if (!this.hasEnoughFuel()) {
    sendFleetElement.classList.add('off');
    sendFleetElement.classList.remove('on');
    invalidInfo = this.loca.LOCA_FLEETSENDING_NOT_ENOUGH_FOIL;
  } else {
    sendFleetElement.classList.add('on');
    sendFleetElement.classList.remove('off');
    sendFleetElement.removeAttribute('disabled');
  }

  if (displayErrors && invalidInfo != null) {
    this.displayErrors([{
      message: invalidInfo
    }]);
  }
};

FleetDispatcher.prototype.refreshStatusBarFleet = function () {
  this.hasValidTarget();
  let missionData = this.getMissionData(this.mission);
  let missionName = missionData !== null ? missionData.name : this.loca.LOCA_FLEET_NO_SELECTION;
  let planetIcon = this.getPlanetIcon(this.targetPlanet.type, false);
  let targetName = '[' + this.targetPlanet.galaxy + ':' + this.targetPlanet.system + ':' + this.targetPlanet.position + '] ' + planetIcon + (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS ? this.loca.LOCA_FLEET_DEBRIS : this.targetPlanet.name);
  $('#statusBarFleet .missionName').text(missionName);
  $('#statusBarFleet .targetName').html(targetName);
  let elemTargetPlayerName = $('#statusBarFleet .targetPlayerName');

  if (this.targetPlanet.type === this.fleetHelper.PLANETTYPE_DEBRIS) {
    elemTargetPlayerName.closest('li').hide();
    elemTargetPlayerName.html('');
  } else {
    let targetPlayerName = '';

    if (this.targetPlayerId === 0 || this.fleetHelper.isPlayerSpace(this.targetPlayerId)) {
      targetPlayerName = this.loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE;
    } else if (this.targetPlayerId === this.playerId) {
      targetPlayerName = this.targetPlayerName;
    } else {
      targetPlayerName = this.targetPlayerRankIcon + '<span class="status_abbr_{color}">{name}</span>';
      targetPlayerName = targetPlayerName.replace('{color}', this.targetPlayerColorClass);
      targetPlayerName = targetPlayerName.replace('{name}', this.targetPlayerName);
    }

    elemTargetPlayerName.closest('li').show();
    elemTargetPlayerName.html(targetPlayerName);
  }
};

FleetDispatcher.prototype.clearMissions = function () {
  this.mission = this.fleetHelper.MISSION_NONE;

  for (let order in this.orders) {
    this.orders[order] = false;
  }
};

FleetDispatcher.prototype.validateMissions = function () {
  let invalid = false;

  if (!this.hasShipsSelected()) {
    invalid = true;
  } else if (!this.hasFreeSlots()) {
    invalid = true;
  } else if (!this.hasValidTarget() || Object.values(this.orders).indexOf(true) === -1) {
    invalid = true;
  }

  if (invalid) {
    this.clearMissions();
  }
};

FleetDispatcher.prototype.refreshMissions = function () {
  $('#missions>li>a.selected').removeClass('selected'); //select expedition if no mission is selected and if it is the only one available

  if (this.isOnlyMissionAvailable(this.fleetHelper.MISSION_EXPEDITION)) {
    if (this.hasMission() === false) {
      this.selectMission(this.fleetHelper.MISSION_EXPEDITION);
    }

    this.updateExpeditionTime();
  } // refresh mission buttons


  for (let mission in this.orders) {
    let missionData = this.getMissionData(mission);
    $('#missions>li#button' + mission).toggleClass('on', missionData.isAvailable === true).toggleClass('off', missionData.isAvailable === false);
  } // @TODO LOCA_FLEET_NO_SELECTION when no mission selected
  // refresh mission


  let missionData = this.getMissionData(this.mission);

  if (missionData !== null) {
    $('.missionName').text(missionData.name);
    $('.mission_description').text(missionData.description);
    $('#missions>li#button' + this.mission + '>a').toggleClass('selected', true);

    if (missionData.isAvailable === false) {
      $('.briefing_overlay').show();
      $('#missionNameWrapper').addClass('off');
    } else {
      $('.briefing_overlay').hide();
      $('#missionNameWrapper').removeClass('off');
    }
  } else {
    $('.briefing_overlay').show();
    $('#missionNameWrapper').addClass('off');
    $('.missionName').text(this.loca.LOCA_FLEET_NO_SELECTION);
    $('.mission_description').text('');
  }

  $('form input[name="mission"]').val(this.mission);
  $('#fightAfterRetreat,' + '#aks,' + '#holdtimeline,' + '#expeditiontimeline,' + '.prioButton,' + '.fleet_dispatch_toggle_wrap').hide();

  if (this.mission === this.fleetHelper.MISSION_ATTACK) {
    $('#fightAfterRetreat').show();
    $('.prioButton').show();
    $('.fleet_dispatch_toggle_wrap').show();
  }

  if (this.mission === this.fleetHelper.MISSION_UNIONATTACK) {
    $('#aks').show();
    $('.prioButton').show();
    $('.fleet_dispatch_toggle_wrap').show();
  }

  if (this.mission === this.fleetHelper.MISSION_DESTROY) {
    $('.prioButton').show();
    $('.fleet_dispatch_toggle_wrap').show();
  }

  if (this.mission === this.fleetHelper.MISSION_HOLD) {
    $('#holdtimeline').show();
  }

  if (this.mission === this.fleetHelper.MISSION_EXPEDITION) {
    $('#expeditiontimeline').show();
  }
};

FleetDispatcher.prototype.refreshCargo = function () {
  formatNumber($('#metal'), this.cargoMetal);
  formatNumber($('#crystal'), this.cargoCrystal);
  formatNumber($('#deuterium'), this.cargoDeuterium);

  if (this.lifeformEnabled) {
    formatNumber($('#food'), this.cargoFood);
  }

  let cargoSpaceUsed = this.getUsedCargoSpace();
  let cargoSpaceFree = this.getFreeCargoSpace();
  let cargoCapacity = this.getCargoCapacity();
  let styleClass = cargoSpaceFree < 0 ? 'overmark' : 'undermark';
  $('#remainingresources').html('<span class="' + styleClass + '">' + tsdpkt(cargoSpaceFree) + '</style>');
  $('#maxresources').html(tsdpkt(cargoCapacity));
  $('#loadRoom .bar_container').data('currentAmount', cargoSpaceUsed).data('capacity', cargoCapacity);
  refreshBars('bar_container', 'filllevel_bar');
};

FleetDispatcher.prototype.refreshPriorities = function () {
  $('form input[name="prioMetal"]').val(this.prioMetal);
  $('form input[name="prioCrystal"]').val(this.prioCrystal);
  $('form input[name="prioDeuterium"]').val(this.prioDeuterium);

  if (this.lifeformEnabled) {
    $('form input[name="prioFood"]').val(this.prioFood);
  }

  $('#prioM1').attr('src', '/img/icons/4b53e83f8b8583ea279fd26f3a55a5.gif');
  $('#prioM2').attr('src', '/img/icons/8afbd59ffe091239a7c6f1e961b267.gif');
  $('#prioM3').attr('src', '/img/icons/4acc67e1ca4d8debb1b114abcb7c1e.gif');

  if (this.lifeformEnabled) {
    $('#prioM4').attr('src', '/img/icons/8860dee24c03537549ad782922b6b5.gif');
  }

  switch (this.prioMetal) {
    case 1:
      $('#prioM1').attr('src', '/img/icons/b357323b99e20a46fc0b2495728351.gif');
      break;

    case 2:
      $('#prioM2').attr('src', '/img/icons/f8959fe540cd329f3a764ad9aeaf93.gif');
      break;

    case 3:
      $('#prioM3').attr('src', '/img/icons/823b3270ed0f4a243287c12d4ee5f8.gif');
      break;

    case 4:
      $('#prioM4').attr('src', '/img/icons/43bf98a73ba1abb53860f2c5b8edc3.gif');
      break;
  }

  $('#prioC1').attr('src', '/img/icons/4b53e83f8b8583ea279fd26f3a55a5.gif');
  $('#prioC2').attr('src', '/img/icons/8afbd59ffe091239a7c6f1e961b267.gif');
  $('#prioC3').attr('src', '/img/icons/4acc67e1ca4d8debb1b114abcb7c1e.gif');

  if (this.lifeformEnabled) {
    $('#prioC4').attr('src', '/img/icons/8860dee24c03537549ad782922b6b5.gif');
  }

  switch (this.prioCrystal) {
    case 1:
      $('#prioC1').attr('src', '/img/icons/b357323b99e20a46fc0b2495728351.gif');
      break;

    case 2:
      $('#prioC2').attr('src', '/img/icons/f8959fe540cd329f3a764ad9aeaf93.gif');
      break;

    case 3:
      $('#prioC3').attr('src', '/img/icons/823b3270ed0f4a243287c12d4ee5f8.gif');
      break;

    case 4:
      $('#prioC4').attr('src', '/img/icons/43bf98a73ba1abb53860f2c5b8edc3.gif');
      break;
  }

  $('#prioD1').attr('src', '/img/icons/4b53e83f8b8583ea279fd26f3a55a5.gif');
  $('#prioD2').attr('src', '/img/icons/8afbd59ffe091239a7c6f1e961b267.gif');
  $('#prioD3').attr('src', '/img/icons/4acc67e1ca4d8debb1b114abcb7c1e.gif');

  if (this.lifeformEnabled) {
    $('#prioD4').attr('src', '/img/icons/8860dee24c03537549ad782922b6b5.gif');
  }

  switch (this.prioDeuterium) {
    case 1:
      $('#prioD1').attr('src', '/img/icons/b357323b99e20a46fc0b2495728351.gif');
      break;

    case 2:
      $('#prioD2').attr('src', '/img/icons/f8959fe540cd329f3a764ad9aeaf93.gif');
      break;

    case 3:
      $('#prioD3').attr('src', '/img/icons/823b3270ed0f4a243287c12d4ee5f8.gif');
      break;

    case 4:
      $('#prioD4').attr('src', '/img/icons/43bf98a73ba1abb53860f2c5b8edc3.gif');
      break;
  }

  if (this.lifeformEnabled) {
    $('#prioF1').attr('src', '/img/icons/4b53e83f8b8583ea279fd26f3a55a5.gif');
    $('#prioF2').attr('src', '/img/icons/8afbd59ffe091239a7c6f1e961b267.gif');
    $('#prioF3').attr('src', '/img/icons/4acc67e1ca4d8debb1b114abcb7c1e.gif');
    $('#prioF4').attr('src', '/img/icons/8860dee24c03537549ad782922b6b5.gif');

    switch (this.prioFood) {
      case 1:
        $('#prioF1').attr('src', '/img/icons/b357323b99e20a46fc0b2495728351.gif');
        break;

      case 2:
        $('#prioF2').attr('src', '/img/icons/f8959fe540cd329f3a764ad9aeaf93.gif');
        break;

      case 3:
        $('#prioF3').attr('src', '/img/icons/823b3270ed0f4a243287c12d4ee5f8.gif');
        break;

      case 4:
        $('#prioF4').attr('src', '/img/icons/43bf98a73ba1abb53860f2c5b8edc3.gif');
        break;
    }
  }
};

FleetDispatcher.prototype.isMissionAvailable = function (missionId) {
  return this.orders[missionId] === true;
};

FleetDispatcher.prototype.hasMission = function () {
  return this.fleetHelper.isMissionValid(this.mission) && this.isMissionAvailable(this.mission);
};

FleetDispatcher.prototype.hasFreePlanetSlots = function () {
  return this.planetCount < this.fleetHelper.MAX_NUMBER_OF_PLANETS;
};

FleetDispatcher.prototype.getAvailableMissions = function () {
  let missions = [];

  for (let mission in this.orders) {
    if (this.orders[mission] === true) {
      missions.push(parseInt(mission));
    }
  }

  return missions;
};

FleetDispatcher.prototype.isOnlyMissionAvailable = function (missionId) {
  let missionsAvailable = this.getAvailableMissions();
  return missionsAvailable.length === 1 && missionsAvailable[0] === missionId;
};

FleetDispatcher.prototype.getMissionData = function (missionId) {
  if (missionId === this.fleetHelper.MISSION_NONE) {
    return null;
  }

  return {
    isAvailable: this.orders[missionId] || false,
    name: this.orderNames[missionId] || '',
    description: this.orderDescriptions[missionId] || ''
  };
};

FleetDispatcher.prototype.getUnionData = function (unionId) {
  for (let i = 0; i < this.unions.length; ++i) {
    if (this.unions[i].id === unionId) {
      return this.unions[i];
    }
  }

  return null;
};

FleetDispatcher.prototype.selectMaxMetal = function () {
  let amount;
  amount = this.getCargoCapacity() - this.cargoCrystal - this.cargoDeuterium - this.cargoFood;
  amount = Math.max(amount, 0);
  amount = Math.min(amount, this.metalOnPlanet);
  this.cargoMetal = Math.max(this.cargoMetal, amount);
};

FleetDispatcher.prototype.selectMinMetal = function () {
  this.cargoMetal = 0;
};

FleetDispatcher.prototype.selectMaxCrystal = function () {
  let amount;
  amount = this.getCargoCapacity() - this.cargoMetal - this.cargoDeuterium - this.cargoFood;
  amount = Math.max(amount, 0);
  amount = Math.min(amount, this.crystalOnPlanet);
  this.cargoCrystal = Math.max(this.cargoCrystal, amount);
};

FleetDispatcher.prototype.getDeuteriumOnPlanetWithoutConsumption = function () {
  return Math.max(0, this.deuteriumOnPlanet - this.getConsumption());
};

FleetDispatcher.prototype.selectMinCrystal = function () {
  this.cargoCrystal = 0;
};

FleetDispatcher.prototype.selectMaxDeuterium = function () {
  let amount;
  amount = this.getCargoCapacity() - this.cargoMetal - this.cargoCrystal - this.cargoFood;
  amount = Math.max(amount, 0);
  amount = Math.min(amount, this.getDeuteriumOnPlanetWithoutConsumption());
  this.cargoDeuterium = Math.max(this.cargoDeuterium, amount);
};

FleetDispatcher.prototype.selectMinDeuterium = function () {
  this.cargoDeuterium = 0;
};

FleetDispatcher.prototype.selectMaxFood = function () {
  let amount;
  amount = this.getCargoCapacity() - this.cargoMetal - this.cargoCrystal - this.cargoDeuterium;
  amount = Math.max(amount, 0);
  amount = Math.min(amount, this.foodOnPlanet);
  this.cargoFood = Math.max(this.cargoFood, amount);
};

FleetDispatcher.prototype.selectMinFood = function () {
  this.cargoFood = 0;
};

FleetDispatcher.prototype.selectMaxAll = function () {
  this.cargoMetal = 0;
  this.cargoCrystal = 0;
  this.cargoDeuterium = 0;
  this.selectMaxDeuterium();
  this.selectMaxCrystal();
  this.selectMaxMetal();

  if ($("#food_box").length) {
    this.cargoFood = 0;
    this.selectMaxFood();
  }
};

FleetDispatcher.prototype.resetCargo = function () {
  this.cargoMetal = 0;
  this.cargoCrystal = 0;
  this.cargoDeuterium = 0;
  this.cargoFood = 0;
};

FleetDispatcher.prototype.updateCargo = function () {
  this.updateMetal();
  this.updateCrystal();
  this.updateDeuterium();

  if ($("#food_box").length) {
    this.updateFood();
  }
};

FleetDispatcher.prototype.updateMetal = function () {
  let amount = getValue($('#metal').val());
  let cargoSpace = this.getCargoCapacity() - this.cargoCrystal - this.cargoDeuterium - this.cargoFood;
  this.cargoMetal = Math.min(amount, this.metalOnPlanet, cargoSpace);
};

FleetDispatcher.prototype.updateCrystal = function () {
  let amount = getValue($('#crystal').val());
  let cargoSpace = this.getCargoCapacity() - this.cargoMetal - this.cargoDeuterium - this.cargoFood;
  this.cargoCrystal = Math.min(amount, this.crystalOnPlanet, cargoSpace);
};

FleetDispatcher.prototype.updateDeuterium = function () {
  let amount = getValue($('#deuterium').val());
  let cargoSpace = this.getCargoCapacity() - this.cargoMetal - this.cargoCrystal - this.cargoFood;
  let deuteriumOnPlanetWithoutConsumption = this.getDeuteriumOnPlanetWithoutConsumption();
  this.cargoDeuterium = Math.min(amount, this.deuteriumOnPlanet, cargoSpace, deuteriumOnPlanetWithoutConsumption);
};

FleetDispatcher.prototype.updateFood = function () {
  if (!this.lifeformEnabled) return;
  let amount = getValue($('#food').val());
  let cargoSpace = this.getCargoCapacity() - this.cargoMetal - this.cargoCrystal - this.cargoDeuterium;
  this.cargoFood = Math.min(amount, this.foodOnPlanet, cargoSpace);
};

FleetDispatcher.prototype.selectMission = function (mission) {
  if (this.fleetHelper.isMissionValid(mission)) {
    this.mission = mission;
  }

  this.updateHoldingTime();
  this.updateExpeditionTime();
  this.refresh();
};

FleetDispatcher.prototype.selectRetreatAfterDefenderRetreat = function (retreatAfterDefenderRetreat) {
  this.retreatAfterDefenderRetreat = retreatAfterDefenderRetreat;
};

FleetDispatcher.prototype.selectLootFoodOnAttack = function (lootFoodOnAttack) {
  this.lootFoodOnAttack = lootFoodOnAttack;
};

FleetDispatcher.prototype.updateHoldingTime = function () {
  if (this.mission === this.fleetHelper.MISSION_HOLD) {
    this.holdingTime = getValue($('#fleet2 #holdingtime').val());
  } else {
    this.holdingTime = 0;
  }
};

FleetDispatcher.prototype.updateExpeditionTime = function () {
  if (this.mission === this.fleetHelper.MISSION_EXPEDITION) {
    this.expeditionTime = getValue($('#fleet2 #expeditiontime').val());
  } else {
    this.expeditionTime = 0;
  }
};

FleetDispatcher.prototype.selectPriority = function (type, priority) {
  if (!this.lifeformEnabled && priority === 4) return;

  switch (type) {
    case 'metal':
      if (this.prioMetal === priority) break;
      if (this.prioCrystal === priority) this.prioCrystal = this.prioMetal;
      if (this.prioDeuterium === priority) this.prioDeuterium = this.prioMetal;
      if (this.prioFood === priority) this.prioFood = this.prioMetal;
      this.prioMetal = priority;
      break;

    case 'crystal':
      if (this.prioCrystal === priority) break;
      if (this.prioMetal === priority) this.prioMetal = this.prioCrystal;
      if (this.prioDeuterium === priority) this.prioDeuterium = this.prioCrystal;
      if (this.prioFood === priority) this.prioFood = this.prioCrystal;
      this.prioCrystal = priority;
      break;

    case 'deuterium':
      if (this.prioDeuterium === priority) break;
      if (this.prioMetal === priority) this.prioMetal = this.prioDeuterium;
      if (this.prioCrystal === priority) this.prioCrystal = this.prioDeuterium;
      if (this.prioFood === priority) this.prioFood = this.prioDeuterium;
      this.prioDeuterium = priority;
      break;

    case 'food':
      if (this.prioFood === priority) break;
      if (this.prioMetal === priority) this.prioMetal = this.prioFood;
      if (this.prioCrystal === priority) this.prioCrystal = this.prioFood;
      if (this.prioDeuterium === priority) this.prioDeuterium = this.prioFood;
      this.prioFood = priority;
      break;
  }
};

FleetDispatcher.prototype.refreshDataAfterAjax = function (data) {
  this.setOrders(data.orders);
  this.setTargetInhabited(data.targetInhabited);
  this.setTargetPlayerId(data.targetPlayerId);
  this.setTargetPlayerName(data.targetPlayerName);
  this.setTargetIsStrong(data.targetIsStrong);
  this.setTargetIsOutlaw(data.targetIsOutlaw);
  this.setTargetIsBuddyOrAllyMember(data.targetIsBuddyOrAllyMember);
  this.setTargetPlayerColorClass(data.targetPlayerColorClass);
  this.setTargetPlayerRankIcon(data.targetPlayerRankIcon);
  this.setPlayerIsOutlaw(data.playerIsOutlaw);
  this.setTargetPlanet(data.targetPlanet);
};
function FleetHelper(cfg) {
  // player specific ship data
  this.shipsData = cfg.shipsData; // game constants

  this.COLONIZATION_ENABLED = cfg.COLONIZATION_ENABLED;
  this.MAX_NUMBER_OF_PLANETS = cfg.MAX_NUMBER_OF_PLANETS;
  this.PLAYER_ID_LEGOR = cfg.PLAYER_ID_LEGOR;
  this.PLAYER_ID_SPACE = cfg.PLAYER_ID_SPACE; // mission constants

  this.MISSION_NONE = cfg.missions.MISSION_NONE;
  this.MISSION_ATTACK = cfg.missions.MISSION_ATTACK;
  this.MISSION_UNIONATTACK = cfg.missions.MISSION_UNIONATTACK;
  this.MISSION_TRANSPORT = cfg.missions.MISSION_TRANSPORT;
  this.MISSION_DEPLOY = cfg.missions.MISSION_DEPLOY;
  this.MISSION_HOLD = cfg.missions.MISSION_HOLD;
  this.MISSION_ESPIONAGE = cfg.missions.MISSION_ESPIONAGE;
  this.MISSION_COLONIZE = cfg.missions.MISSION_COLONIZE;
  this.MISSION_RECYCLE = cfg.missions.MISSION_RECYCLE;
  this.MISSION_DESTROY = cfg.missions.MISSION_DESTROY;
  this.MISSION_MISSILEATTACK = cfg.missions.MISSION_MISSILEATTACK;
  this.MISSION_EXPEDITION = cfg.missions.MISSION_EXPEDITION; // galaxy related constants

  this.DONUT_GALAXY = cfg.DONUT_GALAXY;
  this.DONUT_SYSTEM = cfg.DONUT_SYSTEM;
  this.MAX_GALAXY = cfg.MAX_GALAXY;
  this.MAX_SYSTEM = cfg.MAX_SYSTEM;
  this.MAX_POSITION = cfg.MAX_POSITION;
  this.EXPEDITION_POSITION = cfg.EXPEDITION_POSITION; // fleet related constants

  this.SPEEDFAKTOR_FLEET_PEACEFUL = cfg.SPEEDFAKTOR_FLEET_PEACEFUL;
  this.SPEEDFAKTOR_FLEET_WAR = cfg.SPEEDFAKTOR_FLEET_WAR;
  this.SPEEDFAKTOR_FLEET_HOLDING = cfg.SPEEDFAKTOR_FLEET_HOLDING;
  this.FLEET_DEUTERIUM_SAVE_FACTOR = cfg.FLEET_DEUTERIUM_SAVE_FACTOR; // target types

  this.PLANETTYPE_PLANET = cfg.PLANETTYPE_PLANET;
  this.PLANETTYPE_DEBRIS = cfg.PLANETTYPE_DEBRIS;
  this.PLANETTYPE_MOON = cfg.PLANETTYPE_MOON;
}

FleetHelper.prototype.isPlayerSpace = function (playerId) {
  return playerId === this.PLAYER_ID_SPACE;
};

FleetHelper.prototype.isPlayerLegor = function (playerId) {
  return playerId === this.PLAYER_ID_LEGOR;
};

FleetHelper.prototype.calcDistance = function (from, to, emptySystems, inactiveSystems) {
  let diffGalaxy = Math.abs(from.galaxy - to.galaxy);
  let diffSystem = Math.abs(from.system - to.system);
  let diffPlanet = Math.abs(from.position - to.position);

  if (diffGalaxy != 0) {
    let diff2 = Math.abs(diffGalaxy - this.MAX_GALAXY);

    if (this.DONUT_GALAXY == 1 && diff2 < diffGalaxy) {
      return diff2 * 20000;
    } else {
      return diffGalaxy * 20000;
    }
  } else if (diffSystem != 0) {
    let diff2 = Math.abs(diffSystem - this.MAX_SYSTEM);
    let deltaSystem = 0;

    if (this.DONUT_SYSTEM == 1 && diff2 < diffSystem) {
      deltaSystem = diff2;
    } else {
      deltaSystem = diffSystem;
    }

    deltaSystem = Math.max(deltaSystem - emptySystems - inactiveSystems, 1);
    return deltaSystem * 5 * 19 + 2700;
  } else if (diffPlanet != 0) {
    return diffPlanet * 5 + 1000;
  } else {
    return 5;
  }
};

FleetHelper.prototype.getFleetSpeedFaktor = function (mission) {
  let peaceful = [this.MISSION_TRANSPORT, this.MISSION_DEPLOY, this.MISSION_COLONIZE, this.MISSION_EXPEDITION];
  let war = [this.MISSION_ATTACK, this.MISSION_UNIONATTACK, this.MISSION_ESPIONAGE, this.MISSION_RECYCLE, this.MISSION_DESTROY, this.MISSION_MISSILEATTACK];
  let holding = [this.MISSION_HOLD];
  if (peaceful.includes(mission)) return this.SPEEDFAKTOR_FLEET_PEACEFUL;else if (war.includes(mission)) return this.SPEEDFAKTOR_FLEET_WAR;else if (holding.includes(mission)) return this.SPEEDFAKTOR_FLEET_HOLDING;else return 0;
};

FleetHelper.prototype.calcDuration = function (distance, maxSpeed, speedPercent, mission) {
  mission = mission || this.MISSION_NONE;
  return Math.max(Math.round((35000 / speedPercent * Math.sqrt(distance * 10 / maxSpeed) + 10) / this.getFleetSpeedFaktor(mission)), 1);
};

FleetHelper.prototype.calcConsumption = function (ships, distance, speedPercent, holdingTime, mission) {
  mission = mission || this.MISSION_NONE;
  let that = this;
  let consumption = 0;
  let holdingCosts = 0;
  let shipIds = ships.map(function (ship) {
    return ship.id;
  });
  let maxSpeed = this.getMaxSpeed(shipIds);
  let duration = this.calcDuration(distance, maxSpeed, speedPercent, mission);
  let speedValue = Math.max(0.5, duration * this.getFleetSpeedFaktor(mission) - 10);
  ships.forEach(function (ship) {
    if (ship.number) {
      let shipData = that.getShipData(ship.id);
      let shipSpeedValue = 35000 / speedValue * Math.sqrt(distance * 10 / shipData.speed);
      holdingCosts += shipData.fuelConsumption * ship.number * holdingTime;
      consumption += Math.max(shipData.fuelConsumption * ship.number * distance / 35000 * (shipSpeedValue / 10 + 1) * (shipSpeedValue / 10 + 1), 1);
    }
  });
  consumption = Math.round(consumption);
  consumption += holdingTime > 0 ? Math.max(Math.floor(holdingCosts / 10), 1) : 0;
  return consumption;
};

FleetHelper.prototype.calcCargoCapacity = function (shipId, number) {
  let shipData = this.getShipData(shipId);
  return Math.floor(shipData.baseCargoCapacity * number);
};

FleetHelper.prototype.calcFuelCapacity = function (shipId, number) {
  let shipData = this.getShipData(shipId);
  return shipData.baseFuelCapacity * number;
};

FleetHelper.prototype.getMaxSpeed = function (shipIds) {
  let that = this;
  let speeds = [];
  shipIds.forEach(function (shipId) {
    let shipData = that.getShipData(shipId);
    if (shipData && shipData.speed) speeds.push(shipData.speed);
  });
  let maxSpeed = speeds.reduce(function (a, b) {
    return Math.min(a, b);
  }, 1000000000);
  return maxSpeed;
};

FleetHelper.prototype.getShipData = function (shipId) {
  // shipsData is undefined when you switch to fast
  // the Planets (Target Planet)
  if (typeof this.shipsData === 'undefined') return null;
  return this.shipsData[shipId];
};

FleetHelper.prototype.isAggressiveMission = function (mission) {
  switch (mission) {
    case this.MISSION_ATTACK:
    case this.MISSION_UNIONATTACK:
    case this.MISSION_ESPIONAGE:
    case this.MISSION_DESTROY:
      return true;
  }

  return false;
};

FleetHelper.prototype.isMissionValid = function (mission) {
  switch (mission) {
    case this.MISSION_ATTACK:
    case this.MISSION_UNIONATTACK:
    case this.MISSION_TRANSPORT:
    case this.MISSION_DEPLOY:
    case this.MISSION_HOLD:
    case this.MISSION_ESPIONAGE:
    case this.MISSION_COLONIZE:
    case this.MISSION_RECYCLE:
    case this.MISSION_DESTROY:
    case this.MISSION_MISSILEATTACK:
    case this.MISSION_EXPEDITION:
      return true;
  }

  return false;
};
var cancelProduction_id;
var production_listid;

function cancelProduction(id, listid, question) {
  cancelProduction_id = id;
  production_listid = listid;
  errorBoxDecision(loca.LOCA_ALL_NETWORK_ATTENTION, "" + question + "", loca.LOCA_ALL_YES, loca.LOCA_ALL_NO, cancelProductionStart);
}

function cancelProductionStart() {
  window.location.replace(urlCancleBuilding + '&techid=' + cancelProduction_id + '&listid=' + production_listid);
}
function submitOnKey(keyCode) {
  selectShipsPerFleet("0");

  if (keyCode === 'ArrowLeft') {
    system = system > 1 ? parseInt(system) - 1 : maxSystems;

    if (isMobile) {
      loadContent(galaxy, system);
    } else {
      loadContentNew(galaxy, system);
    }
  } else if (keyCode === 'ArrowRight') {
    system = system < maxSystems ? parseInt(system) + 1 : 1;

    if (isMobile) {
      loadContent(galaxy, system);
    } else {
      loadContentNew(galaxy, system);
    }
  } else if (keyCode === 'ArrowDown') {
    galaxy = galaxy > 1 ? parseInt(galaxy) - 1 : maxGalaxies;

    if (isMobile) {
      loadContent(galaxy, system);
    } else {
      loadContentNew(galaxy, system);
    }
  } else if (keyCode === 'ArrowUp') {
    galaxy = galaxy < maxGalaxies ? parseInt(galaxy) + 1 : 1;

    if (isMobile) {
      loadContent(galaxy, system);
    } else {
      loadContentNew(galaxy, system);
    }
  }
}

function keyevent(ev) {
  let keyCode;
  let focusElement = $(":focus");

  if (focusElement.closest('.ui-dialog').length) {
    return true;
  }

  if (focusElement.closest('.chat_box_textarea').length) {
    return true;
  }

  if (ev) {
    keyCode = ev.key;
  } else {
    return true;
  }

  submitOnKey(keyCode);
}

function launchMissiles(response) {
  var data = $.parseJSON(response);
  token = data.newAjaxToken;
  updateOverlayToken('phalanxSystemDialog', data.newAjaxToken);
  updateOverlayToken('phalanxDialog', data.newAjaxToken);

  if (data["status"]) {
    $("#missileValue").html(data["rockets"]);
    getAjaxEventbox();
  }

  errorBoxAsArray(data["errorbox"]);
  $("#rocketattack").closest('.ui-dialog-content').remove();
}

function movePlanet(url, data, reloadPage) {
  function movePlanetExecute() {
    $.post(url, data, function (res) {
      if (res.error == '') {
        fadeBox(galaxyLoca.reservationSuccess, false);
        setTimeout('reload_page("' + reloadPage + '")', 3000);
      } else {
        fadeBox(res.error, true);
      }
    }, "json");
  }

  errorBoxDecision(galaxyLoca.questionTitle, galaxyLoca.question, LocalizationStrings.yes, LocalizationStrings.no, movePlanetExecute);
}

function discoverPlanet(url, data, success = () => {}) {
  const discover = () => {
    $.post(url, data, function (res) {
      token = res.newAjaxToken;

      if (typeof res.response.success !== 'undefined' && res.response.success === true) {
        getAjaxEventbox();
        success();
        getAjaxResourcebox();
      }

      displayMiniFleetMessage(res.response);
      const discoveryIcons = Array.from(document.getElementsByClassName('planetDiscover'));
      discoveryIcons.forEach(icon => {
        if (icon.classList.contains('position' + res.response.coordinates.position)) {
          return;
        }

        if (res.response.discovery.canSendDiscovery !== true) {
          $(icon).replaceWith(`
                        <div class="planetDiscoverIcons planetDiscoverUnavailable tooltip icon js_hideTipOnMobile"
                            title="${res.response.discovery.canSendDiscovery}">
                        </div>
                    `);
          return;
        }

        const titleText = galaxyLoca.discoverySend + " " + res.response.discovery.discoveryCount;
        icon.title = titleText;
        changeTooltip(icon, titleText);
      });
      const targetIcon = $('.planetDiscover.position' + res.response.coordinates.position);
      targetIcon.replaceWith(`<div class="planetDiscoverIcons planetDiscoverUnavailable tooltip icon js_hideTipOnMobile"
                    title="${galaxyLoca.discoveryUnderway}">
                </div>`);
      document.getElementById('galaxyHeaderDiscoveryCount').innerHTML = res.response.discovery.galaxyHeader.LOCA_GALAXY_LIFEFORM_DISCOVERY_COUNT;
    }, "json");
  };

  if (showDiscoveryWarning) {
    errorBoxDecision(galaxyLoca.discoverQuestionTitle, galaxyLoca.discoverQuestionText, LocalizationStrings.yes, LocalizationStrings.no, discover);
  } else {
    discover();
  }
}

let sendingSystemDiscoveryMission = false;

function sendSystemDiscoveryMission() {
  if (typeof sendDiscoverSystemUrl === 'undefined' || !sendDiscoverSystemUrl) {
    return;
  }

  if (typeof galaxy === 'undefined' || !galaxy) {
    return;
  }

  if (typeof system === 'undefined' || !system) {
    return;
  }

  if (sendingSystemDiscoveryMission) {
    return;
  }

  sendingSystemDiscoveryMission = true;
  $.ajax({
    url: sendDiscoverSystemUrl,
    data: {
      galaxy: galaxy,
      system: system,
      _token: token
    },
    type: "POST",
    dataType: "json",
    success: function (res) {
      token = res.newAjaxToken;

      if (res.response.success) {
        getAjaxEventbox();
        getAjaxResourcebox();
        res.response.sentToCoordinates.map(coords => {
          displayMiniFleetMessage({ ...res.response,
            coordinates: coords
          }, false);
          const targetIcon = $('.planetDiscover.position' + coords.position);
          targetIcon.replaceWith(`
                        <div class="planetDiscoverIcons planetDiscoverUnavailable tooltip icon js_hideTipOnMobile"
                            title="${galaxyLoca.discoveryUnderway}">
                        </div>
                    `);
        });
      } else {
        fadeBox(res.response.message, true);
      }

      sendingSystemDiscoveryMission = false;
    },
    error: function () {
      sendingSystemDiscoveryMission = false;
    }
  });
}

function addToTable(strDataResult, strClass, shipCount) {
  let text = strDataResult.message || strDataResult;

  if (shipCount != null) {
    text += " (" + tsdpkt(shipCount) + ") " + LocalizationStrings.ok;
  }

  if (isMobile) {
    fadeBox(text, strClass != "success");
    return;
  }

  let currentTime = new Date();
  let id = 'fleetstatus' + currentTime.getTime();
  let idHtml = 'id="' + id + '"';
  let myClass = 'class="' + strClass + '"';
  let div = '<div ' + idHtml + ' ' + myClass + '>' + text + '</div>';

  if ($('#fleetstatusrow').has('div').length) {
    $('#fleetstatusrow').empty();
  }

  $(div).prependTo('#fleetstatusrow').fadeOut(3000, function () {
    $(this).remove();
  });
}

function setShips(ship, count) {
  var e = document.getElementById(ship);

  if (e !== null) {
    e.innerHTML = count;
  }
}

function renderContentGalaxy(json) {
  token = json.token;
  updateOverlayToken('phalanxSystemDialog', json.token);
  updateOverlayToken('phalanxDialog', json.token);
  toGalaxyLink = json.system.toGalaxyLink;
  $('#amountColonized').html(json.system.slotsColonized);
  $('#probeValue').html(json.system.availableProbes);
  $('#recyclerValue').html(json.system.availableRecyclers);
  $('#missileValue').html(json.system.availableMissiles);
  $('#slotUsed').html(json.system.usedFleetSlots);
  $('#slotValue').html(json.system.maximumFleetSlots);
  $("input#galaxy_input").val(json.system.galaxy);
  $("input#system_input").val(json.system.system);
  canSwitchGalaxy = json.system.canSwitchGalaxy;
  // TODO: re-enable
  //getAjaxResourcebox();
  $.each(json.filterSettings, function (key, value) {
    if (value) {
      $(`#filterCell #${key}`).addClass('filter_active');
    }
  });

  if (!canSwitchGalaxy) {
    fadeBox(notEnoughDeuteriumMessage, true);
  }

  if (preserveSystemOnPlanetChange) {
    $(".planetlink, .moonlink").querystring({
      galaxy: json.system.galaxy,
      system: json.system.system
    });
  }

  $('#expeditionDebris').remove();
  $('#galaxyRow17planet').remove();
  $('#galaxyRow17debris').remove();
  buildListCountdowns.map(countdownObject => {
    timerHandler.removeCallback(countdownObject.getTimer);
  });
  buildListCountdowns = [];

  for (const galaxyContentObject of json.system.galaxyContent) {
    clearPosition(galaxyContentObject.position);

    if (galaxyContentObject.position === 16) {
      $("#expeditionDebrisSlotDebrisContainer").append(`
                <div id="expeditionDebris" class="name float_left tooltipRel tooltipClose tooltipRight js_hideTipOnMobile js_bday_debris tpd-hideOnClickOutside" rel="debris16">
                    <div style="position: relative;width: 30px;height: 30px;display: inline-block;">
                        <img class="float_left" src="//gf1.geo.gfsrv.net/cdnc5/fa3e396b8af2ae31e28ef3b44eca91.gif" width="30" height="30"/>
                        ${addFleetContainer(galaxyContentObject.position, galaxyContentObject.planets.planetType)}
                    </div>
                </div>
            `);
      $("#expeditionDebris").append(getDebrisTooltip(galaxyContentObject.planets, galaxyContentObject, json.system));
      getFleetIcon(galaxyContentObject.planets.fleet, galaxyContentObject.position, galaxyContentObject.planets.planetType);
      continue;
    }

    if (galaxyContentObject.position === 17) {
      renderEventSpaceObjects(galaxyContentObject, json.system);
      continue;
    }

    $("#galaxyRow" + galaxyContentObject.position).addClass(galaxyContentObject.positionFilters);

    if (galaxyContentObject.planets.length > 0) {
      let shouldLoadPlayerToo = false;

      for (const planet of galaxyContentObject.planets) {
        switch (planet.planetType) {
          case 1:
            renderPlanet(galaxyContentObject, planet, json.system);
            shouldLoadPlayerToo = true;
            break;

          case 2:
            renderDebris(galaxyContentObject, planet, json.system);
            break;

          case 3:
            renderMoon(galaxyContentObject, planet, json.system);
            shouldLoadPlayerToo = true;
            break;
        }
      }

      if (shouldLoadPlayerToo) {
        renderPlayer(galaxyContentObject, json.system);
        colorNumberInFrontOfFriendsPlanet(galaxyContentObject);
        renderPhalanx(galaxyContentObject);
        renderAlliance(galaxyContentObject, json.system);
        renderActions(galaxyContentObject, json.system);
      } else {
        renderEmptySlot(galaxyContentObject, json.system, json.reservedPositions);
      }
    } else {
      renderEmptySlot(galaxyContentObject, json.system, json.reservedPositions);
    }
  }

  $("#galaxyLoading").hide();
  inProgress = false;

  if (typeof IPI !== 'undefined') {
    IPI.refreshHighlights();
  }
}

function renderPlanet(galaxyContentObject, planet, systemData) {
  $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName").html(`<span class="${galaxyContentObject.player.isBuddy ? "status_abbr_buddy" : ''}">${planet.planetName}</span>`);
  $("#galaxyRow" + galaxyContentObject.position + " .cellPlanet").html(`<a href="javascript: void(0);" onclick="${getEspionageMission(galaxyContentObject, planet, systemData)}"><div class="microplanet"></div></a>`);
  $("#galaxyRow" + galaxyContentObject.position + " .cellPlanet .microplanet").addClass(planet.imageInformation).append(getActivityStar(planet.activity)).append(addFleetContainer(galaxyContentObject.position, planet.planetType)).append(getFleetIcon(planet.fleet, galaxyContentObject.position, planet.planetType)).attr('data-planet-id', planet.planetId).addClass('planetTooltip tooltipRel tooltipPersistent tooltipClose tooltipRight js_hideTipOnMobile').attr('rel', 'planet' + galaxyContentObject.position).append(getPlanetTooltip(planet, galaxyContentObject, systemData));
}

function renderDebris(galaxyContentObject, planet, systemData) {
  $("#galaxyRow" + galaxyContentObject.position + " .cellDebris").html(`<a href="javascript: void(0);"><div class="microdebris ${planet.imageInformation}"></div></a>`);
  $("#galaxyRow" + galaxyContentObject.position + " .cellDebris .microdebris").append(addFleetContainer(galaxyContentObject.position, planet.planetType)).append(getFleetIcon(planet.fleet, galaxyContentObject.position, planet.planetType)).attr('rel', 'debris' + galaxyContentObject.position).addClass("tooltipRel tooltipClose tooltipRight js_hideTipOnMobile").append(getDebrisTooltip(planet, galaxyContentObject, systemData));
}

function renderMoon(galaxyContentObject, planet, systemData) {
  $("#galaxyRow" + galaxyContentObject.position + " .cellMoon").html(`<a href="javascript: void(0);" onclick="${getEspionageMission(galaxyContentObject, planet, systemData)}"><div class="micromoon ${planet.imageInformation}"></div></a>`);
  $("#galaxyRow" + galaxyContentObject.position + " .cellMoon .micromoon").append(getActivityStar(planet.activity)).append(addFleetContainer(galaxyContentObject.position, planet.planetType)).append(getFleetIcon(planet.fleet, galaxyContentObject.position, planet.planetType)).attr('data-moon-id', planet.planetId).attr('rel', 'moon' + galaxyContentObject.position).addClass("tooltipRel tooltipClose tooltipRight js_hideTipOnMobile").append(getMoonTooltip(planet, galaxyContentObject, systemData));
}

function renderPlayer(galaxyContentObject, systemData) {
  let {
    player
  } = galaxyContentObject;

  if (player && player.playerId !== 99999) {
    $("#galaxyRow" + galaxyContentObject.position + " .cellPlayerName").html(getPlayerName(galaxyContentObject, systemData));
  }
}

function colorNumberInFrontOfFriendsPlanet(galaxyContentObject) {
  let {
    player
  } = galaxyContentObject;

  if (player.isBuddy) {
    $("#galaxyRow" + galaxyContentObject.position + " .cellPosition").addClass('status_abbr_buddy');
  }
}

function renderEmptySlot(galaxyContentObject, systemData, reservedPlanets) {
  if (galaxyContentObject.availableMissions) {
    let planetNameCell = $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName");
    planetNameCell.html('');
    let reservedPlanet = reservedPlanets[galaxyContentObject.position];

    if (reservedPlanet && reservedPlanet.isReserved && parseInt(reservedPlanet.user_id) === systemData.playerId) {
      planetNameCell.append(`
                <span class="planetMoveGalaxyCooldown" id="cooldown-${galaxyContentObject.position}">
                    ${loca.LOCA_ALL_AJAXLOAD}
                </span>
            `);
      buildListCountdowns.push(new SimpleCountdownTimer(`#cooldown-${galaxyContentObject.position}`, reservedPlanet.cooldown, toGalaxyLink));
    }

    renderEmptySlotActions(galaxyContentObject, systemData);
  }
}

function renderPhalanx(galaxyContentObject) {
  let {
    player
  } = galaxyContentObject;

  if (player) {
    if (galaxyContentObject.actions.canPhalanx) {
      if (player.phalanx.inactive) {
        $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName").append(`<div class="tooltip js_hideTipOnMobile phalanxInctive" title="${loca.LOCA_PHALANX_ERROR_NOT_ENOUTH_DEUT}"></div>`);
      } else {
        $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName").append('<a class="overlay phalanxlink"></a>');
        $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName .phalanxlink").attr('href', player.phalanx.link).append(`<div class="tooltip js_hideTipOnMobile phalanxActive"></div>`).attr("data-overlay-title", player.phalanx.title).attr("data-overlay-class", "phalanx").attr("data-overlay-token", token).attr("data-overlay-token-id", "phalanxDialog");
        $("#galaxyRow" + galaxyContentObject.position + " .cellPlanetName .phalanxActive").attr('title', loca.LOCA_GALAXY_USE_PHALANX);
      }
    }
  }
}

function renderAlliance(galaxyContentObject, systemData) {
  let {
    player
  } = galaxyContentObject;

  if (player.allianceId) {
    $("#galaxyRow" + galaxyContentObject.position + " .cellAlliance").html(`
                <span
                class="${player.isAllianceMember ? "status_abbr_ally_own" : ""} tooltipRel tooltipClose tooltipRight js_hideTipOnMobile"
                rel="alliance${player.allianceId}">
                    ${player.allianceTag} ${getAllianceTooltip(galaxyContentObject, systemData)}
                </span>
            `);
  }
}

function renderActions(galaxyContentObject, systemData) {
  if (systemData.playerId !== galaxyContentObject.player.playerId) {
    $("#galaxyRow" + galaxyContentObject.position + " .cellAction").html(`${getActions(galaxyContentObject, systemData)}`);
  } else {
    let result = `
        ${getDiscoveryLinkIcon(galaxyContentObject)}
        ${`<div class="emptyAction"></div>`}
        ${`<div class="emptyAction"></div>`}
        ${`<div class="emptyAction"></div>`}
        ${`<div class="emptyAction"></div>`}
       `;
    $("#galaxyRow" + galaxyContentObject.position + " .cellAction").html(getDiscoveryLinkIcon(galaxyContentObject)).html(`${result}`);
  }
}

function renderEmptySlotActions(galaxyContentObject, systemData) {
  $("#galaxyRow" + galaxyContentObject.position + " .cellAction").html(`${getEmptySlotActions(galaxyContentObject, systemData)}`);
}

function getPlayerName(galaxyContentObject, systemData) {
  let {
    player
  } = galaxyContentObject;
  let playerName = "";

  if (player.rank && player.rank.hasRank) {
    playerName = `<span class="honorRank ${player.rank.rankClass} tooltip js_hideTipOnMobile" title="${player.rank.rankTitle}"></span>`;
  }

  if (player.playerId !== systemData.playerId) {
    playerName += `<span class="playerName tooltipRel tooltipClose tooltipRight js_hideTipOnMobile ${getPlayerColorClass(player)}"
           rel="player${player.playerId}">${player.playerName}${getPlayerTooltip(galaxyContentObject)}</span>`;
  } else {
    playerName += `<span class="${getPlayerColorClass(player)} ownPlayerRow">${player.playerName}</span>`;
  }

  playerName += getPlayerAbbreviations(player, galaxyContentObject);
  return playerName;
}

function getPlayerColorClass(player) {
  switch (true) {
    case player.isAdmin:
      return "status_abbr_admin";

    case player.isBanned:
      return "status_abbr_banned";

    case player.isOnVacation:
      return "status_abbr_vacation";

    case player.isLongInactive:
      return "status_abbr_longinactive";

    case player.isInactive:
      return "status_abbr_inactive";

    case player.isOutlaw:
      return "status_abbr_outlaw";

    case player.isNewbie:
      return "status_abbr_noob";

    case player.isStrong:
      return "status_abbr_strong";

    case player.isHonorableTarget:
      return "status_abbr_honorableTarget";
  }

  return "status_abbr_active";
}

function getPlayerAbbreviations(player) {
  let returnStatus = [];

  if (player.isAdmin) {
    returnStatus.push(`<span class="status_abbr_admin tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_ADMIN}">${loca.LOCA_GALAXY_PLAYER_STATUS_A}</span>`);
  } else {
    if (player.isBanned) {
      returnStatus.push(`<span class="status_abbr_banned tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_BANNED}">${loca.LOCA_GALAXY_PLAYER_STATUS_G}</span>`);
    }

    if (player.isOnVacation) {
      returnStatus.push(`<span class="status_abbr_vacation tooltip js_hideTipOnMobile" title="${loca.LOCA_STATION_JUMP_VACATION}">${loca.LOCA_GALAXY_PLAYER_STATUS_U}</span>`);
    }

    if (player.isLongInactive) {
      returnStatus.push(`<span class="status_abbr_longinactive tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_TWENTYEIGHT_DAYS_INACTIVE}">${loca.LOCA_GALAXY_PLAYER_STATUS_I_LONG}</span>`);
    } else if (player.isInactive) {
      returnStatus.push(`<span class="status_abbr_inactive tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_SEVEN_DAYS_INACTIVE}">${loca.LOCA_GALAXY_PLAYER_STATUS_I}</span>`);
    }

    if (player.isOutlaw) {
      returnStatus.push(`<span class="status_abbr_outlaw tooltipHTML" title="${loca.LOCA_GALAXY_LEGEND_OUTLAW}|${loca.LOCA_OUTLAW_EXPLANATION}">${loca.LOCA_GALAXY_PLAYER_STATUS_OUTLAW}</span>`);
    }

    if (player.isNewbie) {
      returnStatus.push(`<span class="status_abbr_noob tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_NOOB}">${loca.LOCA_GALAXY_PLAYER_STATUS_N}</span>`);
    }

    if (player.isStrong) {
      returnStatus.push(`<span class="status_abbr_strong tooltip js_hideTipOnMobile" title="${loca.LOCA_GALAXY_LEGEND_STRONG_PLAYER}">${loca.LOCA_GALAXY_PLAYER_STATUS_S}</span>`);
    }

    if (player.isHonorableTarget) {
      returnStatus.push(`<span class="status_abbr_honorableTarget tooltipHTML" title="${loca.LOCA_GALAXY_LEGEND_HONORABLE_TARGET}|${loca.LOCA_GALAXY_LEGEND_HONORABLE_TARGET_EXPLANATION}">${loca.LOCA_GALAXY_PLAYER_STATUS_EP}</span>`);
    }
  }

  return returnStatus.length ? `<pre> (${returnStatus.join()})</pre>` : "";
}

function getPlayerSelectedLanguage(player) {
  if (!player.selectedLanguageIcon) {
    return "";
  }

  return ` <selected-language-icon style="background-image: url('${player.selectedLanguageIcon}');" ></selected-language-icon> `;
}

function getActivityStar(data) {
  if (data.showActivity === false) {
    return "";
  }

  if (data.showMinutes && data.showActivity === 60) {
    return `<div class="activity showMinutes tooltip js_hideTipOnMobile hideTooltipOnMouseenter"
                title="${loca.LOCA_ALL_ACTIVITY}">
                ${data.idleTime}
            </div>`;
  }

  return `<div class="activity minute${data.showActivity} tooltip js_hideTipOnMobile hideTooltipOnMouseenter"
            title="${loca.LOCA_ALL_ACTIVITY}">
        </div>`;
}

function addFleetContainer(planetPosition, planetType) {
  return `<div id="ownFleetStatus_${planetPosition}_${planetType}"
            class="fleetAction js_hideTipOnMobile hideTooltipOnMouseenter"
            title="">
        </div>`;
}

function getFleetIcon(fleetArray, planetPosition, planetType) {
  if (!fleetArray || !fleetArray.length) {
    return "";
  }

  $(`#ownFleetStatus_${planetPosition}_${planetType}`).removeClass('fleetNeutral').addClass('tooltip').addClass(fleetArray[0]['class']).attr('title', fleetArray[0]['text']);
}

function getPlanetTooltip(planet, galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position
  } = galaxyContentObject;
  return `
        <div id="planet${position}" style="display: none;" class="htmlTooltip galaxyTooltip">
            <h1>${loca.LOCA_ALL_PLANET}: <span class="textNormal">${planet.planetName}</span></h1>
            <div class="splitLine"></div>
            <ul class="ListImage">
                <li><span>[${galaxy}:${system}:${position}]</span></li>
                <li><div class="planetTooltip microplanet ${planet['imageInformation']}"></div></li>
            </ul>
            <ul class="ListLinks">
                ${getPlanetOrMoonTooltipLinks(planet, galaxyContentObject, systemData)}
            </ul>
        </div>
        `;
}

function getMoonTooltip(planet, galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position
  } = galaxyContentObject;
  return `
        <div id="moon${position}" style="display: none;" class="htmlTooltip galaxyTooltip">
            <h1><span class="textNormal">${planet.planetName}</span></h1>
            <div class="splitLine"></div>
            <ul class="ListImage">
                <li><span id="pos-moon">[${galaxy}:${system}:${position}]</span></li>
                <li><div class="moonTooltip micromoon ${planet['imageInformation']}"></div></li>
                <li><span id="moonsize" title="${loca.LOCA_GALAXY_MOON_DIAMETER_KM}">${planet.size} ${loca.LOCA_OVERVIEW_JS_KM}</span></li>
            </ul>
            <ul class="ListLinks">
                ${getPlanetOrMoonTooltipLinks(planet, galaxyContentObject, systemData)}
            </ul>
        </div>
        `;
}

function getPlanetOrMoonTooltipLinks(planet, galaxyContentObject, systemData) {
  let linkHTML = getActivityElement(planet.activity);
  let {
    currentPlanetId
  } = systemData;

  if (planet.planetId === currentPlanetId) {
    linkHTML += loca.LOCA_FLEET_NO_ACTION_AVAILABLE;
    return linkHTML;
  }

  let {
    galaxy,
    system,
    position,
    player
  } = galaxyContentObject;

  if (player.isOnVacation) {
    linkHTML += loca.LOCA_FLEET_PLAYER_UMODE;
    return linkHTML;
  }

  if (!systemData.canFly) {
    linkHTML += `<li>${loca.LOCA_FLEET_NO_FREE_SLOTS}</li>`;

    if (!systemData.hasAdmiral) {
      linkHTML += `<li><a href="${premiumLink}">${loca.LOCA_HEADER_GETADMIRAL}</a></li>`;
    }

    return linkHTML;
  }

  if (planet.availableMissions) {
    planet.availableMissions.map(mission => {
      if (mission.missionType === constants.espionage) {
        if (mission.canSpy) {
          let espionageMissionFunction = getEspionageMission(galaxyContentObject, planet, systemData);

          if (espionageMissionFunction) {
            linkHTML += `<li><a href="#"
                                onClick="${espionageMissionFunction}">
                                ${mission.name}
                            </a></li>`;
          }
        }

        if (mission.reportId && mission.reportLink) {
          linkHTML += `<li><a href="${mission.reportLink}" class="overlay">${loca.LOCA_MESSAGES_ESPIONAGEREPORT}</a></li>`;
        }
      } else {
        linkHTML += `<li><a href="${mission.link}">${mission.name}</a></li>`;
      }
    });

    if (galaxyContentObject.actions.canMissileAttack && !player.isAdmin) {
      let holdMissionAvailable = planet.availableMissions.find(availMission => availMission.missionType === 5);

      if (systemData.showOutlawWarning && !systemData.isOutlaw && player.isStrong && !holdMissionAvailable) {
        linkHTML += `<li><a href="#"
                            onClick="outlawWarning(${constants.missleattack}, ${galaxy}, ${system}, ${position}, ${planet.planetType}, ${systemData.availableMissiles});return false;">
                            ${loca.LOCA_FLEET_MISSILEATTACK}
                        </a></li>`;
      } else {
        linkHTML += `<li><a class="overlay" href="${galaxyContentObject.actions.missileAttackLink}&planetType=${planet.planetType}" data-overlay-modal='true'>${loca.LOCA_FLEET_MISSILEATTACK}</a></li>`;
      }
    }

    return linkHTML;
  }

  return loca.LOCA_FLEET_NO_ACTION_AVAILABLE;
}

function getEspionageMission(galaxyContentObject, planet, systemData) {
  let {
    galaxy,
    system,
    position,
    player
  } = galaxyContentObject;
  let {
    settingsProbeCount
  } = systemData;
  let espionageMission = planet.availableMissions.find(availMission => availMission.missionType === constants.espionage);
  let holdMissionAvailable = planet.availableMissions.find(availMission => availMission.missionType === 5);

  if (espionageMission && espionageMission.canSpy && !player.isAdmin && galaxy && system && position && settingsProbeCount) {
    if (systemData.showOutlawWarning && !systemData.isOutlaw && player.isStrong && !holdMissionAvailable) {
      return `outlawWarning(${espionageMission.missionType}, ${galaxy}, ${system}, ${position}, ${planet.planetType}, ${settingsProbeCount});return false;`;
    } else {
      return `sendShips(${espionageMission.missionType}, ${galaxy}, ${system}, ${position}, ${planet.planetType}, ${settingsProbeCount});return false;`;
    }
  }

  return "";
}

function getDebrisTooltip(planet, galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position
  } = galaxyContentObject;
  let {
    metal,
    crystal,
    deuterium
  } = planet.resources;
  let recyclersToSend = Math.min(planet.requiredShips, position === 16 ? systemData.availablePathfinders : systemData.availableRecyclers);
  let linkHTML = "";

  if (!systemData.canFly) {
    linkHTML += `<li>${loca.LOCA_FLEET_NO_FREE_SLOTS}</li>`;

    if (!systemData.hasAdmiral) {
      linkHTML += `<li><a href="${premiumLink}">${loca.LOCA_HEADER_GETADMIRAL}</a></li>`;
    }
  } else if (recyclersToSend && (position === 16 ? systemData.availablePathfinders : systemData.availableRecyclers) && planet.recyclePossible) {
    linkHTML = `<li><a href="#"
            onClick="sendShips(${8}, ${galaxyContentObject.galaxy}, ${galaxyContentObject.system}, ${galaxyContentObject.position}, ${planet.planetType}, ${recyclersToSend});return false;">
                ${loca.LOCA_GALAXY_DEBRIS_REDUCE}
            </a></li>`;
  } else {
    linkHTML = `<li><span class="inactiveLink">${loca.LOCA_GALAXY_DEBRIS_REDUCE}</span></li>`;
  }

  return `
        <div id="debris${position}" style="display: none;" class="htmlTooltip galaxyTooltip">
            <h1>${loca.LOCA_FLEET_DEBRIS}</h1>
            <div class="splitLine"></div>
            <ul class="ListImage">
                <li><span id="pos-debris">[${galaxy}:${system}:${position}]</span></li>
                <li><div class="debrisTooltip microdebris ${planet['imageInformation']}"></div></li>
            </ul>
            <ul class="ListLinks">
                <li class="debris-content">${loca.LOCA_ALL_METAL}: ${number_format(metal.amount, 0)}</li>
                <li class="debris-content">${loca.LOCA_ALL_CRYSTAL}: ${number_format(crystal.amount, 0)}</li>
                <li class="debris-content">${loca.LOCA_ALL_DEUTERIUM}: ${number_format(deuterium.amount, 0)}</li>
                <li class="debris-recyclers">${position === 16 ? loca.LOCA_GALAXY_PATHFINDER_NEEDED : loca.LOCA_GALAXY_RECYCLER_NEEDED}: ${number_format(planet.requiredShips, 0)}</li>
                ${linkHTML}
            </ul>
        </div>
        `;
}

function getPlayerTooltip(galaxyContentObject) {
  let {
    player
  } = galaxyContentObject;
  let {
    actions
  } = player;
  let rankLink = "";

  if (actions.highscore.available) {
    let statsLink = `
            <a href="${actions.highscore.link}">${player.highscorePositionPlayer}</a>
        `;
    rankLink = `<li class="rank">${actions.highscore.title}: ${statsLink}</li>`;
  }

  let messageLink = "";

  if (actions.message.available) {
    if (!actions.message.disabledChatBar) {
      messageLink = `<li><a href="javascript:void(0)" class="sendMail js_openChat" data-playerId="${player.playerId}">${actions.message.title}</a></li>`;
    } else {
      messageLink = `<li><a href="${actions.message.link}" data-playerId="${player.playerId}">${actions.message.title}</a></li>`;
    }
  }

  let buddyLink = "";

  if (actions.buddies.available) {
    if (player.isAdmin) {
      buddyLink = `
                <li>
                    <a style="margin-top: 4px;"
                    href="${actions.buddies.link}"
                    target="_blank" title="${actions.buddies.title}"
                    class="js_hideTipOnMobile no_decoration">
                        <span class="support_icon icon icon_mail" style="margin-top: 5px;"></span> &nbsp;
                        <div style="position:absolute; top: 32px;left:30px">${actions.buddies.title}</div>
                    </a>
                </li>
            `;
    } else {
      buddyLink = `
                <li><a href="${actions.buddies.link}" class="overlay" data-overlay-title="${actions.buddies.title}">${actions.buddies.title}</a></li>
            `;
    }
  }

  let ignoreLink = "";

  if (actions.ignore.available) {
    ignoreLink = `<li><a href="${actions.ignore.link}">${actions.ignore.title}</a></li>`;
  }

  return `
        <div id="player${player.playerId}" style="display: none;"  class="htmlTooltip galaxyTooltip">
            <h1>${getPlayerSelectedLanguage(player)}<span>${player.playerName}</span></h1>
            <div class="splitLine"></div>
            <ul class="ListLinks">
                ${rankLink}
                ${messageLink}
                ${buddyLink}
                ${ignoreLink}
            </ul>
        </div>
        `;
}

function renderEventSpaceObjects(galaxyContentObject, systemData) {
  galaxyContentObject.planets.map(planet => {
    switch (planet.planetType) {
      case 1:
        renderEventPlanet(planet, galaxyContentObject, systemData);
        break;

      case 2:
        renderEventDebris(planet, galaxyContentObject, systemData);
        break;
    }
  });
}

function renderEventPlanet(planet, galaxyContentObject, systemData) {
  if (!planet) {
    return;
  }

  let lastPosition = $("div.expeditionDebrisSlotBoxRow");
  let positionNumber = parseInt(lastPosition.find('.cellPosition').text()) + 1;
  lastPosition.after(`
        <div class="eventSlotRow">
            <div class="eventSlotBoxCell cellPosition">${positionNumber}</div>
            <div class="bdaySlotBox"  id="galaxyRow17planet">
                <div>
                    <h3 class="title float_left">${loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE}:</h3>
                </div>
                <div class="birthdayNameWrapper">
                    <div id="birthdayName" class="name float_left tooltipRel tooltipClose tooltipRight js_hideTipOnMobile js_bday_planet"
                       rel="planet17"
                    >
                        <div style="position: relative;width: 30px;height: 30px;display: inline-block;">
                            <img class="float_left"
                                src="${planet.imageInformation}"
                                width="30"
                                height="30"
                            />
                            ${addFleetContainer(galaxyContentObject.position, planet.planetType)}
                        </div>${planet.planetName}
                        ${getEventPlanetTooltip(planet, galaxyContentObject, systemData)}
                    </div>
                </div>
            </div>
        </div>
    `);
  getFleetIcon(planet.fleet, galaxyContentObject.position, planet.planetType);
}

function renderEventDebris(planet, galaxyContentObject, systemData) {
  if (!planet) {
    return;
  }

  let darkMatterObject = planet.resources.darkMatter;

  if (!darkMatterObject || !darkMatterObject.amount) {
    return;
  }

  let lastPosition = $("#galaxyRow17planet");

  if (!lastPosition.length) {
    lastPosition = $("div.expeditionDebrisSlotBoxRow");
  }

  let positionNumber = parseInt(lastPosition.find('.cellPosition').text()) + 1;
  lastPosition.after(`
        <div class="eventSlotRow">
            <div class="eventSlotBoxCell cellPosition">${positionNumber}</div>
            <div class="bdaySlotBox"  id="galaxyRow17debris">
                <div>
                    <h3 class="title float_left">${loca.LOCA_EVENTH_ENEMY_INFINITELY_SPACE}:</h3>
                </div>
                <div class="birthdayNameWrapper">
                    <div id="birthdayName" class="name float_left tooltipRel tooltipClose tooltipRight js_hideTipOnMobile js_bday_planet"
                       rel="debris17"
                    >
                        <div style="position: relative;width: 30px;height: 30px;display: inline-block;">
                            <img class="float_left" src="//gf3.geo.gfsrv.net/cdn88/e1b6654d1b29bc65aea0b8fc79be80.png" width="30" height="30"/>
                            ${addFleetContainer(galaxyContentObject.position, planet.planetType)}
                        </div>${planet.planetName}
                        ${getEventDebrisTooltip(planet, galaxyContentObject, systemData)}
                    </div>
                </div>
            </div>
        </div>
    `);
  getFleetIcon(planet.fleet, galaxyContentObject.position, planet.planetType);
}

function getEventPlanetTooltip(planet, galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position
  } = galaxyContentObject;
  let linkHTML = '';

  if (!systemData.canFly) {
    linkHTML += `<li>${loca.LOCA_FLEET_NO_FREE_SLOTS}</li>`;

    if (!systemData.hasAdmiral) {
      linkHTML += `<li><a href="${premiumLink}">${loca.LOCA_HEADER_GETADMIRAL}</a></li>`;
    }
  } else {
    planet.availableMissions.map(mission => {
      if (mission.missionType === constants.espionage) {
        if (mission.canSpy) {
          let espionageMissionFunction = getEspionageMission(galaxyContentObject, planet, systemData);

          if (espionageMissionFunction) {
            linkHTML += `<li><a href="#"
                                onClick="${espionageMissionFunction}">
                                ${mission.name}
                            </a></li>`;
          }
        }

        if (mission.reportId && mission.reportLink) {
          linkHTML += `<li><a href="${mission.reportLink}" class="overlay">${loca.LOCA_MESSAGES_ESPIONAGEREPORT}</a></li>`;
        }
      } else {
        linkHTML += `<li><a href="${mission.link}">${mission.name}</a></li>`;
      }
    });
  }

  return `
        <div id="planet${position}" style="display: none;" class="htmlTooltip galaxyTooltip">
            <h1>${loca.LOCA_ALL_PLANET}: <span class="textNormal">${planet.planetName}</span></h1>
            <div class="splitLine"></div>
            <ul class="ListImage">
                <li><span>[${galaxy}:${system}:${position}]</span></li>
                <li><img src="${planet['imageInformation']}" alt="" height="30" width="30"></li>
            </ul>
            <ul class="ListLinks">
                ${linkHTML}
            </ul>
        </div>
        `;
}

function getEventDebrisTooltip(planet, galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position
  } = galaxyContentObject;
  let darkMatterObject = planet.resources.darkMatter;
  let darkmatter = number_format(darkMatterObject.amount);
  let recyclersToSend = planet.requiredShips;
  let linkHTML = "";

  if (!systemData.canFly) {
    linkHTML += `<li>${loca.LOCA_FLEET_NO_FREE_SLOTS}</li>`;

    if (!systemData.hasAdmiral) {
      linkHTML += `<li><a href="${premiumLink}">${loca.LOCA_HEADER_GETADMIRAL}</a></li>`;
    }
  } else if (systemData.availableRecyclers > 0) {
    let recyclerJS = `sendShips(${8}, ${galaxy}, ${system}, ${position}, ${planet.planetType}, ${recyclersToSend})`;
    linkHTML = `<li><a href="#" onClick="${recyclerJS};return false">${loca.LOCA_GALAXY_DEBRIS_REDUCE}</a></li>`;
  } else {
    linkHTML = `<li><span class="inactiveLink">${loca.LOCA_GALAXY_DEBRIS_REDUCE}</span></li>`;
  }

  let headline = loca.LOCA_FLEET_DEBRIS;
  return `
        <div id="debris${position}" style="display: none;" class="htmlTooltip galaxyTooltip">
            <h1>${headline}</h1>
            <div class="splitLine"></div>
            <ul class="ListImage">
                <li><span id="pos-debris">[${galaxy}:${system}:${position}]</span></li>
                <li><img class="float_left" src="//gf3.geo.gfsrv.net/cdn88/e1b6654d1b29bc65aea0b8fc79be80.png" width="30" height="30" alt="${headline}"/></li>
            </ul>
            <ul class="ListLinks">
                <li class="debris-content">${loca.LOCA_ALL_DARKMATTER}: ${darkmatter}</li>
                ${linkHTML}
            </ul>
        </div>
    `;
}

function getActions(galaxyContentObject, systemData) {
  let {
    galaxy,
    system,
    position,
    player
  } = galaxyContentObject;
  let {
    actions
  } = player;
  let mainPlanet = galaxyContentObject.planets.find(planet => planet.planetType === 1);
  let holdMissionAvailable = mainPlanet.availableMissions.find(availMission => availMission.missionType === 5);
  let espionageReportAvailable = mainPlanet.availableMissions.find(availMission => availMission.missionType === 6 && availMission.reportId);
  let espionageClass = '';

  if (espionageReportAvailable) {
    espionageClass = 'hueRotate';
  }

  let espionageLink = "";

  if (player.isAdmin) {
    espionageLink = `<div class="emptyAction"></div>`;
  } else {
    if (galaxyContentObject.actions.canEspionage === false) {
      espionageLink = `<a class="tooltip js_hideTipOnMobile espionage"
                   title="${loca.LOCA_FLEET_NO_ESPIONAGE}"
                   href="javascript: void(0);"
                >
                    <span class="icon icon_eye grayscale"></span>
                </a>`;
    } else {
      let ipiHint = 'ipiGalaxyActionSpy';

      if (galaxyContentObject.player.isOnVacation) {
        ipiHint = 'ipiGalaxyActionSpyVacation';
      }

      espionageLink = `
                <a class="tooltip js_hideTipOnMobile espionage ipiHintable"
                       title="${loca.LOCA_FLEET_ESPIONAGE}"
                       href="javascript: void(0);"
                       onclick="${getEspionageMission(galaxyContentObject, mainPlanet, systemData)}"
                       data-ipi-hint="${ipiHint}"
                    >
                    <span class="icon icon_eye ${espionageClass}"></span>
                </a>`;
    }
  }

  let messageLink = "";

  if (actions.message.available) {
    if (!actions.message.disabledChatBar) {
      messageLink = `<a href="javascript:void(0)" class="sendMail js_openChat tooltip" data-playerId="${player.playerId}" title="${actions.message.title}"><span class="icon icon_chat"></span></a>`;
    } else {
      messageLink = `<a href="${actions.message.link}" class="tooltip" data-playerId="${player.playerId}" title="${actions.message.title}"><span class="icon icon_chat"></span></a>`;
    }
  } else {
    if (player.isAdmin) {
      messageLink = `
                <a href="${actions.buddies.link}"
                    target="_blank" title="${actions.buddies.title}"
                    class="tooltip js_hideTipOnMobile icon">
                        <span class="support_icon icon icon_mail"></span>
                </a>
            `;
    } else {
      messageLink = `<div class="emptyAction"></div>`;
    }
  }

  let buddyLink = "";

  if (actions.buddies.available) {
    if (player.isAdmin === false) {
      buddyLink = `
            <a class="tooltip overlay buddyrequest ipiHintable"
               title="${actions.buddies.title}"
               href="${actions.buddies.link}"
               data-overlay-title="${actions.buddies.title}"
               data-ipi-hint="ipiGalaxySendBuddyRequest"
            >
                <span class="icon icon_user"></span>
            </a>`;
    } else {
      buddyLink = `<div class="emptyAction"></div>`;
    }
  } else {
    buddyLink = `<div class="emptyAction"></div>`;
  }

  let missileLink = "";

  if (galaxyContentObject.actions.canMissileAttack && !player.isAdmin && galaxy && system && position) {
    if (systemData.showOutlawWarning && !systemData.isOutlaw && player.isStrong && !holdMissionAvailable) {
      missileLink = `
                <a class="tooltip js_hideTipOnMobile missleattack"
                       title="${loca.LOCA_FLEET_MISSILEATTACK}"
                       href="javascript: void(0);"
                       onclick="outlawWarning(
                       10,
                       ${galaxy},
                       ${system},
                       ${position},
                       1,
                       ${systemData.availableMissiles}
                               ); return false;"
                    >
                    <span class="icon icon_missile"></span>
                </a>`;
    } else {
      missileLink = `<a class="tooltip js_hideTipOnMobile overlay missleattack"
               title="${loca.LOCA_FLEET_MISSILEATTACK}"
               href="${galaxyContentObject.actions.missileAttackLink}&planetType=${mainPlanet.planetType}"
               data-overlay-modal='true'
            >
                <span class="icon icon_missile"></span>
            </a>`;
    }
  } else if (player.isAdmin) {
    missileLink = `<div class="emptyAction"></div>`;
  } else {
    missileLink = `<a class="tooltip js_hideTipOnMobile missleattack"
               title="${loca.LOCA_FLEET_MISSILEATTACK}"
               href="javascript: void(0);"
            >
                <span class="icon icon_missile grayscale"></span>
            </a>`;
  }

  const discoverLink = getDiscoveryLinkIcon(galaxyContentObject);
  return `
        ${discoverLink}
        ${espionageLink}
        ${messageLink}
        ${buddyLink}
        ${missileLink}
        `;
}

function getEmptySlotActions(galaxyContentObject, systemData) {
  let emptyLink = `<div class="emptyAction"></div>`;
  let coloniseMission = galaxyContentObject.availableMissions.find(availMission => availMission.missionType === 7);
  let colonisationLink = "";

  if (!systemData.canColonize || !coloniseMission || coloniseMission.link === "#") {
    colonisationLink = `<div class="tooltip planetMoveIcons colonize-inactive icon tpd-hideOnClickOutside"
                      title="${coloniseMission ? coloniseMission.description : loca.LOCA_GALAXY_ERROR_COLONIZATION}"></div>`;
  } else {
    colonisationLink = `<a href="${coloniseMission.link}" class="tooltip planetMoveIcons colonize-active icon tpd-hideOnClickOutside ipiHintable" data-ipi-hint="ipiGalaxyColonize">
                    <div class="tooltip planetMoveIcons colonize-active icon tpd-hideOnClickOutside"
                      title="${coloniseMission.description}"></div></a>`;
  }

  let planetMove = galaxyContentObject.availableMissions.find(availMission => availMission.missionType === 0);
  let planetMoveLink = "";

  if (planetMove === undefined) {
    planetMoveLink = `<div class="emptyAction"></div>`;
  } else if (planetMove.planetMovePossible === true) {
    planetMoveLink = `<a class="planetMoveIcons planetMoveDefault tooltip icon js_hideTipOnMobile"
               href="javascript: void(0);"
               onClick="movePlanet(
                       '${planetMove.moveLink}',
                       {'position':${galaxyContentObject.position},
                       'galaxy': ${galaxyContentObject.galaxy},
                       'system': ${galaxyContentObject.system}},
                       '${planetMove.galaxyLink}'
                       ); return false;"
               title="${planetMove.title}"
            ><div class="planetMoveIcons planetMoveDefault tooltip icon js_hideTipOnMobile"
                      title="${planetMove.title}"></div></a>`;
  } else {
    planetMoveLink = `<div class="planetMoveIcons planetMoveInactive tooltip icon"
                      title="${planetMove.title}"></div>`;
  }

  const discoverLink = getDiscoveryLinkIcon(galaxyContentObject);
  return `
        ${discoverLink}
        ${colonisationLink}
        ${planetMoveLink}
        ${emptyLink}
        ${emptyLink}
        `;
}

function getDiscoveryLinkIcon(galaxyContentObject) {
  let discoverLink = "";

  if (constants.lifeformEnabled === true) {
    const discoverMission = galaxyContentObject.availableMissions.find(mission => mission.missionType === constants.discover);

    if (typeof discoverMission !== 'undefined') {
      if (discoverMission.canSend === true) {
        const titleText = galaxyLoca.discoverySend + " " + discoverMission.discoveryCount;
        discoverLink = `<div class="planetDiscoverIcons planetDiscoverDefault icon"><a href="#"
                    class="tooltip js_hideTipOnMobile ipiHintable planetDiscover position${galaxyContentObject.position}"
                    data-ipi-hint="ipiDiscoverLifeform"
                    onClick="discoverPlanet(
                        '${discoverMission.link}',
                        {
                            'galaxy': ${galaxyContentObject.galaxy},
                            'system': ${galaxyContentObject.system},
                            'position':${galaxyContentObject.position},
                            '_token': token
                        }
                    ); return false;"
                    title="${titleText}">
                </a></div>`;
      } else {
        discoverLink = `<div class="planetDiscoverIcons planetDiscoverUnavailable tooltip ipiHintable icon js_hideTipOnMobile"
                    data-ipi-hint="ipiDiscoverLifeform"
                    title="${discoverMission.canSend}">
                </div>`;
      }
    }
  }

  return discoverLink;
}

function getAllianceTooltip(galaxyContentObject) {
  let {
    player
  } = galaxyContentObject;
  let {
    alliance
  } = player.actions;

  if (!alliance) {
    return "";
  }

  let allianceClass = "";

  if (alliance.allianceClassName && alliance.allianceClassCss) {
    allianceClass = `<li>${loca.LOCA_ALLIANCE_CLASS}: <span class="${alliance.allianceClassCss}">${alliance.allianceClassName}</span></li>`;
  }

  let infoPageLink;

  if (player.isAllianceMember) {
    infoPageLink = `<li><a href="${alliance.infoPageLink}">${alliance.infoPageTitle}</a></li>`;
  } else {
    infoPageLink = `<li><a href="allianceInfo.php?allianceId=${player.allianceId}" target="_ally">${alliance.infoPageTitle}</a></li>`;
  }

  let applicationLink = "";

  if (alliance.applicationLink && alliance.applicationTitle) {
    applicationLink = `<li><a href="${alliance.applicationLink}">${alliance.applicationTitle}</a></li>`;
  }

  return `
        <div id="alliance${player.allianceId}" style="display: none;"  class="htmlTooltip galaxyTooltip">
            <h1>
                ${getAllianceSelectedLanguage(player)}
                ${player.allianceName}
            </h1>
            <div class="splitLine"></div>
            <ul class="ListLinks">
                <li class="rank">${loca.LOCA_GALAXY_RANK}: <a href="${alliance.highscoreLink}">${alliance.highscoreTitle}</a></li>
                <li class="members">${loca.LOCA_NETWORK_USERS}: ${alliance.memberCount}</li>
                ${allianceClass}
                ${infoPageLink}
                ${applicationLink}
            </ul>
        </div>
        `;
}

function getAllianceSelectedLanguage(player) {
  if (!player.allianceSelectedLanguage) {
    return "";
  }

  return ` <selected-language-icon style="background-image: url('${player.allianceSelectedLanguage}');" ></selected-language-icon> `;
}

function getActivityElement(activityObject) {
  let {
    idleTime,
    showActivity
  } = activityObject;

  if (showActivity) {
    let idle;

    if (showActivity === 60) {
      idle = loca.LOCA_ALL_ACTIVITY + ": " + idleTime + loca.LOCA_ALL_TIME_MINUTE;
    } else {
      idle = loca.LOCA_ALL_ACTIVITY + ":<div class=\"alert_triangle\"><img src='//gf2.geo.gfsrv.net/cdn12/b4c8503dd1f37dc9924909d28f3b26.gif'/></div>";
    }

    return `<li>${idle}</li>`;
  }

  return "";
}

function clearPosition(position) {
  $("#galaxyRow" + position + " .cellPosition").removeClass('status_abbr_buddy');
  $("#galaxyRow" + position + " .cellPlanet").html("");
  $("#galaxyRow" + position + " .cellPlayerName").html("");
  $("#galaxyRow" + position + " .cellPlanetName").html("");
  $("#galaxyRow" + position + " .cellMoon").html("");
  $("#galaxyRow" + position + " .cellDebris").html("");
  $("#galaxyRow" + position + " .cellAlliance").html("");
  $("#galaxyRow" + position + " .cellAction").html("");
  let rowElement = $("#galaxyRow" + position);
  rowElement.removeClass('inactive_filter');
  rowElement.removeClass('filtered_filter_inactive');
  rowElement.removeClass('vacation_filter');
  rowElement.removeClass('filtered_filter_vacation');
  rowElement.removeClass('strong_filter');
  rowElement.removeClass('filtered_filter_strong');
  rowElement.removeClass('newbie_filter');
  rowElement.removeClass('filtered_filter_newbie');
  rowElement.removeClass('empty_filter');
  rowElement.removeClass('filtered_filter_empty');
}

function displayContentGalaxy(data) {
  // var selector = getTooltipSelector("#inhalt");
  //removeTooltip(selector);
  var json = $.parseJSON(data);
  $("#galaxyContent").html(json.galaxy);
  $('galaxyContent').find('script').each(function () {
    // http://perfectionkills.com/global-eval-what-are-the-options/
    $.globalEval($(this).text());
  });
  tabletInitGalaxyDetails(); //just for the event

  eventBDayInitGalaxy();
  $("#galaxyLoading").hide();

  if (preserveSystemOnPlanetChange) {
    $(".planetlink, .moonlink").querystring({
      galaxy: galaxy,
      system: system
    });
  }

  getAjaxResourcebox();
}

function submitForm() {
  galaxy = $("#galaxy_input").val();
  system = $("#system_input").val();

  if (0 === galaxy.length || !$.isNumeric(+galaxy)) {
    galaxy = 1;
  }

  if (0 === system.length || !$.isNumeric(+system)) {
    system = 1;
  }

  if (mobile) {
    loadContent(galaxy, system);
  } else {
    loadContentNew(galaxy, system);
  }
}

function loadContent(galaxy, system) {
  $("#galaxyLoading").show();

  if (0 === galaxy.length || !$.isNumeric(+galaxy)) {
    galaxy = 1;
  }

  if (0 === system.length || !$.isNumeric(+system)) {
    system = 1;
  }

  $("#galaxy_input").val(galaxy);
  $("#system_input").val(system);
  let phalanxSystemLink = $('#galaxyHeader .phalanxlink.btn_system_action');

  if (phalanxSystemLink.length) {
    phalanxSystemLink.attr('href', phalanxSystemLink.attr('href').replace(/(galaxy=)\d+/, "$1" + galaxy).replace(/(system=)\d+/, "$1" + system));
  }

  $.post(contentLink, {
    galaxy: galaxy,
    system: system,
    _token: token
  }, displayContentGalaxy);
}

function loadContentNew(galaxy, system) {
  if (!canSwitchGalaxy && notEnoughDeuteriumMessage) {
    fadeBox(notEnoughDeuteriumMessage, true);
    return;
  }

  $("#galaxyLoading").show();

  if (0 === galaxy.length || $.isNumeric(+galaxy) === false) {
    galaxy = 1;
  }

  if (0 === system.length || $.isNumeric(+system) === false) {
    system = 1;
  }

  $("input#galaxy_input").val(galaxy);
  $("input#system_input").val(system);
  let phalanxSystemLink = $('#galaxyHeader .phalanxlink.btn_system_action');

  if (phalanxSystemLink.length) {
    phalanxSystemLink.attr('href', phalanxSystemLink.attr('href').replace(/(galaxy=)\d+/, "$1" + galaxy).replace(/(system=)\d+/, "$1" + system));
  }

  if (inProgress === false) {
    inProgress = true;
    $.post(galaxyContentLink, {
        galaxy: galaxy,
        system: system,
        _token: token
    }, renderContentGalaxy);
  }
}

function errorBoxDeuterium() {
  fadeBox(galaxyLoca.deuteriumNeeded, true); // getAjaxResourcebox();
}

function doScan(position, planettype) {
  sendShips(constants.espionage, galaxy, system, position, planettype, spionageAmount);
}

function initPhalanx() {
  getAjaxResourcebox();
  $('.eventFleet:odd').addClass('odd');
  $('.partnerInfo:even').addClass('part-even');
  $(".toggleInfos").click(function () {
    id = $(this).attr("rel");

    if ($(this).attr("class") == "toggleInfos infosOpen") {
      $(this).removeClass("infosOpen");
      $(this).addClass("infosClosed");
      $(this).children().attr("src", '//gf2.geo.gfsrv.net/cdn10/de1e5f629d9e47d283488eee0c0ede.gif');
      $("." + id).attr("style", "display: none;");
    } else {
      $(this).addClass("infosOpen");
      $(this).removeClass("infosClosed");
      $(this).children().attr("src", '//gf3.geo.gfsrv.net/cdnb6/577565fadab7780b0997a76d0dca9b.gif');
      $("." + id).attr("style", "display: block;");
    }
  });
  var $titleBar = $(".overlayDiv.phalanx").siblings('.ui-dialog-titlebar');

  if ($titleBar.find('.refreshPhalanxLink').length) {
    $("#phalanxWrap .refreshPhalanxLink").remove();
  } else {
    $titleBar.find('.ui-dialog-title').append($("#phalanxWrap .refreshPhalanxLink"));
  }
}

function initSpySystem() {
  $('#galaxyHeader').off('click').on('click', '.spysystemlink', function (event) {
    event.preventDefault();
    event.stopPropagation();
    let $target = $(event.target);
    let targetUrl = $target.data('targetUrl');

    if (!targetUrl) {
      targetUrl = $target.parents().data('targetUrl');
    }

    if (!targetUrl) {
      return;
    }

    $.post(targetUrl, {
      galaxy: $("#galaxy_input").val(),
      system: $("#system_input").val(),
      _token: token
    }, 'json').done(function (jsoned) {
      let data = JSON.parse(jsoned);
      token = data.newAjaxToken;
      updateOverlayToken('phalanxDialog', data.newAjaxToken);
      updateOverlayToken('phalanxSystemDialog', data.newAjaxToken);

      for (let i = 0; i < data.planets.length; ++i) {
        $('#ownFleetStatus_' + data.planets[i].position + '_' + data.planets[i].type).removeClass("fleetNeutral").attr('title', galaxyLoca.fleetAttacking).addClass('fleetHostile').addClass('tooltip');
      }

      addToTable(data.text, data.count <= 0 ? 'error' : 'success');

      if (data.count > 0) {
        getAjaxEventbox();
      }
    });
  });
}

function initExpeditionFleetTemplates() {
  $('#expeditionFleetTemplateSelect').on('change', function (e) {
    let expeditionFleetTemplateId = getValue($('#expeditionFleetTemplateSelect').val());

    if (expeditionFleetTemplateId === 0) {
      $('#expeditionbutton').show();
      $('#sendExpeditionFleetTemplateFleet').hide().attr('disabled', true);
    } else {
      let expeditionFleetTemplate = expeditionFleetTemplates.find(template => template.id === expeditionFleetTemplateId);

      if (!expeditionFleetTemplate) {
        $('#expeditionbutton').show();
        $('#sendExpeditionFleetTemplateFleet').hide().attr('disabled', true);
      } else {
        $('#expeditionbutton').hide();
        $('#sendExpeditionFleetTemplateFleet').show();
        galaxyCheckTarget(expeditionFleetTemplateId, galaxy, system);
      }
    }
  });
}

let checkingTarget = false;

function galaxyCheckTarget(expeditionFleetTemplateId, selectedGalaxy, selectedSystem) {
  if (!selectedGalaxy) {
    return;
  }

  if (!selectedSystem) {
    return;
  }

  let expeditionFleetTemplate = expeditionFleetTemplates.find(template => template.id === expeditionFleetTemplateId);

  if (!expeditionFleetTemplate) {
    return;
  }

  if (checkingTarget) {
    return;
  }

  checkingTarget = true;
  let params = {
    'galaxy': selectedGalaxy,
    'system': selectedSystem,
    'position': expeditionPosition,
    'type': spaceObjectTypePlanet,
    'mission': missionExpedition,
    'speed': expeditionFleetTemplate.fleetSpeed,
    '_token': token
  };
  let ships = expeditionFleetTemplate.ships;
  Object.keys(ships).forEach(function (shipId) {
    params['am' + shipId] = ships[shipId];
  });
  $.ajax({
    url: checkTargetUrl,
    type: 'POST',
    dataType: "json",
    data: params,
    success: function (response) {
      if (selectedGalaxy === galaxy && selectedSystem === system && expeditionFleetTemplateId === getValue($('#expeditionFleetTemplateSelect').val())) {
        if (response.targetOk) {
          $('#sendExpeditionFleetTemplateFleet').removeAttr('disabled');
        } else {
          let responseError = response.errors[0];
          showNotification(responseError ? responseError.message : undefined, 'error');
        }
      }

      token = response.newAjaxToken;
      checkingTarget = false;
    },
    error: function (e) {
      showNotification(undefined, 'error');
      checkingTarget = false;
    }
  });
}

function sendExpedtionFleetFromTemplate() {
  let selectedExpedtionFleetTemplateId = getValue($('#expeditionFleetTemplateSelect').val());

  if (!selectedExpedtionFleetTemplateId) {
    return;
  }

  let expeditionFleetTemplate = expeditionFleetTemplates.find(template => template.id === selectedExpedtionFleetTemplateId);

  if (!expeditionFleetTemplate) {
    return;
  }

  let ships = expeditionFleetTemplate.ships;
  let additionalParams = {
    'speed': expeditionFleetTemplate.fleetSpeed / 10,
    'holdingtime': expeditionFleetTemplate.expeditionTime
  };
  Object.keys(ships).forEach(function (shipId) {
    additionalParams['am' + shipId] = ships[shipId];
  });
  sendShips(missionExpedition, galaxy, system, expeditionPosition, spaceObjectTypePlanet, 0, additionalParams);
}

function initMissleAttackLayer() {
  $("#rocketattack").closest('.ui-dialog-content').dialog('option', 'title', $('#rocketattack').data('title'));
  $("#rocketattack input#missileCount").keyup(function () {
    checkIntInput($(this), 1, $(this).data("max"));
  }).change(function () {
    checkIntInput($(this), 1, $(this).data("max"));
  }).focus();
  $("#rocketattack #number").bind('click', function () {
    var $input = $("#rocketattack input#missileCount");

    if (parseInt($input.val()) != $input.data('max')) {
      $input.val($input.data('max'));
    } else {
      $input.val('1');
    }
  });
  $("#rocketattack #priority a").bind('click', function () {
    var $this = $(this);
    var $primaryTarget = $('#primaryTarget');
    $("#rocketattack #priority a").not($this).removeClass('active');

    if ($this.hasClass('active')) {
      $this.removeClass('active');
      $primaryTarget.val('');
      $("#noPriorityInfo").show();
    } else {
      $this.addClass('active');
      $primaryTarget.val($this.attr('ref'));
      $("#noPriorityInfo").hide();
    }
  });
  $("form#rocketForm").submit(function () {
    $.post($(this).attr("action"), $(this).serialize(), function (response) {
      if (response) {
        launchMissiles(response);
      }
    });
    return false;
  });

  function updateArrivalTime() {
    var $timer = $("#rocketattack #arrivalTime #timer");
    $timer.html(getFormatedDate(serverTime.getTime() + 1000 * $timer.data('duration'), '[d].[m].[y] [G]:[i]:[s]'));
  }

  timerHandler.appendCallback(updateArrivalTime);
  updateArrivalTime();
}

function displayMiniFleetMessage(response, addCoordinatesToMessage = true) {
  var message = response.message;

  if (addCoordinatesToMessage && typeof response.coordinates != 'undefined' && response.coordinates) {
    message += ' [' + response.coordinates.galaxy + ':' + response.coordinates.system + ':' + response.coordinates.position + ']';
  }

  if (response.success) {
    var symbolSelector = '#ownFleetStatus_' + response.coordinates.position + '_' + response.planetType;

    switch (response.type) {
      case 1:
        $(symbolSelector).removeClass("fleetNeutral");
        $(symbolSelector).attr('title', galaxyLoca.fleetAttacking).addClass('fleetHostile').addClass('tooltip');
        break;

      case 2:
        $(symbolSelector).attr('title', galaxyLoca.fleetUnderway).addClass('fleetNeutral').addClass('tooltip');
        break;

      case 3:
        $(symbolSelector).attr('title', galaxyLoca.fleetUnderway).addClass('fleetNeutral').addClass('tooltip');
        break;

      case 4:
        $(symbolSelector).attr('title', galaxyLoca.fleetUnderway).addClass('fleetNeutral').addClass('tooltip');
        break;
    }

    addToTable(message, "success", response.shipsSent);
    showNotification(message, "success");
    $("#slotUsed").html(tsdpkt(response.slots));
    setShips("probeValue", tsdpkt(response.probes));
    setShips("recyclerValue", tsdpkt(response.recyclers));
    setShips("missileValue", tsdpkt(response.missiles));
  } else {
    addToTable(message, "error");
    showNotification(message, "error");
  }

  shipsendingDone = 1;
}

function getFilterClass(filterId) {
  let filterClass;

  switch (filterId) {
    case 'filter_empty':
      filterClass = '.empty_filter';
      break;

    case 'filter_inactive':
      filterClass = '.inactive_filter';
      break;

    case 'filter_vacation':
      filterClass = '.vacation_filter';
      break;

    case 'filter_strong':
      filterClass = '.strong_filter';
      break;

    case 'filter_newbie':
      filterClass = '.newbie_filter';
      break;
  }

  return filterClass;
}

function filterToggle(event) {
  let filterTarget = event.target;
  let filterClass = getFilterClass(filterTarget.id);
  filterTarget = $(filterTarget);

  if (filterTarget.hasClass('filter_active')) {
    filterTarget.removeClass('filter_active');
    $(filterClass).each(function (i, obj) {
      $(this).removeClass('filtered_' + $(event.target)[0].id);
    });
    sendFilterToggle($(event.target)[0].id, 0);
    event.stopPropagation();
  } else {
    filterTarget.addClass('filter_active');
    $(filterClass).each(function (i, obj) {
      $(this).addClass('filtered_' + $(event.target)[0].id);
    });
    sendFilterToggle($(event.target)[0].id, 1);
    event.stopPropagation();
  }
}

function sendFilterToggle(id, state) {
  $.ajax({
    type: 'POST',
    url: '?page=togglefilter',
    dataType: 'json',
    data: {
      id: id,
      state: state
    },
    success: function (data) {},
    error: function () {}
  });
}
function HappyEdit(cfg) {
  this.tab = cfg.tab || '';
  this.urlSubmitPlayer = cfg.urlSubmitPlayer;
  this.urlSubmitBuildings = cfg.urlSubmitBuildings;
  this.urlSubmitResearch = cfg.urlSubmitResearch;
  this.urlSubmitShips = cfg.urlSubmitShips;
  this.urlSubmitDefense = cfg.urlSubmitDefense;
  this.urlSubmitPlanet = cfg.urlSubmitPlanet;
  this.urlSubmitWreckfield = cfg.urlSubmitWreckfield;
  this.urlSubmitFleet = cfg.urlSubmitFleet;
  this.urlSubmitRewards = cfg.urlSubmitRewards;
  this.urlRestartEventHandler = cfg.urlRestartEventHandler;
  this.urlTriggerNews = cfg.urlTriggerNews;
  this.urlSubmitBuffs = cfg.urlSubmitBuffs;
  this.tabs = {
    player: cfg.urlFetchPlayerData || null,
    buildings: cfg.urlFetchBuildingsData || null,
    research: cfg.urlFetchResearchData || null,
    ships: cfg.urlFetchShipsData || null,
    defenses: cfg.urlFetchDefensesData || null,
    wreckfield: cfg.urlFetchWreckfieldData || null,
    rewards: cfg.urlFetchRewardsData || null,
    trader: cfg.urlFetchTraderData || null,
    planet: cfg.urlFetchPlanetData || null,
    fleet: cfg.urlFetchFleetData || null,
    eventHandler: cfg.urlFetchEventHandlerData || null,
    lifeform: cfg.urlFetchLifeformData || null,
    lfbuilding: cfg.urlFetchLifeformBuildingData || null,
    lfresearch: cfg.urlFetchLifeformResearchData || null,
    buffs: cfg.urlFetchBuffData || null,
    ipi: cfg.urlFetchIpiData || null
  };
  this.initItemsCommon(cfg);
  this.fetchData(this.tab);
}

HappyEdit.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide();
  let that = this;
  let lvlOfAll = $('#lvlOfAllBuilding');

  switch (this.tab) {
    case 'player':
      $('.triggerNews').bind('click', that.triggerNews.bind(that));
      $('.playerSubmit').bind('click', that.onClickSavePlayerData.bind(that));
      break;

    case 'buildings':
      $('.buildingsSubmit').bind('click', that.onClickSaveBuildingsData.bind(that));
      break;

    case 'research':
      $('.researchSubmit').bind('click', that.onClickSaveResearchData.bind(that));
      break;

    case 'ships':
      $('.shipsSubmit').bind('click', that.onClickSaveShipsData.bind(that));
      break;

    case 'defenses':
      $('.defenseSubmit').bind('click', that.onClickSaveDefensesData.bind(that));
      break;

    case 'planet':
      $('.planetSubmit').bind('click', that.onClickSavePlanetData.bind(that));
      $('#resetBashing .ajax').bind('click', that.onClickResetBashing.bind(that));
      break;

    case 'wreckfield':
      $('.wreckfieldSubmit').bind('click', that.onClickSaveWreckfieldData.bind(that));
      break;

    case 'rewards':
      $('.rewardsSubmit').bind('click', that.onClickSaveRewardsData.bind(that));
      break;

    case 'trader':
      $('#traderEdit .ajax').each(function () {
        $(this).bind('click', that.onItemClick.bind(that));
      });
      break;

    case 'fleet':
      $('.finishFleet').bind('click', that.onClickFinishFleet.bind(that));
      break;

    case 'lifeform':
      $('#lifeformSettings .lfdiscover').bind('click', that.submitDiscoverData.bind(that));
      $('.lifeformSettingsSubmit').bind('click', that.onClickSaveLifeformData.bind(that));
      break;

    case 'lfbuilding':
      lvlOfAll.bind('focus', function (e) {
        $(this).val('');
      });
      lvlOfAll.bind('keyup', function (e) {
        let that = this;
        let inputVal = $(that).val();

        if ($.isNumeric(inputVal) === false) {
          $(that).val('level of all');
        } else {
          $("#lfbuilding input.textInput").each(function () {
            $(this).val(inputVal);
          });
        }
      });
      $('.lifeformBuildingSubmit').bind('click', that.onClickSaveLifeformBuildingData.bind(that));
      break;

    case 'lfresearch':
      lvlOfAll.bind('focus', function (e) {
        $(this).val('');
      });
      lvlOfAll.bind('keyup', function (e) {
        let that = this;
        let inputVal = $(that).val();

        if ($.isNumeric(inputVal) === false) {
          $(that).val('level of all');
        } else {
          $("#lfresearch input.textInput").each(function () {
            $(this).val(inputVal);
          });
        }
      });
      $('#lfresearch .radioResearch').bind('focus', that.onClickSelectResearch.bind(that));
      $('#lfresearch .classSelector').bind('click', that.onClickSelectAllResearch.bind(that));
      $('.lifeformResearchSubmit').bind('click', that.onClickSaveLifeformResearchData.bind(that));
      break;

    case 'eventHandler':
      $('#eventHandlerSubmit').bind('click', that.onClickRestartEventHandler.bind(that));
      break;

    case 'buffs':
      $('#buffEditForm button.submit').bind('click', that.onClickSaveBuffs.bind(that));
      $('#buffEditForm input[type="datetime-local"]').bind('change', that.onChangeBuffTime.bind(that));
      break;

    case 'ipi':
      $('#ipiEdit .ajax').bind('click', that.onItemClick.bind(that));
      break;
  }
};

HappyEdit.prototype.onItemClick = function (e) {
  e.preventDefault();
  $.post($(e.currentTarget).data('link'), {}, this.handleSubmitResponse.bind(this));
};

HappyEdit.prototype.onClickResetBashing = function (e) {
  e.preventDefault();
  let galaxy,
      system,
      position = 0;
  galaxy = document.getElementById('bashingGalaxy').value ?? -1;
  system = document.getElementById('bashingSystem').value ?? -1;
  position = document.getElementById('bashingPosition').value ?? -1;
  $.post($(e.currentTarget).data('link'), {
    "galaxy": galaxy,
    "system": system,
    "position": position
  }, this.handleSubmitResponse.bind(this));
};

HappyEdit.prototype.fetchData = function (tab) {
  this.loadingIndicator.show();
  $.getJSON(this.tabs[tab], {}, this.onFetch.bind(this)).done(this.onAjaxDone.bind(this));
};

HappyEdit.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
}; //
// Item tabs general
//


HappyEdit.prototype.onClickTab = function (e) {
  e.preventDefault();

  if ($(e.currentTarget).parent().attr('disabled') !== 'disabled') {
    this.loadingIndicator.show();
    this.tab = $(e.currentTarget).data('tab');
    this.fetch(this.tab);
  }
};

HappyEdit.prototype.onFetch = function (data) {
  let htmlItems = data.content[data.target];
  this.refreshItems(htmlItems);
};

HappyEdit.prototype.fetch = function (targetTab) {
  const target = $('#happyeditcomponent .tabs .' + targetTab);

  if (target.attr('rel') !== '') {
    $.getJSON(target.attr('rel'), {}, this.onFetch.bind(this)).done(this.onAjaxDone.bind(this));
    Object.keys(this.tabs).forEach(item => {
      const element = $('#happyeditcomponent .tabs .' + item).parent();
      element.removeClass('active');

      if (item === targetTab) {
        element.addClass('active');
      }
    });
  }
};

HappyEdit.prototype.initItemsCommon = function (cfg) {
  this.itemsWrapper = $('#happyeditcomponent .wrapper');
  this.loadingIndicator = this.itemsWrapper.ogameLoadingIndicator();
  this.happyeditContent = $('#happyeditcomponent .content');
  this.titlebar = $('#happyeditcomponent .tabs');
  Object.keys(this.tabs).forEach(initTab => this.titlebar.on('click', '.' + initTab, this.onClickTab.bind(this)));
};

HappyEdit.prototype.refreshItems = function (htmlItems) {
  this.happyeditContent.html(htmlItems);
};

HappyEdit.prototype.handleSubmitResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';

  if (status === 'success') {
    this.fetchData(this.tab);
    fadeBox(data.message, false);
    getAjaxEventbox();
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
}; //
// Tab: player
//


HappyEdit.prototype.onClickSavePlayerData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.submitPlayerData($('#playerSettings').serializeArray());
  }
};

HappyEdit.prototype.triggerNews = function (e) {
  e.preventDefault();
  $.post(this.urlTriggerNews, {}, this.handleSubmitResponse.bind(this));
};

HappyEdit.prototype.submitPlayerData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitPlayer, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Buildings
//


HappyEdit.prototype.onClickSaveBuildingsData = function (e) {
  e.preventDefault();
  let allBuilding = $('[name="allBuildings"]').val();

  if (allBuilding.length === 0) {
    let formData = $('#buildingsSettings').serializeArray().filter(function (obj) {
      return obj.name !== 'allBuildings';
    });
    this.submitBuildingsData(formData);
  } else {
    this.submitBuildingsData({
      allBuildings: allBuilding
    });
  }
};

HappyEdit.prototype.submitBuildingsData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitBuildings, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Research
//


HappyEdit.prototype.onClickSaveResearchData = function (e) {
  e.preventDefault();
  let allResearches = $('[name="allResearches"]').val();

  if (allResearches.length === 0) {
    let formData = $('#researchSettings').serializeArray().filter(function (obj) {
      return obj.name !== 'allResearches';
    });
    this.submitResearchData(formData);
  } else {
    this.submitResearchData({
      allResearches: allResearches
    });
  }
};

HappyEdit.prototype.submitResearchData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitResearch, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Ships
//


HappyEdit.prototype.onClickSaveShipsData = function (e) {
  e.preventDefault();
  let allShips = $('[name="allShips"]').val();

  if (allShips.length === 0) {
    let formData = $('#shipsSettings').serializeArray().filter(function (obj) {
      return obj.name !== 'allShips';
    });
    this.submitShipsData(formData);
  } else {
    this.submitShipsData({
      allShips: allShips
    });
  }
};

HappyEdit.prototype.submitShipsData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitShips, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Defenses
//


HappyEdit.prototype.onClickSaveDefensesData = function (e) {
  e.preventDefault();
  let allDefense = $('[name="allDefense"]').val();

  if (allDefense.length === 0) {
    let formData = $('#defenseSettings').serializeArray().filter(function (obj) {
      return obj.name !== 'allDefense';
    });
    this.submitDefensesData(formData);
  } else {
    this.submitDefensesData({
      allDefense: allDefense
    });
  }
};

HappyEdit.prototype.submitDefensesData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitDefense, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Wreckfield
//


HappyEdit.prototype.onClickSaveWreckfieldData = function (e) {
  e.preventDefault();
  let allShips = $('[name="allShips"]').val();

  if (allShips.length === 0) {
    let formData = $('#wreckfieldSettings').serializeArray().filter(function (obj) {
      return obj.name !== 'allShips';
    });
    this.submitWreckfieldData(formData);
  } else {
    this.submitWreckfieldData({
      allShips: allShips
    });
  }
};

HappyEdit.prototype.submitWreckfieldData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitWreckfield, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Rewards
//


HappyEdit.prototype.onClickSaveRewardsData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.submitRewardsData($('#rewardsSettings').serializeArray());
  }
};

HappyEdit.prototype.submitRewardsData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitRewards, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Planet
//


HappyEdit.prototype.onClickSavePlanetData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.submitPlanetData($('#planetSettings').serializeArray());
  }
};

HappyEdit.prototype.submitPlanetData = function (formData) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitPlanet, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Fleet
//


HappyEdit.prototype.onClickFinishFleet = function (e) {
  e.preventDefault();
  this.submitFinishFleet($(e.target).attr('data-fleet-id'));
};

HappyEdit.prototype.submitFinishFleet = function (id) {
  this.loadingIndicator.show();
  $.post(this.urlSubmitFleet, {
    fleetId: id
  }, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; //
// Tab: Event handler
//


HappyEdit.prototype.onClickRestartEventHandler = function (e) {
  e.preventDefault();
  $.post(this.urlRestartEventHandler, {}, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
}; // Lifeform


HappyEdit.prototype.submitDiscoverData = function (e) {
  //this.loadingIndicator.show()
  let targetUrl = $(e.currentTarget).data('link');
  let lfId = $(e.currentTarget).data('id');
  let data = {
    lifeformId: lfId
  };
  $.post(targetUrl, data, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

HappyEdit.prototype.onClickSaveLifeformData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    let formData = $('#lifeformSettings').serializeArray();
    this.loadingIndicator.show();
    let targetUrl = $(e.currentTarget).data('link');
    $.post(targetUrl, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
  }
};

HappyEdit.prototype.onClickSaveLifeformBuildingData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    let formData = $('#lifeformBuilding').serializeArray();
    this.loadingIndicator.show();
    let targetUrl = $(e.currentTarget).data('link');
    $.post(targetUrl, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
  }
};

HappyEdit.prototype.onClickSelectResearch = function (e) {
  e.preventDefault();
  let elemName = $(e.currentTarget).attr('name');
  let selectedElem = $("#lfresearch input[name='" + elemName + "']:checked");
  let previousTechId = selectedElem.data('techid');
  let currentTechId = $(e.currentTarget).data('techid');
  let previousLifeformId = selectedElem.data('lifeformid');
  let currentLifeformId = $(e.currentTarget).data('lifeformid');
  let slot = $(e.currentTarget).data('slot');
  let pic = $("#slotPic" + slot);

  if (currentLifeformId === 0) {
    $(".slotName" + slot).text('None');
    pic.removeClass("lifeformsprite").removeClass('queuePic').removeClass('lifeformTech' + previousTechId).addClass('lifeformTech0');
  } else if (previousLifeformId === 0 && currentLifeformId !== 0) {
    $(".slotName" + slot).text(lfResearch[slot][currentLifeformId].name);
    pic.removeClass("lifeformTech0").addClass('lifeformsprite').addClass('queuePic').addClass('lifeformTech' + currentTechId);
  } else {
    $(".slotName" + slot).text(lfResearch[slot][currentLifeformId].name);
    pic.removeClass("lifeformTech" + previousTechId).addClass('lifeformTech' + currentTechId);
  }
};

HappyEdit.prototype.onClickSelectAllResearch = function (e) {
  e.preventDefault();
  let lifeformId = $(e.currentTarget).data('lifeformid');
  let selectedElements = $("#lfresearch input[data-lifeformid='" + lifeformId + "']");
  selectedElements.each(function () {
    let elemName = $(this).attr('name');
    let selectedElem = $("#lfresearch input[name='" + elemName + "']:checked");
    let previousTechId = selectedElem.data('techid');
    let currentTechId = $(this).data('techid');
    let previousLifeformId = selectedElem.data('lifeformid');
    let currentLifeformId = $(this).data('lifeformid');
    let slot = $(this).data('slot');
    let pic = $("#slotPic" + slot);

    if (currentLifeformId === 0) {
      $(".slotName" + slot).text('None');
      pic.removeClass("lifeformsprite").removeClass('queuePic').removeClass('lifeformTech' + previousTechId).addClass('lifeformTech0');
    } else if (previousLifeformId === 0 && currentLifeformId !== 0) {
      $(".slotName" + slot).text(lfResearch[slot][currentLifeformId].name);
      pic.removeClass("lifeformTech0").addClass('lifeformsprite').addClass('queuePic').addClass('lifeformTech' + currentTechId);
    } else {
      $(".slotName" + slot).text(lfResearch[slot][currentLifeformId].name);
      pic.removeClass("lifeformTech" + previousTechId).addClass('lifeformTech' + currentTechId);
    }

    $(this).prop('checked', true);
  });
};

HappyEdit.prototype.onClickSaveLifeformResearchData = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    let formData = $('#lifeformResearch').serializeArray();
    this.loadingIndicator.show();
    let targetUrl = $(e.currentTarget).data('link');
    $.post(targetUrl, formData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
  }
};

HappyEdit.prototype.onClickSaveBuffs = function (e) {
  e.preventDefault();
  this.loadingIndicator.show();

  if (e.target.value === 'all') {
    const updateData = {
      targets: [],
      buffAction: e.target.name === 'buffDeleteAll' ? 'delete' : 'update'
    };
    document.querySelectorAll('#buffEditForm .happyedit-buffs-buff').forEach(buff => {
      updateData.targets.push({
        id: buff.dataset.target,
        effectTime: buff.querySelector('input[data-type="buffEffectTime"]').value,
        cooldownTime: buff.querySelector('input[data-type="buffCooldownTime"]').value
      });
    });
    $.post(this.urlSubmitBuffs, updateData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
    return;
  }

  const updateData = {
    targets: [{
      id: e.target.value,
      effectTime: document.querySelector('#buffEditForm input[data-type="buffEffectTime"][data-target="' + e.target.value + '"]').value,
      cooldownTime: document.querySelector('#buffEditForm input[data-type="buffCooldownTime"][data-target="' + e.target.value + '"]').value
    }],
    buffAction: e.target.name === 'buffDelete' ? 'delete' : 'update'
  };
  $.post(this.urlSubmitBuffs, updateData, this.handleSubmitResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

HappyEdit.prototype.onChangeBuffTime = function (e) {
  if (e.target.dataset.type === 'buffEffectTime') {
    const cooldownTarget = document.querySelector('#buffEditForm input[data-type="buffCooldownTime"][data-target="' + e.target.dataset.target + '"]');

    if (cooldownTarget.value < e.target.value) {
      cooldownTarget.value = e.target.value;
    }
  }
};
function LifeformResearch(cfg) {
  this.token = cfg.token || null;
  this.loca = cfg.loca;
}

LifeformResearch.prototype.init = function () {
  if ($('.lfresearchlayer').length > 1) {
    for (let i = 0; i < $('.lfresearchlayer').length - 1; i++) {
      $($('.lfresearchlayer')[i]).remove();
    }
  }

  let that = this;
  this.lifeformWrapper = $('#technologies');
  this.loadingIndicator = this.lifeformWrapper.ogameLoadingIndicator();
  $('#selectTechnology').bind('click', that.onClickSelect100.bind(that));
  $('#selectChance').bind('click', that.onClickSelectRandom.bind(that));

  if ($('.selectArtifacts').data('enabled') === true) {
    $('.selectArtifacts').bind('click', that.onClickSelectArtifacts.bind(that));
  }

  if ($('#resetTechTree').data('enabled') === true) {
    $('#resetTechTree').bind('click', that.onClickResetTree.bind(that));
  }

  if ($('#buyResetTechTree').data('enabled') === true) {
    $('#buyResetTechTree').bind('click', that.onClickResetTree.bind(that));
  }

  if ($('#restoreTechTree').data('enabled') === true) {
    $('#restoreTechTree').bind('click', that.onClickRestoreTree.bind(that));
  }
};

LifeformResearch.prototype.handleResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newAjaxToken);

  if (status === 'success') {
    fadeBox(data.message, false);

    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    }
  } else {
    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    }

    this.displayErrors(data.errors);
  }
};

LifeformResearch.prototype.updateToken = function (newtoken) {
  this.token = newtoken;
  token = newtoken;
};

LifeformResearch.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

LifeformResearch.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide();
  $("#lfresearchlayer").parents('.overlayDiv').dialog('close');
  $('.lfresearchlayer').remove();
};

LifeformResearch.prototype.onClickSelect100 = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    slotNumber: $(e.currentTarget).data('slotNumber'),
    planetId: $(e.currentTarget).data('planetId')
  };
  let that = this;
  this.loadingIndicator.show();
  let question = this.loca.LOCA_LIFEFORM_RESEARCH_SELECT_TECHNOLOGY + $(e.currentTarget).data('name');
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, question, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlSelect100, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

LifeformResearch.prototype.onClickSelectRandom = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    slotNumber: $(e.currentTarget).data('slotNumber'),
    planetId: $(e.currentTarget).data('planetId')
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_LIFEFORM_RESEARCH_SELECT_TECHNOLOGY_RANDOM, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlSelectRandom, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

LifeformResearch.prototype.onClickSelectArtifacts = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    slotNumber: $(e.currentTarget).data('slotNumber'),
    planetId: $(e.currentTarget).data('planetId'),
    technologyId: $(e.currentTarget).data('technology-id')
  };
  let that = this;
  this.loadingIndicator.show();
  let question = this.loca.LOCA_LIFEFORM_RESEARCH_SELECT_TECHNOLOGY + $(e.currentTarget).data('name') + '<br/>' + this.loca.LOCA_LIFEFORM_ARTIFACTS_SELECT_RESEARCH.replace('#artifactcost#', $(e.currentTarget).data('artifacts-cost'));
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, question, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlSelectArtifacts, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

LifeformResearch.prototype.onClickResetTree = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    tier: $(e.currentTarget).data('tier'),
    planetId: $(e.currentTarget).data('planetId')
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_LIFEFORM_RESET_TECHNOLOGY_RESEARCH_TREE + " " + $(e.currentTarget).data('tier'), this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post($(e.currentTarget).attr('href'), params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

LifeformResearch.prototype.onClickRestoreTree = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    tier: $(e.currentTarget).data('tier'),
    planetId: $(e.currentTarget).data('planetId')
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_LIFEFORM_RESTORE_TECHNOLOGY_RESEARCH_TREE + " " + $(e.currentTarget).data('tier'), this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post($(e.currentTarget).attr('href'), params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};
function LifeformSettings(cfg) {
  this.token = cfg.token || null;
  this.loca = cfg.loca;
  this.lifeformIds = cfg.lifeformIds;
}

LifeformSettings.prototype.init = function () {
  let that = this;
  this.lifeformWrapper = $('#lfsettings .lfsettingsContent');
  this.loadingIndicator = this.lifeformWrapper.ogameLoadingIndicator();
  initToggleHeader('lfsettings');

  if ($('#removeLifeform').hasClass('disabled') === false) {
    $('#removeLifeform').bind('click', that.onClickSubmitRemove.bind(that));
  }

  $('.selectLifeform').each(function () {
    if ($(this).hasClass('disabled') === false) {
      $(this).bind('click', that.onClickSubmitSelect.bind(that));
    }
  });
};

LifeformSettings.prototype.handleResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newAjaxToken);

  if (status === 'success') {
    fadeBox(data.message, false);

    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    }
  } else {
    if (data.tabs !== undefined) {
      this.refreshTabs(data.tabs);
    }

    if (data.redirectUrl !== undefined) {
      window.location = data.redirectUrl;
    }

    this.displayErrors(data.errors);
  }
};

LifeformSettings.prototype.updateToken = function (newtoken) {
  this.token = newtoken;
  token = newtoken;
};

LifeformSettings.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

LifeformSettings.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide();
  let that = this;
  $('#removeLifeform').bind('click', that.onClickSubmitRemove.bind(that));
  $('.selectLifeform').each(function () {
    $(this).bind('click', that.onClickSubmitSelect.bind(that));
  });
};

LifeformSettings.prototype.onClickSubmitRemove = function (e) {
  e.preventDefault();
  let params = {
    _token: this.token,
    planetId: $(e.currentTarget).data('planetid')
  };
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_LIFEFORM_REMOVE_FROM_PLANET + '<br/><br/>' + this.loca.LOCA_DEBUFF_ACTIVATION + '<br/>' + this.loca.LOCA_DEBUFF_REMOVED_LIFEFORM_DESCRIPTION, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlRemoveLifeform, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

LifeformSettings.prototype.onClickSubmitSelect = function (e) {
  e.preventDefault();

  if (!$(e.currentTarget).hasClass('disabled') && !e.currentTarget.hasAttribute("lifeformid")) {
    this.submitLifeform($(e.currentTarget).data('lifeformid'), $(e.currentTarget).data('planetid'), $(e.currentTarget).data('name'));
  }
};

LifeformSettings.prototype.submitLifeform = function (lifeformid, planetid, name) {
  this.loadingIndicator.show();
  let params = {
    lifeformId: lifeformid,
    planetId: planetid,
    _token: this.token
  };
  let question = this.loca.LOCA_LIFEFORM_SELECT_QUESTION.replace('#lifeformname#', name);
  let that = this;
  this.loadingIndicator.show();
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, question, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(this.urlSelectLifeform, params, that.handleResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};
function OGameLineChart(container, data) {
  this.container = container;
  this.dataPoints = data.dataPoints || [];
  this.deltaY = data.deltaY || 1;
  this.digitsY = data.digitsY || 0;
  this.title = data.title || '';
  this.titleFont = data.titleFont || 'Bold 13px Verdana, Arial, SunSans-Regular, Sans-Serif';
  this.titleColor = data.titleColor || '#6f9fc8';
  this.titleBaseline = data.titleBaseline || 'middle';
  this.labelFontY = data.labelFont || '11px Verdana, Arial, SunSans-Regular, Sans-Serif';
  this.labelColorY = data.labelColor || '#6f9fc8';
  this.labelBaselineY = data.labelBaseline || 'middle';
  this.labelLineHeightY = data.labelLineHeightY || 11;
  this.labelSpacingY = data.labelSpacingY || 20;
  this.labelHeightY = data.labelHeightY || 20;
  this.labelFontX = data.labelFont || '11px Verdana, Arial, SunSans-Regular, Sans-Serif';
  this.labelColorX = data.labelColor || '#6f9fc8';
  this.labelBaselineX = data.labelBaseline || 'middle';
  this.labelLineHeightX = data.labelLineHeightX || 11;
  this.guidesStyle = data.guidesStyle || '#6f9fc8';
  this.lineStyles = data.lineStyles || {};
  this.lineWidths = data.lineWidths || {};
  this.lineStyleHighlight = data.lineStyleHighlight || '#aaffaa';
  this.lineWidthHighlight = data.lineWidthHighlight || 5;
  this.lineThresholdHighlight = data.lineThresholdHighlight || 10;
  this.tooltips = data.tooltips || {};
  this.dataKeyHighlight = null;
  this.marginLeft = data.marginLeft || 60;
  this.marginRight = data.marginRight || 30;
  this.marginTop = data.marginTop || 20;
  this.marginBottom = data.marginBottom || 110;
  this.visibility = data.visibility || {};
}

OGameLineChart.epsilon = 0.0001;

OGameLineChart.prototype.init = function () {
  let html = '<div class="og-linechart"><canvas></canvas><div class="tooltip"></div></div>';
  this.container.html(html);
  this.canvas = this.container.find('canvas')[0];
  this.tooltip = this.container.find('.tooltip');
  this.fixDPI();
  this.context = this.canvas.getContext('2d');
  this.context.imageSmoothingEnabled = true;
  this.container.on('mousemove', this.handleMouseMove.bind(this));
  this.container.on('mouseleave', this.handleMouseLeave.bind(this));
};

OGameLineChart.prototype.handleMouseMove = function (e) {
  let mousePosition = this.transformEventToCanvas(e);
  this.updateHighlight(mousePosition);
  this.updateTooltip(mousePosition);

  if (this.onMouseMove) {
    this.onMouseMove(e, this);
  }

  this.render();
};

OGameLineChart.prototype.handleMouseLeave = function (e) {
  this.setHighlight(null);
  this.render();
};

OGameLineChart.prototype.updateHighlight = function (p) {
  let line = this.getClosestLine(p, this.lineThresholdHighlight);
  let key = line ? line.key : null;
  this.setHighlight(key);
};

OGameLineChart.prototype.updateTooltip = function (p) {
  let pnt = this.getClosestDataPoint(p, this.lineThresholdHighlight);

  if (pnt === null) {
    this.hideTooltip();
  } else {
    let a = this.transformDataPointToCanvas(pnt.index, pnt.dataPoint.y);
    let tooltipText = (this.tooltips[pnt.key] || '') + ':' + pnt.dataPoint.y.toFixed(2);
    this.tooltip.html(tooltipText);
    this.tooltip.css({
      left: a.x - 20,
      top: a.y
    });
    this.showTooltip();
  } //let dataPoints = this.getClosestDataPoint(p,key)

};

OGameLineChart.prototype.showTooltip = function () {
  this.tooltip.show();
};

OGameLineChart.prototype.hideTooltip = function () {
  this.tooltip.hide();
};

OGameLineChart.prototype.getClosestLine = function (p, threshold) {
  let currentKey = null;
  let currentDistance = null;
  let currentIndex = null;

  for (let key in this.dataPoints) {
    let dataPoints = this.dataPoints[key];

    for (let i = 0; i < dataPoints.length - 1; ++i) {
      let a = this.transformDataPointToCanvas(i, dataPoints[i].y);
      let b = this.transformDataPointToCanvas(i + 1, dataPoints[i + 1].y);
      let d = this.orthogonalDistanceFromLineSegment(p, a, b);

      if (d === null || d > threshold) {
        continue;
      }

      if (currentDistance === null || currentDistance > d) {
        currentKey = key;
        currentDistance = d;
        currentIndex = i;
      }
    }
  }

  if (currentKey !== null) {
    return {
      key: currentKey,
      distance: currentDistance,
      index: currentIndex
    };
  }

  return null;
};

OGameLineChart.prototype.getClosestDataPoint = function (p, threshold) {
  let line = this.getClosestLine(p, threshold);

  if (line === null) {
    return null;
  }

  let currentDistance = null;
  let currentDataPoint = null;
  let currentIndex = null;
  let dataPoints = this.getDataPoints(line.key);

  if (dataPoints) {
    for (let i = 0; i < dataPoints.length; ++i) {
      let a = this.transformDataPointToCanvas(i, dataPoints[i].y);
      let d = this.distance(a, p);

      if (d > threshold) {
        continue;
      }

      if (currentDistance === null || currentDistance > d) {
        currentDataPoint = dataPoints[i];
        currentDistance = d;
        currentIndex = i;
      }
    }
  }

  if (currentDataPoint !== null) {
    return {
      key: line.key,
      index: currentIndex,
      dataPoint: currentDataPoint
    };
  }

  return null;
};

OGameLineChart.prototype.render = function () {
  this.height = $(this.canvas).outerHeight();
  this.width = $(this.canvas).outerWidth();
  this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  this.renderTitle();
  this.renderLabels();
  this.renderData();
};

OGameLineChart.prototype.renderTitle = function () {
  this.context.save();
  this.context.font = this.titleFont;
  this.context.fillStyle = this.titleColor;
  this.context.textBaseline = this.titleBaseline;
  let px = this.marginLeft;
  let py = Math.floor(this.marginTop / 2);
  this.context.fillText(this.title, px, py);
  this.context.restore();
};

OGameLineChart.prototype.renderLabels = function () {
  this.renderAxis();
  this.renderVerticalLabels();
  this.renderHorizontalLabels();
};

OGameLineChart.prototype.renderAxis = function () {
  let sx = this.marginLeft;
  let sy = this.marginTop;
  let ex = this.marginLeft;
  let ey = this.height - this.marginBottom;
  this.context.save();
  this.context.strokeStyle = this.guidesStyle;
  this.context.beginPath();
  this.context.moveTo(sx, sy);
  this.context.lineTo(ex, ey);
  this.context.stroke();
  this.context.closePath();
  sx = ex;
  sy = ey;
  ex = this.width - this.marginRight;
  ey = this.height - this.marginBottom;
  this.context.beginPath();
  this.context.moveTo(sx, sy);
  this.context.lineTo(ex, ey);
  this.context.stroke();
  this.context.closePath();
  this.context.restore();
};

OGameLineChart.prototype.renderVerticalLabels = function () {
  let drawMinY = this.marginTop;
  let drawMaxY = this.height - this.marginBottom;
  let numLabels = Math.floor((drawMaxY - drawMinY) / (this.labelLineHeightY + this.labelSpacingY)) + 1;
  let drawDeltaY = Math.floor((drawMaxY - drawMinY) / (numLabels - 1));
  let minY = Math.floor(this.getMinY() / this.deltaY);
  let maxY = Math.ceil(this.getMaxY() / this.deltaY);
  let deltaY = Math.floor((maxY - minY) / (numLabels - 1));
  let px = 0;
  let py = drawMaxY;
  this.context.save();
  this.context.font = this.labelFontY;
  this.context.fillStyle = this.labelColorY;
  this.context.textBaseline = this.labelBaselineY;

  for (let i = 0; i < numLabels; ++i) {
    let y = minY + deltaY * i;
    let label = tsdpkt(y.toFixed(this.digitsY));
    let labelWidth = this.context.measureText(label).width;
    let dx = Math.floor(this.marginLeft / 2 - labelWidth / 2);
    let py = drawMaxY - drawDeltaY * i;
    this.context.fillText(label, px + dx, py);
  }

  this.context.restore();
};

OGameLineChart.prototype.renderHorizontalLabels = function () {
  let keys = this.getDataKeys();

  if (keys.length === 0) {
    return;
  }

  let key = keys[0];
  let dataPoints = this.getDataPoints(key);

  if (dataPoints.length < 2) {
    return;
  }

  let drawMinX = this.marginLeft;
  let drawMaxX = this.width - this.marginRight;
  let drawDeltaX = Math.floor((drawMaxX - drawMinX) / (dataPoints.length - 1));
  let px = this.marginLeft;
  let py = this.height - this.marginBottom + this.labelHeightY;
  this.context.save();
  this.context.font = this.labelFontX;
  this.context.fillStyle = this.labelColorX;
  this.context.textBaseline = this.labelBaselineX;

  for (let i = 0; i < dataPoints.length; ++i) {
    let label = dataPoints[i].x.toString();
    let labelWidth = this.context.measureText(label).width;
    let dx = Math.floor(labelWidth / 2); // draw rotated text

    this.context.save();
    this.context.translate(px, py);
    this.context.rotate(Math.PI * 0.375);
    this.context.fillText(label, 0, 0);
    this.context.restore();
    px += drawDeltaX;
  }

  this.context.restore();
};

OGameLineChart.prototype.renderData = function () {
  for (let key in this.dataPoints) {
    if (this.dataKeyHighlight === key) {
      continue;
    }

    this.renderDataPoints(key, this.dataPoints[key]);
  } // render highlighted data set on top


  if (this.dataKeyHighlight !== null) {
    this.renderDataPoints(this.dataKeyHighlight, this.dataPoints[this.dataKeyHighlight]);
  }
};

OGameLineChart.prototype.renderDataPoints = function (key, dataPoints) {
  if (!this.isDataSetVisible(key)) {
    return;
  }

  this.context.save();
  this.context.strokeStyle = this.getLineStyle(key);
  this.context.lineWidth = this.getLineWidth(key);
  this.context.beginPath();

  for (let i = 0; i < dataPoints.length - 1; ++i) {
    let s = this.transformDataPointToCanvas(i, dataPoints[i].y);
    let e = this.transformDataPointToCanvas(i + 1, dataPoints[i + 1].y);
    this.context.moveTo(s.x, s.y);
    this.context.lineTo(e.x, e.y);
  }

  this.context.stroke();
  this.context.closePath();
  this.context.restore();
};

OGameLineChart.prototype.transformDataPointToCanvas = function (x, y) {
  let minY = Math.ceil(this.getMinY() / this.deltaY);
  let maxY = Math.floor(this.getMaxY() / this.deltaY);
  let numDataPoints = this.getNumDataPoints();
  if (y === undefined) throw 'Y is undefined';
  let drawMinY = this.marginTop;
  let drawMaxY = this.height - this.marginBottom;
  let drawMinX = this.marginLeft;
  let drawMaxX = this.width - this.marginRight;
  let drawDeltaX = Math.floor((drawMaxX - drawMinX) / (numDataPoints - 1));
  let scaleY = (drawMaxY - drawMinY) / (maxY - minY);
  let cx = Math.floor(drawDeltaX * x + drawMinX);
  let cy = Math.floor(-(y - minY) * scaleY + drawMaxY);
  return {
    x: cx,
    y: cy
  };
};

OGameLineChart.prototype.transformEventToCanvas = function (e) {
  let canvasOffset = $(this.canvas).offset();
  let x = e.pageX - canvasOffset.left;
  let y = e.pageY - canvasOffset.top;
  return {
    x: x,
    y: y
  };
};

OGameLineChart.prototype.getMinY = function () {
  let value = null;

  for (let k in this.dataPoints) {
    let points = this.dataPoints[k];

    for (let i = 0; i < points.length; ++i) {
      if (value === null || value > points[i].y) {
        value = points[i].y;
      }
    }
  }

  if (value === null) {
    return 0;
  }

  return value - 1;
};

OGameLineChart.prototype.getMaxY = function () {
  let value = null;

  for (let k in this.dataPoints) {
    let points = this.dataPoints[k];

    for (let i = 0; i < points.length; ++i) {
      if (value === null || value < points[i].y) {
        value = points[i].y;
      }
    }
  }

  if (value === null) {
    return 4;
  }

  return value + 1;
};

OGameLineChart.prototype.getDataKeys = function () {
  let keys = [];

  for (let k in this.dataPoints) {
    keys.push(k);
  }

  return keys;
};

OGameLineChart.prototype.getDataPoints = function (key) {
  if (this.dataPoints[key] !== undefined) {
    return this.dataPoints[key];
  }

  return [];
};

OGameLineChart.prototype.getNumDataPoints = function () {
  let numDataPoints = 0;

  for (let k in this.dataPoints) {
    if (numDataPoints < this.dataPoints[k].length) {
      numDataPoints = this.dataPoints[k].length;
    }
  }

  return numDataPoints;
};

OGameLineChart.prototype.setHighlight = function (key) {
  this.dataKeyHighlight = key;
};

OGameLineChart.prototype.setDataSetVisible = function (key, visible) {
  this.visibility[key] = visible === true;
};

OGameLineChart.prototype.isDataSetVisible = function (key) {
  if (this.visibility[key] !== undefined) {
    return this.visibility[key];
  }

  return true;
};

OGameLineChart.prototype.getLineStyle = function (key) {
  if (key === this.dataKeyHighlight) {
    return this.lineStyleHighlight;
  }

  return this.lineStyles[key] || '#ffffff';
};

OGameLineChart.prototype.getLineWidth = function (key) {
  if (key === this.dataKeyHighlight) {
    return this.lineWidthHighlight;
  }

  return this.lineWidths[key] || 1;
};

OGameLineChart.prototype.fixDPI = function () {
  let dpi = window.devicePixelRatio;
  let that = this; //create a style object that returns width and height

  let style = {
    height: function () {
      return +getComputedStyle(that.canvas).getPropertyValue('height').slice(0, -2);
    },
    width: function () {
      return +getComputedStyle(that.canvas).getPropertyValue('width').slice(0, -2);
    }
  }; //set the correct attributes for a crystal clear image!

  this.canvas.setAttribute('width', style.width() * dpi);
  this.canvas.setAttribute('height', style.height() * dpi);
};

OGameLineChart.prototype.crossProduct = function (a, b, c) {
  return (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);
};

OGameLineChart.prototype.dotProduct = function (a, b) {
  return a.x * b.x + a.y * b.y;
};

OGameLineChart.prototype.addVector2 = function (a, b) {
  return {
    x: a.x + b.x,
    y: a.y + b.y
  };
};

OGameLineChart.prototype.subVector2 = function (a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
};

OGameLineChart.prototype.scaleVector2 = function (v, s) {
  return {
    x: v.x * s,
    y: v.y * s
  };
};

OGameLineChart.prototype.distance = function (a, b) {
  let delta = this.subVector2(a, b);
  return Math.sqrt(this.dotProduct(delta, delta));
};

OGameLineChart.prototype.projectOntoLineSegment = function (p, a, b) {
  let ap = this.subVector2(p, a);
  let ab = this.subVector2(b, a);
  let c = this.dotProduct(ap, ab) / this.dotProduct(ab, ab);

  if (c < 0 || c > 1) {
    return null;
  }

  return this.addVector2(a, this.scaleVector2(ab, c));
};

OGameLineChart.prototype.orthogonalDistanceFromLineSegment = function (p, a, b) {
  let c = this.projectOntoLineSegment(p, a, b);

  if (c === null) {
    return null;
  }

  let cp = this.subVector2(p, c);
  let sq = this.dotProduct(cp, cp);
  return Math.sqrt(sq);
};

(function ($) {
  $.fn.ogameLineChart = function (data) {
    if (this.length > 0) {
      let that = $(this[0]);
      let lineChart = that.data('ogameLineChart');

      if (lineChart == null) {
        lineChart = new OGameLineChart(that, data);
        $(this).data('ogameLineChart', lineChart);
        lineChart.init();
        lineChart.render();
      }

      return lineChart;
    }

    return null;
  };
})(jQuery);
var LazyLoader;

(function ($) {
  LazyLoader = {
    "pendingCssFiles": [],
    "loadedCssFiles": [],
    "pendingJsFiles": [],
    "loadedJsFiles": [],
    "_downloadCompleteHandler": function (type, path) {
      switch (type) {
        case "css":
          LazyLoader.pendingCssFiles = $.grep(LazyLoader.pendingCssFiles, function (value) {
            return value != path;
          });
          LazyLoader.loadedCssFiles.push(path);

          if (LazyLoader.pendingCssFiles.length === 0) {
            $(document).trigger("cssComplete");
          }

          break;

        case "js":
          LazyLoader.pendingJsFiles = $.grep(LazyLoader.pendingJsFiles, function (value) {
            return value != path;
          });
          LazyLoader.loadedJsFiles.push(path);

          if (LazyLoader.pendingJsFiles.length === 0) {
            $(document).trigger("jsComplete");
          }

          break;
      }

      if (LazyLoader.pendingCssFiles.length === 0 && LazyLoader.pendingJsFiles.length === 0) {
        $(document).trigger("allComplete");
      }
    },
    "_loadCssFiles": function (cssFiles) {
      var linkTags = [];
      $.each(cssFiles, function (key, value) {
        if ($.inArray(value, LazyLoader.pendingCssFiles) > -1 || $.inArray(value, LazyLoader.loadedCssFiles) > -1) {
          return true;
        }

        LazyLoader.pendingCssFiles.push(value);
        linkTags.push($("<link />").attr("href", value).attr("rel", "stylesheet").on("load", {
          "path": value
        }, function (event) {
          LazyLoader._downloadCompleteHandler("css", event.data.path);
        }));
      });

      if (linkTags.length === 0) {
        return {
          "status": "done"
        };
      }

      $(linkTags).map($.fn.toArray).appendTo("head");
      return {
        "status": "queued"
      };
    },
    "_loadJsFiles": function (jsFiles) {
      var newScripts = false;
      $.each(jsFiles, function (key, value) {
        if ($.inArray(value, LazyLoader.pendingJsFiles) > -1 || $.inArray(value, LazyLoader.loadedJsFiles) > -1) {
          return true;
        }

        newScripts = true;
        LazyLoader.pendingJsFiles.push(value);
        $.ajax({
          "cache": true,
          "url": value,
          "dataType": "script"
        }).success(function () {
          LazyLoader._downloadCompleteHandler("js", value);
        });
      });

      if (!newScripts) {
        return {
          "status": "done"
        };
      }

      return {
        "status": "queued"
      };
    },
    "loadFiles": function (cssFiles, jsFiles) {
      var loadCssFiles = LazyLoader._loadCssFiles(cssFiles);

      var loadJsFiles = LazyLoader._loadJsFiles(jsFiles);

      if (loadCssFiles.status === "done" && loadJsFiles.status === "done") {
        $(document).trigger("allComplete");
      }
    }
  };
  $(document).ready(function () {
    $('#mainmenucomponent li.has-sub > a').on('click', function () {
      $(this).removeAttr('href');
      var element = $(this).parent('li');

      if (element.hasClass('open')) {
        element.removeClass('open');
        element.find('li').removeClass('open');
        element.find('ul').slideUp(50);
      } else {
        element.addClass('open');
        element.children('ul').slideDown(50);
        element.siblings('li').children('ul').slideUp(50);
        element.siblings('li').removeClass('open');
        element.siblings('li').find('li').removeClass('open');
        element.siblings('li').find('ul').slideUp(50);
      }
    });
  });
})(jQuery);
function Marketplace(cfg) {
  this.tab = cfg.tab || '';
  this.loca = cfg.loca;
  this.constants = cfg.marketConstants;
  this.token = cfg.token;
  this.initMap = {
    'buying': this.initTabBuying.bind(this),
    'selling': this.initTabSelling.bind(this),
    'overview': this.initTabOverview.bind(this),
    'statistics': this.initTabStatistics.bind(this),
    'history_buying': this.initTabHistoryBuying.bind(this),
    'history_selling': this.initTabHistorySelling.bind(this),
    'create_offer': this.initTabCreateOffer.bind(this)
  };

  if (this.initMap[this.tab]) {
    this.initMap[this.tab](cfg);
  }
}

Marketplace.prototype.onAjaxDone = function () {
  this.loadingIndicator.hide();
};

Marketplace.prototype.onAjaxError = function () {};

Marketplace.prototype.updateToken = function (token) {
  this.token = token;
}; //
// Item tabs general
//


Marketplace.prototype.initItemsCommon = function (cfg) {
  this.itemsWrapper = $('.marketplace .items_wrapper'); //this.itemsWrapper.mCustomScrollbar({theme: 'ogame'})

  this.loadingIndicator = this.itemsWrapper.ogameLoadingIndicator();
  this.items = $('.marketplace .items');
  this.table = this.items.closest('.og-table');
};

Marketplace.prototype.refreshItems = function (htmlItems) {
  this.items.html(htmlItems);
  this.table.toggleClass('isScrollbarVisible', this.items.children().length > 5);
};

Marketplace.prototype.getSorting = function () {
  let sorting = {
    playerName: this.sortPlayerName.getOrder(),
    price: this.sortPrice.getOrder(),
    deliveryTime: this.sortDelivery.getOrder()
  };
  return sorting;
};

Marketplace.prototype.getFilters = function () {
  let filters = {};
  filters.resourceId = $('#filterResources').val();
  filters.shipId = $('#filterShips').val();
  filters.tradableItemId = $('#filterItems').val();
  filters.priceType = $('#filterPriceType').val();
  return filters;
};

Marketplace.prototype.getPagination = function () {
  let pagination = {};
  pagination.page = this.pagination.getPage();
  return pagination;
}; //
// Tab: buying
//


Marketplace.prototype.initTabBuying = function (cfg) {
  this.initItemsCommon(cfg);
  this.urlFetchBuyingItems = cfg.urlFetchBuyingItems || null;
  this.urlAccept = cfg.urlAccept;
  this.sortPlayerName = $('#sortPlayerName').ogameSortable({
    allowUnsorted: true,
    order: '',
    _token: this.token,
    onChange: this.onSortChangeBuying.bind(this)
  });
  this.sortDelivery = $('#sortDelivery').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeBuying.bind(this)
  });
  this.sortPrice = $('#sortPrice').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeBuying.bind(this)
  });
  this.pagination = $('.marketplace .pagination_wrapper').ogamePaginatable({
    page: 1,
    numPages: 1,
    _token: this.token,
    onChange: this.onPaginationChangeBuying.bind(this)
  });
  $('#showFilterResources, #showFilterShips, #showFilterItems, #filterResources, #filterShips, #filterItems, #filterPriceType').on('change', this.onFilterChangeBuying.bind(this));
  this.items.on('click', '.item a.og-button.submit', this.onClickBuyingItem.bind(this));
  this.fetchBuyingItems();
};

Marketplace.prototype.onClickPriceMin = function (e) {
  e.preventDefault();
  let price = $(e.currentTarget).data('priceMin');
  this.inputPrice.val(price);

  if (this.quantity > 0) {
    this.setPrice(parseFloat(price));
  } else {
    this.setPrice(0);
  }
};

Marketplace.prototype.onClickPriceMax = function (e) {
  e.preventDefault();
  let price = $(e.currentTarget).data('priceMax');
  this.inputPrice.val(price);

  if (this.quantity > 0) {
    this.setPrice(parseFloat(price));
  } else {
    this.setPrice(0);
  }
};

Marketplace.prototype.onClickBuyingItem = function (e) {
  e.preventDefault();
  let marketItemId = $(e.currentTarget).data('itemid');
  let itemToken = $(e.currentTarget).data('_token');
  this.submitAcceptBuying(marketItemId, itemToken);
};

Marketplace.prototype.onSortChangeBuying = function (e) {
  this.token = e.token;
  this.fetchBuyingItems();
};

Marketplace.prototype.onFilterChangeBuying = function (e) {
  this.token = e.token;
  this.fetchBuyingItems();
};

Marketplace.prototype.onPaginationChangeBuying = function (e) {
  this.token = e.token;
  this.fetchBuyingItems();
};

Marketplace.prototype.onPaginationChangeHistoryBuying = function (e) {
  this.token = e.token;
  this.fetchHistoryBuyingItems();
};

Marketplace.prototype.onPaginationChangeHistorySelling = function (e) {
  this.token = e.token;
  this.fetchHistorySellingItems();
};

Marketplace.prototype.fetchBuyingItems = function () {
  this.loadingIndicator.show();
  let data = {
    sorting: this.getSorting(),
    filters: this.getFilters(),
    pagination: this.getPagination(),
    _token: this.token
  };
  $.getJSON(this.urlFetchBuyingItems, data, this.onFetchBuyingItems.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.onFetchBuyingItems = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newToken);
  this.refreshItems(htmlItems);
};

Marketplace.prototype.submitAcceptBuying = function (marketItemId, itemToken) {
  let params = {
    marketItemId: marketItemId,
    _token: itemToken
  };
  this.loadingIndicator.show();
  $.post(this.urlAccept, params, this.handleSubmitAcceptBuyingResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.handleSubmitAcceptBuyingResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newToken);

  if (status === 'success') {
    this.fetchBuyingItems();
    fadeBox(data.message, false);
    getAjaxEventbox();
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
}; //
// Tab: selling
//


Marketplace.prototype.initTabSelling = function (cfg) {
  this.initItemsCommon(cfg);
  this.urlFetchSellingItems = cfg.urlFetchSellingItems || null;
  this.urlAccept = cfg.urlAccept;
  this.sortPlayerName = $('#sortPlayerName').ogameSortable({
    allowUnsorted: true,
    order: '',
    _token: this.token,
    onChange: this.onSortChangeSelling.bind(this)
  });
  this.sortDelivery = $('#sortDelivery').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeSelling.bind(this)
  });
  this.sortPrice = $('#sortPrice').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeSelling.bind(this)
  });
  this.pagination = $('.marketplace .pagination_wrapper').ogamePaginatable({
    page: 1,
    numPages: 1,
    _token: this.token,
    onChange: this.onPaginationChangeSelling.bind(this)
  });
  $('#showFilterResources, #showFilterShips, #showFilterItems, #filterResources, #filterShips, #filterItems, #filterPriceType').on('change', this.onFilterChangeSelling.bind(this));
  this.items.on('click', '.item .og-button.submit', this.onClickSellingItem.bind(this));
  this.fetchSellingItems();
};

Marketplace.prototype.onClickSellingItem = function (e) {
  e.preventDefault();
  let marketItemId = $(e.currentTarget).data('itemid');
  let itemToken = $(e.currentTarget).data('_token');
  this.submitAcceptSelling(marketItemId, itemToken);
};

Marketplace.prototype.onSortChangeSelling = function (e) {
  this.token = e.token;
  this.fetchSellingItems();
};

Marketplace.prototype.onFilterChangeSelling = function (e) {
  this.token = e.token;
  this.fetchSellingItems();
};

Marketplace.prototype.onPaginationChangeSelling = function (e) {
  this.token = e.token;
  this.fetchSellingItems();
};

Marketplace.prototype.fetchSellingItems = function () {
  this.loadingIndicator.show();
  let data = {
    sorting: this.getSorting(),
    filters: this.getFilters(),
    pagination: this.getPagination(),
    _token: this.token
  };
  $.getJSON(this.urlFetchSellingItems, data, this.onFetchSellingItems.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.onFetchSellingItems = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newToken);
  this.refreshItems(htmlItems);
};

Marketplace.prototype.submitAcceptSelling = function (marketItemId, itemToken) {
  let params = {
    marketItemId: marketItemId,
    _token: itemToken
  };
  this.loadingIndicator.show();
  $.post(this.urlAccept, params, this.handleSubmitAcceptSellingResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.handleSubmitAcceptSellingResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newToken);

  if (status === 'success') {
    this.fetchSellingItems();
    fadeBox(data.message, false);
    getAjaxEventbox();
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
}; //
// Tab: overview
//


Marketplace.prototype.initTabOverview = function (cfg) {
  this.initItemsCommon();
  this.urlFetchOverviewItems = cfg.urlFetchOverviewItems || null;
  this.items.on('click', '.og-button.delete', this.onClickDeleteItem.bind(this));
  this.sortType = $('#sortType').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeOverview.bind(this)
  });
  this.sortPrice = $('#sortPrice').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeOverview.bind(this)
  });
  this.pagination = $('.marketplace .pagination_wrapper').ogamePaginatable({
    page: 1,
    numPages: 1,
    _token: this.token,
    onChange: this.onPaginationChangeOverview.bind(this)
  });
  this.fetchOverviewItems();
};

Marketplace.prototype.getOverviewSorting = function () {
  let sorting = {
    type: this.sortType.getOrder(),
    price: this.sortPrice.getOrder()
  };
  return sorting;
};

Marketplace.prototype.onSortChangeOverview = function (e) {
  this.token = e.token;
  this.fetchOverviewItems();
};

Marketplace.prototype.onPaginationChangeOverview = function (e) {
  this.token = e.token;
  this.fetchOverviewItems();
};

Marketplace.prototype.onClickDeleteItem = function (e) {
  e.stopPropagation();
  e.preventDefault();
  this.loadingIndicator.show();
  let urlDelete = e.currentTarget.href;
  let params = {
    _token: this.token
  };
  let that = this;
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.LOCA_MARKET_CANCELLATION_NOTE, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    $.post(urlDelete, params, that.handleSubmitDeleteResponse.bind(that)).done(that.onAjaxDone.bind(that));
  }, function () {
    that.loadingIndicator.hide();
  });
};

Marketplace.prototype.handleSubmitDeleteResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newToken);

  if (status === 'success') {
    this.fetchOverviewItems();
    getAjaxEventbox();
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
};

Marketplace.prototype.onItemDeleted = function () {
  this.onAjaxDone();
};

Marketplace.prototype.fetchOverviewItems = function () {
  this.loadingIndicator.show();
  let data = {
    sorting: this.getOverviewSorting(),
    pagination: this.getPagination(),
    _token: this.token
  };
  $.getJSON(this.urlFetchOverviewItems, data, this.onFetchOverviewItems.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.onFetchOverviewItems = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newToken);
  this.refreshItems(htmlItems);
}; //
// Tab: statistics
//


Marketplace.prototype.initTabStatistics = function (cfg) {
  let statisticsChartData = cfg.statisticsChartData || null;
  this.lineChart = $('#chart_container').ogameLineChart(statisticsChartData);
  $('#showRatioMetal').on('change', this.refreshLineChart.bind(this));
  $('#showRatioCrystal').on('change', this.refreshLineChart.bind(this));
  $('#showRatioDeuterium').on('change', this.refreshLineChart.bind(this));
  this.refreshLineChart();
};

Marketplace.prototype.refreshLineChart = function () {
  this.lineChart.setDataSetVisible('metal', $('#showRatioMetal').is(':checked'));
  this.lineChart.setDataSetVisible('crystal', $('#showRatioCrystal').is(':checked'));
  this.lineChart.setDataSetVisible('deuterium', $('#showRatioDeuterium').is(':checked'));
  this.lineChart.render();
}; //
// Tab: history_buying
//


Marketplace.prototype.initTabHistoryBuying = function (cfg) {
  this.initItemsCommon();
  this.urlCollectItem = cfg.urlCollectItem;
  this.urlCollectPrice = cfg.urlCollectPrice;
  this.urlFetchHistoryBuyingItems = cfg.urlFetchHistoryBuyingItems || null;
  this.sortPayment = $('#sortPayment').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeHistoryBuying.bind(this)
  });
  this.sortDate = $('#sortDate').ogameSortable({
    allowUnsorted: true,
    order: 'desc',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeHistoryBuying.bind(this)
  });
  this.pagination = $('.marketplace .pagination_wrapper').ogamePaginatable({
    page: 1,
    numPages: 1,
    _token: this.token,
    onChange: this.onPaginationChangeHistoryBuying.bind(this)
  });
  this.items.on('click', '.item a.og-button.submit.collect-item', this.onClickCollectItem.bind(this));
  this.items.on('click', '.item a.og-button.submit.collect-price', this.onClickCollectPrice.bind(this));
  this.fetchHistoryBuyingItems();
};

Marketplace.prototype.onClickCollectItem = function (e) {
  e.preventDefault();
  let marketTransactionId = $(e.currentTarget).data('transactionid');
  let itemToken = $(e.currentTarget).data('_token');
  this.submitCollectItem(marketTransactionId, itemToken);
};

Marketplace.prototype.submitCollectItem = function (marketTransactionId, itemToken) {
  let params = {
    marketTransactionId: marketTransactionId,
    _token: itemToken
  };
  this.loadingIndicator.show();
  $.post(this.urlCollectItem, params, this.handleSubmitCollectItemResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.handleSubmitCollectItemResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  let statusMessage = data.statusMessage || '';
  let marketTransactionId = data.marketTransactionId || 0;
  this.updateToken(data.newToken);

  if (status === 'success') {
    $('.row.item[data-transactionid="' + marketTransactionId + '"] .col.date').show();
    $("a[data-token]").each(function () {
      $(this).data('_token', data.newToken);
      $(this).attr("data-token", data.newToken);
    });
    $('.collect-item[data-transactionid="' + marketTransactionId + '"]').parent().hide();
    fadeBox(data.message, false);
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
};

Marketplace.prototype.onClickCollectPrice = function (e) {
  e.preventDefault();
  let marketTransactionId = $(e.currentTarget).data('transactionid');
  let itemToken = $(e.currentTarget).data('_token');
  this.submitCollectPrice(marketTransactionId, itemToken);
};

Marketplace.prototype.submitCollectPrice = function (marketTransactionId, itemToken) {
  let params = {
    marketTransactionId: marketTransactionId,
    _token: itemToken
  };
  this.loadingIndicator.show();
  $.post(this.urlCollectPrice, params, this.handleSubmitCollectPriceResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.handleSubmitCollectPriceResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  let statusMessage = data.statusMessage || '';
  let marketTransactionId = data.marketTransactionId || 0;
  this.updateToken(data.newToken);

  if (status === 'success') {
    $('.row.item[data-transactionid="' + marketTransactionId + '"] .col.date').show();
    $("a[data-token]").each(function () {
      $(this).data('_token', data.newToken);
      $(this).attr("data-token", data.newToken);
    });
    $('.collect-price[data-transactionid="' + marketTransactionId + '"]').parent().hide();
    fadeBox(data.message, false);
    getAjaxResourcebox();
  } else {
    this.displayErrors(data.errors);
  }
};

Marketplace.prototype.getHistorySorting = function () {
  return {
    price: this.sortPayment.getOrder(),
    date: this.sortDate.getOrder()
  };
};

Marketplace.prototype.fetchHistoryBuyingItems = function () {
  this.loadingIndicator.show();
  let data = {
    sorting: this.getHistorySorting(),
    pagination: this.getPagination(),
    _token: this.token
  };
  $.getJSON(this.urlFetchHistoryBuyingItems, data, this.onFetchHistoryBuyingItems.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.onFetchHistoryBuyingItems = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newToken);
  this.refreshItems(htmlItems);
};

Marketplace.prototype.onSortChangeHistoryBuying = function (e) {
  this.token = e.token;
  this.fetchHistoryBuyingItems();
}; //
// Tab: history_selling
//


Marketplace.prototype.initTabHistorySelling = function (cfg) {
  this.initItemsCommon();
  this.urlCollectItem = cfg.urlCollectItem;
  this.urlCollectPrice = cfg.urlCollectPrice;
  this.sortPayment = $('#sortPayment').ogameSortable({
    allowUnsorted: true,
    order: '',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeHistorySelling.bind(this)
  });
  this.sortDate = $('#sortDate').ogameSortable({
    allowUnsorted: true,
    order: 'desc',
    align: 'center',
    _token: this.token,
    onChange: this.onSortChangeHistorySelling.bind(this)
  });
  this.pagination = $('.marketplace .pagination_wrapper').ogamePaginatable({
    page: 1,
    numPages: 1,
    _token: this.token,
    onChange: this.onPaginationChangeHistorySelling.bind(this)
  });
  this.urlFetchHistorySellingItems = cfg.urlFetchHistorySellingItems || null;
  this.items.on('click', '.item a.og-button.submit.collect-item', this.onClickCollectItem.bind(this));
  this.items.on('click', '.item a.og-button.submit.collect-price', this.onClickCollectPrice.bind(this));
  this.fetchHistorySellingItems();
};

Marketplace.prototype.fetchHistorySellingItems = function () {
  this.loadingIndicator.show();
  let data = {
    sorting: this.getHistorySorting(),
    pagination: this.getPagination(),
    _token: this.token
  };
  $.getJSON(this.urlFetchHistorySellingItems, data, this.onFetchHistorySellingItems.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.onFetchHistorySellingItems = function (data) {
  let htmlItems = data.content[data.target];
  this.updateToken(data.newToken);
  this.refreshItems(htmlItems);
};

Marketplace.prototype.onSortChangeHistorySelling = function (e) {
  this.token = e.token;
  this.fetchHistorySellingItems();
}; //
// Tab: create_offer
//


Marketplace.prototype.initTabCreateOffer = function (cfg) {
  this.content = $('.marketplace .content');
  this.loadingIndicator = this.content.ogameLoadingIndicator();
  this.ITEM_TYPE_SHIP = cfg.itemTypes.ITEM_TYPE_SHIP;
  this.ITEM_TYPE_RESOURCE = cfg.itemTypes.ITEM_TYPE_RESOURCE;
  this.ITEM_TYPE_TRADABLE_ITEM = cfg.itemTypes.ITEM_TYPE_TRADABLE_ITEM;
  this.MARKET_ITEM_TYPE_SELL_ORDER = cfg.marketItemTypes.SELL_ORDER;
  this.MARKET_ITEM_TYPE_BUY_ORDER = cfg.marketItemTypes.BUY_ORDER;
  this.RESOURCE_TYPE_METAL = cfg.resourceTypes.RESOURCE_TYPE_METAL;
  this.RESOURCE_TYPE_CRYSTAL = cfg.resourceTypes.RESOURCE_TYPE_CRYSTAL;
  this.RESOURCE_TYPE_DEUTERIUM = cfg.resourceTypes.RESOURCE_TYPE_DEUTERIUM;
  this.urlSubmitOffer = cfg.urlSubmitOffer;
  this.marketItemTypes = cfg.marketItemTypes;
  this.formSteps = cfg.formSteps;
  this.itemTypes = cfg.itemTypes;
  this.itemOptions = cfg.itemOptions;
  this.priceTypeOptions = cfg.priceTypeOptions;
  this.currentRatio = cfg.priceValidation.currentRatio;
  this.priceRangeLower = cfg.priceValidation.priceRangeLower;
  this.priceRangeUpper = cfg.priceValidation.priceRangeUpper;
  this.defaultPriceRange = cfg.defaultPriceRange;
  this.marketFee = cfg.marketFee;
  this.itemBox = $('.marketplace #itemBox');
  this.inputMarketItemType = $('.marketplace input[name="type"]');
  this.inputItemType = $('.marketplace input[name="itemType"]');
  this.inputQuantity = $('.marketplace input[name="quantity"]');
  this.inputPrice = $('.marketplace input[name="price"]');
  this.priceLimit = $('.marketplace #priceLimit');
  this.priceLimitMin = $('.marketplace #priceLimit #priceMin');
  this.priceLimitMax = $('.marketplace #priceLimit #priceMax');
  this.priceInformation = $('#orderPriceInformation');
  this.priceToPay = $('#priceToPay');
  this.priceInTotal = $('#priceInTotal');
  this.priceRangeValue = $('#priceRangeValue');
  this.marketFeeElem = $('.marketplace #marketFee');
  this.marketFeeColElem = $('.marketplace #colMarketFee');
  this.dropDownItemId = $('.marketplace #itemId');
  this.dropDownPriceType = $('.marketplace #priceType');
  this.dropDownPriceRange = $('.marketplace #priceRange');
  this.btnSubmitOffer = $('#submitOffer');
  this.dropDownPriceType.ogameDropDown();
  this.dropDownPriceRange.ogameDropDown();
  this.btnOptSellRequest = $('#btnOptSellRequest');
  this.btnOptBuyRequest = $('#btnOptBuyRequest');
  this.btnOptSellOrder = $('#btnOptSellOrder');
  this.btnOptBuyOrder = $('#btnOptBuyOrder');
  this.btnOptShips = $('#btnOptShips');
  this.btnOptResources = $('#btnOptResources');
  this.btnOptItems = $('#btnOptItems');
  this.btnSubmitOffer.on('click', this.onClickSubmitOffer.bind(this));
  this.inputMarketItemType.on('change', this.onChangeMarketItemType.bind(this));
  this.inputItemType.on('change', this.onChangeItemType.bind(this));
  this.inputQuantity.on('blur', this.onChangeQuantity.bind(this));
  this.inputQuantity.on('focus', this.onFocusQuantity.bind(this));
  this.inputQuantity.on('keyup', this.onKeyInputQuantity.bind(this));
  this.inputPrice.on('blur', this.onChangePrice.bind(this));
  this.inputPrice.on('focus', this.onFocusPrice.bind(this));
  this.inputPrice.on('keyup', this.onKeyInputPrice.bind(this));
  this.dropDownItemId.on('change', this.onChangeItemId.bind(this));
  this.dropDownPriceType.on('change', this.onChangePriceType.bind(this));
  this.dropDownPriceRange.on('change', this.onChangePriceRange.bind(this));
  this.priceLimitMin.on('click', this.onClickPriceMin.bind(this));
  this.priceLimitMax.on('click', this.onClickPriceMax.bind(this));
  this.resetPriceType();
  this.resetMarketItemType();
  this.resetItemType();
  this.refreshAvailableItemTypes();
  this.resetPrice();
  this.resetPriceRange();
  this.refreshMarketItemTypes();
  this.refreshFormSteps();
  this.refreshItemTypes();
  this.refreshItemIdOptions();
  this.refreshItemId();
  this.refreshItemBox();
  this.refreshPriceRangeVisiblity();
  this.refreshPrice();
};

Marketplace.prototype.onClickSubmitOffer = function (e) {
  e.preventDefault();
  this.submitOffer();
};

Marketplace.prototype.refreshAvailableItemTypes = function () {
  let minQuantity = this.getMinQuantityByItemType(this.ITEM_TYPE_SHIP);
  let itemOptions = this.getItemOptionsByItemType(this.ITEM_TYPE_SHIP, minQuantity);

  if (this.MARKET_ITEM_TYPE_SELL_ORDER === this.marketItemType) {
    this.marketFeeColElem.show();

    if (itemOptions.length == 0) {
      this.btnOptShips.attr('disabled', 'disabled');
      $("label[for='btnOptShips']").addClass('disabled');
    }
  } else if (this.MARKET_ITEM_TYPE_BUY_ORDER === this.marketItemType) {
    this.marketFeeColElem.hide();
    this.btnOptShips.removeAttr('disabled');
    $("label[for='btnOptShips']").removeClass('disabled');
  }

  minQuantity = this.getMinQuantityByItemType(this.ITEM_TYPE_TRADABLE_ITEM);
  itemOptions = this.getItemOptionsByItemType(this.ITEM_TYPE_TRADABLE_ITEM, minQuantity);

  if (this.MARKET_ITEM_TYPE_SELL_ORDER === this.marketItemType) {
    this.marketFeeColElem.show();

    if (itemOptions.length == 0) {
      this.btnOptItems.attr('disabled', 'disabled');
      $("label[for='btnOptItems']").addClass('disabled');
    }
  } else if (this.MARKET_ITEM_TYPE_BUY_ORDER === this.marketItemType) {
    this.marketFeeColElem.hide();
    this.btnOptItems.removeAttr('disabled');
    $("label[for='btnOptItems']").removeClass('disabled');
  }
};

Marketplace.prototype.submitOffer = function () {
  let params = {
    marketItemType: this.marketItemType,
    itemType: this.itemType,
    itemId: this.itemId,
    quantity: this.quantity,
    priceType: this.priceType,
    price: this.price,
    _token: this.token
  };

  if (this.isOrder()) {
    params.priceRange = this.priceRange;
  }

  this.loadingIndicator.show();
  $.post(this.urlSubmitOffer, params, this.handleSubmitOfferResponse.bind(this)).done(this.onAjaxDone.bind(this));
};

Marketplace.prototype.handleSubmitOfferResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.updateToken(data.newToken);

  if (status === 'success') {
    window.location = data.redirectUrl;
  } else {
    this.displayErrors(data.errors);
  }
};

Marketplace.prototype.resetMarketItemType = function () {
  this.setMarketItemType(this.getFirstMarketItemType());
};

Marketplace.prototype.setMarketItemType = function (marketItemType) {
  let marketItemTypeOld = this.marketItemType;
  this.marketItemType = parseInt(marketItemType);

  if (this.marketItemType !== marketItemTypeOld) {
    if (this.marketItemType === this.MARKET_ITEM_TYPE_BUY_ORDER) {
      this.priceInformation.show();
    }

    if (this.marketItemType === this.MARKET_ITEM_TYPE_SELL_ORDER) {
      this.priceInformation.hide();
    }

    this.resetItemType();
    this.resetItemId();
    this.refreshAvailableItemTypes();
    this.refreshItemTypes();
    this.refreshItemIdOptions();
    this.refreshItemId();
    this.refreshItemBox();
    this.refreshFormSteps();
    this.refreshPriceRangeVisiblity();
  }
};

Marketplace.prototype.resetItemType = function () {
  this.setItemType(this.getFirstItemType());
};

Marketplace.prototype.setItemType = function (itemType) {
  let itemTypeOld = this.itemType;
  this.itemType = parseInt(itemType);

  if (itemTypeOld !== this.itemType) {
    this.resetItemId();
    this.resetPriceTypeOnEqualResource();
    this.refreshItemTypes();
    this.refreshItemIdOptions();
    this.refreshItemId();
    this.refreshItemBox();
  }
};

Marketplace.prototype.resetItemId = function () {
  this.setItemId(this.getFirstItemId(this.itemType));
};

Marketplace.prototype.setItemId = function (itemId) {
  // tradable items use string ids
  if (this.itemType !== this.ITEM_TYPE_TRADABLE_ITEM) {
    itemId = parseInt(itemId);
  }

  let itemIdOld = this.itemId;
  this.itemId = itemId;

  if (itemIdOld !== this.itemId) {
    this.refreshItemBox();
    this.resetQuantity();
    this.resetPriceTypeOnEqualResource();
  }
};

Marketplace.prototype.resetPriceTypeOnEqualResource = function () {
  // can not trade e.g. metal for metal
  if (this.itemType === this.ITEM_TYPE_RESOURCE && this.itemId === this.priceType) {
    switch (this.itemId) {
      case this.RESOURCE_TYPE_METAL:
        this.setPriceType(this.RESOURCE_TYPE_CRYSTAL);
        break;

      case this.RESOURCE_TYPE_CRYSTAL:
        this.setPriceType(this.RESOURCE_TYPE_DEUTERIUM);
        break;

      case this.RESOURCE_TYPE_DEUTERIUM:
        this.setPriceType(this.RESOURCE_TYPE_METAL);
        break;
    }
  }
};

Marketplace.prototype.getDefaultQuantity = function () {
  let itemOption = this.getItemOption(this.itemType, this.itemId);
  return itemOption.minQuantity;
};

Marketplace.prototype.resetQuantity = function () {
  this.setQuantity(this.getDefaultQuantity(), true);
};

Marketplace.prototype.setQuantity = function (quantity, refresh) {
  refresh = refresh || false;
  let quantityOld = this.quantity;
  let itemOption = this.getItemOption(this.itemType, this.itemId);
  let quantityMax = itemOption !== undefined ? Math.min(itemOption.quantity, itemOption.maxQuantity) : 0;
  quantityMax = Math.min(quantityMax, this.constants.MARKET_MAX_QUANTITY);

  if (this.isSelling()) {
    this.quantity = clampInt(quantity, itemOption.minQuantity, quantityMax);
  }

  if (this.isBuying()) {
    this.quantity = clampInt(quantity, itemOption.minQuantity, this.constants.MARKET_MAX_QUANTITY);
  }

  if (this.quantity !== quantityOld || this.quantity !== parseInt(quantity) || refresh === true) {
    this.resetPrice();
    this.refreshQuantity();
    this.refreshPrice();
    this.refreshPriceLimit();
  }
};

Marketplace.prototype.resetPrice = function () {
  let price = this.getPriceCalculated(this.quantity);
  this.setPrice(price);
};

Marketplace.prototype.setPrice = function (price) {
  let priceOld = this.price;
  let priceCalculated = this.getPriceCalculated(this.quantity);
  let priceMin = this.getPriceMin(this.quantity);
  let priceMax = this.getPriceMax(this.quantity);

  if (priceCalculated === undefined || priceMin === undefined || priceMax === undefined || this.quantity === 0) {
    this.price = 0;
  } else {
    this.price = clampFloat(price, priceMin, priceMax);
  }

  if (this.price !== priceOld || this.price !== price) {
    this.refreshPrice();
    this.refreshPriceValidation();
    this.refreshPriceLimit();
  }
};

Marketplace.prototype.resetPriceType = function () {
  this.setPriceType(this.getFirstResourceType());
  this.refreshPriceType();
};

Marketplace.prototype.setPriceType = function (priceType) {
  let priceTypeOld = this.priceType;
  this.priceType = parseInt(priceType);

  if (this.priceType !== priceTypeOld) {
    this.resetPrice();
    this.refreshPriceType();
  }
};

Marketplace.prototype.resetPriceRange = function () {
  this.setPriceRange(this.defaultPriceRange);
};

Marketplace.prototype.setPriceRange = function (priceRange) {
  let priceRangeOld = this.priceRange;
  this.priceRange = parseInt(priceRange);

  if (this.priceRange !== priceRangeOld) {
    this.refreshPrice();
  }
};

Marketplace.prototype.onChangeMarketItemType = function (e) {
  this.setMarketItemType($('.marketplace input[name="type"]:checked').val());
};

Marketplace.prototype.onChangeItemType = function (e) {
  this.setItemType($('.marketplace input[name="itemType"]:checked').val());
};

Marketplace.prototype.onChangeItemId = function (e) {
  this.setItemId(this.dropDownItemId.val());
};

Marketplace.prototype.onChangeQuantity = function (e) {
  this.setQuantity(this.inputQuantity.val());
};

Marketplace.prototype.onFocusQuantity = function (e) {
  this.inputQuantity.val('');
};

Marketplace.prototype.onKeyInputQuantity = function (e) {
  if (e.which == 75) {
    let val = parseInt($(e.target).val()) || 0;

    if (val == 0) {
      val = 1;
    }

    val = val + '000';
    $(e.target).val(val);
  }
};

Marketplace.prototype.onChangePrice = function (e) {
  if (this.quantity > 0) {
    this.setPrice(parseFloat(this.inputPrice.val()));
  } else {
    this.setPrice(0);
  }
};

Marketplace.prototype.onFocusPrice = function (e) {
  this.inputPrice.val('');
};

Marketplace.prototype.onKeyInputPrice = function (e) {
  if (e.which == 75) {
    let val = parseInt($(e.target).val()) || 0;

    if (val == 0) {
      val = 1;
    }

    val = val + '000';
    $(e.target).val(val);
  }
};

Marketplace.prototype.onChangePriceType = function (e) {
  this.setPriceType(this.dropDownPriceType.val());
};

Marketplace.prototype.onChangePriceRange = function (e) {
  this.setPriceRange(this.dropDownPriceRange.val());
  this.refreshPriceInformation();
};

Marketplace.prototype.refreshMarketItemTypes = function () {
  this.btnOptSellOrder.prop('checked', this.marketItemType === this.MARKET_ITEM_TYPE_SELL_ORDER);
  this.btnOptBuyOrder.prop('checked', this.marketItemType === this.MARKET_ITEM_TYPE_BUY_ORDER);
};

Marketplace.prototype.refreshFormSteps = function () {
  let formSteps = this.formSteps[this.marketItemType] || [];
  $('.marketplace .og-sub-step.sub-step-1').html(formSteps[0] || '');
  $('.marketplace .og-sub-step.sub-step-2').html(formSteps[1] || '');
  $('.marketplace .og-sub-step.sub-step-3').html(formSteps[2] || '');
};

Marketplace.prototype.refreshItemTypes = function () {
  this.btnOptShips.prop('checked', this.itemType === this.ITEM_TYPE_SHIP);
  this.btnOptResources.prop('checked', this.itemType === this.ITEM_TYPE_RESOURCE);
  this.btnOptItems.prop('checked', this.itemType === this.ITEM_TYPE_TRADABLE_ITEM);
};

Marketplace.prototype.refreshItemBox = function () {
  let itemOption = this.getItemOption(this.itemType, this.itemId);

  if (itemOption) {
    let html = '';

    if (itemOption.type === this.ITEM_TYPE_TRADABLE_ITEM) {
      html = '<img src="' + itemOption.itemImage + '"/>';
    } else {
      html = '<div class="sprite ' + itemOption.cssClass + '"></div>';
    }

    this.itemBox.find('.thumbnail').html(html);
    this.itemBox.find('.quantity').html(tsdpkt(itemOption.quantity));
  } else {
    this.itemBox.find('.thumbnail').html('');
    this.itemBox.find('.quantity').html('-');
  }
};

Marketplace.prototype.refreshItemIdOptions = function () {
  this.dropDownItemId.ogameDropDown('destroy');
  this.dropDownItemId.html('');
  let htmlOptions = '';

  if (this.ITEM_TYPE_SHIP === this.itemType && this.MARKET_ITEM_TYPE_SELL_ORDER === this.marketItemType) {
    this.itemOptions.ships.forEach(function (option) {
      if (option.quantity > 0) {
        htmlOptions += '<option value="' + option.value + '">' + option.name + '</option>';
      }
    });
  }

  if (this.ITEM_TYPE_SHIP === this.itemType && this.MARKET_ITEM_TYPE_BUY_ORDER === this.marketItemType) {
    this.itemOptions.ships.forEach(function (option) {
      htmlOptions += '<option value="' + option.value + '">' + option.name + '</option>';
    });
  }

  if (this.ITEM_TYPE_RESOURCE === this.itemType) {
    this.itemOptions.resources.forEach(function (option) {
      htmlOptions += '<option value="' + option.value + '">' + option.name + '</option>';
    });
  }

  if (this.ITEM_TYPE_TRADABLE_ITEM === this.itemType && this.MARKET_ITEM_TYPE_SELL_ORDER === this.marketItemType) {
    this.itemOptions.items.forEach(function (option) {
      if (option.quantity > 0) {
        htmlOptions += '<option value="' + option.value + '">' + option.name + '</option>';
      }
    });
  }

  if (this.ITEM_TYPE_TRADABLE_ITEM === this.itemType && this.MARKET_ITEM_TYPE_BUY_ORDER === this.marketItemType) {
    this.itemOptions.items.forEach(function (option) {
      htmlOptions += '<option value="' + option.value + '">' + option.name + '</option>';
    });
  }

  this.dropDownItemId.html(htmlOptions).ogameDropDown();
};

Marketplace.prototype.refreshItemId = function () {
  this.dropDownItemId.find('option').removeAttr('selected');

  if (this.itemId) {
    this.dropDownItemId.find('option[value="' + this.itemId + '"]').attr('selected', 'selected');
  }
};

Marketplace.prototype.refreshQuantity = function () {
  this.inputQuantity.val(this.quantity);
};

Marketplace.prototype.refreshPriceRangeVisiblity = function () {
  if (this.isOrder()) {
    $('#colPriceRange').show();
  } else {
    $('#colPriceRange').hide();
  }
};

Marketplace.prototype.refreshPrice = function () {
  this.refreshPriceRange();
  let priceTotal = parseInt(this.price);
  this.inputPrice.val(priceTotal);
  this.refreshPriceLimit();
  this.refreshMarketFee();
  this.refreshPriceInformation();
};

Marketplace.prototype.refreshPriceType = function () {
  this.dropDownPriceType.find('option').removeAttr('selected');

  if (this.priceType) {
    this.dropDownPriceType.val(this.priceType);
    this.dropDownPriceType.find('option[value="' + this.priceType + '"]').attr('selected', 'selected');
    this.dropDownPriceType.ogameDropDown('refresh');
  }
};

Marketplace.prototype.refreshPriceRange = function () {
  this.dropDownPriceRange.find('option').removeAttr('selected');

  if (this.priceRange) {
    this.dropDownPriceRange.find('option[value="' + this.priceRange + '"]').attr('selected', 'selected');
    this.dropDownPriceRange.val(this.priceRange);
    this.dropDownPriceRange.ogameDropDown('refresh');
  }
};

Marketplace.prototype.refreshPriceLimit = function () {
  let priceMin = this.getPriceMin(this.quantity);
  let priceMax = this.getPriceMax(this.quantity);

  if (priceMin === undefined || priceMax === undefined) {
    this.priceLimitMin.html('');
    this.priceLimitMax.html('');
    this.priceLimitMin.data('priceMin', 0);
    this.priceLimitMax.data('priceMax', 0);
  } else {
    this.priceLimitMin.html(tsdpkt(priceMin));
    this.priceLimitMin.data('priceMin', priceMin);
    this.priceLimitMax.html(tsdpkt(priceMax));
    this.priceLimitMax.data('priceMax', priceMax);
  }
};

Marketplace.prototype.refreshPriceValidation = function () {};

Marketplace.prototype.refreshMarketFee = function () {
  let priceTypeOption = this.getPriceTypeOption(this.priceType);

  if (this.isOrder()) {
    let priceMin = this.getPriceMin(this.quantity);
    let priceMax = this.getPriceMax(this.quantity);
    let feeMin = Math.floor(this.price * (1.0 - this.priceRange / 100) * this.marketFee);
    let feeMax = Math.floor(this.price * (1.0 + this.priceRange / 100) * this.marketFee);
    this.marketFeeElem.html(tsdpkt(feeMin) + ' - ' + tsdpkt(feeMax) + ' ' + priceTypeOption.name);
  } else {
    let fee = Math.floor(this.price * this.marketFee);
    this.marketFeeElem.html(tsdpkt(fee) + ' ' + priceTypeOption.name);
  }
};

Marketplace.prototype.refreshPriceInformation = function () {
  let priceToPayCalc = Math.floor(this.price * (1 + $("#priceRange option:selected").val() / 100));
  this.priceToPay.html(tsdpkt(priceToPayCalc));
  this.priceInTotal.html(tsdpkt(this.price));
  this.priceRangeValue.html($("#priceRange option:selected").text());
};

Marketplace.prototype.getFirstMarketItemType = function () {
  return parseInt(this.marketItemTypes[Object.keys(this.marketItemTypes)[0]]);
};

Marketplace.prototype.getFirstItemType = function () {
  let itemType = parseInt(this.itemTypes[Object.keys(this.itemTypes)[0]]);
  let minQuantity = this.getMinQuantityByItemType(itemType);
  let itemOptions = this.getItemOptionsByItemType(itemType, minQuantity);

  if (itemOptions.length == 0) {
    return this.ITEM_TYPE_RESOURCE;
  }

  return parseInt(this.itemTypes[Object.keys(this.itemTypes)[0]]);
};

Marketplace.prototype.getMinQuantityByItemType = function (itemType) {
  if ((this.ITEM_TYPE_TRADABLE_ITEM === itemType || this.ITEM_TYPE_SHIP === itemType) && this.MARKET_ITEM_TYPE_SELL_ORDER === this.marketItemType) {
    return 1;
  }

  return 0;
};

Marketplace.prototype.getItemOptionsByItemType = function (itemType, minQuantity) {
  let itemOptionsSelected = [];

  if (itemType === undefined) {
    return itemOptionsSelected;
  }

  let items;

  switch (itemType) {
    case this.ITEM_TYPE_SHIP:
      items = this.itemOptions.ships;
      break;

    case this.ITEM_TYPE_RESOURCE:
      items = this.itemOptions.resources;
      break;

    case this.ITEM_TYPE_TRADABLE_ITEM:
      items = this.itemOptions.items;
      break;
  }

  for (let i = 0; i < items.length; i++) {
    if (items[i].quantity >= minQuantity) {
      itemOptionsSelected.push(items[i]);
    }
  }

  return itemOptionsSelected;
};

Marketplace.prototype.getFirstItemId = function (itemType) {
  let minQuantity = this.getMinQuantityByItemType(itemType);
  let itemOptions = this.getItemOptionsByItemType(itemType, minQuantity);
  return itemOptions.length > 0 ? itemOptions[0].value : undefined;
};

Marketplace.prototype.getItemOption = function (itemType, itemId) {
  if (itemType === undefined) {
    return undefined;
  }

  let minQuantity = this.getMinQuantityByItemType(itemType);
  let itemOptions = this.getItemOptionsByItemType(itemType, minQuantity);
  return itemOptions.find(function (itemOption) {
    return itemOption.value === itemId;
  });
};

Marketplace.prototype.getPriceTypeOption = function (priceType) {
  return this.priceTypeOptions.find(function (priceTypeOption) {
    return priceTypeOption.value === priceType;
  });
};

Marketplace.prototype.getFirstResourceType = function () {
  return this.itemOptions.resources[0].value;
};

Marketplace.prototype.isOrder = function () {
  return this.marketItemType === this.MARKET_ITEM_TYPE_BUY_ORDER || this.marketItemType === this.MARKET_ITEM_TYPE_SELL_ORDER;
};

Marketplace.prototype.isBuying = function () {
  return this.marketItemType === this.MARKET_ITEM_TYPE_BUY_ORDER;
};

Marketplace.prototype.isSelling = function () {
  return this.marketItemType === this.MARKET_ITEM_TYPE_SELL_ORDER;
};

Marketplace.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

Marketplace.prototype.isPriceValid = function () {
  let priceCalculated = this.getPriceCalculated(this.quantity);
  let priceMin = this.getPriceMin(this.quantity);
  let priceMax = this.getPriceMax(this.quantity);

  if (priceCalculated === undefined || priceMin === undefined || priceMax === undefined) {
    return false;
  }

  return priceMin < priceCalculated && priceCalculated < priceMax;
};

Marketplace.prototype.getPriceCalculated = function (quantity) {
  let itemOption = this.getItemOption(this.itemType, this.itemId);

  if (itemOption === undefined) {
    return undefined;
  }

  return Math.floor(this.convertMCDTo(itemOption.priceCalculatedInMCD * quantity, this.priceType));
};

Marketplace.prototype.getPriceMin = function (quantity) {
  let priceCalculated = this.getPriceCalculated(quantity);

  if (priceCalculated !== undefined) {
    return this.calcMinPrice(priceCalculated);
  }

  return undefined;
};

Marketplace.prototype.getPriceMax = function (quantity) {
  let priceCalculated = this.getPriceCalculated(quantity);

  if (priceCalculated !== undefined) {
    return this.calcMaxPrice(priceCalculated);
  }

  return undefined;
};

Marketplace.prototype.convertMCDTo = function (mcd, priceType) {
  switch (priceType) {
    case this.RESOURCE_TYPE_METAL:
      return this.convertMCDToMetal(mcd);

    case this.RESOURCE_TYPE_CRYSTAL:
      return this.convertMCDToCrystal(mcd);

    case this.RESOURCE_TYPE_DEUTERIUM:
      return this.convertMCDToDeuterium(mcd);
  }

  return 0;
};

Marketplace.prototype.convertMCDToMetal = function (mcd) {
  return mcd;
};

Marketplace.prototype.convertMCDToCrystal = function (mcd) {
  return mcd * (this.currentRatio.crystal / this.currentRatio.metal);
};

Marketplace.prototype.convertMCDToDeuterium = function (mcd) {
  return mcd * (this.currentRatio.deuterium / this.currentRatio.metal);
};

Marketplace.prototype.calcMinPrice = function (priceCalculated) {
  return Math.max(Math.floor(priceCalculated * (1.0 - this.priceRangeLower)), 1);
};

Marketplace.prototype.calcMaxPrice = function (priceCalculated) {
  return Math.floor(priceCalculated * (1.0 + this.priceRangeUpper));
};

Marketplace.prototype.getMetalAvailable = function () {
  return this.getResourceAvailable(this.RESOURCE_TYPE_CRYSTAL);
};

Marketplace.prototype.getCrystalAvailable = function () {
  return this.getResourceAvailable(this.RESOURCE_TYPE_CRYSTAL);
};

Marketplace.prototype.getDeuteriumAvailable = function () {
  return this.getResourceAvailable(this.RESOURCE_TYPE_CRYSTAL);
};

Marketplace.prototype.getResourceAvailable = function (resourceType) {
  let itemOption = this.getItemOption(this.ITEM_TYPE_RESOURCE, resourceType);
  return itemOption !== undefined ? itemOption.quantity : 0;
};
function Missile(cfg) {
  this.token = cfg.token;
  this.interceptor = cfg.interceptor;
  this.maxInterceptor = cfg.maxInterceptor;
  this.interplanetary = cfg.interplanetary;
  this.maxInterplanetary = cfg.maxInterplanetary;
  this.urlMissileDestroy = cfg.urlMissileDestroy || null;
  this.initCommon(cfg);
}

Missile.prototype.onAjaxDone = function (response) {
  let data = JSON.parse(response);

  if (data.status === 'success') {
    $("#rocketsilo").parents('.overlayDiv').dialog('close');
    let technologyId = $("#technologydetails").data('technology-id');
    technologyDetails.show(technologyId);
    this.deattachCommon();
    $('.rocketlayer').remove();
  }
};

Missile.prototype.initCommon = function (cfg) {
  if ($('.rocketlayer').length > 1) {
    for (let i = 0; i < $('.rocketlayer').length - 1; i++) {
      $($('.rocketlayer')[i]).remove();
    }
  }

  this.missileInterceptor = $('#rocketsilo #destroy_' + this.interceptor);
  this.missileInterplanetary = $('#rocketsilo #destroy_' + this.interplanetary);
  this.destroyButton = $('#rocketsilo #destroyMissiles');
  this.deattachCommon();
  this.missileInterceptor.on('focus', this.onFocusInterceptor.bind(this));
  this.missileInterceptor.on('keyup', this.onKeyInputInterceptor.bind(this));
  this.missileInterplanetary.on('focus', this.onFocusInterplanetary.bind(this));
  this.missileInterplanetary.on('keyup', this.onKeyInputInterplanetary.bind(this));
  this.destroyButton.on('click', this.onClickButtonDestroy.bind(this));
};

Missile.prototype.deattachCommon = function () {
  this.missileInterceptor.off('focus');
  this.missileInterceptor.off('keyup');
  this.missileInterplanetary.off('focus');
  this.missileInterplanetary.off('keyup');
  this.destroyButton.off('click');
};

Missile.prototype.onFocusInterceptor = function (e) {
  this.missileInterceptor.val('');
};

Missile.prototype.onKeyInputInterceptor = function (e) {
  var value = $(e.target).val();

  if (typeof value !== undefined && value !== "") {
    intVal = Math.abs(getValue(value));
    intVal = Math.min(intVal, this.maxInterceptor);
    $(e.target).val(intVal);
  }
};

Missile.prototype.onFocusInterplanetary = function (e) {
  this.missileInterplanetary.val('');
};

Missile.prototype.onKeyInputInterplanetary = function (e) {
  var value = $(e.target).val();

  if (typeof value !== undefined && value !== "") {
    intVal = Math.abs(getValue(value));
    intVal = Math.min(intVal, this.maxInterplanetary);
    $(e.target).val(intVal);
  }
};

Missile.prototype.onClickButtonDestroy = function (e) {
  e.preventDefault();
  let data = {
    interceptorMissile: this.missileInterceptor.val() || 0,
    interplanetaryMissile: this.missileInterplanetary.val() || 0,
    _token: this.token
  };
  $.post(this.urlMissileDestroy, data, this.onDestroyMissiles.bind(this)).done(this.onAjaxDone.bind(this));
};

Missile.prototype.onDestroyMissiles = function (response) {
  let data = JSON.parse(response);
  this.token = data.newAjaxToken;
  token = data.newAjaxToken;

  if (data.status === 'success') {
    fadeBox(data.message, false);
  } else {
    fadeBox(data.message, true);
  }
};
$(function () {
  $('.slideIn').on('click', function () {
    loadDetails($(this).data('type'));
  });
  $('#detail').on('click', '.close_details', function () {
    $('#detail').hide();
  });
});
var textDestination = [];
textDestination[0] = "diameterField";
textDestination[1] = "diameterContentField";
textDestination[2] = "temperatureField";
textDestination[3] = "temperatureContentField";
textDestination[4] = "positionField";
textDestination[5] = "positionContentField";
textDestination[6] = "scoreField";
textDestination[7] = "scoreContentField";
textDestination[8] = "honorField";
textDestination[9] = "honorContentField";

function type() {
  if (animatedOverview) {
    var destination = document.getElementById(textDestination[currentIndex]);

    if (destination) {
      if (textContent[currentIndex].substr(currentChar, 1) == "<" && linetwo != 1) {
        while (textContent[currentIndex].substr(currentChar, 1) != ">") {
          currentChar++;
        }
      }

      if (linetwo == 1) {
        destination.innerHTML = textContent[currentIndex];
        currentChar = destination.innerHTML = textContent[currentIndex].length + 1;
      } else {
        destination.innerHTML = textContent[currentIndex].substr(0, currentChar) + "_";
        currentChar++;
      }

      if (currentChar > textContent[currentIndex].length) {
        destination.innerHTML = textContent[currentIndex];
        currentIndex++;
        currentChar = 0;

        if (currentIndex < textContent.length) {
          type();
        }
      } else {
        setTimeout("type()", 15);
      }
    }
  } else {
    for (var i = 0; i < textDestination.length; i++) {
      document.getElementById(textDestination[i]).innerHTML = textContent[i];
    }
  }
}

function initType() {
  type();
}
function OGamePaginatable(container, data) {
  this.container = container;
  this.page = data.page || 0;
  this.numPages = data.numPages || 0;
  this.size = data.size || 10;
  this.token = data.token || null;
  this.onChange = data.onChange || null;
}

OGamePaginatable.prototype.init = function () {
  let label = this.container.text();
  let html = '<ul class="og-paginatable"></ul>';
  this.element = $(html);
  this.container.html(this.element);
  $(this.element).on('click', 'li', this.handleClick.bind(this));
  this.refresh();
};

OGamePaginatable.prototype.handleClick = function (e) {
  let page = $(e.currentTarget).data('page');

  switch (page) {
    case 'page-first':
      this.page = 1;
      break;

    case 'page-left':
      this.page = clampInt(parseInt(this.page - 1), 1, this.numPages);
      break;

    case 'page-last':
      this.page = this.numPages;
      break;

    case 'page-right':
      this.page = clampInt(parseInt(this.page + 1), 1, this.numPages);
      break;

    default:
      this.page = clampInt(parseInt(page), 1, this.numPages);
      break;
  }

  this.refresh();
  this.notifyChange();
};

OGamePaginatable.prototype.update = function (data) {
  this.page = data.page || this.page;
  this.numPages = data.numPages || this.numPages;
  this.token = data.token || this.token;
  this.refresh();
};

OGamePaginatable.prototype.getPage = function () {
  return this.page;
};

OGamePaginatable.prototype.getNumPages = function () {
  return this.numPages;
};

OGamePaginatable.prototype.notifyChange = function () {
  if (this.onChange) {
    this.onChange({
      page: this.page,
      numPages: this.numPages,
      _token: this.token
    });
  }
};

OGamePaginatable.prototype.refresh = function () {
  if (this.numPages === 0) {
    this.element.html('-');
    return;
  }

  let pageStart = this.page - Math.floor(this.size / 2);
  let pageEnd = pageStart + this.size;

  if (pageStart < 1) {
    let delta = 1 - pageStart;
    pageStart += delta;
    pageEnd += delta;
  } else if (pageEnd > this.numPages) {
    let delta = this.numPages - pageEnd;
    pageStart += delta;
    pageEnd += delta;
  }

  pageStart = clampInt(pageStart, 1, this.numPages);
  pageEnd = clampInt(pageEnd, 1, this.numPages);
  let pages = [];
  pages.push('<li data-page="page-first">&lt;&lt;</li>');
  pages.push('<li data-page="page-left">&lt;</li>');

  for (let page = pageStart; page <= pageEnd; ++page) {
    let stateClass = page === this.page ? 'active' : '';
    pages.push('<li data-page="' + page + '" class="' + stateClass + '">' + page + '</li>');
  }

  pages.push('<li data-page="page-right">&gt;</li>');
  pages.push('<li data-page="page-last">&gt;&gt;</li>');
  this.element.html(pages.join(''));
};

(function ($) {
  $.fn.ogamePaginatable = function (data) {
    if (this.length > 0) {
      let that = $(this[0]);
      let localData = data || {};
      let paginatable = that.data('ogamePaginatable');

      if (paginatable == null) {
        paginatable = new OGamePaginatable(that, localData);
        $(this).data('ogamePaginatable', paginatable);
        paginatable.init();
      }

      return paginatable;
    }

    return null;
  };
})(jQuery);
function PercentageBar(elem) {
  this.elem = $(elem);
  this.elem.data('percentageBarInstance', this);
  this.elem.disableSelection();
  this.value = parseFloat(this.elem.attr('value') || 10 * 2);
  this.minValue = parseInt(this.elem.attr('minValue') || 1 / 2);
  this.steps = parseInt(this.elem.attr('steps') || 10 * 2);
  this.stepSize = parseInt(this.elem.attr('stepSize') || 10 * 2);
  this.useHalfStep = this.elem.attr('useHalfStep') === 'true' || false;
  this.barFactor = 1;
  this.valueOnEnter = null;
  this.isDragging = false;
  this.init();
  this.updateBar();
}

PercentageBar.prototype.init = function () {
  if (this.useHalfStep) {
    this.barFactor = 2;
  }

  this.initBar();
  this.initSteps();

  if (document.createTouch === undefined) {
    this.elem.on('mouseup', this.onMouseUp.bind(this));
    this.elem.on('mousemove', this.onMouseMove.bind(this));
    this.elem.on('mouseenter', this.onMouseEnter.bind(this));
    this.elem.on('mouseleave', this.onMouseLeave.bind(this));
  } else {
    this.elem.on('touchstart', this.onTouchStart.bind(this));
    this.elem.on('touchmove', this.onTouchMove.bind(this));
    this.elem.on('touchend', this.onTouchEnd.bind(this));
  }
};

PercentageBar.prototype.initSteps = function () {
  let html = '<div class="steps">';

  for (let i = 0; i < this.steps; ++i) {
    let label = (i + 1) * this.stepSize;
    html += '<div class="step' + (this.stepSize === 10 ? ' step2' : '') + '"  style="cursor: pointer" onclick="" data-step="' + (i + 1) / this.barFactor + '">' + label + '</div>';
  }

  this.elem.append(html);
};

PercentageBar.prototype.initBar = function () {
  let html = '<div class="bar"></bar>';
  this.elem.append(html);
};

PercentageBar.prototype.updateDrag = function (e) {
  let xMin = this.elem.offset().left;
  let xMax = xMin + this.elem.outerWidth();
  let xCurrent = e.pageX;
  let value = this.calcValue(xCurrent, xMin, xMax);
  this.setValue(value);
};

PercentageBar.prototype.onMouseUp = function (e) {
  if (this.valueOnEnter) {
    this.valueOnEnter = this.getValue();
    this.setValue(this.valueOnEnter);
  }

  this.updateDrag(e);
};

PercentageBar.prototype.onMouseMove = function (e) {
  this.updateDrag(e);
};

PercentageBar.prototype.onMouseEnter = function (e) {
  this.valueOnEnter = this.getValue();
};

PercentageBar.prototype.onMouseLeave = function (e) {
  if (this.valueOnEnter > 0) {
    this.setValue(this.valueOnEnter);
  }
};
/**
 * TOUCH EVENTS
 */


PercentageBar.prototype.onTouchStart = function (e) {
  this.startDrag();
};

PercentageBar.prototype.onTouchMove = function (e) {};

PercentageBar.prototype.onTouchEnd = function (e) {
  if (this.valueOnEnter) {
    this.valueOnEnter = this.getValue();
    this.setValue(this.valueOnEnter);
  }

  this.updateDragTouch(e);
  this.stopDrag();
};

PercentageBar.prototype.startDrag = function () {
  this.isDragging = true;
  this.valueOnEnter = this.getValue();
};

PercentageBar.prototype.stopDrag = function () {
  this.isDragging = false;
};

PercentageBar.prototype.updateDragTouch = function (e) {
  if (this.isDragging === true) {
    let xMin = this.elem.offset().left;
    let xMax = xMin + this.elem.outerWidth();
    let xCurrent = e.originalEvent.pageX;

    if (xCurrent === 0) {
      xCurrent = e.originalEvent.changedTouches[0].pageX;
    }

    let value = this.calcValue(xCurrent, xMin, xMax);
    this.setValue(value);
  }
};

PercentageBar.prototype.calcValue = function (xCurrent, xMin, xMax) {
  let x = clampInt(xCurrent, xMin, xMax);
  let percent = (x - xMin) / (xMax - xMin);
  let valueMin = Math.floor(percent * this.steps);
  let valueMax = Math.ceil(percent * this.steps);
  let value = Math.round((valueMax + valueMin) / 2) / this.barFactor;
  return value;
};

PercentageBar.prototype.setValue = function (valueNew) {
  let valueOld = this.value;
  this.value = clampFloat(valueNew, this.minValue, this.steps);

  if (valueOld !== valueNew) {
    this.elem.trigger($.Event('change', {
      value: this.value
    }));
  }

  this.updateBar();
};

PercentageBar.prototype.getValue = function () {
  return this.value;
};

PercentageBar.prototype.updateBar = function () {
  let xMin = this.elem.offset().left;
  let xMax = xMin + this.elem.outerWidth();
  let width = parseInt(this.value / this.steps * (xMax - xMin) * this.barFactor);
  this.elem.find('.bar').width(width);
  this.elem.find('.step').toggleClass('selected', false);
  this.elem.find('.step[data-step="' + this.value + '"]').toggleClass('selected', true);
};

function addPercentageBarPlugin() {
  (function (jQ) {
    jQ.fn.percentageBar = function (options) {
      let percentageBarInstance = new PercentageBar(this, options);
      return this;
    };
  })(jQuery);
}
$(function () {
  $(".percentSelector").each(function () {
    PercentSelector.initBar(this);
  });
});
var PercentSelector = {};
PercentSelector.fallbackMode = false; //($.browser.msie && $.browser.version < 9);
//This will init a bar (calling this directly is useful for re-doing a bar's sizes in the event it's been resized).

PercentSelector.initBar = function (bar) {
  if (!bar) return;
  var $bar = $(bar);
  var height = $bar.innerHeight();
  $bar.children(".PBcolorGrad").remove();
  $bar.children(".PBoverlay").remove();
  var opcAttr = $bar.attr("onpercentchange");

  if (opcAttr) {
    if (typeof opcAttr == "function") {
      $bar.get(0).onpercentchange = opcAttr;
    } else if (typeof opcAttr == "string") {
      if (/^function/.test(opcAttr)) {
        eval("$bar.get(0).onpercentchange = " + opcAttr);
      } else {
        eval("$bar.get(0).onpercentchange = function() {" + opcAttr + "}");
      }
    }
  }

  if (!PercentSelector.fallbackMode) {
    $bar.append($("<canvas class='PBoverlay'></canvas>").css("height", height).css("width", $bar.innerWidth()));
    $bar.append($("<div class='PBcolorGrad'></div>").css("height", height * 20).css("top", -(2 * height)));
    PercentSelector.createOverlay($bar);
  } else {
    $bar.addClass("fallback");
    $bar.append($("<div class='PBfallbackColor'></div>").css("height", height).css("width", $bar.innerWidth())); //$bar.append($("<div class='PBfallbackOverlay'></div>").css("height", height).css("width", $bar.innerWidth()).css("margin-top", -$bar.innerHeight()));
  }

  if ($bar.attr("percent") != null) {
    //ok, I know this is odd. It's because setPercent ignores the change if it's changing to the percent
    // the bar is already at. It remembers what percent it's at using the percent attribute. So trying to
    // initialize it to the percent attribute causes problems. So I just "reset" the attribute to 100% and then
    // re-initialize to the percent given.
    var percent = parseInt($bar.attr("percent"));
    $bar.attr("percent", 100);
    PercentSelector.setPercent($bar, percent, true);
  }

  if (!bar.isBound) {
    if (!($bar.attr("enabled") && $bar.attr("enabled").toLowerCase() == "false")) {
      var $bindBar = $bar;

      if (document.createTouch == undefined) {
        $bindBar.bind("mousedown", PercentSelector.handlers.mouseDown);
        $bindBar.bind("mousemove", PercentSelector.handlers.mouseMove);
        $bindBar.bind("mouseup", PercentSelector.handlers.mouseUp);
        $bindBar.bind("mouseout", PercentSelector.handlers.mouseOut);
      } else {
        $bindBar.bind("touchstart", PercentSelector.handlers.touchStart);
        $bindBar.bind("touchmove", PercentSelector.handlers.touchMove);
        $bindBar.bind("touchend", PercentSelector.handlers.touchEnd);
      }
    }

    bar.isBound = true; //to prevent multi-binding!
  }
};

PercentSelector.setPercent = function (bar, newPercent, animate) {
  var $bar = $(bar);
  var step = $bar.attr("step");
  if (!step) step = 1;else step = parseInt(step);
  newPercent = Math.round(newPercent / step) * step; //short circuit if the percent is not changing!

  if (newPercent == parseInt($bar.attr("percent"))) return;
  $bar.attr("percent", newPercent);

  if (PercentSelector.fallbackMode) {
    $bar.children(".PBfallbackColor").css("width", $bar.innerWidth() * newPercent / 100.0); //console.log("setting percent to: " + newPercent);
  } else {
    if (animate) {
      $bar.children(".PBcolorGrad").css("-webkit-transition", "-webkit-transform 0.6s ease-in");
      $bar.children(".PBcolorGrad").css("-moz-transition", "-moz-transform 0.6s ease-in");
    } else {
      $bar.children(".PBcolorGrad").css("-webkit-transition", "-webkit-transform 0.1s ease-in"); //turn off the animation in case it's on!

      $bar.children(".PBcolorGrad").css("-moz-transition", "-moz-transform 0.1s ease-in"); //turn off the animation in case it's on!
    }

    var yTrans = Math.round($bar.children(".PBcolorGrad").outerHeight() * .90 * (100 - newPercent) / 100.0);
    var xTrans = Math.round($bar.children(".PBcolorGrad").innerWidth() * ((100 - newPercent) / 100.0));

    if (animate) {
      setTimeout(function () {
        $bar.children(".PBcolorGrad").css("-webkit-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
        $bar.children(".PBcolorGrad").css("-moz-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
        $bar.children(".PBcolorGrad").css("-ms-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
      }, 1);
    } else {
      $bar.children(".PBcolorGrad").css("-webkit-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
      $bar.children(".PBcolorGrad").css("-moz-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
      $bar.children(".PBcolorGrad").css("-ms-transform", "translate(-" + xTrans + "px, -" + yTrans + "px)");
    }
  }
};

PercentSelector.setPercentFromPageX = function (bar, page_x, animate) {
  var $bar = $(bar);
  var x = page_x - $bar.offset().left;
  var width = $bar.outerWidth();
  var percent = 100 * x / width;
  if (percent > 100) percent = 100;
  if (percent < 10) percent = 10;
  percent = Math.round(percent);
  PercentSelector.setPercent(bar, percent, animate);
};

PercentSelector.createOverlay = function (bar) {
  var $bar = $(bar);
  $overlay = $bar.children(".PBoverlay");
  var width = $overlay.innerWidth();
  var height = $overlay.innerHeight();
  var canvas = $overlay.get(0);
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d"); //Create the plastic overlay

  var lingrad = ctx.createLinearGradient(0, 0, 0, height);
  lingrad.addColorStop(0, 'rgba(0,0,0,0.05)');
  lingrad.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.fillStyle = lingrad;
  ctx.fillRect(0, 0, width, height);
  ctx.clearRect(3, 3, width - 6, height - 6);
  lingrad = ctx.createLinearGradient(0, 0, 0, height);
  lingrad.addColorStop(0, 'rgba(0,0,0,0.2)');
  lingrad.addColorStop(1, 'rgba(0,0,0,0.05)');
  ctx.fillStyle = lingrad;
  ctx.fillRect(3, 3, width - 6, height - 6); //create the steps

  var step = $bar.attr("step");
  if (!step) step = 100;
  ctx.lineWidth = 1;
  var maxWidth = width / step;
  var stepWith = width / step;

  for (var curStep = 0; curStep * step < 100; curStep += 1) {
    var x = Math.floor(curStep * step * width / 100) - .5;
    ctx.beginPath();
    ctx.font = "12px serif";
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(((curStep + 1) * 10).toString(), x + stepWith / 2, height / 2, maxWidth); // ctx.strokeText(((curStep + 1) * 10).toString(), x + stepWith/2, height * 1, maxWidth);

    ctx.moveTo(x, height);
    ctx.lineTo(x, height * .75);
    ctx.closePath();
    ctx.stroke();
  }
};

PercentSelector.handlers = {};
/**** touch handling ****/

PercentSelector.handlers.touchDragging = false;

PercentSelector.handlers.touchStart = function (event) {
  var touches = event.originalEvent.touches;
  if (touches.length > 1) return;
  event.preventDefault();
  PercentSelector.handlers.touchDragging = false;
};

PercentSelector.handlers.touchEnd = function (event) {
  touches = event.originalEvent.touches;
  if (touches.length == 0) touches = event.originalEvent.changedTouches;
  if (touches.length > 1) return;
  var bar = touches[0].target.parentNode;
  PercentSelector.setPercentFromPageX(bar, touches[0].pageX, true);

  if (bar.onpercentchange != undefined) {
    bar.onpercentchange($(bar).attr("percent"));
  }

  event.preventDefault();
};

PercentSelector.handlers.touchMove = function (event) {
  PercentSelector.handlers.touchDragging = true;
  var touches = event.originalEvent.touches;
  if (touches.length > 1) return;
  event.preventDefault();
  PercentSelector.setPercentFromPageX(touches[0].target.parentNode, touches[0].pageX);
};
/*** mouse handling ***/


PercentSelector.handlers.mouseDragging = false;

PercentSelector.handlers.mouseDown = function (event) {
  PercentSelector.handlers.mouseDragging = true;
};

PercentSelector.handlers.mouseOut = function (event) {
  if (PercentSelector.handlers.mouseDragging) {
    var bar = PercentSelector.fallbackMode ? event.currentTarget : event.originalEvent.target.parentNode; //         if (bar.onpercentchange != undefined) {
    //             var x = eval(bar.onpercentchange);
    // console.debug(x);
    //             if (typeof x == 'function') {
    //                 x($(bar).attr("percent"));
    //             }
    //             // bar.onpercentchange($(bar).attr("percent"));
    //         }
  }

  PercentSelector.handlers.mouseDragging = false;
};

PercentSelector.handlers.mouseUp = function (event) {
  PercentSelector.handlers.mouseDragging = false;
  var bar = PercentSelector.fallbackMode ? event.currentTarget : event.originalEvent.target.parentNode;
  PercentSelector.setPercentFromPageX(bar, event.pageX, true); // if (bar.onpercentchange != undefined) {
  //     var x = eval(bar.onpercentchange);
  //
  //     if (typeof x == 'function') {
  //         x($(bar).attr("percent"));
  //     }
  //     // bar.onpercentchange($(bar).attr("percent"));
  // }
  // if(bar.onpercentchange != undefined) {
  //     bar.onpercentchange($(bar).attr("percent"));
  // }
};

PercentSelector.handlers.mouseMove = function (event) {
  if (PercentSelector.handlers.mouseDragging) {
    event.preventDefault();
    var bar = PercentSelector.fallbackMode ? event.currentTarget : event.originalEvent.target.parentNode;
    PercentSelector.setPercentFromPageX(bar, event.pageX);
  }
};
$(function () {
  jQuery('.planetlink').hover(function () {
    jQuery(this).parent().addClass('hoverPlanet');
  }, function () {
    jQuery(this).parent().removeClass('hoverPlanet');
  });
  jQuery('.moonlink').hover(function () {
    jQuery(this).parent().addClass('hoverMoon');
  }, function () {
    jQuery(this).parent().removeClass('hoverMoon');
  });
});
var buildUrl;

function sendBuildRequest(url, ev, showSlotWarning) {
  if (ev != undefined) {
    var keyCode;

    if (window.event) {
      keyCode = window.event.keyCode;
    } else if (ev) {
      keyCode = ev.which;
    } else {
      return true;
    }

    if (keyCode != 13) {
      return true;
    }
  }

  function build() {
    if (url == null) {//sendForm();
    } else {
      fastBuild();
    }
  }

  if (url == null) {//fallBackFunc = sendForm;
  } else {
    fallBackFunc = build;
    buildUrl = url;
  }

  if (planetMoveInProgress) {
    errorBoxDecision(LOCA_ALL_NETWORK_ATTENTION, LOCA_PLANETMOVE_BREAKUP_WARNING, LOCA_ALL_YES, LOCA_ALL_NO, fallBackFunc);
  } else {
    if (showSlotWarning) {
      if (lastBuildingSlot['showWarning']) {
        errorBoxDecision(LOCA_ALL_NETWORK_ATTENTION, lastBuildingSlot['slotWarning'], LOCA_ALL_YES, LOCA_ALL_NO, build);
      } else {
        build();
      }
    } else {
      build();
    }
  }

  return false;
}

function fastBuild() {
  location.href = buildUrl;
  return false;
}

function cancelResearch(id, listId, question) {
  errorBoxDecision(LOCA_ALL_NETWORK_ATTENTION, "" + question + "", LOCA_ALL_YES, LOCA_ALL_NO, function () {
    window.location.replace(urlResearchCancel + "&techid=" + id + "&listid=" + listId);
  });
}
var metalTicker = undefined;
var crystalTicker = undefined;
var deuteriumTicker = undefined;
var populationTicker = undefined;
var foodTicker = undefined;

function ResourceTicker() {
  this.timerObj = undefined;
  this.onClickActive = false;
}

ResourceTicker.Metal = 'metal';
ResourceTicker.Crystal = 'crystal';
ResourceTicker.Deuterium = 'deuterium';
ResourceTicker.Energy = 'energy';
ResourceTicker.Population = 'population';
ResourceTicker.Food = 'food';

ResourceTicker.prototype.reload = function (data) {
  this.techs = data.techs || {};
  this.resources = data.resources || {};
  changeTooltip($("#metal_box"), data.resources.metal.tooltip);
  changeTooltip($("#crystal_box"), data.resources.crystal.tooltip);
  changeTooltip($("#deuterium_box"), data.resources.deuterium.tooltip);
  changeTooltip($("#darkmatter_box"), data.resources.darkmatter.tooltip);
  changeTooltip($("#energy_box"), data.resources.energy.tooltip);

  if ($("#population_box").length) {
    changeTooltip($("#population_box"), data.resources.population.tooltip);
  }

  if ($("#food_box").length) {
    changeTooltip($("#food_box"), data.resources.food.tooltip);
  }

  this.refresh();
};

ResourceTicker.prototype.start = function () {
  if (this.timerObj === undefined) {
    this.timerObj = timerHandler.appendCallback(this.update.bind(this));
  }
};

ResourceTicker.prototype.stop = function () {
  if (this.timerObj !== undefined) {
    timerHandler.removeCallback(this.timerObj);
    delete this.timerObj;
  }
};

ResourceTicker.prototype.restart = function () {
  this.stop();
  this.start();
};

ResourceTicker.prototype.update = function () {
  let resourceProduction = {
    metal: 0,
    crystal: 0,
    deuterium: 0
  };

  if ($("#population_box").length) {
    resourceProduction.population = 0;
  }

  for (let resource in resourceProduction) {
    if (resource === 'population') {
      let extraProduction = 0;
      let foodToRemoveExtraPopulation = 0;
      let populationIncreaseBelowCap = 0;
      let populationIncreaseAboveCap = 0;
      let foodConsumptionAboveCap = 0;
      let maxPopulationToStarve = 0;
      let timeTillFoodRunsOut = 0;
      let populationChange = 0;
      let foodChange = 0;

      if (this.resources['population'].amount < Math.min(this.resources['population'].capableToFeed, this.resources['population'].storage)) {
        populationIncreaseBelowCap = Math.min(this.resources['population'].capableToFeed - this.resources['population'].amount, Math.min(this.resources['population'].storage - this.resources['population'].amount, this.resources['population'].growthRate));
        let currentFoodConsumption = this.resources['population'].amount * this.resources['population'].singleFoodConsumption;
        let extraFoodConsumption = populationIncreaseBelowCap * this.resources['population'].singleFoodConsumption;
        extraProduction = Math.max(0, Math.min(this.resources['food'].storage - this.resources['food'].amount, this.resources['food'].production - extraFoodConsumption - currentFoodConsumption));
      }

      if (this.resources['population'].amount >= Math.min(this.resources['population'].capableToFeed, this.resources['population'].storage)) {
        let populationNeedsFoodResource = Math.floor(Math.max(this.resources['population'].amount - this.resources['population'].capableToFeed, 0));
        foodToRemoveExtraPopulation = Math.min(this.resources['food'].amount, populationNeedsFoodResource * this.resources['population'].singleFoodConsumption);
        let foodLeft = Math.max(this.resources['food'].amount - foodToRemoveExtraPopulation, 0);

        if (populationNeedsFoodResource === 0) {
          let currentFoodConsumption = this.resources['population'].amount * this.resources['population'].singleFoodConsumption;
          extraProduction += Math.max(0, Math.min(this.resources['food'].storage - this.resources['population'].amount, this.resources['food'].production - currentFoodConsumption));
        } else {
          timeTillFoodRunsOut = Math.floor(foodLeft / (populationNeedsFoodResource * this.resources['population'].singleFoodConsumption));

          if (this.resources['food'].vacationMode.length > 1) {
            $('.resourceTooltip .timeTillFoodRunsOut').html(this.resources['food'].vacationMode);
          } else {
            $('.resourceTooltip .timeTillFoodRunsOut').html('~' + formatTimeWrapper(timeTillFoodRunsOut, 2, true, " ", false, ""));
          }
        }

        let starvingFactor = 0;

        if (foodLeft + extraProduction > 0) {
          populationIncreaseAboveCap = Math.min(Math.max(this.resources['population'].storage - this.resources['population'].amount - populationIncreaseBelowCap, 0), this.resources['population'].growthRate);
          populationIncreaseAboveCap = Math.min((foodLeft + extraProduction) / this.resources['population'].singleFoodConsumption, populationIncreaseAboveCap);
          foodConsumptionAboveCap = populationIncreaseAboveCap * this.resources['population'].singleFoodConsumption;
        } else {
          starvingFactor = 1;
        }

        let tooMuchPopulation = Math.max(this.resources['population'].amount + populationIncreaseBelowCap + populationIncreaseAboveCap - Math.min(this.resources['population'].storage, this.resources['population'].capableToFeed), 0);
        maxPopulationToStarve = Math.min(this.resources['population'].growthRate * starvingFactor, tooMuchPopulation);
      }

      populationChange += populationIncreaseBelowCap;
      populationChange += populationIncreaseAboveCap;
      populationChange -= maxPopulationToStarve;
      foodChange += extraProduction;
      foodChange -= foodToRemoveExtraPopulation;
      foodChange -= foodConsumptionAboveCap;
      let newAmountPopulation = this.resources['population'].amount + populationChange;

      if (this.resources['population'].amount < this.resources['population'].storage && populationChange > 0) {
        this.resources['population'].amount = Math.min(newAmountPopulation, this.resources['population'].storage);
      } else if (populationChange < 0) {
        this.resources['population'].amount = Math.max(newAmountPopulation, 0);
      } else if (this.resources['population'].amount >= this.resources['population'].storage && populationChange > 0) {
        this.resources['population'].amount = this.resources['population'].storage;
        this.resources['population'].growthRate = 0;
      }

      let newAmountFood = this.resources['food'].amount + foodChange;

      if (this.resources['food'].amount < this.resources['food'].storage && foodChange > 0) {
        this.resources['food'].amount = Math.min(newAmountFood, this.resources['food'].storage);
      } else if (foodChange <= 0) {
        this.resources['food'].amount = Math.max(newAmountFood, 0);
      } else if (newAmountFood === 0) {
        this.resources['food'].amount = 0;
      }
    } else {
      resourceProduction[resource] = this.resources[resource].production;
      let newAmount = this.resources[resource].amount + resourceProduction[resource];

      if (this.resources[resource].amount < this.resources[resource].storage && resourceProduction[resource] > 0) {
        this.resources[resource].amount = Math.min(newAmount, this.resources[resource].storage);
      } else if (resourceProduction[resource] < 0) {
        this.resources[resource].amount = Math.max(newAmount, 0);
      }
    }
  }

  this.refresh();
};

ResourceTicker.prototype.refresh = function () {
  let elements = {
    metal: $('#resources_metal'),
    crystal: $('#resources_crystal'),
    deuterium: $('#resources_deuterium'),
    darkmatter: $('#resources_darkmatter'),
    energy: $('#resources_energy'),
    population: $('#resources_population'),
    food: $('#resources_food')
  }; // metal

  elements.metal.html(gfNumberGetHumanReadable(Math.floor(this.resources.metal.amount), true));
  elements.metal.removeClass('overmark middlemark');
  storageClass = this.getStorageClass(this.resources.metal.amount, this.resources.metal.storage);

  if (storageClass) {
    elements.metal.toggleClass(storageClass, true);
  } // crystal


  elements.crystal.html(gfNumberGetHumanReadable(Math.floor(this.resources.crystal.amount), true));
  elements.crystal.removeClass('overmark middlemark');
  storageClass = this.getStorageClass(this.resources.crystal.amount, this.resources.crystal.storage);

  if (storageClass) {
    elements.crystal.toggleClass(storageClass, true);
  } // deuterium


  elements.deuterium.html(gfNumberGetHumanReadable(Math.floor(this.resources.deuterium.amount), true));
  elements.deuterium.removeClass('overmark middlemark');
  storageClass = this.getStorageClass(this.resources.deuterium.amount, this.resources.deuterium.storage);

  if (storageClass) {
    elements.deuterium.toggleClass(storageClass, true);
  } // darkmatter


  elements.darkmatter.html(gfNumberGetHumanReadable(this.resources.darkmatter.amount, true)); // energy

  elements.energy.html(gfNumberGetHumanReadable(Math.floor(this.resources.energy.amount), true));
  elements.energy.toggleClass('overmark', this.resources.energy.amount < 0); // population

  if (elements.population.length) {
    elements.population.html(gfNumberGetHumanReadable(Math.floor(this.resources.population.amount), true));
    elements.population.removeClass('overmark middlemark');
    storageClass = this.getStorageClass(this.resources.population.amount, this.resources.population.storage);

    if (storageClass) {
      elements.population.toggleClass(storageClass, true);
    }
  } // food


  if (elements.food.length) {
    elements.food.html(gfNumberGetHumanReadable(Math.floor(this.resources.food.amount), true));
    elements.food.removeClass('overmark middlemark');
    storageClass = this.getStorageClass(this.resources.food.amount, this.resources.food.storage);

    if (storageClass) {
      elements.food.toggleClass(storageClass, true);
    }
  }
};

ResourceTicker.prototype.getStorageClass = function (amount, storage) {
  if (amount >= storage) {
    return 'overmark';
  } else if (amount >= storage * 0.9) {
    return 'middlemark';
  }

  return undefined;
};

ResourceTicker.prototype.activateOnClick = function () {
  if (this.onClickActive === true) {
    return;
  }

  $("#metal_box, #crystal_box, #deuterium_box").off('click').on('click', function (event) {
    location.href = $(this).data('shopUrl');
  });
  this.onClickActive = true;
};

var resourcesBar = new ResourceTicker();

function reloadResources(data, callback) {
  if (typeof data == 'string') {
    data = $.parseJSON(data);
  }

  resourcesBar.reload(data);
  resourcesBar.activateOnClick();

  if (data.vacation === true) {
    resourcesBar.stop();
  } else {
    resourcesBar.restart();
  }

  honorScore = data.honorScore;
  darkMatter = data.resources.darkmatter.amount;

  if (typeof callback == 'function') {
    callback(data.resources);
  }
}

function getAjaxResourcebox(callback) {
    // TODO: re-enable
  /*$.get(ajaxResourceboxURI, function (data) {
    reloadResources(data, callback);
  }, "text");*/
}
window.addEventListener('load', () => {
  const formElement = document.getElementById('resourcesettingsForm');

  if (formElement === null) {
    return;
  }

  formElement.addEventListener('submit', event => {
    event.preventDefault();
    const formData = new FormData(formElement, formElement.querySelector('input[type=submit]'));
    let postData = {};

    for (const entry of formData.entries()) {
      postData[entry[0]] = entry[1];
    }

    postData['_token'] = token;
    $.post(saveResourcesettingsUrl, postData, data => {
      const result = JSON.parse(data);
      token = result.newAjaxToken ?? token;

      if (typeof result.status === "undefined" || result.status !== 'success') {
        if (typeof result.errors === "object" && result.errors.length > 0) {
          console.log(result.errors);
          fadeBox(result.errors[0].message, true);
        }

        return;
      }

      fadeBox(result.message ?? '', false);
      getAjaxResourcebox();

      if (typeof result.changes === 'undefined' || result.changes.length <= 0) {
        return;
      }

      document.querySelector('#resourcesettingscomponent .productionFactorValue').textContent = Math.floor((result.prodfactor ?? 0) * 100);

      const updateRow = (row, data) => {
        Object.entries(data).forEach(([resourceIdx, value]) => {
          const productionSpan = row.querySelector('td[data-resourceIdx="' + resourceIdx + '"] span');
          productionSpan.textContent = value.number ?? value.value ?? 0;
          changeTooltip(productionSpan, value.tooltipNumber ?? value.title ?? 0);

          if (productionSpan.classList.contains(value.class) === false) {
            productionSpan.classList.remove('undermark');
            productionSpan.classList.remove('overmark');
            productionSpan.classList.remove('normalmark');
            productionSpan.classList.add(value.class);
          }
        });
      };

      result.changes.forEach(techId => {
        if (typeof result.techlist[techId] === 'undefined') {
          return;
        }

        const techRow = document.querySelector('#resourcesettingscomponent tr[data-techid="' + techId + '"]');

        if (techRow === null) {
          return;
        }

        updateRow(techRow, result.techlist[techId].techProduction);
      });
      updateRow(document.querySelector('#resourcesettingscomponent .summaryHourly'), result.hourly);
      updateRow(document.querySelector('#resourcesettingscomponent .summaryDaily'), result.daily);
      updateRow(document.querySelector('#resourcesettingscomponent .summaryWeekly'), result.weekly); // handle ipi menu content update

      if (typeof result.ipiMenuData === 'object') {
        IPI.updateMenuContent(result.ipiMenuData);
      }
    });
    return false;
  });
});
ogame.retrieveEmail = {
  send: function () {
    $.ajax({
      type: "POST",
      url: window.location.href + '&' + $.param({
        action: 'get'
      }),
      data: {
        username: $('#username').val(),
        password: $('#password').val()
      },
      dataType: "json",
      success: function (data) {
        $('#response').html(data.response).removeClass().addClass(data.type);
      }
    });
  }
};
$(document).ready(function () {
  $('#retrieveEmailComponent #username').off().keypress(function (event) {
    if (event.which == 13) {
      event.preventDefault();
      $('#retrieveEmailComponent #password').focus();
    }
  });
  $('#retrieveEmailComponent #password').off().keypress(function (event) {
    if (event.which == 13) {
      event.preventDefault();
      ogame.retrieveEmail.send();
    }
  });
  $('#retrieve').off().on('click', function () {
    ogame.retrieveEmail.send();
  });
});
function Rewarding(cfg) {
  this.tab = cfg.tab || '';
  this.token = cfg.token;
  this.tiers = cfg.tiers;
  this.currentTier = cfg.currentTier;
  this.urlFetchTasks = cfg.urlFetchTasks || null;
  this.urlFetchRewards = cfg.urlFetchRewards || null;
  this.selectedTier = cfg.selectedTier || 1;
  this.initMap = {
    'tasks': this.initTabTasks.bind(this),
    'rewards': this.initTabRewards.bind(this)
  };

  if (this.initMap[this.tab]) {
    this.initMap[this.tab](cfg);
  }
}

Rewarding.prototype.onAjaxTasksDone = function () {
  this.loadingIndicator.hide();
};

Rewarding.prototype.onAjaxSelectDone = function () {
  this.loadingIndicator.hide();
};

Rewarding.prototype.onAjaxRewardsDone = function () {
  this.loadingIndicator.hide();
  let that = this;
  that.urlSubmitReward = urlSubmitReward;
  $('#rewardings .normalRewards .singleReward').each(function () {
    this.urlSubmitReward = that.urlSubmitReward;
    this.token = that.token;
    $(this).bind('click', that.onClickButtonSelectReward.bind(that));
    $(this).hover(function () {
      $(this).find(".select-button").css('background-position', '0 -214px');
    }, function () {
      $(this).find(".select-button").css('background-position', '0 -188px');
    });
  });
};

Rewarding.prototype.displayErrors = function (errors) {
  // only display the first error
  let error = errors[0] || undefined;

  if (error) {
    fadeBox(error.message, true);
  }
};

Rewarding.prototype.onAjaxError = function () {}; // general


Rewarding.prototype.initCommon = function (cfg) {
  this.taskWrapper = $('#rewardings .rewardlist_wrapper');
  this.loadingIndicator = this.taskWrapper.ogameLoadingIndicator();
  this.taskContent = $('#rewardings .rewardContent');
  this.titlebar = $('#rewardings .titlebar');
  this.tierButton = $('#rewardings #tothetier');
};

Rewarding.prototype.refreshContent = function (htmlItems) {
  this.taskContent.html(htmlItems);
}; //tab tasks


Rewarding.prototype.initTabTasks = function (cfg) {
  this.initCommon(cfg);
  this.titlebar.on('click', '#buttonTasks', this.onClickButtonTasks.bind(this));

  for (var key in this.tiers) {
    if (this.tiers.hasOwnProperty(key)) {
      this.titlebar.on('click', 'div[data-tier="' + key + '"]', this.onClickButtonRewards.bind(this));
    }
  }

  this.tierButton.on('click', '.tier-button', this.onClickButtonCurrentTier.bind(this));
  this.fetchTasks();
};

Rewarding.prototype.onClickButtonTasks = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.fetchTasks();
    $('#rewardings .titlebar #buttonTasks').attr('disabled', 'disabled');

    for (var key in this.tiers) {
      if (this.tiers.hasOwnProperty(key)) {
        $('#rewardings .titlebar div[data-tier="' + key + '"]').removeAttr('disabled');
      }
    }
  }
};

Rewarding.prototype.onClickButtonRewards = function (e) {
  e.preventDefault();
  let targetTier = $(e.currentTarget).data('tier');

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.fetchRewards(targetTier);
  }
};

Rewarding.prototype.onClickButtonCurrentTier = function (e) {
  e.preventDefault();
  let targetTier = this.currentTier;
  this.fetchRewards(targetTier);
};

Rewarding.prototype.onClickButtonSelectReward = function (e) {
  e.preventDefault();

  if (!e.currentTarget.hasAttribute("disabled")) {
    this.submitReward($(e.currentTarget).data('id'));
  }
};

Rewarding.prototype.fetchTasks = function (targetTab) {
  this.loadingIndicator.show();
  let data = {
    _token: this.token
  };
  $.getJSON(this.urlFetchTasks, data, this.onFetchTasks.bind(this)).done(this.onAjaxTasksDone.bind(this));
};

Rewarding.prototype.onFetchTasks = function (data) {
  let htmlItems = data.content[data.target];
  this.token = data.newAjaxToken;
  this.refreshContent(htmlItems);
}; //tabs rewards


Rewarding.prototype.initTabRewards = function (cfg) {
  this.initCommon(cfg);
  this.titlebar.on('click', '#buttonTasks', this.onClickButtonTasks.bind(this));

  for (let key in this.tiers) {
    if (this.tiers.hasOwnProperty(key)) {
      this.titlebar.on('click', 'div[data-tier="' + key + '"]', this.onClickButtonRewards.bind(this));
    }
  }

  this.tierButton.on('click', '.tier-button', this.onClickButtonCurrentTier.bind(this));
  this.fetchRewards(this.selectedTier);
};

Rewarding.prototype.fetchRewards = function (targetTier) {
  this.loadingIndicator.show();
  let data = {
    tier: targetTier,
    _token: this.token
  };
  this.selectedTier = targetTier;
  $.getJSON(this.urlFetchRewards, data, this.onFetchRewards.bind(this)).done(this.onAjaxRewardsDone.bind(this));

  for (var key in this.tiers) {
    if (this.tiers.hasOwnProperty(key)) {
      $('#rewardings .titlebar div[data-tier="' + key + '"]').removeAttr('disabled');
    }
  }

  $('#rewardings .titlebar #buttonTasks').removeAttr('disabled');
  $('#rewardings .titlebar div[data-tier="' + targetTier + '"]').attr('disabled', 'disabled');
};

Rewarding.prototype.onFetchRewards = function (data) {
  let htmlItems = data.content[data.target];
  this.token = data.newAjaxToken;
  this.refreshContent(htmlItems);
};

Rewarding.prototype.submitReward = function (selectedReward) {
  this.loadingIndicator.show();
  let params = {
    selectedReward: selectedReward,
    selectedTier: this.selectedTier,
    _token: this.token
  };
  $.post(this.urlSubmitReward, params, this.handleSubmitRewardResponse.bind(this)).done(this.onAjaxSelectDone.bind(this));
};

Rewarding.prototype.handleSubmitRewardResponse = function (response) {
  let data = JSON.parse(response);
  let status = data.status || 'failure';
  this.token = data.newAjaxToken;

  if (status === 'success') {
    let selectOne = $('#rewardings #select_one');
    selectOne.removeClass('overmark');
    selectOne.addClass('undermark');
    selectOne.html(data.rewardSelected);
    let titleBarButton = $('#rewardings .titlebar .btn_blue[data-tier="' + data.selectedTier + '"]');
    titleBarButton.addClass('undermark');
    $('#rewardings .normalRewards .singleReward').each(function () {
      $(this).attr('disabled', 'disabled');

      if ($(this).data('id') !== data.selectedReward) {
        $('#rewardings .normalRewards #itemBox' + $(this).data('id') + ' .thumbnail').data('status', 'off').attr('data-status', 'off');
      }
    });
    $('#rewardings .normalRewards .select-button').each(function () {
      $(this).remove();
    });

    if (data.allOfficers === false) {
      $('#rewardings .additionalRewards .singleReward').each(function () {
        $('#rewardings .additionalRewards #itemBox' + $(this).data('id') + ' .thumbnail').data('status', 'off').attr('data-status', 'off');
      });
    }

    fadeBox(data.message, false);
  } else {
    this.displayErrors(data.errors);
  }
};
function OGameSortable(container, data) {
  this.container = container;
  this.state = (data.state || 'active') === 'active' ? 'active' : 'inactive';
  this.order = data.order || '';
  this.align = data.align || '';
  this.allowUnsorted = data.allowUnsorted || false;
  this.token = data.token || null;
  this.onChange = data.onChange || null;
}

OGameSortable.prototype.init = function () {
  let label = this.container.text();
  let html = '<div class="og-sortable"><h3>' + label + '</h3><div class="icon"></div></div>';
  this.element = $(html);
  this.container.html(this.element);
  this.icon = this.element.find('.icon');
  $(this.element).on('click', this.handleClick.bind(this));
  this.refresh();
};

OGameSortable.prototype.handleClick = function () {
  if (this.state === 'active') {
    if (this.order === 'asc') {
      this.order = 'desc';
    } else if (this.order === 'desc' && this.allowUnsorted === false) {
      this.order = 'asc';
    } else if (this.order === 'desc' && this.allowUnsorted === true) {
      this.order = '';
    } else if (this.order === '') {
      this.order = 'asc';
    }

    this.refresh();
    this.notifyChange();
  }
};

OGameSortable.prototype.notifyChange = function () {
  if (this.onChange) {
    this.onChange({
      order: this.order,
      state: this.state,
      _token: this.token
    });
  }
};

OGameSortable.prototype.activate = function () {
  this.state = 'active';
  this.refresh();
  this.notifyChange();
};

OGameSortable.prototype.deactivate = function () {
  this.state = 'inactive';
  this.refresh();
  this.notifyChange();
};

OGameSortable.prototype.isValidOrder = function (order) {
  if (this.allowUnsorted === true) {
    return ['', 'asc', 'desc'].indexOf(order) !== -1;
  } else {
    return ['asc', 'desc'].indexOf(order) !== -1;
  }
};

OGameSortable.prototype.setOrder = function (order) {
  if (this.isValidOrder(order)) {
    this.order = order;
    this.refresh();
    this.notifyChange();
  }
};

OGameSortable.prototype.getOrder = function () {
  return this.order;
};

OGameSortable.prototype.refresh = function () {
  this.refreshAlign();
  this.refreshState();
  this.refreshOrder();
};

OGameSortable.prototype.refreshAlign = function () {
  this.element.toggleClass('left', this.align === 'left');
  this.element.toggleClass('center', this.align === 'center');
  this.element.toggleClass('right', this.align === 'right');
};

OGameSortable.prototype.refreshState = function () {
  this.element.toggleClass('active', this.state === 'active');
  this.element.toggleClass('inactive', this.state === 'inactive');
};

OGameSortable.prototype.refreshOrder = function () {
  this.element.toggleClass('asc', this.order === 'asc');
  this.element.toggleClass('desc', this.order === 'desc');
};

OGameSortable.prototype.update = function (data) {
  this.token = data.token || this.token;
};

(function ($) {
  $.fn.ogameSortable = function (data) {
    if (this.length > 0) {
      let that = $(this[0]);
      let localData = data || {};
      let sortable = that.data('ogameSortable');

      if (sortable == null) {
        sortable = new OGameSortable(that, localData);
        $(this).data('ogameSortable', sortable);
        sortable.init();
      }

      return sortable;
    }

    return null;
  };
})(jQuery);
function initStandardFleet() {
  $(".list tr:even").addClass("alt");
  $(".standardFleetSubmit").unbind('click').bind('click', function () {
    $(this).parents('form').submit();
  });
  $(".standardFleetReset").unbind('click').bind('click', function () {
    $(this).parents('form')[0].reset();
  });
  $('.changeFleet').unbind('click').bind('click', function () {
    $('.combatunits').val($(this).attr('rel')).trigger('change');
    $(this).parents('.ui-dialog').find('.ui-dialog-titlebar-close').click();
  });
}

function setShipsFleet(ships, tempName, techId) {
  $("#template_id").val(techId);
  $("#template_name").val(tempName);

  for (var techID in ships) {
    $("#ship" + techID).val(ships[techID]);
  }
}
$(function () {
  $('.techdetail').on('click', function () {
    loadDetails($(this).data('techid'));
  });
  $('#detail').on('click', '.close_details', function () {
    $('#detail').hide();
  });
});
$(function () {
  var sheet = function () {
    var style = document.createElement("style"); // WebKit hack

    style.appendChild(document.createTextNode(""));
    document.head.appendChild(style);
    return style.sheet;
  }();

  $(document).on("click", ".technology .icon button.upgrade", function (event) {
    event.preventDefault();
    event.stopPropagation();
    let isSpaceProvider = $(this).data("is-spaceprovider") == 1;
    let technologyId = $(this).data("technology");
    let showLifeformBonusCapReached = $(this).data("lifeform-bonus-cap-reached") > 0;

    if (planetMoveInProgress) {
      return errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.planetMoveBreakUpWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId);
      });
    }

    if (lastBuildingSlot.showWarning && !isSpaceProvider) {
      return errorBoxDecision(LocalizationStrings.notice, lastBuildingSlot.slotWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId);
      });
    }

    if (showLifeformBonusCapReached) {
      return errorBoxDecision(LocalizationStrings.attention, loca.LOCA_LIFEFORM_BONUS_CAP_REACHED_WARNING, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId);
      });
    }

    buildListActionBuild(technologyId);
  });
  $(document).on("click", ".technology .icon button.buildmulti", function (event) {
    event.preventDefault();
    event.stopPropagation();
    let isSpaceProvider = $(this).data("is-spaceprovider") == 1;
    let technologyId = $(this).data("technology");
    let showLifeformBonusCapReached = $(this).data("lifeform-bonus-cap-reached") > 0;

    if (planetMoveInProgress) {
      return errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.planetMoveBreakUpWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId, 1, 4);
      });
    }

    if (lastBuildingSlot.showWarning && !isSpaceProvider) {
      return errorBoxDecision(LocalizationStrings.notice, lastBuildingSlot.slotWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId, 1, 4);
      });
    }

    if (showLifeformBonusCapReached) {
      return errorBoxDecision(LocalizationStrings.attention, loca.LOCA_LIFEFORM_BONUS_CAP_REACHED_WARNING, LocalizationStrings.yes, LocalizationStrings.no, function () {
        buildListActionBuild(technologyId, 1, 4);
      });
    }

    buildListActionBuild(technologyId, 1, 4);
  }); // var active = $('.technology[data-status="active"]');
  // if (active.length > 0) {
  //     setInterval(function() {
  //         active.each(function() {
  //             var $this = $(this);
  //             $this.attr("data-progress",
  //                 Math.round(
  //                     (1 - (
  //                         ($this.data("end") - Math.floor((Date.now() + window.timeDiff + window.timeZoneDiffSeconds * 1000) / 1000))
  //                         / ($this.data("end") - $this.data("start"))
  //                     )) * 100
  //                 )
  //             );
  //
  //             let targetAmount = $('.targetamount').attr('data-value');
  //             let amountHolder = $this.find('.amount');
  //             amountHolder.text(parseInt(targetAmount) - parseInt($('#shipSumCount7').text()));
  //         });
  //     }, 1000);
  // }
});
function TechnologyDetails(params) {
  this.setParams(params);
}

TechnologyDetails.prototype.init = function () {
  $(document).on('click', '.technology.hasDetails:not(.showsDetails) .icon', this.onClickShow.bind(this));
  $(document).on('click', '#technologydetails .close, .showsDetails', this.onClickHide.bind(this));
  $(document).on('change', '#technologydetails .build_amount', this.onChangeAmount.bind(this));
  $(document).on('keypress', '#technologydetails .build_amount', this.onKeyPressAmount.bind(this));
  $(document).on('click', '#technologydetails button.upgrade', this.onClickUpgrade.bind(this));
  $(document).on('click', '#technologydetails a.upgrade', this.onClickUpgradeStorage.bind(this));
  $(document).on('click', '#technologydetails a.build-it_premium', this.onClickBuyCommander.bind(this));
  $(document).on('click', '#technologydetails button.downgrade', this.onClickDowngrade.bind(this));
  $(document).on('click', '#technologydetails button.maximum', this.onClickMaximum.bind(this));
  $(document).on('click', '#technologydetails .button.select_class', this.onClickSelectClass.bind(this));
  $(document).on('click', '#technologydetails .button.deselect_class', this.onClickDeselectClass.bind(this));
  $(document).on('click', '#technologydetails button[data-target]:not(#technologydetails button[data-target*="overlay=1"], #technologydetails button.overlay)', function () {});
};

TechnologyDetails.prototype.setParams = function (params) {
  this.loca = params.loca;
  this.technologyDetailsEndpoint = params.technologyDetailsEndpoint;
  this.selectCharacterClassEndpoint = params.selectCharacterClassEndpoint;
  this.deselectCharacterClassEndpoint = params.deselectCharacterClassEndpoint;
};

TechnologyDetails.prototype.onChangeAmount = function (e) {
  let $input = $(e.currentTarget);
  let minVal = parseInt($input.attr('min'));
  let maxVal = parseInt($input.attr('max'));
  let val = parseInt(getValue($input.val())) || 0;

  if (typeof minVal !== 'undefined') {
    val = Math.max(val, minVal);
  }

  if (typeof maxVal !== 'undefined') {
    val = Math.min(val, maxVal);
  }

  $input.val(val);
};

TechnologyDetails.prototype.onKeyPressAmount = function (e) {
  if (getKeyCode(e) == 13) {
    $('#technologydetails button.upgrade').click();
  }
};

TechnologyDetails.prototype.onClickUpgrade = function (e) {
  let technologyId = $(e.currentTarget).data('technology');
  let amount = $('#build_amount').val() || 1;

  if (planetMoveInProgress) {
    return errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.planetMoveBreakUpWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
      buildListActionBuild(technologyId, amount);
    });
  }

  if (lastBuildingSlot.showWarning == true) {
    return errorBoxDecision(LocalizationStrings.notice, lastBuildingSlot.slotWarning, LocalizationStrings.yes, LocalizationStrings.no, function () {
      buildListActionBuild(technologyId, amount);
    });
  }

  if (showLifeformBonusCapReached) {
    return errorBoxDecision(LocalizationStrings.attention, this.loca.LOCA_LIFEFORM_BONUS_CAP_REACHED_WARNING, LocalizationStrings.yes, LocalizationStrings.no, function () {
      buildListActionBuild(technologyId, amount);
    });
  }

  buildListActionBuild(technologyId, amount);
};

TechnologyDetails.prototype.onClickUpgradeStorage = function (e) {
  let technologyUrl = $(e.currentTarget).data('url');
  let technologyQuestion1 = $(e.currentTarget).data('title');
  let technologyQuestion2 = $(e.currentTarget).data('question');
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, technologyQuestion1 + ' - ' + technologyQuestion2, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    document.location.replace(technologyUrl);
  });
};

TechnologyDetails.prototype.onClickBuyCommander = function (e) {
  let technologyId = $(e.currentTarget).data('technology');
  let technologyUrl = $(e.currentTarget).data('url');
  let technologyQuestion = $(e.currentTarget).data('question');
  let buyResourceOverlayHref = $(e.currentTarget).attr("href");
  let amount = $('#build_amount').val();

  if (technologyUrl && technologyQuestion) {
    errorBoxDecision(this.loca.LOCA_ALL_NOTICE, technologyQuestion, this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
      document.location.replace(technologyUrl);
    });
  } else if (buyResourceOverlayHref) {
    $(e.currentTarget).attr("href", buyResourceOverlayHref + "&amount=" + amount + "&techID=" + technologyId);
  }
};

TechnologyDetails.prototype.handleDowngrade = function (technologyId, technologyName) {
  errorBoxDecision(this.loca.LOCA_ALL_NETWORK_ATTENTION, this.loca.locaDemolishStructureQuestion.replace('TECHNOLOGY_NAME', technologyName) + '<br><br>' + $('#demolition_costs_tooltip').html(), this.loca.LOCA_ALL_YES, this.loca.LOCA_ALL_NO, function () {
    buildListActionDemolish(technologyId);
  });
};

TechnologyDetails.prototype.onClickDowngrade = function (e) {
  let technologyId = $(e.currentTarget).data('technology');
  let technologyName = $(e.currentTarget).data('name');

  if (planetMoveInProgress) {
    errorBoxDecision(LocalizationStrings.attention, LocalizationStrings.planetMoveBreakUpWarning, LocalizationStrings.yes, LocalizationStrings.no, this.handleDowngrade.bind(this, technologyId, technologyName));
  } else {
    this.handleDowngrade(technologyId, technologyName);
  }
};

TechnologyDetails.prototype.onClickMaximum = function (e) {
  this.setMaximumBuildableAmount();
};

TechnologyDetails.prototype.onClickSelectClass = function (e) {
  e.preventDefault();
  let characterClassId = $(e.currentTarget).data('characterclassid');
  this.selectClass(characterClassId);
};

TechnologyDetails.prototype.onClickDeselectClass = function (e) {
  e.preventDefault();
  let characterClassId = $(e.currentTarget).data('characterclassid');
  this.deselectClass(characterClassId);
};

TechnologyDetails.prototype.onClickShow = function (e) {
  this.show($(e.currentTarget).closest('.hasDetails').data('technology'));
};

TechnologyDetails.prototype.onClickHide = function (e) {
  this.hide($(e.currentTarget));
};

TechnologyDetails.prototype.selectClass = function (characterClassId) {
  let that = this;
  let selectCharacterClassEndpoint = this.selectCharacterClassEndpoint.replace('CHARACTERCLASSID', characterClassId);
  $.post(selectCharacterClassEndpoint).done(function (data) {
    var json = $.parseJSON(data);

    if (json.status === 'success') {
      that.show(37); //        document.location.replace(json.redirectUrl)
    } else {
      that.displayErrors(json);
    }
  });
};

TechnologyDetails.prototype.deselectClass = function (characterClassId) {
  let that = this;
  let deselectCharacterClassEndpoint = this.deselectCharacterClassEndpoint.replace('CHARACTERCLASSID', characterClassId);
  $.post(deselectCharacterClassEndpoint).done(function (data) {
    var json = $.parseJSON(data);

    if (json.status === 'success') {
      that.show(37); //document.location.replace(json.redirectUrl)
    } else {
      that.displayErrors(json);
    }
  });
};

TechnologyDetails.prototype.displayErrors = function (data) {
  let errorCode = data.errorCode || 0;
  let errorMessage = data.errorMessage || '';
  fadeBox(errorMessage, true);
};

TechnologyDetails.prototype.show = function (technologyId) {
  let that = this;
  let element = $('.technology.hasDetails[data-technology=' + technologyId + ']');
  let elemTechnologyDetailsWrapper = $('#technologydetails_wrapper');
  let elemTechnologyDetailsContent = $('#technologydetails_content');
  let elemTechnologyDetails = $('#technologydetails');
  let locationIndicator = elemTechnologyDetailsContent.ogameLoadingIndicator();
  locationIndicator.show();
  $.ajax({
    url: this.technologyDetailsEndpoint,
    data: {
      technology: technologyId
    }
  }).done(function (json) {
    if (json.status === 'failure') {
      that.displayErrors(json.errors);
      locationIndicator.hide();
    } else {
      elemTechnologyDetailsWrapper.toggleClass('slide-up', true);
      elemTechnologyDetailsWrapper.toggleClass('slide-down', false);
      $('.showsDetails').removeClass('showsDetails');
      element.closest('.hasDetails').addClass('showsDetails');
      locationIndicator.hide();
      let anchor = $('header[data-anchor=technologyDetails]');

      if (elemTechnologyDetails.length > 0) {
        removeTooltip(elemTechnologyDetails.find(getTooltipSelector()));
        elemTechnologyDetails.replaceWith(json.content[json.target]);
        elemTechnologyDetails.addClass(anchor.data('technologydetails-size')).offset(anchor.offset());
      } else {
        elemTechnologyDetailsContent.append(json.content[json.target]);
        elemTechnologyDetails.addClass(anchor.data('technologydetails-size')).offset(anchor.offset());
      } //techID is magically defined by setting data in the .html; not always so we check it
      // and set it to harmless 0 as default. This is used for the repair dock.


      $(document).trigger("ajaxShowElement", typeof technologyId === 'undefined' ? 0 : technologyId);
    }
  });
};

TechnologyDetails.prototype.hide = function () {
  let elemTechnologyDetails = $('#technologydetails');
  removeTooltip(elemTechnologyDetails.find(getTooltipSelector()));
  $('#technologydetails_wrapper').removeClass('slide-up');
  this.startSlideDown();
  $('.showsDetails').removeClass('showsDetails');
};

TechnologyDetails.prototype.startSlideDown = function () {
  $('#technologydetails_wrapper').toggleClass('slide-down', true);
  this.timerSlideDownEnd = setTimeout(function () {
    this.stopSlideDown();
  }.bind(this), 500);
};

TechnologyDetails.prototype.stopSlideDown = function () {
  $('#technologydetails_wrapper').removeClass('slide-down');
  clearTimeout(this.timerSlideDownEnd);
  this.timerSlideDownEnd = null;
};

TechnologyDetails.prototype.setMaximumBuildableAmount = function () {
  var $buildAmount = $('#technologydetails #build_amount');
  $buildAmount.val($buildAmount.attr('max'));
};
